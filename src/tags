abcd::~abcd	../include/abcd.h	/^    ~abcd();$/;"	p	class:abcd	access:public	signature:()
abcd::abcd	../include/abcd.h	/^    abcd();$/;"	p	class:abcd	access:public	signature:()
abcd::~abcd	../src/abcd.cpp	/^abcd::~abcd()$/;"	f	class:abcd	signature:()
abcd::abcd	../src/abcd.cpp	/^abcd::abcd()$/;"	f	class:abcd	signature:()
abcd::allocateMumpsSlaves	../include/abcd.h	/^    void allocateMumpsSlaves();$/;"	p	class:abcd	access:private	signature:()
abcd::allocateMumpsSlaves	../src/mumps.cpp	/^void abcd::allocateMumpsSlaves()$/;"	f	class:abcd	signature:()
abcd::analyseAugmentedSystems	../include/abcd.h	/^    void analyseAugmentedSystems();$/;"	p	class:abcd	access:private	signature:()
abcd::analyseAugmentedSystems	../src/mumps.cpp	/^void abcd::analyseAugmentedSystems()$/;"	f	class:abcd	signature:()
abcd::analyseFrame	../include/abcd.h	/^    void analyseFrame();$/;"	p	class:abcd	access:private	signature:()
abcd::analyseFrame	../src/structure.cpp	/^void abcd::analyseFrame()$/;"	f	class:abcd	signature:()
abcd::analyseFrame	structure.cpp	/^void abcd::analyseFrame()$/
abcd::augmentMatrix	structure.cpp	/^abcd::augmentMatrix ( std::vector<CompCol_Mat_doub/
abcd::bcg	../include/abcd.h	/^    void bcg();$/;"	p	class:abcd	access:private	signature:()
abcd::bcg	../src/bcg.cpp	/^void abcd::bcg()$/;"	f	class:abcd	signature:()
abcd::bc	../include/abcd.h	/^    int bc(int);$/;"	p	class:abcd	access:public	signature:(int)
abcd::bc	../src/abcd.cpp	/^int abcd::bc(int job)$/;"	f	class:abcd	signature:(int job)
abcd::b	../include/abcd.h	/^    Eigen::Matrix<double,Dynamic, Dynamic, ColMajor> b;$/;"	m	class:abcd	access:private
abcd::block_size	../include/abcd.h	/^    int block_size;$/;"	m	class:abcd	access:public
abcd::col_interconnections	../include/abcd.h	/^    std::map<int,std::vector<int> > col_interconnections;$/;"	m	class:abcd	access:public
abcd::column_index	../include/abcd.h	/^    std::vector<std::vector<int> > column_index;$/;"	m	class:abcd	access:public
abcd::comm_map	../include/abcd.h	/^    Eigen::VectorXi comm_map;$/;"	m	class:abcd	access:private
abcd::computeNorms	../include/abcd.h	/^    void computeNorms();$/;"	p	class:abcd	access:private	signature:()
abcd::compute_rho	../include/abcd.h	/^    double compute_rho(Eigen::MatrixXd X, Eigen::MatrixXd U, double thresh);$/;"	p	class:abcd	access:private	signature:(Eigen::MatrixXd X, Eigen::MatrixXd U, double thresh)
abcd::compute_rho	../src/bcg.cpp	/^double abcd::compute_rho(Eigen::MatrixXd x, Eigen::MatrixXd u, double thresh)$/;"	f	class:abcd	signature:(Eigen::MatrixXd x, Eigen::MatrixXd u, double thresh)
abcd::createAugmentedSystems	../include/abcd.h	/^    void createAugmentedSystems();$/;"	p	class:abcd	access:private	signature:()
abcd::createAugmentedSystems	../src/mumps.cpp	/^void abcd::createAugmentedSystems()$/;"	f	class:abcd	signature:()
abcd::createInterComm	../include/abcd.h	/^    void createInterComm();$/;"	p	class:abcd	access:private	signature:()
abcd::createInterComm	../src/comms.cpp	/^void abcd::createInterComm()$/;"	f	class:abcd	signature:()
abcd::dcntl	../include/abcd.h	/^    double dcntl[10];$/;"	m	class:abcd	access:public
abcd::dcol_	../include/abcd.h	/^    VectorXd dcol_;$/;"	m	class:abcd	access:private
abcd::ddot	../include/abcd.h	/^    Eigen::MatrixXd ddot(Eigen::MatrixXd p, Eigen::MatrixXd ap);$/;"	p	class:abcd	access:private	signature:(Eigen::MatrixXd p, Eigen::MatrixXd ap)
abcd::ddot	../src/utils.cpp	/^Eigen::MatrixXd abcd::ddot(Eigen::MatrixXd p, Eigen::MatrixXd ap)$/;"	f	class:abcd	signature:(Eigen::MatrixXd p, Eigen::MatrixXd ap)
abcd::distributePartitions	../include/abcd.h	/^    void distributePartitions();$/;"	p	class:abcd	access:private	signature:()
abcd::distributePartitions	../src/comms.cpp	/^void abcd::distributePartitions()$/;"	f	class:abcd	signature:()
abcd::distributeRhs	../include/abcd.h	/^    void distributeRhs();$/;"	p	class:abcd	access:private	signature:()
abcd::distributeRhs	../src/comms.cpp	/^void abcd::distributeRhs()$/;"	f	class:abcd	signature:()
abcd::drow_	../include/abcd.h	/^    VectorXd drow_;$/;"	m	class:abcd	access:private
abcd::factorizeAugmentedSystems	../include/abcd.h	/^    void factorizeAugmentedSystems();$/;"	p	class:abcd	access:private	signature:()
abcd::factorizeAugmentedSystems	../src/mumps.cpp	/^void abcd::factorizeAugmentedSystems()$/;"	f	class:abcd	signature:()
abcd::getMumpsInfo	../include/abcd.h	/^    inline int getMumpsInfo(int i) { return mumps.info[ i - 1 ]; }$/;"	f	class:abcd	access:private	signature:(int i)
abcd::getMumpsRinfo	../include/abcd.h	/^    inline double getMumpsRinfo(int i) { return mumps.rinfo[ i - 1 ]; }$/;"	f	class:abcd	access:private	signature:(int i)
abcd::glob_to_local	../include/abcd.h	/^    std::map<int,int> glob_to_local;$/;"	m	class:abcd	access:public
abcd::gmgs	../include/abcd.h	/^    void gmgs(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, Eigen::SparseMatrix<double> G, int s, bool use_a);$/;"	p	class:abcd	access:private	signature:(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, Eigen::SparseMatrix<double> G, int s, bool use_a)
abcd::gmgs	../include/abcd.h	/^    void gmgs(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, int s, bool use_a);$/;"	p	class:abcd	access:private	signature:(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, int s, bool use_a)
abcd::gmgs	../src/bcg.cpp	/^void abcd::gmgs(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r,$/;"	f	class:abcd	signature:(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r, Eigen::SparseMatrix<double> g, int s, bool use_a)
abcd::gmgs	../src/bcg.cpp	/^void abcd::gmgs(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r, int s, bool use_a)$/;"	f	class:abcd	signature:(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r, int s, bool use_a)
abcd::gqr	../include/abcd.h	/^    int gqr(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, Eigen::SparseMatrix<double> G, int s, bool use_a);$/;"	p	class:abcd	access:private	signature:(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, Eigen::SparseMatrix<double> G, int s, bool use_a)
abcd::gqr	../include/abcd.h	/^    int gqr(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, int s, bool use_a);$/;"	p	class:abcd	access:private	signature:(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, int s, bool use_a)
abcd::gqr	../src/bcg.cpp	/^int abcd::gqr(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r,$/;"	f	class:abcd	signature:(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r, Eigen::SparseMatrix<double> g, int s, bool use_a)
abcd::gqr	../src/bcg.cpp	/^int abcd::gqr(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r, int s, bool use_a)$/;"	f	class:abcd	signature:(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r, int s, bool use_a)
ABCD_HXX_	../include/abcd.h	9;"	d
abcd::icntl	../include/abcd.h	/^    int icntl[10];$/;"	m	class:abcd	access:public
~abcd	../include/abcd.h	/^    ~abcd();$/;"	p	class:abcd	access:public	signature:()
abcd	../include/abcd.h	/^    abcd();$/;"	p	class:abcd	access:public	signature:()
abcd	../include/abcd.h	/^class abcd$/;"	c
abcd::initializeCimmino	../include/abcd.h	/^    void initializeCimmino();$/;"	p	class:abcd	access:private	signature:()
abcd::initializeCimmino	../src/cimmino.cpp	/^void abcd::initializeCimmino()$/;"	f	class:abcd	signature:()
abcd::initialize	../include/abcd.h	/^    void initialize();$/;"	p	class:abcd	access:private	signature:()
abcd::initializeMumps	../include/abcd.h	/^    void initializeMumps(bool local);$/;"	p	class:abcd	access:private	signature:(bool local)
abcd::initializeMumps	../include/abcd.h	/^    void initializeMumps();$/;"	p	class:abcd	access:private	signature:()
abcd::initializeMumps	../src/mumps.cpp	/^void abcd::initializeMumps(bool local)$/;"	f	class:abcd	signature:(bool local)
abcd::initializeMumps	../src/mumps.cpp	/^void abcd::initializeMumps()$/;"	f	class:abcd	signature:()
abcd::initialize	../src/abcd.cpp	/^void abcd::initialize()$/;"	f	class:abcd	signature:()
abcd::instance_type	../include/abcd.h	/^    int instance_type; \/\/\/ The type of process : 0 for CG, 1 for MUMPS Slave$/;"	m	class:abcd	access:public
abcd::inter_comm	../include/abcd.h	/^    mpi::communicator inter_comm; \/\/\/ The communicator shared by CG masters$/;"	m	class:abcd	access:public
abcd::intra_comm	../include/abcd.h	/^    mpi::communicator intra_comm; \/\/\/ The communicator of local slaves$/;"	m	class:abcd	access:public
abcd::irn	../include/abcd.h	/^    int *irn;$/;"	m	class:abcd	access:public
abcd::itmax	../include/abcd.h	/^    int itmax;$/;"	m	class:abcd	access:public
abcd::jcn	../include/abcd.h	/^    int *jcn;$/;"	m	class:abcd	access:public
abcd::local_column_index	../include/abcd.h	/^    std::vector<std::vector<int> > local_column_index;$/;"	m	class:abcd	access:public
abcd::m	../include/abcd.h	/^    int m;$/;"	m	class:abcd	access:public
abcd::m_l	../include/abcd.h	/^    int m_l, nz_l;$/;"	m	class:abcd	access:public
abcd::m_n	../include/abcd.h	/^    int m_n;$/;"	m	class:abcd	access:private
abcd::m_nz	../include/abcd.h	/^    int m_nz;$/;"	m	class:abcd	access:private
abcd::mtx	../include/abcd.h	/^    Eigen::SparseMatrix<double, RowMajor> mtx;$/;"	m	class:abcd	access:private
abcd::mumps	../include/abcd.h	/^    DMUMPS_STRUC_C mumps;$/;"	m	class:abcd	access:private
abcd::my_master	../include/abcd.h	/^    int my_master;$/;"	m	class:abcd	access:private
abcd::my_slaves	../include/abcd.h	/^    std::vector<int> my_slaves;$/;"	m	class:abcd	access:private
abcd::nbparts	../include/abcd.h	/^    int nbparts; \/\/\/ The number of partitions$/;"	m	class:abcd	access:public
abcd::nbrows	../include/abcd.h	/^    ArrayXi nbrows; \/\/\/ The number of rows per partition$/;"	m	class:abcd	access:public
abcd::n	../include/abcd.h	/^    int n;$/;"	m	class:abcd	access:public
abcd::normres	../include/abcd.h	/^    std::vector<double> normres;$/;"	m	class:abcd	access:private
abcd::nrhs	../include/abcd.h	/^    int nrhs;$/;"	m	class:abcd	access:public
abcd::nrmA	../include/abcd.h	/^    double nrmA;$/;"	m	class:abcd	access:private
abcd::nz	../include/abcd.h	/^    int nz;$/;"	m	class:abcd	access:public
abcd::nz_l	../include/abcd.h	/^    int m_l, nz_l;$/;"	m	class:abcd	access:public
abcd::parallel_cg	../include/abcd.h	/^    int parallel_cg; \/\/\/ The number of parallel CG instances$/;"	m	class:abcd	access:public
abcd::partitioning_type	../include/abcd.h	/^    int partitioning_type;$/;"	m	class:abcd	access:public
abcd::partitionMatrix	../include/abcd.h	/^    void partitionMatrix();$/;"	p	class:abcd	access:private	signature:()
abcd::partitionMatrix	../src/structure.cpp	/^void abcd::partitionMatrix()$/;"	f	class:abcd	signature:()
abcd::partitionMatrix	structure.cpp	/^void abcd::partitionMatrix()$/
abcd::partitionWeights	../include/abcd.h	/^    void partitionWeights(std::vector<int> &, std::vector<int>, int);$/;"	p	class:abcd	access:private	signature:(std::vector<int> &, std::vector<int>, int)
abcd::partitionWeights	../src/utils.cpp	/^void abcd::partitionWeights(std::vector<int> &parts, std::vector<int> weights, int nb_parts)$/;"	f	class:abcd	signature:(std::vector<int> &parts, std::vector<int> weights, int nb_parts)
abcd::parts_id	../include/abcd.h	/^    std::vector<int> parts_id;$/;"	m	class:abcd	access:public
abcd::parts	../include/abcd.h	/^    std::vector<Eigen::SparseMatrix<double, RowMajor> > parts;$/;"	m	class:abcd	access:private
abcd::preprocess	../include/abcd.h	/^    void preprocess();$/;"	p	class:abcd	access:private	signature:()
abcd::preprocess	../src/preprocess.cpp	/^void abcd::preprocess()$/;"	f	class:abcd	signature:()
abcd::rhs	../include/abcd.h	/^    double *rhs;$/;"	m	class:abcd	access:public
abcd::scaleMatrix	../include/abcd.h	/^    void scaleMatrix(int norm);$/;"	p	class:abcd	access:private	signature:(int norm)
abcd::scaleMatrix	../src/preprocess.cpp	/^void abcd::scaleMatrix(int norm)$/;"	f	class:abcd	signature:(int norm)
abcd::setMumpsCntl	../include/abcd.h	/^    inline void setMumpsCntl(int i, double v) { mumps.cntl[ i - 1 ] = v ; }$/;"	f	class:abcd	access:private	signature:(int i, double v)
abcd::setMumpsIcntl	../include/abcd.h	/^    inline void setMumpsIcntl(int i, int v) { mumps.icntl[ i - 1 ] = v ; }$/;"	f	class:abcd	access:private	signature:(int i, int v)
~abcd	../src/abcd.cpp	/^abcd::~abcd()$/;"	f	class:abcd	signature:()
abcd	../src/abcd.cpp	/^abcd::abcd()$/;"	f	class:abcd	signature:()
abcd::start_index	../include/abcd.h	/^    int start_index; \/\/\/ To define wether it's Fortran-Style (1) or C-Style (0)$/;"	m	class:abcd	access:public
abcd::strow	../include/abcd.h	/^    ArrayXi strow; \/\/\/ The starting row index of each partition$/;"	m	class:abcd	access:public
abcd::sumProject	../include/abcd.h	/^    Eigen::MatrixXd sumProject(double alpha, Eigen::MatrixXd B, double beta, Eigen::MatrixXd X);$/;"	p	class:abcd	access:private	signature:(double alpha, Eigen::MatrixXd B, double beta, Eigen::MatrixXd X)
abcd::sumProject	../src/mumps.cpp	/^Eigen::MatrixXd abcd::sumProject(double alpha, Eigen::MatrixXd B, double beta, Eigen::MatrixXd X)$/;"	f	class:abcd	signature:(double alpha, Eigen::MatrixXd B, double beta, Eigen::MatrixXd X)
abcd::sym	../include/abcd.h	/^    bool sym; \/\/\/ Symmetry$/;"	m	class:abcd	access:public
abcd::use_xk	../include/abcd.h	/^    bool use_xk;$/;"	m	class:abcd	access:private
abcd::val	../include/abcd.h	/^    double *val;$/;"	m	class:abcd	access:public
abcd::xk	../include/abcd.h	/^    Eigen::Matrix<double,Dynamic, Dynamic, ColMajor> xk;$/;"	m	class:abcd	access:private
abs2_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct abs2_impl$/;"	s	namespace:Eigen::internal
abs2_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct abs2_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
abs2	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(abs2, Scalar) abs2(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
abs2	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_abs2_op)     abs2() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
abs2	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::abs2() const$/;"	f	class:Eigen::Cwise	signature:() const
abs2	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^abs2() const$/;"	f	signature:() const
abs2_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct abs2_retval$/;"	s	namespace:Eigen::internal
absDeterminant	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typename MatrixType::RealScalar absDeterminant() const;$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
absDeterminant	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR	signature:() const
absDeterminant	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typename MatrixType::RealScalar absDeterminant() const;$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
absDeterminant	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR	signature:() const
absDeterminant	../include/Eigen/src/QR/HouseholderQR.h	/^    typename MatrixType::RealScalar absDeterminant() const;$/;"	p	class:Eigen::HouseholderQR	access:public	signature:() const
absDeterminant	../include/Eigen/src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::HouseholderQR	signature:() const
AbsDiagIndex	../include/Eigen/src/Core/Diagonal.h	/^    AbsDiagIndex = DiagIndex<0 ? -DiagIndex : DiagIndex, \/\/ only used if DiagIndex != Dynamic$/;"	e	enum:Eigen::internal::traits::__anon148
absDistance	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar absDistance(const VectorType& p) const { return ei_abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
absDistance	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Scalar absDistance(const VectorType& p) const { return internal::abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
abs_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct abs_impl$/;"	s	namespace:Eigen::internal
abs	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(abs, Scalar) abs(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
abs	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_abs_op)      abs() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
abs	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::abs() const$/;"	f	class:Eigen::Cwise	signature:() const
abs	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^abs() const$/;"	f	signature:() const
abs_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct abs_retval$/;"	s	namespace:Eigen::internal
ABx_lx	../include/Eigen/src/Core/util/Constants.h	/^  ABx_lx              = 0x200,$/;"	e	enum:Eigen::DecompositionOptions
AccessorLevels	../include/Eigen/src/Core/util/Constants.h	/^enum AccessorLevels {$/;"	g	namespace:Eigen
accessors_level	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct accessors_level$/;"	s	namespace:Eigen::internal
acc	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const
acc	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const DoublePacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const DoublePacket& c, const ResPacket& alpha, ResPacket& r) const
acc	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const Scalar& c, const Scalar& alpha, Scalar& r) const { r += alpha * c; }$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const Scalar& c, const Scalar& alpha, Scalar& r) const
AccPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef ResPacket AccPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
AccPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type AccPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
AccPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::AccPacket AccPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
acos	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^acos() const$/;"	f	signature:() const
Action	../include/Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	g	namespace:Eigen
ActualCols	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      ActualCols = Transpose ? MaxRows : MaxCols$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon106
ActualIndex	../include/Eigen/src/Core/BandMatrix.h	/^        ActualIndex = ReturnOpposite ? -Index : Index,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon80
_ActualLhsType	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<ActualLhsType>::type _ActualLhsType;$/;"	t	class:Eigen::ProductBase	access:public
ActualLhsType	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;$/;"	t	class:Eigen::ProductBase	access:public
ActualLhsType	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
ActualLhsType	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::ExtractType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
ActualPacketAccessBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = 0x0;$/;"	m	namespace:Eigen
ActualPacketAccessBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = PacketAccessBit;$/;"	m	namespace:Eigen
_ActualRhsType	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<ActualRhsType>::type _ActualRhsType;$/;"	t	class:Eigen::ProductBase	access:public
ActualRhsType	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;$/;"	t	class:Eigen::ProductBase	access:public
ActualRows	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      ActualRows = Transpose ? MaxCols : MaxRows,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon106
add_const	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	s	namespace:Eigen::internal
add_const	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type_if_arithmetic	../include/Eigen/src/Core/DenseCoeffsBase.h	/^template<typename T> struct add_const_on_value_type_if_arithmetic$/;"	s	namespace:Eigen::internal
add_const_on_value_type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	s	namespace:Eigen::internal
AddCost	../include/Eigen/src/Core/NumTraits.h	/^    AddCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon277
address	../include/Eigen/src/Core/util/Memory.h	/^    const_pointer address( const_reference value ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( const_reference value ) const
address	../include/Eigen/src/Core/util/Memory.h	/^    pointer address( reference value ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( reference value ) const
addTo	../include/Eigen/src/Core/DiagonalMatrix.h	/^    void addTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
addTo	../include/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void addTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
addTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void addTo(Dest& dst) const { scaleAndAddTo(dst,Scalar(1)); }$/;"	f	class:Eigen::ProductBase	access:public	signature:(Dest& dst) const
addTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void addTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(1)); }$/;"	f	class:Eigen::ScaledProduct	access:public	signature:(Dest& dst) const
adjoint	../include/Eigen/src/Core/MatrixBase.h	/^    const AdjointReturnType adjoint() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
adjoint	../include/Eigen/src/Core/Transpose.h	/^MatrixBase<Derived>::adjoint() const$/;"	f	class:Eigen::MatrixBase	signature:() const
adjoint	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline const TriangularView<const typename MatrixType::AdjointReturnType,TransposeMode> adjoint() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
adjoint	../include/Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType adjoint() const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
adjoint	../include/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation adjoint() const { return JacobiRotation(internal::conj(m_c), -m_s); }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
adjoint	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const AdjointReturnType adjoint() const { return transpose(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
adjointInPlace	../include/Eigen/src/Core/MatrixBase.h	/^    void adjointInPlace();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
adjointInPlace	../include/Eigen/src/Core/Transpose.h	/^inline void MatrixBase<Derived>::adjointInPlace()$/;"	f	class:Eigen::MatrixBase	signature:()
AdjointReturnType	../include/Eigen/src/Core/MatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
AdjointReturnType	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Affine2d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Affine> Affine2d;$/;"	t	namespace:Eigen
Affine2f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Affine> Affine2f;$/;"	t	namespace:Eigen
Affine3d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Affine> Affine3d;$/;"	t	namespace:Eigen
Affine3f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Affine> Affine3f;$/;"	t	namespace:Eigen
AffineCompact2d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,AffineCompact> AffineCompact2d;$/;"	t	namespace:Eigen
AffineCompact2f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,AffineCompact> AffineCompact2f;$/;"	t	namespace:Eigen
AffineCompact3d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,AffineCompact> AffineCompact3d;$/;"	t	namespace:Eigen
AffineCompact3f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,AffineCompact> AffineCompact3f;$/;"	t	namespace:Eigen
AffineCompact	../include/Eigen/src/Core/util/Constants.h	/^  AffineCompact = 0x10 | Affine,$/;"	e	enum:Eigen::TransformTraits
Affine	../include/Eigen/src/Core/util/Constants.h	/^  Affine        = 0x2,$/;"	e	enum:Eigen::TransformTraits
affine	../include/Eigen/src/Geometry/Transform.h	/^  inline AffinePart affine() { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform	access:public	signature:()
affine	../include/Eigen/src/Geometry/Transform.h	/^  inline ConstAffinePart affine() const { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
AffinePart	../include/Eigen/src/Geometry/Transform.h	/^                              Block<MatrixType,Dim,HDim> >::type AffinePart;$/;"	t	class:Eigen::Transform	access:public
AffinePart	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::AffinePart AffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
AffineTransformType	../include/Eigen/src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Affine> AffineTransformType;$/;"	t	class:Eigen::Translation	access:public
a	../include/Eigen/src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	m	struct:Eigen::internal::has_none	access:public
a	../include/Eigen/src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	m	struct:Eigen::internal::has_std_result_type	access:public
a	../include/Eigen/src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	m	struct:Eigen::internal::has_tr1_result	access:public
a	../include/Eigen/src/SVD/JacobiSVD.h	/^  enum { a = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon414
aligned_allocator	../include/Eigen/src/Core/util/Memory.h	/^    aligned_allocator( const aligned_allocator& )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( const aligned_allocator& )
aligned_allocator	../include/Eigen/src/Core/util/Memory.h	/^    aligned_allocator( const aligned_allocator<U>& )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( const aligned_allocator<U>& )
~aligned_allocator	../include/Eigen/src/Core/util/Memory.h	/^    ~aligned_allocator()$/;"	f	class:Eigen::aligned_allocator	access:public	signature:()
aligned_allocator	../include/Eigen/src/Core/util/Memory.h	/^    aligned_allocator()$/;"	f	class:Eigen::aligned_allocator	access:public	signature:()
aligned_allocator	../include/Eigen/src/Core/util/Memory.h	/^class aligned_allocator$/;"	c	namespace:Eigen
aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection& ) : EIGEN_ALIGNED_ALLOCATOR<T>() {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const aligned_allocator_indirection& )
aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const aligned_allocator_indirection<U>& )
aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<T>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const EIGEN_ALIGNED_ALLOCATOR<T>& )
aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const EIGEN_ALIGNED_ALLOCATOR<U>& )
~aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^    ~aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:()
aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:()
aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^  class aligned_allocator_indirection : public EIGEN_ALIGNED_ALLOCATOR<T>$/;"	c	namespace:Eigen	inherits:EIGEN_ALIGNED_ALLOCATOR
AlignedBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int AlignedBit = 0x80;$/;"	m	namespace:Eigen
~AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox(const VectorType& _min, const VectorType& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& _min, const VectorType& _max)
AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)
AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const VectorType& p) : m_min(p), m_max(p) {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p)
AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(int _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(int _dim)
AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/All.h	110;"	d
AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/All.h	55;"	d
~AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^  ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox(const OtherVectorType1& _min, const OtherVectorType2& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const OtherVectorType1& _min, const OtherVectorType2& _max)
AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)
AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const MatrixBase<Derived>& a_p)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& a_p)
AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(Index _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(Index _dim)
aligned_delete	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> inline void aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
aligned_free	../include/Eigen/src/Core/util/Memory.h	/^inline void aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
aligned_free	../include/Eigen/src/Core/util/Memory.h	/^void  aligned_free(void *ptr);$/;"	p	namespace:Eigen::internal	signature:(void *ptr)
Aligned	../include/Eigen/src/Core/util/Constants.h	/^  Aligned=1 $/;"	e	enum:Eigen::__anon208
aligned_malloc	../include/Eigen/src/Core/util/Memory.h	/^inline void* aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
aligned_malloc	../include/Eigen/src/Core/util/Memory.h	/^void* aligned_malloc(size_t size);$/;"	p	namespace:Eigen::internal	signature:(size_t size)
AlignedMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Aligned> AlignedMapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
aligned_new	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> inline T* aligned_new(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
AlignedOnScalar	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
AlignedOnScalar	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
AlignedOnScalar	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
AlignedOnScalar	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
AlignedOnScalar	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
AlignedOnScalar	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
AlignedOnScalar	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
AlignedOnScalar	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
AlignedOnScalar	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
AlignedOnScalar	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon245
AlignedOnScalar	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon246
AlignedOnScalar	../include/Eigen/src/Core/GenericPacketMath.h	/^    AlignedOnScalar = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon230
aligned_realloc	../include/Eigen/src/Core/util/Memory.h	/^inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(void *ptr, size_t new_size, size_t old_size)
AlignedScaling2d	../include/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,2> AlignedScaling2d;$/;"	t	namespace:Eigen
AlignedScaling2f	../include/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 2> AlignedScaling2f;$/;"	t	namespace:Eigen
AlignedScaling3d	../include/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,3> AlignedScaling3d;$/;"	t	namespace:Eigen
AlignedScaling3f	../include/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 3> AlignedScaling3f;$/;"	t	namespace:Eigen
~aligned_stack_memory_handler	../include/Eigen/src/Core/util/Memory.h	/^    ~aligned_stack_memory_handler()$/;"	f	class:Eigen::internal::aligned_stack_memory_handler	access:public	signature:()
aligned_stack_memory_handler	../include/Eigen/src/Core/util/Memory.h	/^    aligned_stack_memory_handler(T* ptr, size_t size, bool dealloc)$/;"	f	class:Eigen::internal::aligned_stack_memory_handler	access:public	signature:(T* ptr, size_t size, bool dealloc)
aligned_stack_memory_handler	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> class aligned_stack_memory_handler$/;"	c	namespace:Eigen::internal
alignment	../include/Eigen/src/Core/Redux.h	/^    alignment = (Derived::Flags & AlignedBit) ? Aligned : Unaligned$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon275
AlignmentMask	../include/Eigen/src/Cholesky/LLT.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::LLT::__anon404
AlignmentMask	../include/Eigen/src/Eigen2Support/SVD.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::SVD::__anon440
all	../include/Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::all() const$/;"	f	class:Eigen::DenseBase	signature:() const
all	../include/Eigen/src/Core/DenseBase.h	/^    bool all(void) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(void) const
all	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_all>::Type all() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
allocateA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateA() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateA()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateAll	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateAll() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateAll	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateAll()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateB() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateB()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocatedSize	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline size_t allocatedSize() const { return m_allocatedSize; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:() const
allocate	../include/Eigen/src/Core/util/Memory.h	/^    pointer allocate( size_type num, const void* hint = 0 )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( size_type num, const void* hint = 0 )
allocate	../include/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)
allocate	../include/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)
allocate	../include/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)
allocate	../include/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, QRPreconditioner>&) {}$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, QRPreconditioner>&)
allocate	../include/Eigen/src/SVD/JacobiSVD.h	/^    void allocate(Index rows, Index cols, unsigned int computationOptions);$/;"	p	class:Eigen::JacobiSVD	access:private	signature:(Index rows, Index cols, unsigned int computationOptions)
allocate	../include/Eigen/src/SVD/JacobiSVD.h	/^void JacobiSVD<MatrixType, QRPreconditioner>::allocate(Index rows, Index cols, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD	signature:(Index rows, Index cols, unsigned int computationOptions)
allocateMumpsSlaves	../include/abcd.h	/^    void allocateMumpsSlaves();$/;"	p	class:abcd	access:private	signature:()
allocateMumpsSlaves	../src/mumps.cpp	/^void abcd::allocateMumpsSlaves()$/;"	f	class:abcd	signature:()
allocateW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateW() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
allocateW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateW()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
all_unroller	../include/Eigen/src/Core/BooleanRedux.h	/^struct all_unroller<Derived, 1>$/;"	s	namespace:Eigen::internal
all_unroller	../include/Eigen/src/Core/BooleanRedux.h	/^struct all_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
all_unroller	../include/Eigen/src/Core/BooleanRedux.h	/^struct all_unroller$/;"	s	namespace:Eigen::internal
alpha	../include/Eigen/src/Core/ProductBase.h	/^    const Scalar& alpha() const { return m_alpha; }$/;"	f	class:Eigen::ScaledProduct	access:public	signature:() const
AltiVec	../include/Eigen/src/Core/util/Constants.h	/^    AltiVec = 0x2,$/;"	e	enum:Eigen::Architecture::Type
always_void	../include/Eigen/src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	s	namespace:Eigen::internal
AmbientDimAtCompileTime	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon432
AmbientDimAtCompileTime	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::Hyperplane::__anon439
AmbientDimAtCompileTime	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::ParametrizedLine::__anon433
AmbientDimAtCompileTime	../include/Eigen/src/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon371
AmbientDimAtCompileTime	../include/Eigen/src/Geometry/Hyperplane.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::Hyperplane::__anon393
AmbientDimAtCompileTime	../include/Eigen/src/Geometry/ParametrizedLine.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::ParametrizedLine::__anon372
~AmbiVector	../include/Eigen/src/SparseCore/AmbiVector.h	/^    ~AmbiVector() { delete[] m_buffer; }$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:()
AmbiVector	../include/Eigen/src/SparseCore/AmbiVector.h	/^    AmbiVector(Index size)$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:(Index size)
AmbiVector	../include/Eigen/src/SparseCore/AmbiVector.h	/^class AmbiVector$/;"	c	namespace:Eigen::internal
amd_flip	../include/Eigen/src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_flip(const T& i) { return -i-2; }$/;"	f	namespace:Eigen::internal	signature:(const T& i)
amd_marked	../include/Eigen/src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline bool amd_marked(const T0* w, const T1& j) { return w[j]<0; }$/;"	f	namespace:Eigen::internal	signature:(const T0* w, const T1& j)
amd_mark	../include/Eigen/src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline void amd_mark(const T0* w, const T1& j) { return w[j] = amd_flip(w[j]); }$/;"	f	namespace:Eigen::internal	signature:(const T0* w, const T1& j)
amd_unflip	../include/Eigen/src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_unflip(const T& i) { return i<0 ? amd_flip(i) : i; }$/;"	f	namespace:Eigen::internal	signature:(const T& i)
analyseAugmentedSystems	../include/abcd.h	/^    void analyseAugmentedSystems();$/;"	p	class:abcd	access:private	signature:()
analyseAugmentedSystems	../src/mumps.cpp	/^void abcd::analyseAugmentedSystems()$/;"	f	class:abcd	signature:()
analyseFrame	../include/abcd.h	/^    void analyseFrame();$/;"	p	class:abcd	access:private	signature:()
analyseFrame	../src/structure.cpp	/^void abcd::analyseFrame()$/;"	f	class:abcd	signature:()
analyzePattern	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
analyzePattern	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& analyzePattern(const MatrixType& )$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatrixType& )
analyzePattern	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& analyzePattern(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
analyzePattern	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void analyzePattern(const MatrixType& amat);$/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& amat)
analyzePattern	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::analyzePattern(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT	signature:(const _MatrixType& amat)
analyzePattern	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& analyzePattern(const MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const MatrixType& A)
analyzePattern	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Derived& analyzePattern(const MatrixType& matrix);$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixType& matrix)
analyzePattern	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixType& a)
analyzePattern	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(ColSpMatrix& mat);$/;"	p	class:Eigen::PastixBase	access:protected	signature:(ColSpMatrix& mat)
analyzePattern	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
analyzePattern	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
analyzePattern	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
analyzePattern	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::analyzePattern(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase	signature:(ColSpMatrix& mat)
analyzePattern	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& a, bool doLDLT)
analyzePattern	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& a)
analyzePattern	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& a)
analyzePattern	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& a)
analyzePattern	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperILU	access:public	signature:(const MatrixType& matrix)
analyzePattern	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLU	access:public	signature:(const MatrixType& matrix)
analyzePattern	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& \/*matrix*\/)$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const MatrixType& )
analyzePattern	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixType& matrix)
analyzePattern_preordered	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern_preordered(const CholMatrixType& a, bool doLDLT);$/;"	p	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const CholMatrixType& a, bool doLDLT)
analyzePattern_preordered	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::analyzePattern_preordered(const CholMatrixType& ap, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase	signature:(const CholMatrixType& ap, bool doLDLT)
Ancestor	../include/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_all<Lhs>::type Ancestor;$/;"	t	struct:Eigen::internal::traits	access:public
AngleAxisd	../include/Eigen/src/Eigen2Support/Geometry/All.h	35;"	d
AngleAxisd	../include/Eigen/src/Eigen2Support/Geometry/All.h	90;"	d
AngleAxisd	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
AngleAxisd	../include/Eigen/src/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
AngleAxisf	../include/Eigen/src/Eigen2Support/Geometry/All.h	34;"	d
AngleAxisf	../include/Eigen/src/Eigen2Support/Geometry/All.h	89;"	d
AngleAxisf	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
AngleAxisf	../include/Eigen/src/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/All.h	33;"	d
AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/All.h	88;"	d
AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis() {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen	inherits:RotationBase
AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline AngleAxis(const QuaternionType& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& q)
AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline AngleAxis(Scalar angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:(Scalar angle, const MatrixBase<Derived>& axis)
AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis<OtherScalarType>& other)
AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
AngleAxis	../include/Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis() {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
AngleAxis	../include/Eigen/src/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen	inherits:RotationBase
AngleAxis	../include/Eigen/src/Geometry/AngleAxis.h	/^  inline AngleAxis(Scalar angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:(Scalar angle, const MatrixBase<Derived>& axis)
AngleAxis	../include/Eigen/src/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis<OtherScalarType>& other)
AngleAxis	../include/Eigen/src/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
AngleAxis	../include/Eigen/src/Geometry/AngleAxis.h	/^  template<typename QuatDerived> inline explicit AngleAxis(const QuaternionBase<QuatDerived>& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionBase<QuatDerived>& q)
AngleAxisType	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::Quaternion	access:public
AngleAxisType	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::QuaternionBase	access:public
AngleAxisType	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef typename Base::AngleAxisType AngleAxisType;$/;"	t	class:Eigen::Quaternion	access:public
angle	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
angle	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
angle	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
angle	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
angle	../include/Eigen/src/Geometry/AngleAxis.h	/^  Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
angle	../include/Eigen/src/Geometry/AngleAxis.h	/^  Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
angle	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
angle	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
angularDistance	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar angularDistance(const Quaternion& other) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other) const
angularDistance	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Scalar Quaternion<Scalar>::angularDistance(const Quaternion& other) const$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other) const
angularDistance	../include/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::angularDistance(const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other) const
angularDistance	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> Scalar angularDistance(const QuaternionBase<OtherDerived>& other) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other) const
any	../include/Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::any() const$/;"	f	class:Eigen::DenseBase	signature:() const
any	../include/Eigen/src/Core/DenseBase.h	/^    bool any(void) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(void) const
any	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_any>::Type any() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
any_unroller	../include/Eigen/src/Core/BooleanRedux.h	/^struct any_unroller<Derived, 1>$/;"	s	namespace:Eigen::internal
any_unroller	../include/Eigen/src/Core/BooleanRedux.h	/^struct any_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
any_unroller	../include/Eigen/src/Core/BooleanRedux.h	/^struct any_unroller$/;"	s	namespace:Eigen::internal
append	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    void append(const Scalar& v, Index i)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const Scalar& v, Index i)
apply_block_householder_on_the_left	../include/Eigen/src/Householder/BlockHouseholder.h	/^void apply_block_householder_on_the_left(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs)
applyHouseholderOnTheLeft	../include/Eigen/src/Core/MatrixBase.h	/^    void applyHouseholderOnTheLeft(const EssentialPart& essential,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
applyHouseholderOnTheLeft	../include/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheLeft($/;"	f	class:Eigen::MatrixBase	signature:( const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
applyHouseholderOnTheRight	../include/Eigen/src/Core/MatrixBase.h	/^    void applyHouseholderOnTheRight(const EssentialPart& essential,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
applyHouseholderOnTheRight	../include/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheRight($/;"	f	class:Eigen::MatrixBase	signature:( const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
applyOnTheLeft	../include/Eigen/src/Core/EigenBase.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived> &other)
applyOnTheLeft	../include/Eigen/src/Core/MatrixBase.h	/^    void applyOnTheLeft(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
applyOnTheLeft	../include/Eigen/src/Core/MatrixBase.h	/^    void applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
applyOnTheLeft	../include/Eigen/src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
applyOnTheRight	../include/Eigen/src/Core/EigenBase.h	/^inline void MatrixBase<Derived>::applyOnTheRight(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived> &other)
applyOnTheRight	../include/Eigen/src/Core/MatrixBase.h	/^    void applyOnTheRight(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
applyOnTheRight	../include/Eigen/src/Core/MatrixBase.h	/^    void applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
applyOnTheRight	../include/Eigen/src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
apply_rotation_in_the_plane	../include/Eigen/src/Jacobi/Jacobi.h	/^void apply_rotation_in_the_plane(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j);$/;"	p	namespace:Eigen::internal	signature:(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)
apply_rotation_in_the_plane	../include/Eigen/src/Jacobi/Jacobi.h	/^void \/*EIGEN_DONT_INLINE*\/ apply_rotation_in_the_plane(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)$/;"	f	namespace:Eigen::internal	signature:(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)
applyThisOnTheLeft	../include/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
applyThisOnTheLeft	../include/Eigen/src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheLeft(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst, Workspace& workspace) const
applyThisOnTheLeft	../include/Eigen/src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst) const
applyThisOnTheRight	../include/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
applyThisOnTheRight	../include/Eigen/src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheRight(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst, Workspace& workspace) const
applyThisOnTheRight	../include/Eigen/src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst) const
applyTranspositionOnTheLeft	../include/Eigen/src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheLeft(Index i, Index j)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index i, Index j)
applyTranspositionOnTheRight	../include/Eigen/src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheRight(Index i, Index j)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index i, Index j)
ARCHITECTURE_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	264;"	d	file:
ARCHITECTURE_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	267;"	d	file:
ARCHITECTURE_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	270;"	d	file:
ARCHITECTURE_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	273;"	d	file:
ARCHITECTURE_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	276;"	d	file:
ARCHITECTURE_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	280;"	d	file:
Architecture	../include/Eigen/src/Core/util/Constants.h	/^namespace Architecture$/;"	n	namespace:Eigen
ArrayBase	../include/Eigen/src/Core/ArrayBase.h	/^    ArrayBase() : Base() {}$/;"	f	class:Eigen::ArrayBase	access:protected	signature:()
ArrayBase	../include/Eigen/src/Core/ArrayBase.h	/^    ArrayBase(Index,Index);$/;"	p	class:Eigen::ArrayBase	access:private	signature:(Index,Index)
ArrayBase	../include/Eigen/src/Core/ArrayBase.h	/^    explicit ArrayBase(Index);$/;"	p	class:Eigen::ArrayBase	access:private	signature:(Index)
ArrayBase	../include/Eigen/src/Core/ArrayBase.h	/^template<typename Derived> class ArrayBase$/;"	c	namespace:Eigen	inherits:DenseBase
ArrayBase	../include/Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> explicit ArrayBase(const ArrayBase<OtherDerived>&);$/;"	p	class:Eigen::ArrayBase	access:private	signature:(const ArrayBase<OtherDerived>&)
array	../include/Eigen/src/Core/ArrayBase.h	/^    ArrayBase<Derived>& array() { return *this; }$/;"	f	class:Eigen::ArrayBase	access:public	signature:()
array	../include/Eigen/src/Core/ArrayBase.h	/^    const ArrayBase<Derived>& array() const { return *this; }$/;"	f	class:Eigen::ArrayBase	access:public	signature:() const
Array	../include/Eigen/src/Core/Array.h	/^    Array(const Scalar& x, const Scalar& y);$/;"	p	class:Eigen::Array	access:public	signature:(const Scalar& x, const Scalar& y)
Array	../include/Eigen/src/Core/Array.h	/^    Array(Index rows, Index cols);$/;"	p	class:Eigen::Array	access:public	signature:(Index rows, Index cols)
Array	../include/Eigen/src/Core/Array.h	/^    Array(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Array	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Array	../include/Eigen/src/Core/Array.h	/^class Array$/;"	c	namespace:Eigen	inherits:PlainObjectBase
Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::Array	access:public	signature:(const ArrayBase<OtherDerived>& other)
Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Array& other)$/;"	f	class:Eigen::Array	access:public	signature:(const Array& other)
Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array	access:public	signature:(const EigenBase<OtherDerived> &other)
Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Array	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)$/;"	f	class:Eigen::Array	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& x, const Scalar& y, const Scalar& z)$/;"	f	class:Eigen::Array	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z)
Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const T0& x, const T1& y)$/;"	f	class:Eigen::Array	access:public	signature:(const T0& x, const T1& y)
Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE explicit Array() : Base()$/;"	f	class:Eigen::Array	access:public	signature:()
Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE explicit Array(Index dim)$/;"	f	class:Eigen::Array	access:public	signature:(Index dim)
Array	../include/Eigen/src/Core/Array.h	/^    explicit Array(const Scalar *data);$/;"	p	class:Eigen::Array	access:public	signature:(const Scalar *data)
array	../include/Eigen/src/Core/DenseStorage.h	/^  EIGEN_USER_ALIGN16 T array[1];$/;"	m	struct:Eigen::internal::plain_array	access:public
array	../include/Eigen/src/Core/DenseStorage.h	/^  EIGEN_USER_ALIGN16 T array[Size];$/;"	m	struct:Eigen::internal::plain_array	access:public
array	../include/Eigen/src/Core/DenseStorage.h	/^  T array[Size];$/;"	m	struct:Eigen::internal::plain_array	access:public
Array	../include/Eigen/src/Core/Map.h	/^  ::Array(const Scalar *data)$/;"	f	class:Eigen::Array	signature:(const Scalar *data)
array	../include/Eigen/src/Core/MatrixBase.h	/^    ArrayWrapper<Derived> array() { return derived(); }$/;"	f	class:Eigen::MatrixBase	access:public	signature:()
array	../include/Eigen/src/Core/MatrixBase.h	/^    const ArrayWrapper<const Derived> array() const { return derived(); }$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
ArrayWrapper	../include/Eigen/src/Core/ArrayWrapper.h	/^class ArrayWrapper : public ArrayBase<ArrayWrapper<ExpressionType> >$/;"	c	namespace:Eigen	inherits:ArrayBase
ArrayWrapper	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline ArrayWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(ExpressionType& matrix)
ArrayXpr	../include/Eigen/src/Core/util/Constants.h	/^struct ArrayXpr {};$/;"	s	namespace:Eigen
asDiagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^MatrixBase<Derived>::asDiagonal() const$/;"	f	class:Eigen::MatrixBase	signature:() const
asDiagonal	../include/Eigen/src/Core/MatrixBase.h	/^    const DiagonalWrapper<const Derived> asDiagonal() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
asin	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^asin() const$/;"	f	signature:() const
asPermutation	../include/Eigen/src/Core/MatrixBase.h	/^    const PermutationWrapper<const Derived> asPermutation() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
asPermutation	../include/Eigen/src/Core/PermutationMatrix.h	/^const PermutationWrapper<const Derived> MatrixBase<Derived>::asPermutation() const$/;"	f	class:Eigen::MatrixBase	signature:() const
assign_conj_scalar_eig2mkl	../include/Eigen/src/Core/util/MKL_support.h	/^inline void assign_conj_scalar_eig2mkl<MKL_Complex16,dcomplex>(MKL_Complex16& mklScalar, const dcomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex16& mklScalar, const dcomplex& eigenScalar)
assign_conj_scalar_eig2mkl	../include/Eigen/src/Core/util/MKL_support.h	/^inline void assign_conj_scalar_eig2mkl<MKL_Complex8,scomplex>(MKL_Complex8& mklScalar, const scomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex8& mklScalar, const scomplex& eigenScalar)
assign_conj_scalar_eig2mkl	../include/Eigen/src/Core/util/MKL_support.h	/^static inline void assign_conj_scalar_eig2mkl(MKLType& mklScalar, const EigenType& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKLType& mklScalar, const EigenType& eigenScalar)
assign_DefaultTraversal_CompleteUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_DefaultTraversal_CompleteUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
assign_DefaultTraversal_InnerUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_InnerUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_DefaultTraversal_InnerUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_InnerUnrolling$/;"	s	namespace:Eigen::internal
assignGeneric	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline void assignGeneric(const OtherDerived& other)$/;"	f	class:Eigen::SparseMatrixBase	access:protected	signature:(const OtherDerived& other)
assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, InnerUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, InnerUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InvalidTraversal, Unrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, SliceVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& assign(const OtherDerived& other)$/;"	f	class:Eigen::SparseMatrixBase	access:protected	signature:(const OtherDerived& other)
assign	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DONT_INLINE SparseVector& assign(const SparseMatrixBase<OtherDerived>& _other)$/;"	f	class:Eigen::SparseVector	access:protected	signature:(const SparseMatrixBase<OtherDerived>& _other)
assign_innervec_CompleteUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_innervec_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_innervec_CompleteUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_innervec_CompleteUnrolling$/;"	s	namespace:Eigen::internal
assign_innervec_InnerUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_innervec_InnerUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_innervec_InnerUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_innervec_InnerUnrolling$/;"	s	namespace:Eigen::internal
assign_LinearTraversal_CompleteUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_LinearTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_LinearTraversal_CompleteUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_LinearTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
assignProduct	../include/Eigen/src/Core/PermutationMatrix.h	/^    void assignProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationBase	access:protected	signature:(const Lhs& lhs, const Rhs& rhs)
assignProduct	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^TriangularView<MatrixType,UpLo>& TriangularView<MatrixType,UpLo>::assignProduct(const ProductBase<ProductDerived, _Lhs,_Rhs>& prod, const Scalar& alpha)$/;"	f	class:Eigen::TriangularView	signature:(const ProductBase<ProductDerived, _Lhs,_Rhs>& prod, const Scalar& alpha)
assignProduct	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& assignProduct(const ProductBase<ProductDerived, Lhs,Rhs>& prod, const Scalar& alpha);$/;"	p	class:Eigen::TriangularView	access:protected	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& prod, const Scalar& alpha)
assign_scalar_eig2mkl	../include/Eigen/src/Core/util/MKL_support.h	/^inline void assign_scalar_eig2mkl<MKL_Complex16,dcomplex>(MKL_Complex16& mklScalar, const dcomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex16& mklScalar, const dcomplex& eigenScalar)
assign_scalar_eig2mkl	../include/Eigen/src/Core/util/MKL_support.h	/^inline void assign_scalar_eig2mkl<MKL_Complex8,scomplex>(MKL_Complex8& mklScalar, const scomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex8& mklScalar, const scomplex& eigenScalar)
assign_scalar_eig2mkl	../include/Eigen/src/Core/util/MKL_support.h	/^static inline void assign_scalar_eig2mkl(MKLType& mklScalar, const EigenType& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKLType& mklScalar, const EigenType& eigenScalar)
assign_selector	../include/Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,false,false> {$/;"	s	namespace:Eigen::internal
assign_selector	../include/Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,false,true> {$/;"	s	namespace:Eigen::internal
assign_selector	../include/Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,true,false> {$/;"	s	namespace:Eigen::internal
assign_selector	../include/Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,true,true> {$/;"	s	namespace:Eigen::internal
assign_traits	../include/Eigen/src/Core/Assign.h	/^struct assign_traits$/;"	s	namespace:Eigen::internal
assignTranspose	../include/Eigen/src/Core/PermutationMatrix.h	/^    void assignTranspose(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase	access:protected	signature:(const PermutationBase<OtherDerived>& other)
asSluMatrix	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^SluMatrix asSluMatrix(MatrixType& mat)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat)
atan2_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct atan2_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
atan2_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct atan2_default_impl$/;"	s	namespace:Eigen::internal
atan2_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct atan2_impl : atan2_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:atan2_default_impl
atan2	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(atan2, Scalar) atan2(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
atan2_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct atan2_retval$/;"	s	namespace:Eigen::internal
at	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar at(Index key, Scalar defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index key, Scalar defaultValue = Scalar(0)) const
atInRange	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar atInRange(size_t start, size_t end, Index key, Scalar defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t start, size_t end, Index key, Scalar defaultValue = Scalar(0)) const
atWithInsertion	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar& atWithInsertion(Index key, Scalar defaultValue = Scalar(0))$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index key, Scalar defaultValue = Scalar(0))
AutoAlign	../include/Eigen/src/Core/util/Constants.h	/^  AutoAlign = 0,$/;"	e	enum:Eigen::__anon212
axis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
axis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
axis	../include/Eigen/src/Geometry/AngleAxis.h	/^  const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
axis	../include/Eigen/src/Geometry/AngleAxis.h	/^  Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Ax_lBx	../include/Eigen/src/Core/util/Constants.h	/^  Ax_lBx              = 0x100,$/;"	e	enum:Eigen::DecompositionOptions
BandMatrixBase	../include/Eigen/src/Core/BandMatrix.h	/^class BandMatrixBase : public EigenBase<Derived>$/;"	c	namespace:Eigen::internal	inherits:EigenBase
BandMatrix	../include/Eigen/src/Core/BandMatrix.h	/^class BandMatrix : public BandMatrixBase<BandMatrix<_Scalar,Rows,Cols,Supers,Subs,Options> >$/;"	c	namespace:Eigen::internal	inherits:BandMatrixBase
BandMatrix	../include/Eigen/src/Core/BandMatrix.h	/^    inline BandMatrix(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)
BandMatrixWrapper	../include/Eigen/src/Core/BandMatrix.h	/^class BandMatrixWrapper : public BandMatrixBase<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	c	namespace:Eigen::internal	inherits:BandMatrixBase
BandMatrixWrapper	../include/Eigen/src/Core/BandMatrix.h	/^    inline BandMatrixWrapper(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)
Base	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodDecomposition> Base;$/;"	t	class:Eigen::CholmodDecomposition	access:private
Base	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLDLT	access:private
Base	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLLT	access:private
Base	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT> Base;$/;"	t	class:Eigen::CholmodSupernodalLLT	access:private
Base	../include/Eigen/src/Core/ArrayBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::ArrayBase	access:public
Base	../include/Eigen/src/Core/Array.h	/^    typedef PlainObjectBase<Array> Base;$/;"	t	class:Eigen::Array	access:public
Base	../include/Eigen/src/Core/ArrayWrapper.h	/^    typedef ArrayBase<ArrayWrapper> Base;$/;"	t	class:Eigen::ArrayWrapper	access:public
Base	../include/Eigen/src/Core/ArrayWrapper.h	/^    typedef MatrixBase<MatrixWrapper<ExpressionType> > Base;$/;"	t	class:Eigen::MatrixWrapper	access:public
Base	../include/Eigen/src/Core/BandMatrix.h	/^    typedef BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor> Base;$/;"	t	class:Eigen::internal::TridiagonalMatrix	access:private
Base	../include/Eigen/src/Core/BandMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Base	../include/Eigen/src/Core/Block.h	/^    typedef MapBase<Block> Base;$/;"	t	class:Eigen::Block	access:public
Base	../include/Eigen/src/Core/Block.h	/^    typedef typename internal::dense_xpr_base<Block>::type Base;$/;"	t	class:Eigen::Block	access:public
Base	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::type Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl	access:public
Base	../include/Eigen/src/Core/CwiseBinaryOp.h	/^                                         typename internal::traits<Rhs>::StorageKind>::ret>::Base Base;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
Base	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseNullaryOp>::type Base;$/;"	t	class:Eigen::CwiseNullaryOp	access:public
Base	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp, XprType,typename internal::traits<XprType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryOp	access:public
Base	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:public
Base	../include/Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp, MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryView	access:public
Base	../include/Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename internal::dense_xpr_base< CwiseUnaryView<ViewOp, MatrixType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:public
Base	../include/Eigen/src/Core/DenseBase.h	/^    typedef DenseCoeffsBase<Derived> Base;$/;"	t	class:Eigen::DenseBase	access:public
Base	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Base	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, WriteAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Base	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Base	../include/Eigen/src/Core/DiagonalProduct.h	/^    typedef MatrixBase<DiagonalProduct> Base;$/;"	t	class:Eigen::DiagonalProduct	access:public
Base	../include/Eigen/src/Core/Flagged.h	/^    typedef MatrixBase<Flagged> Base;$/;"	t	class:Eigen::Flagged	access:public
Base	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    typedef typename internal::dense_xpr_base<ForceAlignedAccess>::type Base;$/;"	t	class:Eigen::ForceAlignedAccess	access:public
Base	../include/Eigen/src/Core/GeneralProduct.h	/^    typedef Matrix<typename internal::scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType,1,1> Base;$/;"	t	class:Eigen::GeneralProduct	access:private
Base	../include/Eigen/src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::MapBase	access:public
Base	../include/Eigen/src/Core/MapBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::MapBase	access:public
Base	../include/Eigen/src/Core/Map.h	/^    typedef MapBase<Map> Base;$/;"	t	class:Eigen::Map	access:public
Base	../include/Eigen/src/Core/MatrixBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::MatrixBase	access:public
Base	../include/Eigen/src/Core/Matrix.h	/^    typedef PlainObjectBase<Matrix> Base;$/;"	t	class:Eigen::Matrix	access:public
Base	../include/Eigen/src/Core/NestByValue.h	/^    typedef typename internal::dense_xpr_base<NestByValue>::type Base;$/;"	t	class:Eigen::NestByValue	access:public
Base	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::PermutationBase	access:private
Base	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<Map> Base;$/;"	t	class:Eigen::Map	access:private
Base	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationMatrix> Base;$/;"	t	class:Eigen::PermutationMatrix	access:private
Base	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationWrapper> Base;$/;"	t	class:Eigen::PermutationWrapper	access:private
base	../include/Eigen/src/Core/PlainObjectBase.h	/^    Base& base() { return *static_cast<Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
base	../include/Eigen/src/Core/PlainObjectBase.h	/^    const Base& base() const { return *static_cast<const Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
Base	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::PlainObjectBase	access:public
Base	../include/Eigen/src/Core/ProductBase.h	/^    typedef MatrixBase<Derived> Base;$/;"	t	class:Eigen::ProductBase	access:public
Base	../include/Eigen/src/Core/ProductBase.h	/^                       typename NestedProduct::_RhsNested> Base;$/;"	t	class:Eigen::ScaledProduct	access:public
Base	../include/Eigen/src/Core/Product.h	/^    typedef typename internal::dense_xpr_base<Product<Lhs, Rhs> >::type Base;$/;"	t	class:ProductImpl	access:public
Base	../include/Eigen/src/Core/Product.h	/^                                                typename Rhs::StorageKind>::ret>::Base Base;$/;"	t	class:Product	access:public
Base	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef MatrixBase<CoeffBasedProduct> Base;$/;"	t	class:Eigen::CoeffBasedProduct	access:public
Base	../include/Eigen/src/Core/Replicate.h	/^    typedef typename internal::dense_xpr_base<Replicate>::type Base;$/;"	t	class:Eigen::Replicate	access:public
Base	../include/Eigen/src/Core/ReturnByValue.h	/^    typedef typename internal::dense_xpr_base<ReturnByValue>::type Base;$/;"	t	class:Eigen::ReturnByValue	access:public
Base	../include/Eigen/src/Core/Reverse.h	/^    typedef typename internal::dense_xpr_base<Reverse>::type Base;$/;"	t	class:Eigen::Reverse	access:public
Base	../include/Eigen/src/Core/Select.h	/^    typedef typename internal::dense_xpr_base<Select>::type Base;$/;"	t	class:Eigen::Select	access:public
Base	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef TriangularBase<SelfAdjointView> Base;$/;"	t	class:Eigen::SelfAdjointView	access:public
Base	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    typedef typename internal::dense_xpr_base<SelfCwiseBinaryOp>::type Base;$/;"	t	class:Eigen::SelfCwiseBinaryOp	access:public
Base	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef ReturnByValue<triangular_solve_retval> Base;$/;"	t	struct:Eigen::internal::triangular_solve_retval	access:public
Base	../include/Eigen/src/Core/Stride.h	/^    typedef Stride<0, Value> Base;$/;"	t	class:Eigen::InnerStride	access:private
Base	../include/Eigen/src/Core/Stride.h	/^    typedef Stride<Value, 0> Base;$/;"	t	class:Eigen::OuterStride	access:private
Base	../include/Eigen/src/Core/Swap.h	/^    typedef typename internal::dense_xpr_base<SwapWrapper>::type Base;$/;"	t	class:Eigen::SwapWrapper	access:public
Base	../include/Eigen/src/Core/Transpose.h	/^    typedef typename internal::TransposeImpl_base<MatrixType>::type Base;$/;"	t	class:Eigen::TransposeImpl	access:public
Base	../include/Eigen/src/Core/Transpose.h	/^    typedef typename TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::Transpose	access:public
Base	../include/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<Map> Base;$/;"	t	class:Eigen::Map	access:public
Base	../include/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<Transpositions> Base;$/;"	t	class:Eigen::Transpositions	access:public
Base	../include/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<TranspositionsWrapper> Base;$/;"	t	class:Eigen::TranspositionsWrapper	access:public
Base	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularBase<TriangularView> Base;$/;"	t	class:Eigen::TriangularView	access:public
Base	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef blas_traits<NestedXpr> Base;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Base	../include/Eigen/src/Core/VectorBlock.h	/^                     internal::traits<VectorType>::Flags & RowMajorBit ? Size : 1> Base;$/;"	t	class:Eigen::VectorBlock	access:private
Base	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::dense_xpr_base<PartialReduxExpr>::type Base;$/;"	t	class:Eigen::PartialReduxExpr	access:public
Base	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis	access:private
Base	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef RotationBase<Quaternion<_Scalar>,3> Base;$/;"	t	class:Eigen::Quaternion	access:private
Base	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D	access:private
Base	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef FullPivLU<MatrixType> Base;$/;"	t	class:Eigen::LU	access:public
Base	../include/Eigen/src/Eigen2Support/Minor.h	/^    typedef MatrixBase<Minor> Base;$/;"	t	class:Eigen::Minor	access:public
Base	../include/Eigen/src/Eigen2Support/QR.h	/^    typedef HouseholderQR<MatrixType> Base;$/;"	t	class:Eigen::QR	access:public
Base	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef SelfAdjointEigenSolver<_MatrixType> Base;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:private
Base	../include/Eigen/src/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis	access:private
Base	../include/Eigen/src/Geometry/Homogeneous.h	/^    typedef MatrixBase<Homogeneous> Base;$/;"	t	class:Eigen::Homogeneous	access:public
Base	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<const Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map	access:private
Base	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map	access:private
Base	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef QuaternionBase<Quaternion<_Scalar,_Options> > Base;$/;"	t	class:Eigen::Quaternion	access:private
Base	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef RotationBase<Derived, 3> Base;$/;"	t	class:Eigen::QuaternionBase	access:private
Base	../include/Eigen/src/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D	access:private
Base	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef IterativeSolverBase<BiCGSTAB> Base;$/;"	t	class:Eigen::BiCGSTAB	access:private
Base	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef IterativeSolverBase<ConjugateGradient> Base;$/;"	t	class:Eigen::ConjugateGradient	access:private
Base	../include/Eigen/src/misc/Image.h	/^  typedef ReturnByValue<image_retval_base> Base;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
Base	../include/Eigen/src/misc/Kernel.h	/^  typedef ReturnByValue<kernel_retval_base> Base;$/;"	t	struct:Eigen::internal::kernel_retval_base	access:public
Base	../include/Eigen/src/misc/Solve.h	/^  typedef ReturnByValue<solve_retval_base> Base;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
Base	../include/Eigen/src/misc/SparseSolve.h	/^  typedef ReturnByValue<sparse_solve_retval_base> Base;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
Base	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLDLT<MatrixType,Options> > Base;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Base	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLLT<MatrixType,_UpLo> > Base;$/;"	t	class:Eigen::PardisoLLT	access:protected
Base	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLU<MatrixType> > Base;$/;"	t	class:Eigen::PardisoLU	access:protected
Base	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLDLT<MatrixType, _UpLo> > Base; $/;"	t	class:Eigen::PastixLDLT	access:public
Base	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLLT<MatrixType, _UpLo> > Base;$/;"	t	class:Eigen::PastixLLT	access:public
Base	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLU<MatrixType> > Base;$/;"	t	class:Eigen::PastixLU	access:public
Base	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialCholesky> Base;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Base	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLDLT> Base;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Base	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLLT> Base;$/;"	t	class:Eigen::SimplicialLLT	access:public
Base	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^      BinaryOp,Lhs,Rhs, InnerIterator> Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl::InnerIterator	access:public
Base	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::MatrixTypeIterator Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:private
Base	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::MatrixTypeReverseIterator Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:private
Base	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::MatrixTypeIterator Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:private
Base	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::MatrixTypeReverseIterator Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:private
Base	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef SparseMatrixBase<SparseDenseOuterProduct> Base;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:public
Base	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename _LhsNested::InnerIterator Base;$/;"	t	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:private
Base	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      Transpose<const typename Rhs::DiagonalVectorType> >::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Base	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename CwiseUnaryOp<scalar_multiple_op<typename Lhs::Scalar>,const Rhs>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Base	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename CwiseUnaryOp<scalar_multiple_op<typename Rhs::Scalar>,const Lhs>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Base	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      typename Lhs::DiagonalVectorType>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Base	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Base	../include/Eigen/src/SparseCore/SparseProduct.h	/^    typedef SparseMatrixBase<SparseSparseProduct> Base;$/;"	t	class:Eigen::SparseSparseProduct	access:public
Base	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename _MatrixTypeNested::InnerIterator Base;$/;"	t	class:Eigen::TransposeImpl::InnerIterator	access:private
Base	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator Base;$/;"	t	class:Eigen::TransposeImpl::ReverseInnerIterator	access:private
Base	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixTypeNestedCleaned::InnerIterator Base;$/;"	t	class:Eigen::SparseTriangularView::InnerIterator	access:private
Base	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixTypeNestedCleaned::ReverseInnerIterator Base;$/;"	t	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:private
Base	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperILU> Base;$/;"	t	class:Eigen::SuperILU	access:public
Base	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperLU> Base;$/;"	t	class:Eigen::SuperLU	access:public
BasisReturnType	../include/Eigen/src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime> BasisReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
BAx_lx	../include/Eigen/src/Core/util/Constants.h	/^  BAx_lx              = 0x400,$/;"	e	enum:Eigen::DecompositionOptions
bcg	../include/abcd.h	/^    void bcg();$/;"	p	class:abcd	access:private	signature:()
bcg	../src/bcg.cpp	/^void abcd::bcg()$/;"	f	class:abcd	signature:()
bc	../include/abcd.h	/^    int bc(int);$/;"	p	class:abcd	access:public	signature:(int)
bc	../src/abcd.cpp	/^int abcd::bc(int job)$/;"	f	class:abcd	signature:(int job)
BiCGSTAB	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  BiCGSTAB() : Base() {}$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:()
BiCGSTAB	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  BiCGSTAB(const MatrixType& A) : Base(A) {}$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const MatrixType& A)
~BiCGSTAB	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  ~BiCGSTAB() {}$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:()
bicgstab	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^bool bicgstab(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, const Rhs& rhs, Dest& x, const Preconditioner& precond, int& iters, typename Dest::RealScalar& tol_error)
BiCGSTAB	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^class BiCGSTAB : public IterativeSolverBase<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen	inherits:IterativeSolverBase
bidiagonal	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    const BidiagonalType& bidiagonal() const { return m_bidiagonal; }$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:() const
BidiagonalType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef BandMatrix<RealScalar, ColsAtCompileTime, ColsAtCompileTime, 1, 0> BidiagonalType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
binaryExpr	../include/Eigen/src/plugins/CommonCwiseBinaryOps.h	/^binaryExpr(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other, const CustomBinaryOp& func = CustomBinaryOp()) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other, const CustomBinaryOp& func = CustomBinaryOp()) const
BinaryFunc	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef scalar_product_op<T> BinaryFunc;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
binary_result_of_select	../include/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_std_result_type)>$/;"	s	namespace:Eigen::internal
binary_result_of_select	../include/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_tr1_result)>$/;"	s	namespace:Eigen::internal
binary_result_of_select	../include/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select {typedef ArgType0 type;};$/;"	s	namespace:Eigen::internal
b	../include/abcd.h	/^    Eigen::Matrix<double,Dynamic, Dynamic, ColMajor> b;$/;"	m	class:abcd	access:private
b	../include/Eigen/src/SVD/JacobiSVD.h	/^         b = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon414
blas_data_mapper	../include/Eigen/src/Core/util/BlasUtil.h	/^    blas_data_mapper(Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::blas_data_mapper	access:public	signature:(Scalar* data, Index stride)
blas_data_mapper	../include/Eigen/src/Core/util/BlasUtil.h	/^class blas_data_mapper$/;"	c	namespace:Eigen::internal
BLASFUNC	../include/Eigen/src/misc/blas.h	9;"	d
BLAS_H	../include/Eigen/src/misc/blas.h	2;"	d
BLASLONG	../include/Eigen/src/misc/blas.h	/^typedef long BLASLONG;$/;"	t
BLASLONG	../include/Eigen/src/misc/blas.h	/^typedef long long BLASLONG;$/;"	t
blas_traits	../include/Eigen/src/Core/Transpose.h	/^struct blas_traits<SelfCwiseBinaryOp<BinOp,NestedXpr,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
blas_traits	../include/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<const T>$/;"	s	namespace:Eigen::internal	inherits:blas_traits
blas_traits	../include/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
blas_traits	../include/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_multiple_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
blas_traits	../include/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
blas_traits	../include/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<Transpose<NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
blas_traits	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename XprType> struct blas_traits$/;"	s	namespace:Eigen::internal
BLASULONG	../include/Eigen/src/misc/blas.h	/^typedef unsigned long BLASULONG;$/;"	t
BLASULONG	../include/Eigen/src/misc/blas.h	/^typedef unsigned long long BLASULONG;$/;"	t
blockA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline LhsScalar* blockA() { return m_blockA; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
blockB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockB() { return m_blockB; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
blocked	../include/Eigen/src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE typename MatrixType::Index blocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat)
blocked	../include/Eigen/src/Cholesky/LLT.h	/^  static typename MatrixType::Index blocked(MatrixType& m)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& m)
blocked_lu	../include/Eigen/src/LU/PartialPivLU.h	/^  static Index blocked_lu(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)$/;"	f	struct:Eigen::internal::partial_lu_impl	access:public	signature:(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)
Block	../include/Eigen/src/Core/Block.h	/^class Block<XprType,BlockRows,BlockCols, InnerPanel,true>$/;"	c	namespace:Eigen	inherits:MapBase
Block	../include/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)$/;"	f	class:Eigen::Block	access:protected	signature:(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
Block	../include/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr,$/;"	f	class:Eigen::Block	access:public	signature:(XprType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)
Block	../include/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, Index i)$/;"	f	class:Eigen::Block	access:public	signature:(XprType& xpr, Index i)
Block	../include/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, Index startRow, Index startCol)$/;"	f	class:Eigen::Block	access:public	signature:(XprType& xpr, Index startRow, Index startCol)
Block	../include/Eigen/src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, bool HasDirectAccess> class Block$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
block	../include/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> block(Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f	signature:(Index startRow, Index startCol, Index blockRows, Index blockCols)
block	../include/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, BlockRows, BlockCols> block(Index startRow, Index startCol)$/;"	f	signature:(Index startRow, Index startCol)
block	../include/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> block(Index startRow, Index startCol, Index blockRows, Index blockCols) const$/;"	f	signature:(Index startRow, Index startCol, Index blockRows, Index blockCols) const
block	../include/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, BlockRows, BlockCols> block(Index startRow, Index startCol) const$/;"	f	signature:(Index startRow, Index startCol) const
block_size	../include/abcd.h	/^    int block_size;$/;"	m	class:abcd	access:public
BlockSize	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^    BlockSize  = EIGEN_PLAIN_ENUM_MAX(mr,nr)$/;"	e	enum:Eigen::internal::tribb_kernel::__anon110
BlockType	../include/Eigen/src/LU/PartialPivLU.h	/^  typedef Block<MatrixType,Dynamic,Dynamic> BlockType;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
blockW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockW() { return m_blockW; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
blueNorm	../include/Eigen/src/Core/MatrixBase.h	/^    RealScalar blueNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
blueNorm	../include/Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
blueNorm	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_blueNorm,RealScalar>::Type blueNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
BOOST_AUTO_TEST_CASE	../test/src/test.cpp	/^BOOST_AUTO_TEST_CASE(my_test)$/;"	f	signature:(my_test)
BOOST_TEST_DYN_LINK	../test/src/test.cpp	5;"	d	file:
BOOST_TEST_MODULE	../test/src/test.cpp	6;"	d	file:
BothDirections	../include/Eigen/src/Core/util/Constants.h	/^  BothDirections $/;"	e	enum:Eigen::DirectionType
BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER	../include/Eigen/src/Core/util/StaticAssert.h	/^        BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
BottomLeftCeil	../include/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
bottomLeftCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> bottomLeftCorner(Index cRows, Index cCols)$/;"	f	signature:(Index cRows, Index cCols)
bottomLeftCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> bottomLeftCorner()$/;"	f	signature:()
bottomLeftCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> bottomLeftCorner(Index cRows, Index cCols) const$/;"	f	signature:(Index cRows, Index cCols) const
bottomLeftCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> bottomLeftCorner() const$/;"	f	signature:() const
BottomLeftFloor	../include/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomLeft	../include/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
BottomLeft	../include/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRightCeil	../include/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
bottomRightCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> bottomRightCorner(Index cRows, Index cCols)$/;"	f	signature:(Index cRows, Index cCols)
bottomRightCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> bottomRightCorner()$/;"	f	signature:()
bottomRightCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> bottomRightCorner(Index cRows, Index cCols) const$/;"	f	signature:(Index cRows, Index cCols) const
bottomRightCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> bottomRightCorner() const$/;"	f	signature:() const
BottomRightFloor	../include/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRight	../include/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
BottomRight	../include/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
bottomRows	../include/Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr bottomRows(Index n) const$/;"	f	signature:(Index n) const
bottomRows	../include/Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr bottomRows(Index n)$/;"	f	signature:(Index n)
bottomRows	../include/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type bottomRows() const$/;"	f	signature:() const
bottomRows	../include/Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type bottomRows()$/;"	f	signature:()
bruteforce_det3_helper	../include/Eigen/src/LU/Determinant.h	/^inline const typename Derived::Scalar bruteforce_det3_helper$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<Derived>& matrix, int a, int b, int c)
bruteforce_det4_helper	../include/Eigen/src/LU/Determinant.h	/^const typename Derived::Scalar bruteforce_det4_helper$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<Derived>& matrix, int j, int k, int m, int n)
buildS	solve.cpp	/^abcd::buildS (  )$/;"	f	class:abcd
BuildType	../include/Eigen/src/Core/BandMatrix.h	/^      typedef Block<CoefficientsType,1, DiagonalSize> BuildType;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType	access:public
BuiltIn	../include/Eigen/src/Core/util/Constants.h	/^  BuiltIn$/;"	e	enum:Eigen::__anon211
CanVectorizeInner	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeInner = internal::traits<CoeffBasedProduct>::CanVectorizeInner$/;"	e	enum:Eigen::CoeffBasedProduct::__anon88
CanVectorizeInner	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeInner =    SameType$/;"	e	enum:Eigen::internal::traits::__anon87
CanVectorizeLhs	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeLhs = (!LhsRowMajor) && (LhsFlags & PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon87
CanVectorizeRhs	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeRhs = RhsRowMajor && (RhsFlags & PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon87
cast_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct cast_impl$/;"	s	namespace:Eigen::internal
cast	../include/Eigen/src/Core/MathFunctions.h	/^inline NewType cast(const OldType& x)$/;"	f	namespace:Eigen::internal	signature:(const OldType& x)
cast	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
cast	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
cast	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
cast	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
cast	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline typename internal::cast_return_type<Quaternion,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
cast	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
cast	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline typename internal::cast_return_type<Scaling,Scaling<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Scaling	access:public	signature:() const
cast	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
cast	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation	access:public	signature:() const
cast	../include/Eigen/src/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
cast	../include/Eigen/src/Geometry/AngleAxis.h	/^  inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
cast	../include/Eigen/src/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
cast	../include/Eigen/src/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
cast	../include/Eigen/src/Geometry/Quaternion.h	/^  inline typename internal::cast_return_type<Derived,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
cast	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
cast	../include/Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling<NewScalarType> cast() const$/;"	f	class:Eigen::UniformScaling	access:public	signature:() const
cast	../include/Eigen/src/Geometry/Transform.h	/^  inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim,Mode,Options> >::type cast() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
cast	../include/Eigen/src/Geometry/Translation.h	/^  inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation	access:public	signature:() const
cast	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^cast() const$/;"	f	signature:() const
cast_to_pointer_type	../include/Eigen/src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return const_cast<PointerType>(ptr); }$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType ptr)
cast_to_pointer_type	../include/Eigen/src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return ptr; }$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType ptr)
caxpyc	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(caxpyc)(int *, float  *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *, float *, int *)
caxpy	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(caxpy) (int *, float  *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *, float *, int *)
ccopy	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(ccopy) (int *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, int *, float *, int *)
cdiv	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^std::complex<Scalar> cdiv(Scalar xr, Scalar xi, Scalar yr, Scalar yi)$/;"	f	namespace:Eigen	signature:(Scalar xr, Scalar xi, Scalar yr, Scalar yi)
cdotcw	../include/Eigen/src/misc/blas.h	/^int  BLASFUNC(cdotcw)  (int *, float  *, int *, float  *, int *, float*);$/;"	p	signature:(int *, float *, int *, float *, int *, float*)
cdotuw	../include/Eigen/src/misc/blas.h	/^int  BLASFUNC(cdotuw)  (int *, float  *, int *, float  *, int *, float*);$/;"	p	signature:(int *, float *, int *, float *, int *, float*)
center	../include/Eigen/src/Geometry/AlignedBox.h	/^  center() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
cgbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgbmv)(char *, int *, int *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cge2mm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cge2mm)(char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cgema	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgema)(char *, char *, int *, int *, float  *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *, float *, int *)
cgemm3m	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgemm3m)(char *, char *, int *, int *, int *, float *,$/;"	p	signature:(char *, char *, int *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cgemm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgemm)(char *, char *, int *, int *, int *, float *,$/;"	p	signature:(char *, char *, int *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cgems	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgems)(char *, char *, int *, int *, float  *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *, float *, int *)
cgemt	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgemt)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *)
cgemv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgemv)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cgerc	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgerc)(int *,    int *, float *,  float *, int *,$/;"	p	signature:(int *, int *, float *, float *, int *, float *, int *, float *, int *)
cgeru	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgeru)(int *,    int *, float *,  float *, int *,$/;"	p	signature:(int *, int *, float *, float *, int *, float *, int *, float *, int *)
cgesv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgesv)(int *, int *, float  *, int *, int *, float *, int *, int *);$/;"	p	signature:(int *, int *, float *, int *, int *, float *, int *, int *)
cgetf2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgetf2)(int *, int *, float  *, int *, int *, int *);$/;"	p	signature:(int *, int *, float *, int *, int *, int *)
cgetrf	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgetrf)(int *, int *, float  *, int *, int *, int *);$/;"	p	signature:(int *, int *, float *, int *, int *, int *)
cgetrs	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cgetrs)(char *, int *, int *, float  *, int *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, int *, float *, int *, int *, float *, int *, int *)
chbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(chbmv)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
check_coordinates	../include/Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase	access:protected	signature:(Index row, Index col) const
check_coordinates_internal	../include/Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index , Index ) const {}$/;"	f	class:Eigen::TriangularBase	access:protected	signature:(Index , Index ) const
check_coordinates_internal	../include/Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase	access:protected	signature:(Index row, Index col) const
check_rows_cols_for_overflow	../include/Eigen/src/Core/PlainObjectBase.h	/^EIGEN_ALWAYS_INLINE void check_rows_cols_for_overflow(Index rows, Index cols)$/;"	f	namespace:Eigen::internal	signature:(Index rows, Index cols)
checkSanity	../include/Eigen/src/Core/MapBase.h	/^    void checkSanity() const$/;"	f	class:Eigen::MapBase	access:protected	signature:() const
check_size_for_overflow	../include/Eigen/src/Core/util/Memory.h	/^EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
check_template_parameters	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  static void check_template_parameters()$/;"	f	class:Eigen::SparseMatrix	access:private	signature:()
_check_template_params	../include/Eigen/src/Core/PlainObjectBase.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
_check_template_params	../include/Eigen/src/Geometry/Quaternion.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::Quaternion	access:protected	signature:()
check_template_params	../include/Eigen/src/Geometry/Transform.h	/^    static EIGEN_STRONG_INLINE void check_template_params()$/;"	f	class:Eigen::Transform	access:protected	signature:()
check_that_malloc_is_allowed	../include/Eigen/src/Core/util/Memory.h	/^inline void check_that_malloc_is_allowed()$/;"	f	namespace:Eigen::internal	signature:()
check_transpose_aliasing_compile_time_selector	../include/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector<DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_compile_time_selector	../include/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector$/;"	s	namespace:Eigen::internal
checkTransposeAliasing_impl	../include/Eigen/src/Core/Transpose.h	/^struct checkTransposeAliasing_impl<Derived, OtherDerived, false>$/;"	s	namespace:Eigen::internal
checkTransposeAliasing_impl	../include/Eigen/src/Core/Transpose.h	/^struct checkTransposeAliasing_impl$/;"	s	namespace:Eigen::internal
checkTransposeAliasing	../include/Eigen/src/Core/DenseBase.h	/^    void checkTransposeAliasing(const OtherDerived& other) const;$/;"	p	class:Eigen::DenseBase	access:protected	signature:(const OtherDerived& other) const
checkTransposeAliasing	../include/Eigen/src/Core/Transpose.h	/^void DenseBase<Derived>::checkTransposeAliasing(const OtherDerived& other) const$/;"	f	class:Eigen::DenseBase	signature:(const OtherDerived& other) const
check_transpose_aliasing_run_time_selector	../include/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_run_time_selector	../include/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector$/;"	s	namespace:Eigen::internal
chemm3m	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(chemm3m)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
chemm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(chemm)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
chemv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(chemv) (char *, int *, float  *, float *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cher2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cher2) (char *, int *, float   *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *, int *)
cher2k	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cher2k)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cher2m	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cher2m)(char *, char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cher	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cher) (char *, int *, float   *, float  *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *)
cherk	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cherk)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *)
CholMatrixType	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef MatrixType CholMatrixType;$/;"	t	class:Eigen::CholmodBase	access:public
CholMatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholesky	access:public
CholMatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
CholMatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLDLT	access:public
CholMatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLLT	access:public
CholMatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index>                   CholMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
CholMatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index>               CholMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
CholmodAuto	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodBase	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodBase(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
~CholmodBase	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodBase()$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
CholmodBase	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodBase()$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
CholmodBase	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
cholmod_configure_matrix	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^void cholmod_configure_matrix(CholmodType& mat)$/;"	f	namespace:Eigen::internal	signature:(CholmodType& mat)
CholmodDecomposition	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition() : Base() { init(); }$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:()
CholmodDecomposition	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:(const MatrixType& matrix)
~CholmodDecomposition	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodDecomposition() {}$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:()
CholmodDecomposition	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodDecomposition : public CholmodBase<_MatrixType, _UpLo, CholmodDecomposition<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
cholmod	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    cholmod_common& cholmod() { return m_cholmod; }$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
CholmodLDLt	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodMode	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^enum CholmodMode {$/;"	g	namespace:Eigen
CholmodSimplicialLDLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:public	signature:()
CholmodSimplicialLDLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:public	signature:(const MatrixType& matrix)
~CholmodSimplicialLDLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLDLT() {}$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:public	signature:()
CholmodSimplicialLDLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLDLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
CholmodSimplicialLLt	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodSimplicialLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLLT	access:public	signature:()
CholmodSimplicialLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLLT	access:public	signature:(const MatrixType& matrix)
~CholmodSimplicialLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLLT() {}$/;"	f	class:Eigen::CholmodSimplicialLLT	access:public	signature:()
CholmodSimplicialLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
CholmodSupernodalLLt	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodSupernodalLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSupernodalLLT	access:public	signature:()
CholmodSupernodalLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSupernodalLLT	access:public	signature:(const MatrixType& matrix)
~CholmodSupernodalLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSupernodalLLT() {}$/;"	f	class:Eigen::CholmodSupernodalLLT	access:public	signature:()
CholmodSupernodalLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSupernodalLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
chpmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(chpmv) (char *, int *, float  *, float *,$/;"	p	signature:(char *, int *, float *, float *, float *, int *, float *, float *, int *)
chpr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(chpr2) (char *, int *, float   *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *)
chpr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(chpr) (char *, int *, float   *, float  *, int *, float  *);$/;"	p	signature:(char *, int *, float *, float *, int *, float *)
c	../include/Eigen/src/Jacobi/Jacobi.h	/^    Scalar c() const { return m_c; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
c	../include/Eigen/src/Jacobi/Jacobi.h	/^    Scalar& c() { return m_c; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:()
cj	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<LhsScalar,RhsScalar,ConjLhs,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits	access:protected
cj	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,ConjLhs,false> cj;$/;"	m	class:Eigen::internal::gebp_traits	access:protected
cj	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,false,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits	access:protected
CJMADD	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1109;"	d
clamp	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
clamp	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
claswp	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(claswp)(int *, float  *, int *, int *, int *, int *, int *);$/;"	p	signature:(int *, float *, int *, int *, int *, int *, int *)
clauu2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(clauu2)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
clauum	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(clauum)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
clean	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void clean()$/;"	f	class:Eigen::PastixBase	access:protected	signature:()
clearFactors	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void clearFactors()$/;"	f	class:Eigen::SuperLUBase	access:protected	signature:()
clear	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline void clear() { m_size = 0; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
cnorm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cnorm)(char *, int *, int *, float  *, int *);$/;"	p	signature:(char *, int *, int *, float *, int *)
CoeffBasedProduct	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^class CoeffBasedProduct$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,MatrixBase
CoeffBasedProduct	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    inline CoeffBasedProduct(const CoeffBasedProduct& other)$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(const CoeffBasedProduct& other)
CoeffBasedProduct	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    inline CoeffBasedProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
CoeffBasedProductMode	../include/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon215
coeffByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeffByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
Coefficients	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^                        : int(AmbientDimAtCompileTime)+1,1> Coefficients;$/;"	t	class:Eigen::Hyperplane	access:public
Coefficients	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar, 4, 1> Coefficients;$/;"	t	class:Eigen::Quaternion	access:public
Coefficients	../include/Eigen/src/Geometry/Hyperplane.h	/^                        : Index(AmbientDimAtCompileTime)+1,1,Options> Coefficients;$/;"	t	class:Eigen::Hyperplane	access:public
Coefficients	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef Map<const Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits	access:public
Coefficients	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef Map<Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits	access:public
Coefficients	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<_Scalar,4,1,_Options> Coefficients;$/;"	t	struct:Eigen::internal::traits	access:public
Coefficients	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Coefficients Coefficients;$/;"	t	class:Eigen::QuaternionBase	access:public
Coefficients	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef typename internal::traits<Map>::Coefficients Coefficients;$/;"	t	class:Eigen::Map	access:public
Coefficients	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Quaternion>::Coefficients Coefficients;$/;"	t	class:Eigen::Quaternion	access:public
CoefficientsType	../include/Eigen/src/Core/BandMatrix.h	/^  typedef _CoefficientsType CoefficientsType;$/;"	t	struct:Eigen::internal::traits	access:public
CoefficientsType	../include/Eigen/src/Core/BandMatrix.h	/^  typedef Matrix<Scalar,DataRowsAtCompileTime,ColsAtCompileTime,Options&RowMajor?RowMajor:ColMajor> CoefficientsType;$/;"	t	struct:Eigen::internal::traits	access:public
CoefficientsType	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrix	access:public
CoefficientsType	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixWrapper	access:public
CoefficientsType	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED	../include/Eigen/src/Core/util/StaticAssert.h	/^        COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
coeff	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/Block.h	/^    EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Block	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/Block.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Block	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index rows, Index cols) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index rows, Index cols) const
coeff	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    coeff(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/DiagonalProduct.h	/^    const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/Flagged.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/Flagged.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeff(Index index) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeff(Index row, Index col) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/NestByValue.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/NestByValue.h	/^    inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index row, Index col) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/ProductBase.h	/^    typename Base::CoeffReturnType coeff(Index i) const$/;"	f	class:Eigen::ProductBase	access:public	signature:(Index i) const
coeff	../include/Eigen/src/Core/ProductBase.h	/^    typename Base::CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ProductBase	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/Replicate.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Replicate	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index) const
coeff	../include/Eigen/src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index,Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index,Index) const
coeff	../include/Eigen/src/Core/Reverse.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/Reverse.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/Select.h	/^    const Scalar coeff(Index i) const$/;"	f	class:Eigen::Select	access:public	signature:(Index i) const
coeff	../include/Eigen/src/Core/Select.h	/^    const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::Select	access:public	signature:(Index i, Index j) const
coeff	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/Transpose.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/Transpose.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/Transpositions.h	/^    inline const Index& coeff(Index i) const { return indices().coeff(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i) const
coeff	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const  { return derived().coeff(row,col); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Core/VectorwiseOp.h	/^    const Scalar coeff(Index index) const$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:(Index index) const
coeff	../include/Eigen/src/Core/VectorwiseOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:(Index i, Index j) const
coeff	../include/Eigen/src/Eigen2Support/Minor.h	/^    inline const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Minor	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/Geometry/Homogeneous.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Homogeneous	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_Index>::coeff(_Index i)$/;"	f	class:Eigen::internal::AmbiVector	signature:(_Index i)
coeff	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar& coeff(Index i);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(Index i)
coeff	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col) const
coeff	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index i) const { return m_data.at(i); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i) const
coeff	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index row, Index col) const
CoeffReadCost	../include/Eigen/src/Core/BandMatrix.h	/^    CoeffReadCost = internal::traits<_CoefficientsType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon82
CoeffReadCost	../include/Eigen/src/Core/BandMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
CoeffReadCost	../include/Eigen/src/Core/BandMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon81
CoeffReadCost	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    CoeffReadCost = LhsCoeffReadCost + RhsCoeffReadCost + functor_traits<BinaryOp>::Cost$/;"	e	enum:Eigen::internal::traits::__anon65
CoeffReadCost	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    CoeffReadCost = functor_traits<NullaryOp>::Cost$/;"	e	enum:Eigen::internal::traits::__anon287
CoeffReadCost	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    CoeffReadCost = _XprTypeNested::CoeffReadCost + functor_traits<UnaryOp>::Cost$/;"	e	enum:Eigen::internal::traits::__anon59
CoeffReadCost	../include/Eigen/src/Core/CwiseUnaryView.h	/^    CoeffReadCost = traits<_MatrixTypeNested>::CoeffReadCost + functor_traits<ViewOp>::Cost,$/;"	e	enum:Eigen::internal::traits::__anon232
CoeffReadCost	../include/Eigen/src/Core/DenseBase.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::DenseBase::__anon216
CoeffReadCost	../include/Eigen/src/Core/DiagonalProduct.h	/^    CoeffReadCost = NumTraits<Scalar>::MulCost + MatrixType::CoeffReadCost + DiagonalType::DiagonalVectorType::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon77
CoeffReadCost	../include/Eigen/src/Core/Matrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon289
CoeffReadCost	../include/Eigen/src/Core/PermutationMatrix.h	/^    CoeffReadCost = _IndicesType::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon118
CoeffReadCost	../include/Eigen/src/Core/PermutationMatrix.h	/^      CoeffReadCost = Traits::CoeffReadCost,$/;"	e	enum:Eigen::PermutationBase::__anon117
CoeffReadCost	../include/Eigen/src/Core/PermutationMatrix.h	/^      CoeffReadCost = Traits::CoeffReadCost,$/;"	e	enum:Eigen::Transpose::__anon119
CoeffReadCost	../include/Eigen/src/Core/ProductBase.h	/^    CoeffReadCost = 0 \/\/ FIXME why is it needed ?$/;"	e	enum:Eigen::internal::traits::__anon288
CoeffReadCost	../include/Eigen/src/Core/Product.h	/^    CoeffReadCost = 0 \/\/ TODO CoeffReadCost should not be part of the expression traits$/;"	e	enum:internal::traits::__anon48
CoeffReadCost	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CoeffReadCost = InnerSize == Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon87
CoeffReadCost	../include/Eigen/src/Core/Replicate.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon67
CoeffReadCost	../include/Eigen/src/Core/Reverse.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon115
CoeffReadCost	../include/Eigen/src/Core/Select.h	/^    CoeffReadCost = traits<typename remove_all<ConditionMatrixNested>::type>::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon60
CoeffReadCost	../include/Eigen/src/Core/SelfAdjointView.h	/^    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon83
CoeffReadCost	../include/Eigen/src/Core/Transpose.h	/^    CoeffReadCost = MatrixTypeNestedPlain::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon73
CoeffReadCost	../include/Eigen/src/Core/TriangularMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::TriangularBase::__anon233
CoeffReadCost	../include/Eigen/src/Core/TriangularMatrix.h	/^    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon234
CoeffReadCost	../include/Eigen/src/Core/VectorwiseOp.h	/^    CoeffReadCost = TraversalSize * traits<_MatrixTypeNested>::CoeffReadCost + int(CostOpType::value)$/;"	e	enum:Eigen::internal::traits::__anon69
CoeffReadCost	../include/Eigen/src/Eigen2Support/Minor.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost \/\/ minor is used typically on tiny matrices,$/;"	e	enum:Eigen::internal::traits::__anon441
CoeffReadCost	../include/Eigen/src/Geometry/Homogeneous.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon390
CoeffReadCost	../include/Eigen/src/SparseCore/SparseBlock.h	/^    CoeffReadCost = MatrixType::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon20
CoeffReadCost	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    CoeffReadCost = LhsCoeffReadCost + RhsCoeffReadCost + NumTraits<Scalar>::MulCost$/;"	e	enum:Eigen::internal::traits::__anon30
CoeffReadCost	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon35
CoeffReadCost	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
CoeffReadCost	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost*10$/;"	e	enum:Eigen::internal::traits::__anon32
CoeffReadCost	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon31
CoeffReadCost	../include/Eigen/src/SparseCore/SparseProduct.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon17
CoeffReadCost	../include/Eigen/src/SparseCore/SparseVector.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon25
coeffRefByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    coeffRefByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner)
coeffRefByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void coeffRefByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index) const
coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index) const
coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index row, Index col) const
coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index row, Index col) const
coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/Block.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::Block	access:public	signature:(Index index) const
coeffRef	../include/Eigen/src/Core/Block.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::Block	access:public	signature:(Index row, Index col) const
coeffRef	../include/Eigen/src/Core/Block.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Block	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/Block.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Block	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    coeffRef(Index index)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void coeffRef();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
coeffRef	../include/Eigen/src/Core/Flagged.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index) const
coeffRef	../include/Eigen/src/Core/Flagged.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col) const
coeffRef	../include/Eigen/src/Core/Flagged.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/Flagged.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index) const
coeffRef	../include/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col) const
coeffRef	../include/Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/NestByValue.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/NestByValue.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index) const
coeffRef	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index row, Index col) const
coeffRef	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/ProductBase.h	/^    const Scalar& coeffRef(Index i) const$/;"	f	class:Eigen::ProductBase	access:public	signature:(Index i) const
coeffRef	../include/Eigen/src/Core/ProductBase.h	/^    const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::ProductBase	access:public	signature:(Index row, Index col) const
coeffRef	../include/Eigen/src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index,Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index,Index)
coeffRef	../include/Eigen/src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index)
coeffRef	../include/Eigen/src/Core/Reverse.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/Reverse.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index) const
coeffRef	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col) const
coeffRef	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index) const
coeffRef	../include/Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index row, Index col) const
coeffRef	../include/Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index) const
coeffRef	../include/Eigen/src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index row, Index col) const
coeffRef	../include/Eigen/src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index)
coeffRef	../include/Eigen/src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/Transpositions.h	/^    inline Index& coeffRef(Index i) { return indices().coeffRef(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i)
coeffRef	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::TriangularView	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col) { return derived().coeffRef(row,col); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/Eigen2Support/Minor.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Minor	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_Index>::coeffRef(_Index i)$/;"	f	class:Eigen::internal::AmbiVector	signature:(_Index i)
coeffRef	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar& coeffRef(Index i);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(Index i)
coeffRef	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
coeffRef	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
coeffRef	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index row, Index col)
CoeffReturnType	../include/Eigen/src/Core/ArrayBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::ArrayBase	access:public
CoeffReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::DenseBase	access:public
CoeffReturnType	../include/Eigen/src/Core/DenseCoeffsBase.h	/^                     >::type CoeffReturnType;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
CoeffReturnType	../include/Eigen/src/Core/MapBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MapBase	access:public
CoeffReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
CoeffReturnType	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::conditional<_HasDirectAccess, const Scalar&, Scalar>::type CoeffReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
coeffSeparator	../include/Eigen/src/Core/IO.h	/^  std::string coeffSeparator;$/;"	m	struct:Eigen::IOFormat	access:public
coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:()
coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:()
coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
coeffs	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
coeffs	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
coeffs	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
coeffs	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
coeffs	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  const VectorType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Scaling	access:public	signature:() const
coeffs	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  VectorType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Scaling	access:public	signature:()
coeffs	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
coeffs	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^    inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Map	access:public	signature:()
coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Coefficients& coeffs() { return m_coeffs;}$/;"	f	class:Eigen::Quaternion	access:public	signature:()
coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^    inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Map	access:public	signature:() const
coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^    inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Map	access:public	signature:() const
coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^  inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^  inline const typename internal::traits<Derived>::Coefficients& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^  inline typename internal::traits<Derived>::Coefficients& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
CoeffVectorType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
CoeffVectorType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::Tridiagonalization	access:public
CoeffVectorType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::CoeffVectorType CoeffVectorType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
coeff_visitor	../include/Eigen/src/Core/Visitor.h	/^struct coeff_visitor$/;"	s	namespace:Eigen::internal
cofactor_3x3	../include/Eigen/src/LU/Inverse.h	/^inline typename MatrixType::Scalar cofactor_3x3(const MatrixType& m)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& m)
cofactor_4x4	../include/Eigen/src/LU/Inverse.h	/^inline typename MatrixType::Scalar cofactor_4x4(const MatrixType& matrix)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& matrix)
CoherentAccessPattern	../include/Eigen/src/SparseCore/SparseUtil.h	/^const int CoherentAccessPattern     = 0x1;$/;"	m	namespace:Eigen
col	../include/Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,Dynamic,1> col(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Index i)
col	../include/Eigen/src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::all_unroller::__anon226
col	../include/Eigen/src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::any_unroller::__anon227
col	../include/Eigen/src/Core/SelfAdjointView.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon85
col	../include/Eigen/src/Core/SelfAdjointView.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon86
col	../include/Eigen/src/Core/TriangularMatrix.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon236
col	../include/Eigen/src/Core/Visitor.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::visitor_impl::__anon51
col	../include/Eigen/src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor	access:public
col	../include/Eigen/src/plugins/BlockMethods.h	/^inline ColXpr col(Index i)$/;"	f	signature:(Index i)
col	../include/Eigen/src/plugins/BlockMethods.h	/^inline ConstColXpr col(Index i) const$/;"	f	signature:(Index i) const
col	../include/Eigen/src/SparseCore/CoreIterators.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::col(Index i) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index i) const
col	../include/Eigen/src/SparseCore/SparseBlock.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::SparseInnerVectorSet::InnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseBlock.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::SparseInnerVectorSet::ReverseInnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::col(Index i)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index i)
col	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return Lhs::IsRowMajor ? index() : m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_rhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Index col() const { return Transpose ? m_outer : Base::row(); }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,1> col(Index j) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index j) const
col	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,1> col(Index j);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index j)
col	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    inline typename TransposeImpl<MatrixType,Sparse>::Index col() const { return Base::row(); }$/;"	f	class:Eigen::TransposeImpl::InnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    inline typename TransposeImpl<MatrixType,Sparse>::Index col() const { return Base::row(); }$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index col() const { return Base::col(); }$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index col() const { return Base::col(); }$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseUtil.h	/^  const Index& col() const { return m_col; }$/;"	f	class:Eigen::Triplet	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index col() const { return IsColVector ? 0 : index(); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
col	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index col() const { return IsColVector ? 0 : index(); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
colIndexByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
col_interconnections	../include/abcd.h	/^    std::map<int,std::vector<int> > col_interconnections;$/;"	m	class:abcd	access:public
ColMajor	../include/Eigen/src/Core/util/Constants.h	/^  ColMajor = 0,$/;"	e	enum:Eigen::__anon212
colOffset	../include/Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value()>0 ? m_index.value() : 0; }$/;"	f	struct:Eigen::internal::traits	access:public	signature:() const
colPivHouseholderQr	../include/Eigen/src/Core/MatrixBase.h	/^    const ColPivHouseholderQR<PlainObject> colPivHouseholderQr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
ColPivHouseholderQR	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
ColPivHouseholderQR	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR()$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:()
ColPivHouseholderQR	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(Index rows, Index cols)
colPivHouseholderQr	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^MatrixBase<Derived>::colPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
ColPivHouseholderQR	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^template<typename _MatrixType> class ColPivHouseholderQR$/;"	c	namespace:Eigen
ColPivHouseholderQRPreconditioner	../include/Eigen/src/Core/util/Constants.h	/^  ColPivHouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
ColsAtCompileTime	../include/Eigen/src/Cholesky/LDLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon405
ColsAtCompileTime	../include/Eigen/src/Cholesky/LLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon403
ColsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon81
ColsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon82
ColsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
ColsAtCompileTime	../include/Eigen/src/Core/Block.h	/^    ColsAtCompileTime = MatrixCols == 0 ? 0 : BlockCols,$/;"	e	enum:Eigen::internal::traits::__anon228
ColsAtCompileTime	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    ColsAtCompileTime = traits<Ancestor>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon64
ColsAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon216
ColsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^      ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon279
ColsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^    ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon281
ColsAtCompileTime	../include/Eigen/src/Core/DiagonalProduct.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon77
ColsAtCompileTime	../include/Eigen/src/Core/MapBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon76
ColsAtCompileTime	../include/Eigen/src/Core/Matrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon289
ColsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^    ColsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon118
ColsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon117
ColsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon119
ColsAtCompileTime	../include/Eigen/src/Core/ProductBase.h	/^    ColsAtCompileTime = traits<Rhs>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
ColsAtCompileTime	../include/Eigen/src/Core/Product.h	/^    ColsAtCompileTime = RhsCleaned::ColsAtCompileTime,$/;"	e	enum:internal::traits::__anon48
ColsAtCompileTime	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      ColsAtCompileTime = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon87
ColsAtCompileTime	../include/Eigen/src/Core/Replicate.h	/^    ColsAtCompileTime = ColFactor==Dynamic || int(MatrixType::ColsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon67
ColsAtCompileTime	../include/Eigen/src/Core/Reverse.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon115
ColsAtCompileTime	../include/Eigen/src/Core/Select.h	/^    ColsAtCompileTime = ConditionMatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon60
ColsAtCompileTime	../include/Eigen/src/Core/Transpose.h	/^    ColsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon73
ColsAtCompileTime	../include/Eigen/src/Core/TriangularMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon233
ColsAtCompileTime	../include/Eigen/src/Core/VectorwiseOp.h	/^    ColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon68
ColsAtCompileTime	../include/Eigen/src/Eigen2Support/Minor.h	/^    ColsAtCompileTime = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon441
ColsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon43
ColsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon41
ColsAtCompileTime	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon44
ColsAtCompileTime	../include/Eigen/src/Eigenvalues/RealSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon39
ColsAtCompileTime	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon40
ColsAtCompileTime	../include/Eigen/src/Geometry/Homogeneous.h	/^    ColsAtCompileTime = Direction==Horizontal ? ColsPlusOne : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon390
ColsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^      ColsAtCompileTime = internal::traits<HouseholderSequence>::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon8
ColsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^    ColsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon7
ColsAtCompileTime	../include/Eigen/src/LU/FullPivLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon395
ColsAtCompileTime	../include/Eigen/src/LU/PartialPivLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon394
ColsAtCompileTime	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon4
ColsAtCompileTime	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon6
ColsAtCompileTime	../include/Eigen/src/QR/HouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon5
ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseBlock.h	/^    ColsAtCompileTime = IsRowMajor ? MatrixType::ColsAtCompileTime : Size,$/;"	e	enum:Eigen::internal::traits::__anon20
ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    ColsAtCompileTime    = Tr ? int(traits<Lhs>::ColsAtCompileTime)     : int(traits<Rhs>::ColsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon30
ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    ColsAtCompileTime = _Rhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon35
ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon32
ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon31
ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseProduct.h	/^    ColsAtCompileTime    = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon17
ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseVector.h	/^    ColsAtCompileTime = IsColVector ? 1 : Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon25
ColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon416
ColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon417
ColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
ColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon419
ColsAtCompileTime	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon420
ColsAtCompileTimeMinusOne	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTimeMinusOne = internal::decrement_size<ColsAtCompileTime>::ret$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon420
ColsBlockXpr	../include/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ColsBlockXpr;$/;"	t
cols	../include/Eigen/src/Cholesky/LDLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LDLT	access:public	signature:() const
cols	../include/Eigen/src/Cholesky/LLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LLT	access:public	signature:() const
cols	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    inline Index cols() const { return m_cholmodFactor->n; }$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
cols	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
cols	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
cols	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
cols	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
cols	../include/Eigen/src/Core/Block.h	/^    inline Index cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::Block	access:public	signature:() const
cols	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const {$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
cols	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:() const
cols	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
cols	../include/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
cols	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseIndex cols(void) const {return _Cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
cols	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseIndex cols(void) const {return m_cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
cols	../include/Eigen/src/Core/DenseStorage.h	/^    static inline DenseIndex cols(void) {return _Cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void)
cols	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline Index cols() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
cols	../include/Eigen/src/Core/DiagonalProduct.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:() const
cols	../include/Eigen/src/Core/EigenBase.h	/^  inline Index cols() const { return derived().cols(); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
cols	../include/Eigen/src/Core/Flagged.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
cols	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
Cols	../include/Eigen/src/Core/GeneralProduct.h	/^    Cols  = _Rhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon122
cols	../include/Eigen/src/Core/MapBase.h	/^    inline Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
cols	../include/Eigen/src/Core/NestByValue.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
cols	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Index cols() const { return indices().size(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
cols	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:() const
cols	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline int cols() const { return m_permutation.cols(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
cols	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
cols	../include/Eigen/src/Core/ProductBase.h	/^    inline Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
cols	../include/Eigen/src/Core/Product.h	/^    inline Index cols() const { return m_rhs.cols(); }$/;"	f	class:Product	access:public	signature:() const
cols	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
cols	../include/Eigen/src/Core/Replicate.h	/^    inline Index cols() const { return m_matrix.cols() * m_colFactor.value(); }$/;"	f	class:Eigen::Replicate	access:public	signature:() const
cols	../include/Eigen/src/Core/ReturnByValue.h	/^    inline Index cols() const { return static_cast<const Derived*>(this)->cols(); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:() const
cols	../include/Eigen/src/Core/Reverse.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Reverse	access:public	signature:() const
cols	../include/Eigen/src/Core/Select.h	/^    Index cols() const { return m_condition.cols(); }$/;"	f	class:Eigen::Select	access:public	signature:() const
cols	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
cols	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
cols	../include/Eigen/src/Core/SolveTriangular.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:() const
cols	../include/Eigen/src/Core/Swap.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
cols	../include/Eigen/src/Core/Transpose.h	/^    inline Index cols() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
cols	../include/Eigen/src/Core/Transpositions.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:() const
cols	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
cols	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
cols	../include/Eigen/src/Core/VectorwiseOp.h	/^    Index cols() const { return (Direction==Horizontal ? 1 : m_matrix.cols()); }$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:() const
cols	../include/Eigen/src/Eigen2Support/Minor.h	/^    inline Index cols() const { return m_matrix.cols() - 1; }$/;"	f	class:Eigen::Minor	access:public	signature:() const
cols	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    Index cols() const { return m_hess.packedMatrix().cols(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:() const
cols	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:() const
cols	../include/Eigen/src/Geometry/Homogeneous.h	/^    inline Index cols() const { return m_matrix.cols() + (int(Direction)==Horizontal ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous	access:public	signature:() const
cols	../include/Eigen/src/Geometry/Homogeneous.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:() const
cols	../include/Eigen/src/Geometry/Homogeneous.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:() const
cols	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Index cols() const { return rows(); }$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
cols	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index cols() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:() const
cols	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:() const
cols	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index cols() const { return mp_matrix ? mp_matrix->cols() : 0; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
cols	../include/Eigen/src/LU/FullPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
cols	../include/Eigen/src/LU/Inverse.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:() const
cols	../include/Eigen/src/LU/PartialPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
cols	../include/Eigen/src/misc/Image.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
cols	../include/Eigen/src/misc/Kernel.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
cols	../include/Eigen/src/misc/Solve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
cols	../include/Eigen/src/misc/SparseSolve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:() const
cols	../include/Eigen/src/misc/SparseSolve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
cols	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
cols	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
cols	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
cols	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index cols() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:() const
cols	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
cols	../include/Eigen/src/QR/HouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
cols	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return Tr ? m_lhs.cols() : m_rhs.cols(); }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsColVector ? 1 : m_size; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
cols	../include/Eigen/src/SparseCore/SparseView.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
cols	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
cols	../include/Eigen/src/SVD/JacobiSVD.h	/^    inline Index cols() const { return m_cols; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
cols	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline Index cols() const { return m_copyMatrix.cols(); }$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
colsPermutation	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
colsPermutation	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
ColsPlusOne	../include/Eigen/src/Geometry/Homogeneous.h	/^    ColsPlusOne = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon390
ColSpMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor> ColSpMatrix;$/;"	t	class:Eigen::PastixBase	access:public
ColSpMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLDLT	access:public
ColSpMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLLT	access:public
ColSpMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLU	access:public
cols_select	../include/Eigen/src/Core/GeneralProduct.h	/^    cols_select = product_size_category<Cols,MaxCols>::value,$/;"	e	enum:Eigen::internal::product_type::__anon123
colStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index colStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
colStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void colStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
ColType	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColType;$/;"	t	class:Eigen::JacobiSVD	access:public
column_index	../include/abcd.h	/^    std::vector<std::vector<int> > column_index;$/;"	m	class:abcd	access:public
ColumnVectorType	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::EigenSolver	access:protected
ColumnVectorType	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealSchur	access:public
ColVector	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1> ColVector;$/;"	t	class:Eigen::SVD	access:private
ColVectorType	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1, MatrixType::Options, MatrixType::MaxRowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::LU	access:public
ColVectorType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
ColVectorType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
colwise	../include/Eigen/src/Core/DenseBase.h	/^    ColwiseReturnType colwise();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
colwise	../include/Eigen/src/Core/DenseBase.h	/^    ConstColwiseReturnType colwise() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
colwise	../include/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise() const$/;"	f	class:Eigen::DenseBase	signature:() const
colwise	../include/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise()$/;"	f	class:Eigen::DenseBase	signature:()
ColwiseReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ColXpr	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::ColXpr ColXpr;$/;"	t	class:Eigen::MatrixBase	access:public
ColXpr	../include/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ColXpr;$/;"	t
~CommaInitializer	../include/Eigen/src/Core/CommaInitializer.h	/^  inline ~CommaInitializer()$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:()
CommaInitializer	../include/Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(XprType& xpr, const DenseBase<OtherDerived>& other)
CommaInitializer	../include/Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(XprType& xpr, const Scalar& s)
CommaInitializer	../include/Eigen/src/Core/CommaInitializer.h	/^struct CommaInitializer$/;"	s	namespace:Eigen
comm_map	../include/abcd.h	/^    Eigen::VectorXi comm_map;$/;"	m	class:abcd	access:private
comp_cols	../include/abcd.h	/^bool comp_cols(Eigen::SparseMatrix<double, RowMajor> L, Eigen::SparseMatrix<double, RowMajor> R);$/;"	p	signature:(Eigen::SparseMatrix<double, RowMajor> L, Eigen::SparseMatrix<double, RowMajor> R)
comp_cols	../src/utils.cpp	/^bool comp_cols(Eigen::SparseMatrix<double, RowMajor> L, Eigen::SparseMatrix<double, RowMajor> R)$/;"	f	signature:(Eigen::SparseMatrix<double, RowMajor> L, Eigen::SparseMatrix<double, RowMajor> R)
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	100;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	103;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	106;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	109;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	117;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	12;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	137;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	140;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	157;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	15;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	160;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	163;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	26;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	32;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	38;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	44;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	50;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	64;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	71;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	75;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	78;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	80;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	89;"	d	file:
COMPILER_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	97;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	110;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	119;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	143;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	148;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	17;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	27;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	33;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	40;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	46;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	53;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	58;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	66;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	83;"	d	file:
COMPILER_VERSION_MAJOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	90;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	111;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	120;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	144;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	149;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	18;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	28;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	34;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	41;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	47;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	54;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	59;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	67;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	84;"	d	file:
COMPILER_VERSION_MINOR	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	91;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	113;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	124;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	127;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	145;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	150;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	19;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	29;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	35;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	55;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	60;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	68;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	85;"	d	file:
COMPILER_VERSION_PATCH	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	93;"	d	file:
COMPILER_VERSION_TWEAK	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	131;"	d	file:
COMPILER_VERSION_TWEAK	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	22;"	d	file:
CompleteUnrolling	../include/Eigen/src/Core/util/Constants.h	/^  CompleteUnrolling$/;"	e	enum:Eigen::__anon210
ComplexEigenSolver	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      ComplexEigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
ComplexEigenSolver	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver()$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:()
ComplexEigenSolver	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver(Index size)$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:(Index size)
ComplexEigenSolver	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^template<typename _MatrixType> class ComplexEigenSolver$/;"	c	namespace:Eigen
ComplexMatrixType	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> ComplexMatrixType;$/;"	t	class:Eigen::ComplexSchur	access:public
ComplexScalar	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^  typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	struct:Eigen::internal::stem_function	access:public
ComplexScalar	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
ComplexScalar	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexSchur	access:public
ComplexScalar	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::EigenSolver	access:public
ComplexScalar	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealSchur	access:public
ComplexSchur	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur(const MatrixType& matrix, bool computeU = true)$/;"	f	class:Eigen::ComplexSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
ComplexSchur	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::ComplexSchur	access:public	signature:(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)
ComplexSchur	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^template<typename _MatrixType> class ComplexSchur$/;"	c	namespace:Eigen
complex_schur_reduce_to_hessenberg	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg<MatrixType, false>$/;"	s	namespace:Eigen::internal
complex_schur_reduce_to_hessenberg	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg$/;"	s	namespace:Eigen::internal
CompressedStorage	../include/Eigen/src/SparseCore/CompressedStorage.h	/^class CompressedStorage$/;"	c	namespace:Eigen::internal
CompressedStorage	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const CompressedStorage& other)
~CompressedStorage	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    ~CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
CompressedStorage	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
CompressedStorage	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t size)
ComputationInfo	../include/Eigen/src/Core/util/Constants.h	/^enum ComputationInfo {$/;"	g	namespace:Eigen
computeDirect	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::computeDirect(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver	signature:(const MatrixType& matrix, int options)
computeDirect	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver& computeDirect(const MatrixType& matrix, int options = ComputeEigenvectors);$/;"	p	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, int options = ComputeEigenvectors)
ComputeEigenvectors	../include/Eigen/src/Core/util/Constants.h	/^  ComputeEigenvectors = 0x80,$/;"	e	enum:Eigen::DecompositionOptions
ComputeFullU	../include/Eigen/src/Core/util/Constants.h	/^  ComputeFullU        = 0x04,$/;"	e	enum:Eigen::DecompositionOptions
ComputeFullV	../include/Eigen/src/Core/util/Constants.h	/^  ComputeFullV        = 0x10,$/;"	e	enum:Eigen::DecompositionOptions
computeImage	../include/Eigen/src/Eigen2Support/LU.h	/^    void computeImage(ImageMatrixType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(ImageMatrixType *result) const
compute	../include/Eigen/src/Cholesky/LDLT.h	/^    LDLT& compute(const MatrixType& matrix);$/;"	p	class:Eigen::LDLT	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::compute(const MatrixType& a)$/;"	f	class:Eigen::LDLT	signature:(const MatrixType& a)
compute	../include/Eigen/src/Cholesky/LLT.h	/^    LLT& compute(const MatrixType& matrix);$/;"	p	class:Eigen::LLT	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/Cholesky/LLT.h	/^LLT<MatrixType,_UpLo>& LLT<MatrixType,_UpLo>::compute(const MatrixType& a)$/;"	f	class:Eigen::LLT	signature:(const MatrixType& a)
compute	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& compute(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/Eigen2Support/SVD.h	/^    void compute(const MatrixType& matrix);$/;"	p	class:Eigen::SVD	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::SVD	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver& compute(const MatrixType& matrix, bool computeEigenvectors = true);$/;"	p	class:Eigen::ComplexEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
compute	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^ComplexEigenSolver<MatrixType>& ComplexEigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver	signature:(const MatrixType& matrix, bool computeEigenvectors)
compute	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur& compute(const MatrixType& matrix, bool computeU = true);$/;"	p	class:Eigen::ComplexSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
compute	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)$/;"	f	class:Eigen::ComplexSchur	signature:(const MatrixType& matrix, bool computeU)
compute	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver& compute(const MatrixType& matrix, bool computeEigenvectors = true);$/;"	p	class:Eigen::EigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
compute	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^EigenSolver<MatrixType>& EigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::EigenSolver	signature:(const MatrixType& matrix, bool computeEigenvectors)
compute	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^compute(const MatrixType& matA, const MatrixType& matB, int options)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	signature:(const MatrixType& matA, const MatrixType& matB, int options)
compute	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver& compute(const MatrixType& matA, const MatrixType& matB,$/;"	p	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, int options = ComputeEigenvectors|Ax_lBx)
compute	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition& compute(const MatrixType& matrix)$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:(const MatrixType& matrix)
_compute	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    static void _compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp);$/;"	p	class:Eigen::HessenbergDecomposition	access:private	signature:(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)
_compute	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^void HessenbergDecomposition<MatrixType>::_compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)$/;"	f	class:Eigen::HessenbergDecomposition	signature:(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)
compute	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur& compute(const MatrixType& matrix, bool computeU = true);$/;"	p	class:Eigen::RealSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
compute	../include/Eigen/src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)$/;"	f	class:Eigen::RealSchur	signature:(const MatrixType& matrix, bool computeU)
compute	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::compute(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver	signature:(const MatrixType& matrix, int options)
compute	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver& compute(const MatrixType& matrix, int options = ComputeEigenvectors);$/;"	p	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, int options = ComputeEigenvectors)
compute	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    void compute(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)
compute	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    void compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors)
compute	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization& compute(const MatrixType& matrix)$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& compute(const MatrixType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatrixType& mat)
compute	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& compute(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
compute	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT<Scalar>& compute(const MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& amat)
compute	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& compute(const MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const MatrixType& A)
compute	../include/Eigen/src/LU/FullPivLU.h	/^    FullPivLU& compute(const MatrixType& matrix);$/;"	p	class:Eigen::FullPivLU	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>& FullPivLU<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivLU	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/LU/PartialPivLU.h	/^    PartialPivLU& compute(const MatrixType& matrix);$/;"	p	class:Eigen::PartialPivLU	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>& PartialPivLU<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::PartialPivLU	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Derived& compute(const MatrixType& matrix);$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::compute(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixType& a)
compute	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute(ColSpMatrix& mat);$/;"	p	class:Eigen::PastixBase	access:protected	signature:(ColSpMatrix& mat)
compute	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::compute(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase	signature:(ColSpMatrix& mat)
compute	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& compute(const MatrixType& matrix);$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^ColPivHouseholderQR<MatrixType>& ColPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& compute(const MatrixType& matrix);$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^FullPivHouseholderQR<MatrixType>& FullPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR& compute(const MatrixType& matrix);$/;"	p	class:Eigen::HouseholderQR	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/QR/HouseholderQR.h	/^HouseholderQR<MatrixType>& HouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::HouseholderQR	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD& compute(const MatrixType& matrix)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD& compute(const MatrixType& matrix, unsigned int computationOptions);$/;"	p	class:Eigen::JacobiSVD	access:public	signature:(const MatrixType& matrix, unsigned int computationOptions)
compute	../include/Eigen/src/SVD/JacobiSVD.h	/^JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType& matrix, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD	signature:(const MatrixType& matrix, unsigned int computationOptions)
compute	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization& compute(const MatrixType& matrix);$/;"	p	class:Eigen::internal::UpperBidiagonalization	access:public	signature:(const MatrixType& matrix)
compute	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^UpperBidiagonalization<_MatrixType>& UpperBidiagonalization<_MatrixType>::compute(const _MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization	signature:(const _MatrixType& matrix)
compute	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixType& matrix)
computeInverseAndDetWithCheck	../include/Eigen/src/Core/MatrixBase.h	/^    void computeInverseAndDetWithCheck($/;"	p	class:Eigen::MatrixBase	access:public	signature:( ResultType& inverse, typename ResultType::Scalar& determinant, bool& invertible, const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision() ) const
computeInverseAndDetWithCheck	../include/Eigen/src/LU/Inverse.h	/^inline void MatrixBase<Derived>::computeInverseAndDetWithCheck($/;"	f	class:Eigen::MatrixBase	signature:( ResultType& inverse, typename ResultType::Scalar& determinant, bool& invertible, const RealScalar& absDeterminantThreshold ) const
compute_inverse_and_det_with_check	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check { \/* nothing! general case not supported. *\/ };$/;"	s	namespace:Eigen::internal
computeInverse	../include/Eigen/src/Core/MatrixBase.h	/^    void computeInverse(MatrixBase<ResultType> *result) const {$/;"	f	class:Eigen::MatrixBase	access:public	signature:(MatrixBase<ResultType> *result) const
computeInverse	../include/Eigen/src/Eigen2Support/LU.h	/^    inline void computeInverse(ResultType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(ResultType *result) const
compute_inverse	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
compute_inverse	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
compute_inverse	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
compute_inverse	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal	inherits:compute_inverse_size4
compute_inverse	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse$/;"	s	namespace:Eigen::internal
compute_inverse_size2_helper	../include/Eigen/src/LU/Inverse.h	/^inline void compute_inverse_size2_helper($/;"	f	namespace:Eigen::internal	signature:( const MatrixType& matrix, const typename ResultType::Scalar& invdet, ResultType& result)
compute_inverse_size3_helper	../include/Eigen/src/LU/Inverse.h	/^inline void compute_inverse_size3_helper($/;"	f	namespace:Eigen::internal	signature:( const MatrixType& matrix, const typename ResultType::Scalar& invdet, const Matrix<typename ResultType::Scalar,3,1>& cofactors_col0, ResultType& result)
compute_inverse_size4	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, double, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
compute_inverse_size4	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, float, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
compute_inverse_size4	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse_size4$/;"	s	namespace:Eigen::internal
computeInverseWithCheck	../include/Eigen/src/Core/MatrixBase.h	/^    void computeInverseWithCheck($/;"	p	class:Eigen::MatrixBase	access:public	signature:( ResultType& inverse, bool& invertible, const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision() ) const
computeInverseWithCheck	../include/Eigen/src/LU/Inverse.h	/^inline void MatrixBase<Derived>::computeInverseWithCheck($/;"	f	class:Eigen::MatrixBase	signature:( ResultType& inverse, bool& invertible, const RealScalar& absDeterminantThreshold ) const
computeKernel	../include/Eigen/src/Eigen2Support/LU.h	/^    void computeKernel(KernelMatrixType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(KernelMatrixType *result) const
computeNormOfT	../include/Eigen/src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Scalar RealSchur<MatrixType>::computeNormOfT()$/;"	f	class:Eigen::RealSchur	signature:()
computeNormOfT	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    Scalar computeNormOfT();$/;"	p	class:Eigen::RealSchur	access:private	signature:()
computeNorms	../include/abcd.h	/^    void computeNorms();$/;"	p	class:abcd	access:private	signature:()
computePositiveUnitary	../include/Eigen/src/Eigen2Support/SVD.h	/^    void computePositiveUnitary(PositiveType *positive, UnitaryType *unitary) const;$/;"	p	class:Eigen::SVD	access:public	signature:(PositiveType *positive, UnitaryType *unitary) const
computePositiveUnitary	../include/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computePositiveUnitary(UnitaryType *positive,$/;"	f	class:Eigen::SVD	signature:(UnitaryType *positive, PositiveType *unitary) const
computeProductBlockingSizes	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void computeProductBlockingSizes(std::ptrdiff_t& k, std::ptrdiff_t& m, std::ptrdiff_t& n)$/;"	f	namespace:Eigen::internal	signature:(std::ptrdiff_t& k, std::ptrdiff_t& m, std::ptrdiff_t& n)
computeProductBlockingSizes	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^void computeProductBlockingSizes(std::ptrdiff_t& k, std::ptrdiff_t& m, std::ptrdiff_t& n)$/;"	f	namespace:Eigen::internal	signature:(std::ptrdiff_t& k, std::ptrdiff_t& m, std::ptrdiff_t& n)
compute_rho	../include/abcd.h	/^    double compute_rho(Eigen::MatrixXd X, Eigen::MatrixXd U, double thresh);$/;"	p	class:abcd	access:private	signature:(Eigen::MatrixXd X, Eigen::MatrixXd U, double thresh)
compute_rho	../src/bcg.cpp	/^double abcd::compute_rho(Eigen::MatrixXd x, Eigen::MatrixXd u, double thresh)$/;"	f	class:abcd	signature:(Eigen::MatrixXd x, Eigen::MatrixXd u, double thresh)
computeRoots	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void computeRoots(const MatrixType& m, VectorType& roots)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(const MatrixType& m, VectorType& roots)
computeRotationScaling	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  void computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const;$/;"	p	class:Eigen::Transform	access:public	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
computeRotationScaling	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^void Transform<Scalar,Dim>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
computeRotationScaling	../include/Eigen/src/Eigen2Support/SVD.h	/^    void computeRotationScaling(RotationType *unitary, ScalingType *positive) const;$/;"	p	class:Eigen::SVD	access:public	signature:(RotationType *unitary, ScalingType *positive) const
computeRotationScaling	../include/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeRotationScaling(RotationType *rotation, ScalingType *scaling) const$/;"	f	class:Eigen::SVD	signature:(RotationType *rotation, ScalingType *scaling) const
computeRotationScaling	../include/Eigen/src/Geometry/Transform.h	/^  void computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const;$/;"	p	class:Eigen::Transform	access:public	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
computeRotationScaling	../include/Eigen/src/Geometry/Transform.h	/^void Transform<Scalar,Dim,Mode,Options>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
computeScalingRotation	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  void computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const;$/;"	p	class:Eigen::Transform	access:public	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
computeScalingRotation	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^void Transform<Scalar,Dim>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
computeScalingRotation	../include/Eigen/src/Eigen2Support/SVD.h	/^    void computeScalingRotation(ScalingType *positive, RotationType *unitary) const;$/;"	p	class:Eigen::SVD	access:public	signature:(ScalingType *positive, RotationType *unitary) const
computeScalingRotation	../include/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeScalingRotation(ScalingType *scaling, RotationType *rotation) const$/;"	f	class:Eigen::SVD	signature:(ScalingType *scaling, RotationType *rotation) const
computeScalingRotation	../include/Eigen/src/Geometry/Transform.h	/^  void computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const;$/;"	p	class:Eigen::Transform	access:public	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
computeScalingRotation	../include/Eigen/src/Geometry/Transform.h	/^void Transform<Scalar,Dim,Mode,Options>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
computeShift	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexScalar computeShift(Index iu, Index iter);$/;"	p	class:Eigen::ComplexSchur	access:private	signature:(Index iu, Index iter)
computeShift	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^typename ComplexSchur<MatrixType>::ComplexScalar ComplexSchur<MatrixType>::computeShift(Index iu, Index iter)$/;"	f	class:Eigen::ComplexSchur	signature:(Index iu, Index iter)
computeShift	../include/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)$/;"	f	class:Eigen::RealSchur	signature:(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)
computeShift	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    void computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)
ComputeThinU	../include/Eigen/src/Core/util/Constants.h	/^  ComputeThinU        = 0x08,$/;"	e	enum:Eigen::DecompositionOptions
ComputeThinV	../include/Eigen/src/Core/util/Constants.h	/^  ComputeThinV        = 0x20,$/;"	e	enum:Eigen::DecompositionOptions
computeU	../include/Eigen/src/SVD/JacobiSVD.h	/^    inline bool computeU() const { return m_computeFullU || m_computeThinU; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
computeUnitaryPositive	../include/Eigen/src/Eigen2Support/SVD.h	/^    void computeUnitaryPositive(UnitaryType *unitary, PositiveType *positive) const;$/;"	p	class:Eigen::SVD	access:public	signature:(UnitaryType *unitary, PositiveType *positive) const
computeUnitaryPositive	../include/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeUnitaryPositive(UnitaryType *unitary,$/;"	f	class:Eigen::SVD	signature:(UnitaryType *unitary, PositiveType *positive) const
computeV	../include/Eigen/src/SVD/JacobiSVD.h	/^    inline bool computeV() const { return m_computeFullV || m_computeThinV; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
concat_columns	splib_utils.cpp	/^concat_columns ( CompCol_Mat_double &A, std::vector<CompCol_Mat_double> &B, std::vector<int> st_cols )$/;"	f
conditional_aligned_delete_auto	../include/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline void conditional_aligned_delete_auto(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
conditional_aligned_delete	../include/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline void conditional_aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
conditional_aligned_free	../include/Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
conditional_aligned_free	../include/Eigen/src/Core/util/Memory.h	/^template<> inline void conditional_aligned_free<false>(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
conditional_aligned_malloc	../include/Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
conditional_aligned_malloc	../include/Eigen/src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_malloc<false>(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
conditional_aligned_new_auto	../include/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_new_auto(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
conditional_aligned_new	../include/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_new(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
conditional_aligned_realloc	../include/Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t new_size, size_t old_size)
conditional_aligned_realloc	../include/Eigen/src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t new_size, size_t)
conditional_aligned_realloc_new_auto	../include/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new_auto(T* pts, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(T* pts, size_t new_size, size_t old_size)
conditional_aligned_realloc_new	../include/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new(T* pts, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(T* pts, size_t new_size, size_t old_size)
conditional	../include/Eigen/src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	s	namespace:Eigen::internal
conditional	../include/Eigen/src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	s	namespace:Eigen::internal
conditionMatrix	../include/Eigen/src/Core/Select.h	/^    const ConditionMatrixType& conditionMatrix() const$/;"	f	class:Eigen::Select	access:public	signature:() const
ConditionMatrixNested	../include/Eigen/src/Core/Select.h	/^  typedef typename ConditionMatrixType::Nested ConditionMatrixNested;$/;"	t	struct:Eigen::internal::traits	access:public
conj_expr_if	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^template<bool Cond, typename T> struct conj_expr_if$/;"	s	namespace:Eigen::internal	inherits:conditional
conj_helper	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet2d, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet4f, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2d, Packet1cd, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet4f, Packet2cf, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<RealScalar, std::complex<RealScalar>, false,Conj>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<std::complex<RealScalar>, RealScalar, Conj,false>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename Scalar> struct conj_helper<Scalar,Scalar,false,false>$/;"	s	namespace:Eigen::internal
conj_if	../include/Eigen/src/Core/util/BlasUtil.h	/^template<> struct conj_if<false> {$/;"	s	namespace:Eigen::internal
conj_if	../include/Eigen/src/Core/util/BlasUtil.h	/^template<> struct conj_if<true> {$/;"	s	namespace:Eigen::internal
conj_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct conj_impl$/;"	s	namespace:Eigen::internal
conj_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct conj_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
Conj	../include/Eigen/src/Core/Functors.h	/^    Conj = NumTraits<LhsScalar>::IsComplex$/;"	e	enum:Eigen::internal::scalar_conj_product_op::__anon294
conj	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(conj, Scalar) conj(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
ConjLhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
ConjLhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
ConjLhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
ConjLhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
conj_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct conj_retval$/;"	s	namespace:Eigen::internal
ConjRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
ConjRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
ConjRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
ConjRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
ConjugateGradient	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^class ConjugateGradient : public IterativeSolverBase<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	c	namespace:Eigen	inherits:IterativeSolverBase
ConjugateGradient	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ConjugateGradient() : Base() {}$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:()
ConjugateGradient	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ConjugateGradient(const MatrixType& A) : Base(A) {}$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const MatrixType& A)
~ConjugateGradient	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ~ConjugateGradient() {}$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:()
conjugate_gradient	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^void conjugate_gradient(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, const Rhs& rhs, Dest& x, const Preconditioner& precond, int& iters, typename Dest::RealScalar& tol_error)
Conjugate	../include/Eigen/src/Core/BandMatrix.h	/^        Conjugate = ReturnOpposite && NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon80
conjugate	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline const TriangularView<MatrixConjugateReturnType,Mode> conjugate() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
conjugate	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularView<MatrixConjugateReturnType,Mode> conjugate()$/;"	f	class:Eigen::TriangularView	access:public	signature:()
conjugate	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::conjugate() const$/;"	f	class:Eigen::Quaternion	signature:() const
conjugate	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion conjugate(void) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(void) const
conjugate	../include/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::conjugate() const$/;"	f	class:Eigen::QuaternionBase	signature:() const
conjugate	../include/Eigen/src/Geometry/Quaternion.h	/^  Quaternion<Scalar> conjugate() const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:() const
conjugate	../include/Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType conjugate() const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
conjugate	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^conjugate() const$/;"	f	signature:() const
ConjugateReturnType	../include/Eigen/src/Householder/HouseholderSequence.h	/^    > ConjugateReturnType;$/;"	t	class:Eigen::HouseholderSequence	access:public
ConjugateReturnType	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type ConjugateReturnType;$/;"	t
conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex, DenseIndex, DenseIndex cols) { m_cols = cols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex, DenseIndex cols)
conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex,DenseIndex,DenseIndex)
conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex, DenseIndex rows, DenseIndex cols) { m_rows = rows; m_cols = cols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex rows, DenseIndex cols)
conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex, DenseIndex rows, DenseIndex) { m_rows = rows; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex rows, DenseIndex)
conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex size, DenseIndex, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex, DenseIndex cols)
conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex size, DenseIndex rows, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex rows, DenseIndex cols)
conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex size, DenseIndex rows, DenseIndex)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex rows, DenseIndex)
conservativeResize	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
conservativeResize	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index rows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, NoChange_t)
conservativeResize	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index size)
conservativeResize	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(NoChange_t, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(NoChange_t, Index cols)
conservative_resize_like_impl	../include/Eigen/src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl<Derived,OtherDerived,true>$/;"	s	namespace:Eigen::internal
conservative_resize_like_impl	../include/Eigen/src/Core/PlainObjectBase.h	/^struct internal::conservative_resize_like_impl$/;"	s	class:Eigen::internal
conservativeResizeLike	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResizeLike(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const DenseBase<OtherDerived>& other)
conservative_sparse_sparse_product_impl	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^static void conservative_sparse_sparse_product_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	namespace:Eigen::internal	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res)
conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
ConstAffinePart	../include/Eigen/src/Geometry/Transform.h	/^                              const Block<const MatrixType,Dim,HDim> >::type ConstAffinePart;$/;"	t	class:Eigen::Transform	access:public
ConstAffinePart	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::ConstAffinePart ConstAffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
ConstAlignedMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
Constant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& value)
Constant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index rows, Index cols, const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols, const Scalar& value)
Constant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index size, const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const Scalar& value)
Constant	../include/Eigen/src/Core/DenseBase.h	/^    Constant(const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value)
Constant	../include/Eigen/src/Core/DenseBase.h	/^    Constant(Index rows, Index cols, const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols, const Scalar& value)
Constant	../include/Eigen/src/Core/DenseBase.h	/^    Constant(Index size, const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const Scalar& value)
ConstantReturnType	../include/Eigen/src/Core/ArrayBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::ArrayBase	access:public
ConstantReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ConstantReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
ConstantReturnType	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Matrix<Scalar,Dynamic,Dynamic> > ConstantReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
const_blas_data_mapper	../include/Eigen/src/Core/util/BlasUtil.h	/^class const_blas_data_mapper$/;"	c	namespace:Eigen::internal
const_blas_data_mapper	../include/Eigen/src/Core/util/BlasUtil.h	/^    const_blas_data_mapper(const Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::const_blas_data_mapper	access:public	signature:(const Scalar* data, Index stride)
const_cast_derived	../include/Eigen/src/Core/EigenBase.h	/^  inline Derived& const_cast_derived() const$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
const_cast_derived	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& const_cast_derived() const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
ConstColsBlockXpr	../include/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ConstColsBlockXpr;$/;"	t
ConstColwiseReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ConstColXpr	../include/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ConstColXpr;$/;"	t
const_derived	../include/Eigen/src/Core/EigenBase.h	/^  inline const Derived& const_derived() const$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
ConstDiagonalIndexReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
ConstDiagonalReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef const Diagonal<const Derived> ConstDiagonalReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
ConstFixedSegmentReturnType	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	s	class:Eigen::DenseBase	access:public
ConstLinearPart	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef const Block<const MatrixType,Dim,Dim> ConstLinearPart;$/;"	t	class:Eigen::Transform	access:public
ConstLinearPart	../include/Eigen/src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,Dim,int(Mode)==(AffineCompact)> ConstLinearPart;$/;"	t	class:Eigen::Transform	access:public
ConstMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
ConstMatrixType	../include/Eigen/src/Geometry/Transform.h	/^  typedef const MatrixType ConstMatrixType;$/;"	t	class:Eigen::Transform	access:public
ConstNColsBlockXpr	../include/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	s
ConstNColsBlockXpr::Type	../include/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:ConstNColsBlockXpr	access:public
ConstNormalReturnType	../include/Eigen/src/Geometry/Hyperplane.h	/^  typedef const Block<const Coefficients,AmbientDimAtCompileTime,1> ConstNormalReturnType;$/;"	t	class:Eigen::Hyperplane	access:public
ConstNRowsBlockXpr	../include/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	s
ConstNRowsBlockXpr::Type	../include/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:ConstNRowsBlockXpr	access:public
const_pointer	../include/Eigen/src/Core/util/Memory.h	/^    typedef const T*  const_pointer;$/;"	t	class:Eigen::aligned_allocator	access:public
const_pointer	../include/Eigen/src/StlSupport/details.h	/^    typedef const T*  const_pointer;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
const_reference	../include/Eigen/src/Core/util/Memory.h	/^    typedef const T&  const_reference;$/;"	t	class:Eigen::aligned_allocator	access:public
const_reference	../include/Eigen/src/StlSupport/details.h	/^    typedef const T&  const_reference;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
ConstReverseReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef const Reverse<const Derived, BothDirections> ConstReverseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ConstRowsBlockXpr	../include/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowsBlockXpr;$/;"	t
ConstRowwiseReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ConstRowXpr	../include/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowXpr;$/;"	t
construct_elements_of_array	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
construct_from_matrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  struct construct_from_matrix$/;"	s	class:Eigen::Transform	access:public
construct_from_matrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  template<typename OtherDerived> struct construct_from_matrix<OtherDerived, true>$/;"	s	class:Eigen::Transform	access:public
construct	../include/Eigen/src/Core/util/Memory.h	/^    void  construct(pointer p, Args&&... args)$/;"	f	class:Eigen::aligned_allocator	access:public	signature:(pointer p, Args&&... args)
construct	../include/Eigen/src/Core/util/Memory.h	/^    void construct( pointer p, const T& value )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( pointer p, const T& value )
constructor_without_unaligned_array_assert	../include/Eigen/src/Core/DenseStorage.h	/^struct constructor_without_unaligned_array_assert {};$/;"	s	namespace:Eigen::internal
ConstSegmentReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef const VectorBlock<const Derived> ConstSegmentReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ConstSelfAdjointViewReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
ConstStartMinusOne	../include/Eigen/src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime==1 ? 1 : SizeMinusOne> ConstStartMinusOne;$/;"	t	class:Eigen::MatrixBase	access:public
ConstTranslationPart	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef const Block<const MatrixType,Dim,1> ConstTranslationPart;$/;"	t	class:Eigen::Transform	access:public
ConstTranslationPart	../include/Eigen/src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,1,int(Mode)==(AffineCompact)> ConstTranslationPart;$/;"	t	class:Eigen::Transform	access:public
ConstTransposeReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef const Transpose<const Derived> ConstTransposeReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ConstTransposeReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::ConstTransposeReturnType ConstTransposeReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
ConstTriangularViewReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
contains	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
contains	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool contains(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p) const
contains	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
contains	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline bool contains(const MatrixBase<Derived>& a_p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& a_p) const
copy_bool	../include/Eigen/src/Core/util/Macros.h	/^    inline bool copy_bool(bool b) { return b; }$/;"	f	namespace:Eigen::internal	signature:(bool b)
copyCoeffByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeffByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner, const DenseBase<OtherDerived>& other)
copyCoeffByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void copyCoeffByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
copyCoeff	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
copyCoeff	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
copyCoeff	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void copyCoeff();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
copyCoeff	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
copyCoeff	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
copyCoeff	../include/Eigen/src/Core/Swap.h	/^    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
copyCoeff	../include/Eigen/src/Core/Swap.h	/^    void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
copyCoeff	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, Other& other)$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col, Other& other)
copyPacketByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacketByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner, const DenseBase<OtherDerived>& other)
copyPacketByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void copyPacketByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
copyPacket	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
copyPacket	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
copyPacket	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void copyPacket();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
copyPacket	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
copyPacket	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
copyPacket	../include/Eigen/src/Core/Swap.h	/^    void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
copyPacket	../include/Eigen/src/Core/Swap.h	/^    void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
corner	../include/Eigen/src/Core/DenseBase.h	/^    Block<Derived> corner(CornerType type, Index cRows, Index cCols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type, Index cRows, Index cCols)
corner	../include/Eigen/src/Core/DenseBase.h	/^    Block<Derived, CRows, CCols> corner(CornerType type);$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type)
corner	../include/Eigen/src/Core/DenseBase.h	/^    const Block<Derived> corner(CornerType type, Index cRows, Index cCols) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type, Index cRows, Index cCols) const
corner	../include/Eigen/src/Core/DenseBase.h	/^    const Block<Derived, CRows, CCols> corner(CornerType type) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type) const
corner	../include/Eigen/src/Eigen2Support/Block.h	/^  ::corner(CornerType type, Index cRows, Index cCols)$/;"	f	class:Eigen::DenseBase	signature:(CornerType type, Index cRows, Index cCols)
corner	../include/Eigen/src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type) const$/;"	f	class:Eigen::DenseBase	signature:(CornerType type) const
corner	../include/Eigen/src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type)$/;"	f	class:Eigen::DenseBase	signature:(CornerType type)
corner	../include/Eigen/src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type, Index cRows, Index cCols) const$/;"	f	class:Eigen::DenseBase	signature:(CornerType type, Index cRows, Index cCols) const
corner	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType corner(CornerType corner) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(CornerType corner) const
CornerType	../include/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	g	namespace:Eigen
CornerType	../include/Eigen/src/Geometry/AlignedBox.h	/^  enum CornerType$/;"	g	class:Eigen::AlignedBox	access:public
cosh	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> cosh() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
cos	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> cos() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
cos	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_cos_op)      cos() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
cos	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::cos() const$/;"	f	class:Eigen::Cwise	signature:() const
cos	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^cos() const$/;"	f	signature:() const
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 2 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon301
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon328
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon329
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon330
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon331
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon332
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon333
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon302
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon303
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<LhsScalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon295
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost)\/2, \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon293
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon291
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon296
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon297
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon300
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon304
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon305
Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::IsComplex ? NumTraits<Scalar>::AddCost : 0,$/;"	e	enum:Eigen::internal::functor_traits::__anon307
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon309
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon310
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon311
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon312
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon356
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon357
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon358
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon359
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon354
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon355
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon343
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon344
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon345
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon346
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon347
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon348
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon349
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon350
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon351
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon321
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon319
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon318
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon337
Cost	../include/Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon298
Cost	../include/Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon299
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon334
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon313
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon314
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon361
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon360
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon352
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon353
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon308
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon316
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon320
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon327
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon306
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon335
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon315
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon317
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon336
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon340
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon341
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon342
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon338
Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon339
Cost	../include/Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon365
Cost	../include/Eigen/src/Core/Redux.h	/^    Cost = (  Derived::SizeAtCompileTime == Dynamic$/;"	e	enum:Eigen::internal::redux_traits::__anon270
Cost	../include/Eigen/src/Core/VectorwiseOp.h	/^  template<typename _Scalar, int Size> struct Cost$/;"	s	struct:Eigen::internal::member_redux	access:public
Cost	../include/Eigen/src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon52
Cost	../include/Eigen/src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon53
CostOpType	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::template Cost<InputScalar,int(TraversalSize)> CostOpType;$/;"	t	struct:Eigen::internal::traits	access:public
CostOpType	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::template Cost<InputScalar,TraversalSize> CostOpType;$/;"	t	struct:Eigen::internal::traits	access:public
count	../include/Eigen/src/Core/BooleanRedux.h	/^inline typename DenseBase<Derived>::Index DenseBase<Derived>::count() const$/;"	f	class:Eigen::DenseBase	signature:() const
count	../include/Eigen/src/Core/DenseBase.h	/^    Index count() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
count	../include/Eigen/src/Core/VectorwiseOp.h	/^    const PartialReduxExpr<ExpressionType, internal::member_count<Index>, Direction> count() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
cpotf2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cpotf2)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
cpotrf	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cpotrf)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
cpotri	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cpotri)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
cpuid_is_vendor	../include/Eigen/src/Core/util/Memory.h	/^inline bool cpuid_is_vendor(int abcd[4], const char* vendor)$/;"	f	namespace:Eigen::internal	signature:(int abcd[4], const char* vendor)
createAugmentedSystems	../include/abcd.h	/^    void createAugmentedSystems();$/;"	p	class:abcd	access:private	signature:()
createAugmentedSystems	../src/mumps.cpp	/^void abcd::createAugmentedSystems()$/;"	f	class:abcd	signature:()
createInterComm	../include/abcd.h	/^    void createInterComm();$/;"	p	class:abcd	access:private	signature:()
createInterComm	../src/comms.cpp	/^void abcd::createInterComm()$/;"	f	class:abcd	signature:()
cross3_impl	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct cross3_impl<Architecture::SSE,VectorLhs,VectorRhs,float,true>$/;"	s	namespace:Eigen::internal
cross3_impl	../include/Eigen/src/Geometry/OrthoMethods.h	/^struct cross3_impl {$/;"	s	namespace:Eigen::internal
cross3	../include/Eigen/src/Core/MatrixBase.h	/^    PlainObject cross3(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
cross3	../include/Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross3(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
cross	../include/Eigen/src/Core/MatrixBase.h	/^    cross(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
cross	../include/Eigen/src/Core/VectorwiseOp.h	/^    const CrossReturnType cross(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:(const MatrixBase<OtherDerived>& other) const
cross	../include/Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
cross	../include/Eigen/src/Geometry/OrthoMethods.h	/^VectorwiseOp<ExpressionType,Direction>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	signature:(const MatrixBase<OtherDerived>& other) const
cross_product_return_type	../include/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> struct cross_product_return_type {$/;"	s	class:Eigen::MatrixBase	access:public
CrossReturnType	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::PlainObject CrossReturnType;$/;"	t	class:Eigen::VectorwiseOp	access:public
crotg	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(crotg) (float  *, float  *, float  *, float  *);$/;"	p	signature:(float *, float *, float *, float *)
csbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(csbmv)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
cscal	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(cscal) (int *,  float  *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *)
CSC_middleRows	splib_utils.cpp	/^CompCol_Mat_double CSC_middleRows (CompRow_Mat_double &M, int st_row, int nb_rows) {$/;"	f
csc_transpose	splib_utils.cpp	/^csc_transpose ( CompCol_Mat_double &M )$/;"	f
csc_transpose	splib_utils.cpp	/^csc_transpose ( CompRow_Mat_double &M )$/;"	f
cspmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cspmv) (char *, int *, float  *, float *,$/;"	p	signature:(char *, int *, float *, float *, float *, int *, float *, float *, int *)
cspr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cspr2) (char *, int *, float   *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *)
cspr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(cspr) (char *, int *, float   *, float  *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *)
CSR_middleRows	splib_utils.cpp	/^CompRow_Mat_double CSR_middleRows (CompRow_Mat_double &M, int st_row, int nb_rows) {$/;"	f
csrot	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(csrot) (int *, float  *, int *, float  *, int *, float  *, float  *);$/;"	p	signature:(int *, float *, int *, float *, int *, float *, float *)
csr_transpose	splib_utils.cpp	/^csr_transpose ( CompCol_Mat_double &M )$/;"	f
csr_transpose	splib_utils.cpp	/^csr_transpose ( CompRow_Mat_double &M )$/;"	f
csscal	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(csscal)(int *,  float  *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *)
cs_tdfs	../include/Eigen/src/OrderingMethods/Amd.h	/^Index cs_tdfs(Index j, Index k, Index *head, const Index *next, Index *post, Index *stack)$/;"	f	namespace:Eigen::internal	signature:(Index j, Index k, Index *head, const Index *next, Index *post, Index *stack)
cswap	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(cswap) (int *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, int *, float *, int *)
cs_wclear	../include/Eigen/src/OrderingMethods/Amd.h	/^static int cs_wclear (Index mark, Index lemax, Index *w, Index n)$/;"	f	namespace:Eigen::internal	signature:(Index mark, Index lemax, Index *w, Index n)
csymm3m	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(csymm3m)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
csymm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(csymm)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
csymv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(csymv) (char *, int *, float  *, float *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
csyr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(csyr2) (char *, int *, float   *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *, int *)
csyr2k	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(csyr2k)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
csyr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(csyr) (char *, int *, float   *, float  *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *)
csyrk	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(csyrk)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *)
ctbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ctbmv) (char *, char *, char *, int *, int *, float  *, int *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, float *, int *, float *, int *)
ctbsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ctbsv) (char *, char *, char *, int *, int *, float  *, int *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, float *, int *, float *, int *)
c_to_fortran_numbering	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void c_to_fortran_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat)
ctpmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ctpmv) (char *, char *, char *, int *, float  *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, float *, float *, int *)
ctpsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ctpsv) (char *, char *, char *, int *, float  *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, float *, float *, int *)
ctrmm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ctrmm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, float *, float *, int *, float *, int *)
ctrmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ctrmv) (char *, char *, char *, int *, float  *, int *,$/;"	p	signature:(char *, char *, char *, int *, float *, int *, float *, int *)
ctrsm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ctrsm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, float *, float *, int *, float *, int *)
ctrsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ctrsv) (char *, char *, char *, int *, float  *, int *,$/;"	p	signature:(char *, char *, char *, int *, float *, int *, float *, int *)
ctrti2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ctrti2)(char *, char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, char *, int *, float *, int *, int *)
ctrtri	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ctrtri)(char *, char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, char *, int *, float *, int *, int *)
cube	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_cube_op)     cube() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
cube	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::cube() const$/;"	f	class:Eigen::Cwise	signature:() const
cube	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^cube() const$/;"	f	signature:() const
cwiseAbs2	../include/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseAbs2() const { return derived(); }$/;"	f	signature:() const
cwiseAbs	../include/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseAbs() const { return derived(); }$/;"	f	signature:() const
CwiseBinaryOpImpl	../include/Eigen/src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Dense>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
CwiseBinaryOpImpl	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
CwiseBinaryOpImpl	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CwiseBinaryOpImpl()$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:()
CwiseBinaryOp	../include/Eigen/src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,CwiseBinaryOpImpl
CwiseBinaryOp	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE CwiseBinaryOp(const Lhs& lhs, const Rhs& rhs, const BinaryOp& func = BinaryOp())$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:(const Lhs& lhs, const Rhs& rhs, const BinaryOp& func = BinaryOp())
CwiseBinaryXpr	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryFunc, Lhs, Rhs> CwiseBinaryXpr;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
CwiseBinaryXpr	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> CwiseBinaryXpr;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
cwiseEqual	../include/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
cwiseEqual	../include/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseEqual(const Scalar& s) const$/;"	f	signature:(const Scalar& s) const
cwise	../include/Eigen/src/Core/MatrixBase.h	/^    inline const Cwise<Derived> cwise() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
cwise	../include/Eigen/src/Core/MatrixBase.h	/^    inline Cwise<Derived> cwise();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
cwise	../include/Eigen/src/Eigen2Support/Cwise.h	/^inline const Cwise<Derived> MatrixBase<Derived>::cwise() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Cwise	../include/Eigen/src/Eigen2Support/Cwise.h	/^    inline Cwise(const ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Cwise	access:public	signature:(const ExpressionType& matrix)
cwise	../include/Eigen/src/Eigen2Support/Cwise.h	/^inline Cwise<Derived> MatrixBase<Derived>::cwise()$/;"	f	class:Eigen::MatrixBase	signature:()
Cwise	../include/Eigen/src/Eigen2Support/Cwise.h	/^template<typename ExpressionType> class Cwise$/;"	c	namespace:Eigen
cwiseInverse	../include/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseInverse() const { return derived(); }$/;"	f	signature:() const
cwiseMax	../include/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMax(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
cwiseMax	../include/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMax(const Scalar &other) const$/;"	f	signature:(const Scalar &other) const
cwiseMin	../include/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMin(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
cwiseMin	../include/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMin(const Scalar &other) const$/;"	f	signature:(const Scalar &other) const
cwiseNotEqual	../include/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseNotEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
CwiseNullaryOp	../include/Eigen/src/Core/CwiseNullaryOp.h	/^class CwiseNullaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
CwiseNullaryOp	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    CwiseNullaryOp(Index rows, Index cols, const NullaryOp& func = NullaryOp())$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index rows, Index cols, const NullaryOp& func = NullaryOp())
cwiseProduct	../include/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseProduct(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
cwiseProduct	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::cwiseProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
cwiseProduct	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    cwiseProduct(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
cwiseQuotient	../include/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseQuotient(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
cwiseSqrt	../include/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseSqrt() const { return derived(); }$/;"	f	signature:() const
CwiseUnaryOpImpl	../include/Eigen/src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,XprType,Dense>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
CwiseUnaryOpImpl	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
CwiseUnaryOp	../include/Eigen/src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,CwiseUnaryOpImpl
CwiseUnaryOp	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    inline CwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:(const XprType& xpr, const UnaryOp& func = UnaryOp())
CwiseUnaryViewImpl	../include/Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Dense>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
CwiseUnaryViewImpl	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
CwiseUnaryView	../include/Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryView : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,CwiseUnaryViewImpl
CwiseUnaryView	../include/Eigen/src/Core/CwiseUnaryView.h	/^    inline CwiseUnaryView(const MatrixType& mat, const ViewOp& func = ViewOp())$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:(const MatrixType& mat, const ViewOp& func = ViewOp())
damax	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(damax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
damin	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(damin) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dasum	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(dasum) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
data	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
data	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
data	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:()
data	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:()
data	../include/Eigen/src/Core/Block.h	/^    inline const Scalar* data() const;$/;"	p	class:Eigen::Block	access:public	signature:() const
data	../include/Eigen/src/Core/DenseStorage.h	/^    inline const T *data() const { return 0; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
data	../include/Eigen/src/Core/DenseStorage.h	/^    inline const T *data() const { return m_data.array; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
data	../include/Eigen/src/Core/DenseStorage.h	/^    inline const T *data() const { return m_data; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
data	../include/Eigen/src/Core/DenseStorage.h	/^    inline T *data() { return 0; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
data	../include/Eigen/src/Core/DenseStorage.h	/^    inline T *data() { return m_data.array; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
data	../include/Eigen/src/Core/DenseStorage.h	/^    inline T *data() { return m_data; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
data	../include/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE  Scalar* data() { eigen_internal_assert(false && "should never be called"); return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if	access:public	signature:()
data	../include/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if	access:public	signature:()
data	../include/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return m_data.array; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if	access:public	signature:()
data	../include/Eigen/src/Core/MapBase.h	/^    inline const Scalar* data() const { return m_data; }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
data	../include/Eigen/src/Core/MapBase.h	/^    inline const Scalar* data() const { return this->m_data; }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
data	../include/Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue* data() { return this->m_data; } \/\/ no const-cast here so non-const-correct code will give a compile error$/;"	f	class:Eigen::MapBase	access:public	signature:()
data	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar *data() const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
data	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar *data()$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
data	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
data	../include/Eigen/src/Core/Swap.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
data	../include/Eigen/src/Core/Swap.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:()
data	../include/Eigen/src/Core/Transpose.h	/^    inline const Scalar* data() const { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
data	../include/Eigen/src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:()
data	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
data	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
data	../include/Eigen/src/Geometry/Transform.h	/^  const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
data	../include/Eigen/src/Geometry/Transform.h	/^  Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
data	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
data	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
_data	../include/Eigen/src/SparseCore/SparseVector.h	/^    internal::CompressedStorage<Scalar,Index>& _data() const { return m_data; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
_data	../include/Eigen/src/SparseCore/SparseVector.h	/^    internal::CompressedStorage<Scalar,Index>& _data() { return m_data; }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
DataRowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon81
DataRowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon82
DataRowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^      DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic))$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon79
daxpy	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(daxpy) (int *, double *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *, double *, int *)
dcntl	../include/abcd.h	/^    double dcntl[10];$/;"	m	class:abcd	access:public
dcol_	../include/abcd.h	/^    VectorXd dcol_;$/;"	m	class:abcd	access:private
dcomplex	../include/Eigen/src/Core/util/MKL_support.h	/^typedef std::complex<double> dcomplex;$/;"	t	namespace:Eigen
dcopy	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(dcopy) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
ddot	../include/abcd.h	/^    Eigen::MatrixXd ddot(Eigen::MatrixXd p, Eigen::MatrixXd ap);$/;"	p	class:abcd	access:private	signature:(Eigen::MatrixXd p, Eigen::MatrixXd ap)
ddot	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(ddot)  (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
ddot	../src/utils.cpp	/^Eigen::MatrixXd abcd::ddot(Eigen::MatrixXd p, Eigen::MatrixXd ap)$/;"	f	class:abcd	signature:(Eigen::MatrixXd p, Eigen::MatrixXd ap)
ddot	utils.cpp	/^double abcd::ddot(VECTOR_double &p, VECTOR_double &ap)$/;"	f	class:abcd
deallocate	../include/Eigen/src/Core/util/Memory.h	/^    void deallocate( pointer p, size_type \/*num*\/ )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( pointer p, size_type )
debug	../include/Eigen/src/Core/Assign.h	/^  static void debug()$/;"	f	struct:Eigen::internal::assign_traits	access:public	signature:()
debug	../include/Eigen/src/Core/GeneralProduct.h	/^  static void debug()$/;"	f	struct:Eigen::internal::product_type	access:public	signature:()
DEC	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	284;"	d	file:
Dec	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  typedef CholmodBase<_MatrixType,_UpLo,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  typedef CholmodBase<_MatrixType,_UpLo,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^  typedef DiagonalPreconditioner<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef BiCGSTAB<_MatrixType, _Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^  typedef IncompleteLUT<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef IterativeSolverBase<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
dec	../include/Eigen/src/misc/Image.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
dec	../include/Eigen/src/misc/Kernel.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
dec	../include/Eigen/src/misc/Solve.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
dec	../include/Eigen/src/misc/SparseSolve.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
Dec	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  typedef PardisoImpl<_Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  typedef PardisoImpl<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  typedef PastixBase<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  typedef PastixBase<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SimplicialCholeskyBase<Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SimplicialCholeskyBase<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef SuperLUBase<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef SuperLUBase<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Dec	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  typedef UmfPackLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Dec	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  typedef UmfPackLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
DECL_GSISX	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	66;"	d
DECL_GSSVX	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	30;"	d
DecompositionOptions	../include/Eigen/src/Core/util/Constants.h	/^enum DecompositionOptions {$/;"	g	namespace:Eigen
DecompositionType	../include/Eigen/src/misc/Image.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
DecompositionType	../include/Eigen/src/misc/Kernel.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::kernel_retval_base	access:public
DecompositionType	../include/Eigen/src/misc/Solve.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
DecompositionType	../include/Eigen/src/misc/SparseSolve.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
decrement_size	../include/Eigen/src/Householder/Householder.h	/^template<int n> struct decrement_size$/;"	s	namespace:Eigen::internal
Default	../include/Eigen/src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	e	enum:Eigen::Default_t
default_packet_traits	../include/Eigen/src/Core/GenericPacketMath.h	/^struct default_packet_traits$/;"	s	namespace:Eigen::internal
default_prunning_func	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    default_prunning_func(Scalar ref, RealScalar eps) : reference(ref), epsilon(eps) {}$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func	access:public	signature:(Scalar ref, RealScalar eps)
default_prunning_func	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  struct default_prunning_func {$/;"	s	class:Eigen::SparseMatrix	access:private
Default_t	../include/Eigen/src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	g	namespace:Eigen
DefaultTraversal	../include/Eigen/src/Core/util/Constants.h	/^  DefaultTraversal,$/;"	e	enum:Eigen::__anon209
DenseBase	../include/Eigen/src/Core/DenseBase.h	/^    DenseBase()$/;"	f	class:Eigen::DenseBase	access:protected	signature:()
DenseBase	../include/Eigen/src/Core/DenseBase.h	/^    DenseBase(int,int);$/;"	p	class:Eigen::DenseBase	access:private	signature:(int,int)
DenseBase	../include/Eigen/src/Core/DenseBase.h	/^    explicit DenseBase(int);$/;"	p	class:Eigen::DenseBase	access:private	signature:(int)
DenseBase	../include/Eigen/src/Core/DenseBase.h	/^template<typename Derived> class DenseBase$/;"	c	namespace:Eigen	inherits:internal::special_scalar_op_base
DenseBase	../include/Eigen/src/Core/DenseBase.h	/^    template<typename OtherDerived> explicit DenseBase(const DenseBase<OtherDerived>&);$/;"	p	class:Eigen::DenseBase	access:private	signature:(const DenseBase<OtherDerived>&)
DenseCoeffsBase	../include/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen	inherits:DenseCoeffsBase
DenseCoeffsBase	../include/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectWriteAccessors>$/;"	c	namespace:Eigen	inherits:DenseCoeffsBase
DenseCoeffsBase	../include/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived,ReadOnlyAccessors> : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
DenseCoeffsBase	../include/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, WriteAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen	inherits:DenseCoeffsBase
Dense	../include/Eigen/src/Core/util/Constants.h	/^struct Dense {};$/;"	s	namespace:Eigen
DenseIndex	../include/Eigen/src/Core/util/XprHelper.h	/^typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE DenseIndex;$/;"	t	namespace:Eigen
DenseMatrixType	../include/Eigen/src/Core/BandMatrix.h	/^    typedef Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
DenseMatrixType	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime, 0, MaxRowsAtCompileTime, MaxColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::DiagonalBase	access:public
DenseMatrixType	../include/Eigen/src/Core/PermutationMatrix.h	/^            DenseMatrixType;$/;"	t	class:Eigen::PermutationBase	access:public
DenseMatrixType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Derived::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::Transpose	access:public
DenseMatrixType	../include/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
DenseMatrixType	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularBase	access:public
DenseMatrixType	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularView	access:public
DenseMatrixType	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
DenseMatrixType	../include/Eigen/src/Core/TriangularMatrix.h	/^      typedef typename TriangularView<MatrixType,Mode>::DenseMatrixType DenseMatrixType;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
DenseSparseProductReturnType	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs, int InnerSize> struct DenseSparseProductReturnType$/;"	s	namespace:Eigen
DenseSparseProductReturnType	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs> struct DenseSparseProductReturnType<Lhs,Rhs,1>$/;"	s	namespace:Eigen
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex, DenseIndex, DenseIndex cols) : m_cols(cols) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex, DenseIndex cols)
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex,DenseIndex,DenseIndex)
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex, DenseIndex rows, DenseIndex cols) : m_rows(rows), m_cols(cols) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex rows, DenseIndex cols)
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex, DenseIndex rows, DenseIndex) : m_rows(rows) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex rows, DenseIndex)
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex size, DenseIndex, DenseIndex cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_cols(cols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex, DenseIndex cols)
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex size, DenseIndex rows, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex rows, DenseIndex cols)
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex size, DenseIndex rows, DenseIndex) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex rows, DenseIndex)
~DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
~DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
~DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(internal::constructor_without_unaligned_array_assert) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_rows(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, 0, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen	inherits:DenseStorage
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, Dynamic, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, 0, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen	inherits:DenseStorage
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Cols, int _Options> class DenseStorage<T, 0, _Rows, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, 0, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen	inherits:DenseStorage
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, Dynamic, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Cols, int _Options> class DenseStorage<T, Size, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Options> class DenseStorage<T, Size, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage$/;"	c	namespace:Eigen
DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Options> class DenseStorage<T, Size, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseTimeSparseProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^class DenseTimeSparseProduct$/;"	c	namespace:Eigen	inherits:ProductBase
DenseTimeSparseProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    DenseTimeSparseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::DenseTimeSparseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
DenseTimeSparseSelfAdjointProduct	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class DenseTimeSparseSelfAdjointProduct$/;"	c	namespace:Eigen	inherits:ProductBase
DenseTimeSparseSelfAdjointProduct	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    DenseTimeSparseSelfAdjointProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::DenseTimeSparseSelfAdjointProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
DenseType	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::DiagonalBase	access:public
DenseType	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef Derived DenseType;$/;"	t	class:Eigen::PlainObjectBase	access:public
DenseType	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::TriangularBase	access:public
dense_xpr_base_dispatcher_for_doxygen	../include/Eigen/src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal	inherits:ArrayBase
dense_xpr_base_dispatcher_for_doxygen	../include/Eigen/src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal	inherits:MatrixBase
Depth	../include/Eigen/src/Core/GeneralProduct.h	/^    Depth = EIGEN_SIZE_MIN_PREFER_FIXED(_Lhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon122
depth_select	../include/Eigen/src/Core/GeneralProduct.h	/^    depth_select = product_size_category<Depth,MaxDepth>::value$/;"	e	enum:Eigen::internal::product_type::__anon123
deque_base	../include/Eigen/src/StlSupport/StdDeque.h	/^                Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > deque_base;$/;"	t	class:std::deque	access:private
deque	../include/Eigen/src/StlSupport/StdDeque.h	/^  class deque<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std	inherits:deque
derived	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
derived	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
Derived	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl	access:private
Derived	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, XprType> Derived;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:public
Derived	../include/Eigen/src/Core/CwiseUnaryView.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:public
derived	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
derived	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:()
derived	../include/Eigen/src/Core/EigenBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
derived	../include/Eigen/src/Core/EigenBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:()
Derived	../include/Eigen/src/Core/Product.h	/^    typedef Product<Lhs, Rhs> Derived;$/;"	t	class:ProductImpl	access:private
derived	../include/Eigen/src/Core/Transpositions.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
derived	../include/Eigen/src/Core/Transpositions.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:()
derived	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
derived	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:()
derived	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
derived	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:()
derived	../include/Eigen/src/Geometry/RotationBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
derived	../include/Eigen/src/Geometry/RotationBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:()
derived	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
derived	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
derived	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    const Derived& derived() const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
derived	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Derived& derived()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
derived	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    const Derived& derived() const$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
derived	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Derived& derived()$/;"	f	class:Eigen::PastixBase	access:public	signature:()
derived	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
derived	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:()
Derived	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl	access:public
Derived	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:public
Derived	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:public
derived	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
derived	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
derived	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
derived	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
destroy	../include/Eigen/src/Core/util/Memory.h	/^    void destroy( pointer p )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( pointer p )
destruct_elements_of_array	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
determinant_impl	../include/Eigen/src/LU/Determinant.h	/^> struct determinant_impl$/;"	s	namespace:Eigen::internal
determinant_impl	../include/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 1>$/;"	s	namespace:Eigen::internal
determinant_impl	../include/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 2>$/;"	s	namespace:Eigen::internal
determinant_impl	../include/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 3>$/;"	s	namespace:Eigen::internal
determinant_impl	../include/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 4>$/;"	s	namespace:Eigen::internal
determinant	../include/Eigen/src/Core/MatrixBase.h	/^    Scalar determinant() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
determinant	../include/Eigen/src/Core/TriangularMatrix.h	/^    Scalar determinant() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
determinant	../include/Eigen/src/LU/Determinant.h	/^inline typename internal::traits<Derived>::Scalar MatrixBase<Derived>::determinant() const$/;"	f	class:Eigen::MatrixBase	signature:() const
determinant	../include/Eigen/src/LU/FullPivLU.h	/^    typename internal::traits<MatrixType>::Scalar determinant() const;$/;"	p	class:Eigen::FullPivLU	access:public	signature:() const
determinant	../include/Eigen/src/LU/FullPivLU.h	/^typename internal::traits<MatrixType>::Scalar FullPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::FullPivLU	signature:() const
determinant	../include/Eigen/src/LU/PartialPivLU.h	/^    typename internal::traits<MatrixType>::Scalar determinant() const;$/;"	p	class:Eigen::PartialPivLU	access:public	signature:() const
determinant	../include/Eigen/src/LU/PartialPivLU.h	/^typename internal::traits<MatrixType>::Scalar PartialPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::PartialPivLU	signature:() const
determinant	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:() const
determinant	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
determinant	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:() const
determinant	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    Scalar determinant() const;$/;"	p	class:Eigen::SuperLU	access:public	signature:() const
determinant	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^typename SuperLU<MatrixType>::Scalar SuperLU<MatrixType>::determinant() const$/;"	f	class:Eigen::SuperLU	signature:() const
determinant	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    Scalar determinant() const;$/;"	p	class:Eigen::UmfPackLU	access:public	signature:() const
determinant	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^typename UmfPackLU<MatrixType>::Scalar UmfPackLU<MatrixType>::determinant() const$/;"	f	class:Eigen::UmfPackLU	signature:() const
dgbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dgbmv)(char *, int *, int *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dge2mm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dge2mm)(char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dgema	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dgema)(char *, char *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, double *, int *, double*, int *)
dgemm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dgemm)(char *, char *, int *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dgems	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dgems)(char *, char *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, double *, int *, double*, int *)
dgemt	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dgemt)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *)
dgemv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dgemv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dger	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dger)(int *,    int *, double *, double *, int *,$/;"	p	signature:(int *, int *, double *, double *, int *, double *, int *, double *, int *)
dgesv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dgesv)(int *, int *, double *, int *, int *, double*, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, double*, int *, int *)
dgetf2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dgetf2)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
dgetrf	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dgetrf)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
dgetrs	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dgetrs)(char *, int *, int *, double *, int *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, int *, double *, int *, int *, double *, int *, int *)
DiagonalBase	../include/Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
diagonal	../include/Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,Dynamic> diagonal(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Index i)
diagonal	../include/Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,SizeAtCompileTime> diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:()
diagonal	../include/Eigen/src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,Dynamic> diagonal(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Index i) const
diagonal	../include/Eigen/src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,SizeAtCompileTime> diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
diagonal	../include/Eigen/src/Core/BandMatrix.h	/^    template<int N> inline const typename DiagonalIntReturnType<N>::Type diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
diagonal	../include/Eigen/src/Core/BandMatrix.h	/^    template<int N> inline typename DiagonalIntReturnType<N>::Type diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:()
diagonal	../include/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal() const$/;"	f	class:Eigen::internal::MatrixBase	signature:() const
diagonal	../include/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal()$/;"	f	class:Eigen::internal::MatrixBase	signature:()
diagonal	../include/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index) const$/;"	f	class:Eigen::internal::MatrixBase	signature:(Index index) const
diagonal	../include/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index)$/;"	f	class:Eigen::internal::MatrixBase	signature:(Index index)
diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalWrapper	access:public	signature:() const
diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:() const
diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:()
diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    const ConstDiagonalReturnType diagonal() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    DiagonalReturnType diagonal();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Index> typename ConstDiagonalIndexReturnType<Index>::Type diagonal() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Index> typename DiagonalIndexReturnType<Index>::Type diagonal();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    typename ConstDiagonalIndexReturnType<Dynamic>::Type diagonal(Index index) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index index) const
diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    typename DiagonalIndexReturnType<Dynamic>::Type diagonal(Index index);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index index)
diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    typename MatrixBase::template ConstDiagonalIndexReturnType<Dynamic>::Type diagonal(Index index) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index index) const
diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    typename MatrixBase::template DiagonalIndexReturnType<Dynamic>::Type diagonal(Index index);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index index)
diagonal	../include/Eigen/src/Core/ProductBase.h	/^    const Diagonal<const FullyLazyCoeffBaseProductType,0> diagonal() const$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
diagonal	../include/Eigen/src/Core/ProductBase.h	/^    const Diagonal<FullyLazyCoeffBaseProductType,Dynamic> diagonal(Index index) const$/;"	f	class:Eigen::ProductBase	access:public	signature:(Index index) const
diagonal	../include/Eigen/src/Core/ProductBase.h	/^    const Diagonal<FullyLazyCoeffBaseProductType,Index> diagonal() const$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
diagonal	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,0> diagonal() const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
diagonal	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,DiagonalIndex> diagonal() const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
diagonal	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,Dynamic> diagonal(Index index) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index index) const
diagonal	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    DiagonalReturnType diagonal() const;$/;"	p	class:Eigen::Tridiagonalization	access:public	signature:() const
diagonal	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::diagonal() const$/;"	f	class:Eigen::Tridiagonalization	signature:() const
diagonal	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline CwiseBinaryOp< internal::scalar_difference_op<Scalar>, const VectorType, const VectorType> diagonal() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
diagonal	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Diagonal<const SparseMatrix> diagonal() const { return *this; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
DiagonalIndexReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
DiagonalIntReturnType	../include/Eigen/src/Core/BandMatrix.h	/^    template<int Index> struct DiagonalIntReturnType {$/;"	s	class:Eigen::internal::BandMatrixBase	access:public
diagonalLength	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index diagonalLength(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase	access:protected	signature:(Index i) const
DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalMatrix$/;"	c	namespace:Eigen	inherits:DiagonalBase
DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    explicit inline DiagonalMatrix(const MatrixBase<OtherDerived>& other) : m_diagonal(other)$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const MatrixBase<OtherDerived>& other)
DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalBase<OtherDerived>& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalBase<OtherDerived>& other)
DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalMatrix& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalMatrix& other)
DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y, const Scalar& z) : m_diagonal(x,y,z) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z)
DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y) : m_diagonal(x,y) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const Scalar& x, const Scalar& y)
DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix() {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(Index dim) : m_diagonal(dim) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index dim)
DiagonalPreconditioner	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class DiagonalPreconditioner$/;"	c	namespace:Eigen
DiagonalPreconditioner	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner(const MatrixType& mat) : m_invdiag(mat.cols())$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatrixType& mat)
DiagonalPreconditioner	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner() : m_isInitialized(false) {}$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:()
DiagonalProduct	../include/Eigen/src/Core/DiagonalProduct.h	/^class DiagonalProduct : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,MatrixBase
DiagonalProduct	../include/Eigen/src/Core/DiagonalProduct.h	/^    inline DiagonalProduct(const MatrixType& matrix, const DiagonalType& diagonal)$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(const MatrixType& matrix, const DiagonalType& diagonal)
DiagonalReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef Diagonal<Derived> DiagonalReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
DiagonalReturnType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^            >::type DiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization	access:public
DiagonalSize	../include/Eigen/src/Core/BandMatrix.h	/^        DiagonalSize = (RowsAtCompileTime==Dynamic || ColsAtCompileTime==Dynamic)$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon80
diagonalSize	../include/Eigen/src/Core/MatrixBase.h	/^    inline Index diagonalSize() const { return (std::min)(rows(),cols()); }$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
DiagonalType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type DiagonalType;$/;"	t	class:Eigen::Tridiagonalization	access:public
DiagonalVectorType	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalWrapper	access:public
DiagonalVectorType	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits	access:public
DiagonalVectorType	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef Matrix<_Scalar,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1> DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits	access:public
DiagonalVectorType	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalBase	access:public
DiagonalVectorType	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalMatrix	access:public
DiagonalWrapper	../include/Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalWrapper$/;"	c	namespace:Eigen	inherits:DiagonalBase,internal::no_assignment_operator
DiagonalWrapper	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalWrapper(DiagonalVectorType& diagonal) : m_diagonal(diagonal) {}$/;"	f	class:Eigen::DiagonalWrapper	access:public	signature:(DiagonalVectorType& diagonal)
diagScaleMatrix	preprocess.cpp	/^abcd::diagScaleMatrix ( VECTOR_double drow, VECTOR_double dcol)$/;"	f	class:abcd
diagScaleRhs	preprocess.cpp	/^abcd::diagScaleRhs ( VECTOR_double &b)$/;"	f	class:abcd
DiagSizeAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^      DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon419
DiagVectorType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1> DiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
difference_type	../include/Eigen/src/Core/util/Memory.h	/^    typedef std::ptrdiff_t difference_type;$/;"	t	class:Eigen::aligned_allocator	access:public
difference_type	../include/Eigen/src/StlSupport/details.h	/^    typedef ptrdiff_t difference_type;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
dimensionOfKernel	../include/Eigen/src/LU/FullPivLU.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
dimensionOfKernel	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
dimensionOfKernel	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
dim	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline int dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size()-1 : AmbientDimAtCompileTime; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Dim	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon438
dim	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline int dim() const { return int(AmbientDimAtCompileTime)==Dynamic ? m_coeffs.size()-1 : int(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
dim	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline int dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Dim	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon436
Dim	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon437
Dim	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Scaling::__anon435
Dim	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon434
Dim	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon431
dim	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size()-1 : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Dim	../include/Eigen/src/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon392
dim	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_coeffs.size()-1 : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
dim	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  inline Index dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Dim	../include/Eigen/src/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon380
Dim	../include/Eigen/src/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon382
Dim	../include/Eigen/src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon383
Dim	../include/Eigen/src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon384
Dim	../include/Eigen/src/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon374
Dim	../include/Eigen/src/Geometry/Transform.h	/^    Dim = Transform::Dim,$/;"	e	enum:Eigen::internal::transform_traits::__anon373
Dim	../include/Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon377
Dim	../include/Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon378
Dim	../include/Eigen/src/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon370
dipair	../include/abcd.h	/^typedef std::pair<double,int> dipair;$/;"	t
DirectAccessBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int DirectAccessBit = 0x40;$/;"	m	namespace:Eigen
DirectAccessors	../include/Eigen/src/Core/util/Constants.h	/^  DirectAccessors, $/;"	e	enum:Eigen::AccessorLevels
direction	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
direction	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Direction	../include/Eigen/src/Geometry/Homogeneous.h	/^    enum { Direction = _Direction };$/;"	e	enum:Eigen::Homogeneous::__anon391
direction	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
direction	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
DirectionType	../include/Eigen/src/Core/util/Constants.h	/^enum DirectionType { $/;"	g	namespace:Eigen
DirectLinearAccessType	../include/Eigen/src/Core/util/BlasUtil.h	/^    >::type DirectLinearAccessType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
direct_selfadjoint_eigenvalues	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType,int Size,bool IsComplex> struct direct_selfadjoint_eigenvalues$/;"	s	namespace:Eigen::internal
direct_selfadjoint_eigenvalues	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,2,false>$/;"	s	namespace:Eigen::internal
direct_selfadjoint_eigenvalues	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,3,false>$/;"	s	namespace:Eigen::internal
DirectWriteAccessors	../include/Eigen/src/Core/util/Constants.h	/^  DirectWriteAccessors$/;"	e	enum:Eigen::AccessorLevels
distance	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  RealScalar distance(const VectorType& p) const { return ei_sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
distance	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  RealScalar distance(const VectorType& p) const { return internal::sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
distributePartitions	../include/abcd.h	/^    void distributePartitions();$/;"	p	class:abcd	access:private	signature:()
distributePartitions	../src/comms.cpp	/^void abcd::distributePartitions()$/;"	f	class:abcd	signature:()
distributeRhs	../include/abcd.h	/^    void distributeRhs();$/;"	p	class:abcd	access:private	signature:()
distributeRhs	../src/comms.cpp	/^void abcd::distributeRhs()$/;"	f	class:abcd	signature:()
dlaswp	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dlaswp)(int *, double *, int *, int *, int *, int *, int *);$/;"	p	signature:(int *, double *, int *, int *, int *, int *, int *)
dlauu2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dlauu2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
dlauum	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dlauum)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
dmax	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(dmax)  (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dmin	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(dmin)  (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dnorm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dnorm)(char *, int *, int *, double *, int *);$/;"	p	signature:(char *, int *, int *, double *, int *)
dnrm2	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(dnrm2) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
doComputeEigenvectors	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::doComputeEigenvectors(RealScalar matrixnorm)$/;"	f	class:Eigen::ComplexEigenSolver	signature:(RealScalar matrixnorm)
doComputeEigenvectors	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    void doComputeEigenvectors(RealScalar matrixnorm);$/;"	p	class:Eigen::ComplexEigenSolver	access:private	signature:(RealScalar matrixnorm)
doComputeEigenvectors	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    void doComputeEigenvectors();$/;"	p	class:Eigen::EigenSolver	access:private	signature:()
doComputeEigenvectors	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^void EigenSolver<MatrixType>::doComputeEigenvectors()$/;"	f	class:Eigen::EigenSolver	signature:()
DontAlignCols	../include/Eigen/src/Core/IO.h	/^enum { DontAlignCols = 1 };$/;"	e	enum:Eigen::__anon54
DontAlign	../include/Eigen/src/Core/util/Constants.h	/^  DontAlign = 0x2$/;"	e	enum:Eigen::__anon212
dot	../include/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
dot	../include/Eigen/src/Core/MatrixBase.h	/^    dot(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
dot	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> inline Scalar dot(const QuaternionBase<OtherDerived>& other) const { return coeffs().dot(other.coeffs()); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other) const
dot	../include/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
dot	../include/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived>& other) const
dot	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> Scalar dot(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
dot	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> Scalar dot(const SparseMatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other) const
dot_nocheck	../include/Eigen/src/Core/Dot.h	/^struct dot_nocheck$/;"	s	namespace:Eigen::internal
dot_nocheck	../include/Eigen/src/Core/Dot.h	/^struct dot_nocheck<T, U, true>$/;"	s	namespace:Eigen::internal
DoublePacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  struct DoublePacket$/;"	s	class:Eigen::internal::gebp_traits	access:public
dparm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Array<RealScalar,IPARM_SIZE,1>& dparm()$/;"	f	class:Eigen::PastixBase	access:public	signature:()
dparm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    double& dparm(int idxparam)$/;"	f	class:Eigen::PastixBase	access:public	signature:(int idxparam)
dpotf2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dpotf2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
dpotrf	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dpotrf)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
dpotri	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dpotri)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
drotg	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(drotg) (double *, double *, double *, double *);$/;"	p	signature:(double *, double *, double *, double *)
drot	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(drot)  (int *, double *, int *, double *, int *, double *, double *);$/;"	p	signature:(int *, double *, int *, double *, int *, double *, double *)
drotmg	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(drotmg)(double *, double *, double *, double *, double *);$/;"	p	signature:(double *, double *, double *, double *, double *)
drotm	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(drotm) (int *, double *, int *, double *, int *, double *);$/;"	p	signature:(int *, double *, int *, double *, int *, double *)
drow_	../include/abcd.h	/^    VectorXd drow_;$/;"	m	class:abcd	access:private
dsbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dsbmv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dscal	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(dscal) (int *,  double *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *)
dsdot	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(dsdot) (int *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, int *, float *, int *)
dspmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dspmv) (char *, int *, double  *, double *,$/;"	p	signature:(char *, int *, double *, double *, double *, int *, double *, double *, int *)
dspr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dspr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *)
dspr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dspr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *)
DST_CHAN	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	70;"	d
DST_CTRL	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	71;"	d
DstHasDirectAccess	../include/Eigen/src/Core/Assign.h	/^    DstHasDirectAccess = Derived::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon218
DstHasDirectAccess	../include/Eigen/src/Core/Assign_MKL.h	/^      DstHasDirectAccess = Dst::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
DstIsAligned	../include/Eigen/src/Core/Assign.h	/^    DstIsAligned = Derived::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon218
dswap	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(dswap) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
dsymm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dsymm)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dsymv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dsymv) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
dsyr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dsyr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, int *)
dsyr2k	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dsyr2k)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
dsyr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dsyr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *)
dsyrk	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dsyrk)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, double *, int *)
dtbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dtbmv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
dtbsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dtbsv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
dtpmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dtpmv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
dtpsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dtpsv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
dtrmm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dtrmm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
dtrmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dtrmv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
dtrsm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dtrsm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
dtrsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dtrsv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
dtrti2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dtrti2)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
dtrtri	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(dtrtri)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
dumpMemory	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(Stream& s)
dumpMemory	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(Stream& s)
dumpMemory	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(Stream& s)
Dynamic	../include/Eigen/src/Core/util/Constants.h	/^const int Dynamic = -1;$/;"	m	namespace:Eigen
dzamax	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(dzamax)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dzamin	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(dzamin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dzasum	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(dzasum)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dzmax	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(dzmax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dzmin	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(dzmin) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
dznrm2	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(dznrm2)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
ei_abs2	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_abs2(const T& x) { return internal::abs2(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_abs	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_abs (const T& x) { return internal::abs(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_aligned_delete	../include/Eigen/src/Eigen2Support/Memory.h	/^template<typename T> inline void ei_aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen	signature:(T *ptr, size_t size)
ei_aligned_free	../include/Eigen/src/Eigen2Support/Memory.h	/^inline void  ei_aligned_free(void *ptr) { internal::aligned_free(ptr); }$/;"	f	namespace:Eigen	signature:(void *ptr)
ei_aligned_malloc	../include/Eigen/src/Eigen2Support/Memory.h	/^inline void* ei_aligned_malloc(size_t size) { return internal::aligned_malloc(size); }$/;"	f	namespace:Eigen	signature:(size_t size)
ei_aligned_new	../include/Eigen/src/Eigen2Support/Memory.h	/^template<typename T> inline T* ei_aligned_new(size_t size)$/;"	f	namespace:Eigen	signature:(size_t size)
ei_aligned_realloc	../include/Eigen/src/Eigen2Support/Memory.h	/^inline void* ei_aligned_realloc(void *ptr, size_t new_size, size_t old_size) { return internal::aligned_realloc(ptr, new_size, old_size); }$/;"	f	namespace:Eigen	signature:(void *ptr, size_t new_size, size_t old_size)
ei_assert	../include/Eigen/src/Eigen2Support/Macros.h	28;"	d
ei_atan2	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_atan2(const T& x,const T& y) { return internal::atan2(x,y); }$/;"	f	namespace:Eigen	signature:(const T& x,const T& y)
ei_cleantype	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T>   { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T*>  { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T&>  { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T*>        { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T&>        { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype { typedef T type; };$/;"	s	namespace:Eigen
ei_conditional_aligned_free	../include/Eigen/src/Eigen2Support/Memory.h	/^template<bool Align> inline void ei_conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen	signature:(void *ptr)
ei_conditional_aligned_malloc	../include/Eigen/src/Eigen2Support/Memory.h	/^template<bool Align> inline void* ei_conditional_aligned_malloc(size_t size)$/;"	f	namespace:Eigen	signature:(size_t size)
ei_conditional_aligned_realloc	../include/Eigen/src/Eigen2Support/Memory.h	/^template<bool Align> inline void* ei_conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen	signature:(void* ptr, size_t new_size, size_t old_size)
ei_conj	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_conj(const T& x) { return internal::conj(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_cos	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_cos (const T& x) { return internal::cos(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_declare_aligned_stack_constructed_variable	../include/Eigen/src/Core/util/Memory.h	578;"	d
ei_exp	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_exp (const T& x) { return internal::exp(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
eigen2_dot	../include/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::eigen2_dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
eigen2_dot	../include/Eigen/src/Core/MatrixBase.h	/^      Scalar eigen2_dot(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
eigen2_dot	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar eigen2_dot(const Quaternion& other) const { return m_coeffs.eigen2_dot(other.m_coeffs); }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other) const
EIGEN2_GEOMETRY_MODULE_H	../include/Eigen/src/Eigen2Support/Geometry/All.h	2;"	d
EIGEN2_LEASTSQUARES_H	../include/Eigen/src/Eigen2Support/LeastSquares.h	26;"	d
EIGEN2_LU_H	../include/Eigen/src/Eigen2Support/LU.h	26;"	d
eigen2_lu	../include/Eigen/src/Core/MatrixBase.h	/^    const LU<PlainObject> eigen2_lu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
eigen2_lu	../include/Eigen/src/Eigen2Support/LU.h	/^MatrixBase<Derived>::eigen2_lu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
EIGEN2_MACROS_H	../include/Eigen/src/Eigen2Support/Macros.h	26;"	d
EIGEN2_MATH_FUNCTIONS_H	../include/Eigen/src/Eigen2Support/MathFunctions.h	26;"	d
EIGEN2_MEMORY_H	../include/Eigen/src/Eigen2Support/Memory.h	26;"	d
EIGEN2_META_H	../include/Eigen/src/Eigen2Support/Meta.h	26;"	d
eigen2_part_return_type	../include/Eigen/src/Core/TriangularMatrix.h	/^struct eigen2_part_return_type<MatrixType, SelfAdjoint>$/;"	s	namespace:Eigen::internal
eigen2_part_return_type	../include/Eigen/src/Core/TriangularMatrix.h	/^struct eigen2_part_return_type$/;"	s	namespace:Eigen::internal
eigen2_product_return_type	../include/Eigen/src/Core/TriangularMatrix.h	/^    struct eigen2_product_return_type$/;"	s	class:Eigen::TriangularView	access:public
EIGEN2_QR_H	../include/Eigen/src/Eigen2Support/QR.h	27;"	d
EIGEN2_SVD_H	../include/Eigen/src/Eigen2Support/SVD.h	26;"	d
EIGEN2_VECTORBLOCK_H	../include/Eigen/src/Eigen2Support/VectorBlock.h	27;"	d
Eigen::ABx_lx	../include/Eigen/src/Core/util/Constants.h	/^  ABx_lx              = 0x200,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::AccessorLevels	../include/Eigen/src/Core/util/Constants.h	/^enum AccessorLevels {$/;"	g	namespace:Eigen
_EIGEN_ACCUMULATE_PACKETS	../include/Eigen/src/Core/products/GeneralMatrixVector.h	287;"	d
_EIGEN_ACCUMULATE_PACKETS	../include/Eigen/src/Core/products/GeneralMatrixVector.h	335;"	d
_EIGEN_ACCUMULATE_PACKETS	../include/Eigen/src/Core/products/GeneralMatrixVector.h	555;"	d
_EIGEN_ACCUMULATE_PACKETS	../include/Eigen/src/Core/products/GeneralMatrixVector.h	80;"	d
Eigen::Action	../include/Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	g	namespace:Eigen
Eigen::ActualPacketAccessBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = 0x0;$/;"	m	namespace:Eigen
Eigen::ActualPacketAccessBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = PacketAccessBit;$/;"	m	namespace:Eigen
Eigen::Affine2d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Affine> Affine2d;$/;"	t	namespace:Eigen
Eigen::Affine2f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Affine> Affine2f;$/;"	t	namespace:Eigen
Eigen::Affine3d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Affine> Affine3d;$/;"	t	namespace:Eigen
Eigen::Affine3f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Affine> Affine3f;$/;"	t	namespace:Eigen
Eigen::AffineCompact2d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,AffineCompact> AffineCompact2d;$/;"	t	namespace:Eigen
Eigen::AffineCompact2f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,AffineCompact> AffineCompact2f;$/;"	t	namespace:Eigen
Eigen::AffineCompact3d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,AffineCompact> AffineCompact3d;$/;"	t	namespace:Eigen
Eigen::AffineCompact3f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,AffineCompact> AffineCompact3f;$/;"	t	namespace:Eigen
Eigen::AffineCompact	../include/Eigen/src/Core/util/Constants.h	/^  AffineCompact = 0x10 | Affine,$/;"	e	enum:Eigen::TransformTraits
Eigen::Affine	../include/Eigen/src/Core/util/Constants.h	/^  Affine        = 0x2,$/;"	e	enum:Eigen::TransformTraits
EIGEN_ALIGN_128	../include/Eigen/src/Eigen2Support/Macros.h	31;"	d
EIGEN_ALIGN16	../include/Eigen/src/Core/util/Macros.h	282;"	d
EIGEN_ALIGNED_ALLOCA	../include/Eigen/src/Core/util/Memory.h	573;"	d
Eigen::aligned_allocator::address	../include/Eigen/src/Core/util/Memory.h	/^    const_pointer address( const_reference value ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( const_reference value ) const
Eigen::aligned_allocator::address	../include/Eigen/src/Core/util/Memory.h	/^    pointer address( reference value ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( reference value ) const
Eigen::aligned_allocator::aligned_allocator	../include/Eigen/src/Core/util/Memory.h	/^    aligned_allocator( const aligned_allocator& )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( const aligned_allocator& )
Eigen::aligned_allocator::aligned_allocator	../include/Eigen/src/Core/util/Memory.h	/^    aligned_allocator( const aligned_allocator<U>& )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( const aligned_allocator<U>& )
Eigen::aligned_allocator::~aligned_allocator	../include/Eigen/src/Core/util/Memory.h	/^    ~aligned_allocator()$/;"	f	class:Eigen::aligned_allocator	access:public	signature:()
Eigen::aligned_allocator::aligned_allocator	../include/Eigen/src/Core/util/Memory.h	/^    aligned_allocator()$/;"	f	class:Eigen::aligned_allocator	access:public	signature:()
Eigen::aligned_allocator::allocate	../include/Eigen/src/Core/util/Memory.h	/^    pointer allocate( size_type num, const void* hint = 0 )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( size_type num, const void* hint = 0 )
Eigen::aligned_allocator::const_pointer	../include/Eigen/src/Core/util/Memory.h	/^    typedef const T*  const_pointer;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::const_reference	../include/Eigen/src/Core/util/Memory.h	/^    typedef const T&  const_reference;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::construct	../include/Eigen/src/Core/util/Memory.h	/^    void  construct(pointer p, Args&&... args)$/;"	f	class:Eigen::aligned_allocator	access:public	signature:(pointer p, Args&&... args)
Eigen::aligned_allocator::construct	../include/Eigen/src/Core/util/Memory.h	/^    void construct( pointer p, const T& value )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( pointer p, const T& value )
Eigen::aligned_allocator::deallocate	../include/Eigen/src/Core/util/Memory.h	/^    void deallocate( pointer p, size_type \/*num*\/ )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( pointer p, size_type )
Eigen::aligned_allocator::destroy	../include/Eigen/src/Core/util/Memory.h	/^    void destroy( pointer p )$/;"	f	class:Eigen::aligned_allocator	access:public	signature:( pointer p )
Eigen::aligned_allocator::difference_type	../include/Eigen/src/Core/util/Memory.h	/^    typedef std::ptrdiff_t difference_type;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator	../include/Eigen/src/Core/util/Memory.h	/^class aligned_allocator$/;"	c	namespace:Eigen
EIGEN_ALIGNED_ALLOCATOR	../include/Eigen/src/StlSupport/details.h	30;"	d
Eigen::aligned_allocator_indirection::aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection& ) : EIGEN_ALIGNED_ALLOCATOR<T>() {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const aligned_allocator_indirection& )
Eigen::aligned_allocator_indirection::aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const aligned_allocator_indirection<U>& )
Eigen::aligned_allocator_indirection::aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<T>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const EIGEN_ALIGNED_ALLOCATOR<T>& )
Eigen::aligned_allocator_indirection::aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:(const EIGEN_ALIGNED_ALLOCATOR<U>& )
Eigen::aligned_allocator_indirection::~aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^    ~aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:()
Eigen::aligned_allocator_indirection::aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection	access:public	signature:()
Eigen::aligned_allocator_indirection::const_pointer	../include/Eigen/src/StlSupport/details.h	/^    typedef const T*  const_pointer;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::const_reference	../include/Eigen/src/StlSupport/details.h	/^    typedef const T&  const_reference;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::difference_type	../include/Eigen/src/StlSupport/details.h	/^    typedef ptrdiff_t difference_type;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection	../include/Eigen/src/StlSupport/details.h	/^  class aligned_allocator_indirection : public EIGEN_ALIGNED_ALLOCATOR<T>$/;"	c	namespace:Eigen	inherits:EIGEN_ALIGNED_ALLOCATOR
Eigen::aligned_allocator_indirection::pointer	../include/Eigen/src/StlSupport/details.h	/^    typedef T*        pointer;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::rebind	../include/Eigen/src/StlSupport/details.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::rebind::other	../include/Eigen/src/StlSupport/details.h	/^      typedef aligned_allocator_indirection<U> other;$/;"	t	struct:Eigen::aligned_allocator_indirection::rebind	access:public
Eigen::aligned_allocator_indirection::reference	../include/Eigen/src/StlSupport/details.h	/^    typedef T&        reference;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::size_type	../include/Eigen/src/StlSupport/details.h	/^    typedef size_t    size_type;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator_indirection::value_type	../include/Eigen/src/StlSupport/details.h	/^    typedef T         value_type;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
Eigen::aligned_allocator::max_size	../include/Eigen/src/Core/util/Memory.h	/^    size_type max_size() const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:() const
Eigen::aligned_allocator::operator ==	../include/Eigen/src/Core/util/Memory.h	/^    bool operator==(const aligned_allocator<T>& ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:(const aligned_allocator<T>& ) const
Eigen::aligned_allocator::operator !=	../include/Eigen/src/Core/util/Memory.h	/^    bool operator!=(const aligned_allocator<T>& ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:(const aligned_allocator<T>& ) const
Eigen::aligned_allocator::pointer	../include/Eigen/src/Core/util/Memory.h	/^    typedef T*        pointer;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::rebind	../include/Eigen/src/Core/util/Memory.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::rebind::other	../include/Eigen/src/Core/util/Memory.h	/^        typedef aligned_allocator<U> other;$/;"	t	struct:Eigen::aligned_allocator::rebind	access:public
Eigen::aligned_allocator::reference	../include/Eigen/src/Core/util/Memory.h	/^    typedef T&        reference;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::size_type	../include/Eigen/src/Core/util/Memory.h	/^    typedef size_t    size_type;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::aligned_allocator::value_type	../include/Eigen/src/Core/util/Memory.h	/^    typedef T         value_type;$/;"	t	class:Eigen::aligned_allocator	access:public
Eigen::AlignedBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int AlignedBit = 0x80;$/;"	m	namespace:Eigen
Eigen::AlignedBox::~AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox(const VectorType& _min, const VectorType& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& _min, const VectorType& _max)
Eigen::AlignedBox::AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)
Eigen::AlignedBox::AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const VectorType& p) : m_min(p), m_max(p) {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p)
Eigen::AlignedBox::AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(int _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(int _dim)
Eigen::AlignedBox::~AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^  ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox(const OtherVectorType1& _min, const OtherVectorType2& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const OtherVectorType1& _min, const OtherVectorType2& _max)
Eigen::AlignedBox::AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)
Eigen::AlignedBox::AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const MatrixBase<Derived>& a_p)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& a_p)
Eigen::AlignedBox::AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(Index _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(Index _dim)
Eigen::AlignedBox::AmbientDimAtCompileTime	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon432
Eigen::AlignedBox::AmbientDimAtCompileTime	../include/Eigen/src/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon371
Eigen::AlignedBox::BottomLeftCeil	../include/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::BottomLeftFloor	../include/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::BottomLeft	../include/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::BottomRightCeil	../include/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::BottomRightFloor	../include/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::BottomRight	../include/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::cast	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::cast	../include/Eigen/src/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::center	../include/Eigen/src/Geometry/AlignedBox.h	/^  center() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::clamp	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
Eigen::AlignedBox::clamp	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
Eigen::AlignedBox::contains	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::contains	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool contains(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p) const
Eigen::AlignedBox::contains	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::contains	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline bool contains(const MatrixBase<Derived>& a_p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& a_p) const
Eigen::AlignedBox::corner	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType corner(CornerType corner) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(CornerType corner) const
Eigen::AlignedBox::CornerType	../include/Eigen/src/Geometry/AlignedBox.h	/^  enum CornerType$/;"	g	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::diagonal	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline CwiseBinaryOp< internal::scalar_difference_op<Scalar>, const VectorType, const VectorType> diagonal() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::dim	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline int dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size()-1 : AmbientDimAtCompileTime; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::dim	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size()-1 : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::extend	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
Eigen::AlignedBox::extend	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const VectorType& p)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p)
Eigen::AlignedBox::extend	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
Eigen::AlignedBox::extend	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const MatrixBase<Derived>& a_p)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& a_p)
Eigen::AlignedBox::exteriorDistance	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline Scalar exteriorDistance(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p) const
Eigen::AlignedBox::exteriorDistance	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline NonInteger exteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::exteriorDistance	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline NonInteger exteriorDistance(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& p) const
EIGEN_ALIGNEDBOX_H	../include/Eigen/src/Geometry/AlignedBox.h	26;"	d
Eigen::AlignedBox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
Eigen::AlignedBox	../include/Eigen/src/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
Eigen::AlignedBox::Index	../include/Eigen/src/Geometry/AlignedBox.h	/^  typedef DenseIndex                                Index;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::intersection	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox intersection(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::isApprox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  bool isApprox(const AlignedBox& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::AlignedBox::isApprox	../include/Eigen/src/Geometry/AlignedBox.h	/^  bool isApprox(const AlignedBox& other, RealScalar prec = ScalarTraits::dummy_precision()) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& other, RealScalar prec = ScalarTraits::dummy_precision()) const
Eigen::AlignedBox::isEmpty	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline bool isEmpty() const { return (m_min.array() > m_max.array()).any(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::isNull	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool isNull() const { return (m_min.cwise() > m_max).any(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::isNull	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline bool isNull() const { return isEmpty(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::max	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::max	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::max	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::max	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::Max	../include/Eigen/src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::merged	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox merged(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::min	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::min	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::min	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::min	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::Min	../include/Eigen/src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::m_max	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
Eigen::AlignedBox::m_max	../include/Eigen/src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
Eigen::AlignedBox::m_min	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
Eigen::AlignedBox::m_min	../include/Eigen/src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
Eigen::AlignedBox::NonInteger	../include/Eigen/src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::NonInteger      NonInteger;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::RealScalar	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::RealScalar	../include/Eigen/src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::Real               RealScalar;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::sample	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType sample() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::Scalar	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::Scalar	../include/Eigen/src/Geometry/AlignedBox.h	/^  typedef _Scalar                                   Scalar;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::ScalarTraits	../include/Eigen/src/Geometry/AlignedBox.h	/^  typedef NumTraits<Scalar>                         ScalarTraits;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::setEmpty	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline void setEmpty()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::setNull	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline void setNull()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::setNull	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline void setNull() { setEmpty(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Eigen::AlignedBox::sizes	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline const CwiseBinaryOp< internal::scalar_difference_op<Scalar>, const VectorType, const VectorType> sizes() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::AlignedBox::squaredExteriorDistance	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbiantDim>::squaredExteriorDistance(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox	signature:(const VectorType& p) const
Eigen::AlignedBox::squaredExteriorDistance	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline Scalar squaredExteriorDistance(const VectorType& p) const;$/;"	p	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p) const
Eigen::AlignedBox::squaredExteriorDistance	../include/Eigen/src/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	signature:(const AlignedBox& b) const
Eigen::AlignedBox::squaredExteriorDistance	../include/Eigen/src/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const MatrixBase<Derived>& a_p) const$/;"	f	class:Eigen::AlignedBox	signature:(const MatrixBase<Derived>& a_p) const
Eigen::AlignedBox::squaredExteriorDistance	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline Scalar squaredExteriorDistance(const AlignedBox& b) const;$/;"	p	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
Eigen::AlignedBox::squaredExteriorDistance	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline Scalar squaredExteriorDistance(const MatrixBase<Derived>& a_p) const;$/;"	p	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& a_p) const
Eigen::AlignedBox::TopLeftCeil	../include/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::TopLeftFloor	../include/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::TopLeft	../include/Eigen/src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::TopRightCeil	../include/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::TopRightFloor	../include/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::TopRight	../include/Eigen/src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
Eigen::AlignedBox::translate	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& translate(const VectorType& t)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& t)
Eigen::AlignedBox::translate	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& translate(const MatrixBase<Derived>& a_t)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& a_t)
Eigen::AlignedBox::VectorType	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::VectorType	../include/Eigen/src/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1>  VectorType;$/;"	t	class:Eigen::AlignedBox	access:public
Eigen::AlignedBox::volume	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline Scalar volume() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Eigen::Aligned	../include/Eigen/src/Core/util/Constants.h	/^  Aligned=1 $/;"	e	enum:Eigen::__anon208
Eigen::AlignedScaling2d	../include/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,2> AlignedScaling2d;$/;"	t	namespace:Eigen
Eigen::AlignedScaling2f	../include/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 2> AlignedScaling2f;$/;"	t	namespace:Eigen
Eigen::AlignedScaling3d	../include/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,3> AlignedScaling3d;$/;"	t	namespace:Eigen
Eigen::AlignedScaling3f	../include/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 3> AlignedScaling3f;$/;"	t	namespace:Eigen
EIGEN_ALIGN	../include/Eigen/src/Core/util/Macros.h	88;"	d
EIGEN_ALIGN	../include/Eigen/src/Core/util/Macros.h	90;"	d
EIGEN_ALIGN_STATICALLY	../include/Eigen/src/Core/util/Macros.h	96;"	d
EIGEN_ALIGN_STATICALLY	../include/Eigen/src/Core/util/Macros.h	98;"	d
EIGEN_ALIGN_TO_BOUNDARY	../include/Eigen/src/Core/util/Macros.h	272;"	d
EIGEN_ALLANDANY_H	../include/Eigen/src/Core/BooleanRedux.h	26;"	d
EIGEN_ALLOCA	../include/Eigen/src/Core/util/Memory.h	517;"	d
EIGEN_ALLOCA	../include/Eigen/src/Core/util/Memory.h	519;"	d
EIGEN_ALWAYS_INLINE	../include/Eigen/src/Core/util/Macros.h	156;"	d
EIGEN_ALWAYS_INLINE	../include/Eigen/src/Core/util/Macros.h	158;"	d
EIGEN_AMBIVECTOR_H	../include/Eigen/src/SparseCore/AmbiVector.h	26;"	d
Eigen::AngleAxis::AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis() {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline AngleAxis(const QuaternionType& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& q)
Eigen::AngleAxis::AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline AngleAxis(Scalar angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:(Scalar angle, const MatrixBase<Derived>& axis)
Eigen::AngleAxis::AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis<OtherScalarType>& other)
Eigen::AngleAxis::AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::AngleAxis::AngleAxis	../include/Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis() {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::AngleAxis	../include/Eigen/src/Geometry/AngleAxis.h	/^  inline AngleAxis(Scalar angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis	access:public	signature:(Scalar angle, const MatrixBase<Derived>& axis)
Eigen::AngleAxis::AngleAxis	../include/Eigen/src/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis<OtherScalarType>& other)
Eigen::AngleAxis::AngleAxis	../include/Eigen/src/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::AngleAxis::AngleAxis	../include/Eigen/src/Geometry/AngleAxis.h	/^  template<typename QuatDerived> inline explicit AngleAxis(const QuaternionBase<QuatDerived>& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionBase<QuatDerived>& q)
Eigen::AngleAxis::angle	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::angle	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::angle	../include/Eigen/src/Geometry/AngleAxis.h	/^  Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::angle	../include/Eigen/src/Geometry/AngleAxis.h	/^  Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::axis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::axis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::axis	../include/Eigen/src/Geometry/AngleAxis.h	/^  const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::axis	../include/Eigen/src/Geometry/AngleAxis.h	/^  Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis::Base	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis	access:private
Eigen::AngleAxis::Base	../include/Eigen/src/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis	access:private
Eigen::AngleAxis::cast	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::cast	../include/Eigen/src/Geometry/AngleAxis.h	/^  inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::Dim	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon438
Eigen::AngleAxis::Dim	../include/Eigen/src/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon392
Eigen::AngleAxisd	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
Eigen::AngleAxisd	../include/Eigen/src/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
Eigen::AngleAxisf	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
Eigen::AngleAxisf	../include/Eigen/src/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
Eigen::AngleAxis::fromRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::AngleAxis::fromRotationMatrix	../include/Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::AngleAxis::fromRotationMatrix	../include/Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis	signature:(const MatrixBase<Derived>& mat)
EIGEN_ANGLEAXIS_H	../include/Eigen/src/Geometry/AngleAxis.h	26;"	d
Eigen::AngleAxis::Identity	../include/Eigen/src/Geometry/AngleAxis.h	/^  static inline const AngleAxis Identity() { return AngleAxis(0, Vector3::UnitX()); }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Eigen::AngleAxis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen	inherits:RotationBase
Eigen::AngleAxis	../include/Eigen/src/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen	inherits:RotationBase
Eigen::AngleAxis::inverse	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::inverse	../include/Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
Eigen::AngleAxis::isApprox	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  bool isApprox(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::AngleAxis::isApprox	../include/Eigen/src/Geometry/AngleAxis.h	/^  bool isApprox(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::AngleAxis::m_angle	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis	access:protected
Eigen::AngleAxis::m_angle	../include/Eigen/src/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis	access:protected
Eigen::AngleAxis::Matrix3	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::Matrix3	../include/Eigen/src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::m_axis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis	access:protected
Eigen::AngleAxis::m_axis	../include/Eigen/src/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis	access:protected
Eigen::AngleAxis::operator =	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::AngleAxis::operator =	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const QuaternionType& q);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& q)
Eigen::AngleAxis::operator =	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis	signature:(const MatrixBase<Derived>& mat)
Eigen::AngleAxis::operator =	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionType& q)$/;"	f	class:Eigen::AngleAxis	signature:(const QuaternionType& q)
Eigen::AngleAxis::operator *	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  friend inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis	access:friend	signature:(const QuaternionType& a, const AngleAxis& b)
Eigen::AngleAxis::operator *	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline friend Matrix3 operator* (const Matrix3& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis	access:friend	signature:(const Matrix3& a, const AngleAxis& b)
Eigen::AngleAxis::operator *	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline Matrix3 operator* (const Matrix3& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const Matrix3& other) const
Eigen::AngleAxis::operator *	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other) const
Eigen::AngleAxis::operator *	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& other) const
Eigen::AngleAxis::operator *	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline Vector3 operator* (const Vector3& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const Vector3& other) const
Eigen::AngleAxis::operator =	../include/Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::AngleAxis::operator =	../include/Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const QuaternionBase<QuatDerived>& q);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const QuaternionBase<QuatDerived>& q)
Eigen::AngleAxis::operator =	../include/Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis	signature:(const MatrixBase<Derived>& mat)
Eigen::AngleAxis::operator =	../include/Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionBase<QuatDerived>& q)$/;"	f	class:Eigen::AngleAxis	signature:(const QuaternionBase<QuatDerived>& q)
Eigen::AngleAxis::operator *	../include/Eigen/src/Geometry/AngleAxis.h	/^  friend inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis	access:friend	signature:(const QuaternionType& a, const AngleAxis& b)
Eigen::AngleAxis::operator *	../include/Eigen/src/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other) const
Eigen::AngleAxis::operator *	../include/Eigen/src/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& other) const
Eigen::AngleAxis::QuaternionType	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::QuaternionType	../include/Eigen/src/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::Scalar	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::Scalar	../include/Eigen/src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis	signature:(void) const
Eigen::AngleAxis::toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Matrix3 toRotationMatrix(void) const;$/;"	p	class:Eigen::AngleAxis	access:public	signature:(void) const
Eigen::AngleAxis::toRotationMatrix	../include/Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis	signature:(void) const
Eigen::AngleAxis::toRotationMatrix	../include/Eigen/src/Geometry/AngleAxis.h	/^  Matrix3 toRotationMatrix(void) const;$/;"	p	class:Eigen::AngleAxis	access:public	signature:(void) const
Eigen::AngleAxis::Vector3	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis	access:public
Eigen::AngleAxis::Vector3	../include/Eigen/src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis	access:public
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	42;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	../include/Eigen/src/Core/arch/Default/Settings.h	61;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	../include/Eigen/src/Core/arch/NEON/PacketMath.h	41;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	../include/Eigen/src/Core/arch/SSE/PacketMath.h	37;"	d
Eigen::Architecture::AltiVec	../include/Eigen/src/Core/util/Constants.h	/^    AltiVec = 0x2,$/;"	e	enum:Eigen::Architecture::Type
Eigen::Architecture::Generic	../include/Eigen/src/Core/util/Constants.h	/^    Generic = 0x0,$/;"	e	enum:Eigen::Architecture::Type
Eigen::Architecture	../include/Eigen/src/Core/util/Constants.h	/^namespace Architecture$/;"	n	namespace:Eigen
Eigen::Architecture::SSE	../include/Eigen/src/Core/util/Constants.h	/^    SSE = 0x1,$/;"	e	enum:Eigen::Architecture::Type
Eigen::Architecture::Target	../include/Eigen/src/Core/util/Constants.h	/^    Target = SSE$/;"	e	enum:Eigen::Architecture::Type
Eigen::Architecture::Type	../include/Eigen/src/Core/util/Constants.h	/^  enum Type {$/;"	g	namespace:Eigen::Architecture
EIGEN_ARCH_WANTS_ALIGNMENT	../include/Eigen/src/Eigen2Support/Macros.h	33;"	d
EIGEN_ARCH_WANTS_STACK_ALIGNMENT	../include/Eigen/src/Core/util/Macros.h	79;"	d
EIGEN_ARCH_WANTS_STACK_ALIGNMENT	../include/Eigen/src/Core/util/Macros.h	81;"	d
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    Array(const Scalar& x, const Scalar& y);$/;"	p	class:Eigen::Array	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    Array(Index rows, Index cols);$/;"	p	class:Eigen::Array	access:public	signature:(Index rows, Index cols)
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    Array(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Array	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::Array	access:public	signature:(const ArrayBase<OtherDerived>& other)
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Array& other)$/;"	f	class:Eigen::Array	access:public	signature:(const Array& other)
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Array	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)$/;"	f	class:Eigen::Array	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& x, const Scalar& y, const Scalar& z)$/;"	f	class:Eigen::Array	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z)
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const T0& x, const T1& y)$/;"	f	class:Eigen::Array	access:public	signature:(const T0& x, const T1& y)
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE explicit Array() : Base()$/;"	f	class:Eigen::Array	access:public	signature:()
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE explicit Array(Index dim)$/;"	f	class:Eigen::Array	access:public	signature:(Index dim)
Eigen::Array::Array	../include/Eigen/src/Core/Array.h	/^    explicit Array(const Scalar *data);$/;"	p	class:Eigen::Array	access:public	signature:(const Scalar *data)
Eigen::Array::Array	../include/Eigen/src/Core/Map.h	/^  ::Array(const Scalar *data)$/;"	f	class:Eigen::Array	signature:(const Scalar *data)
Eigen::ArrayBase::ArrayBase	../include/Eigen/src/Core/ArrayBase.h	/^    ArrayBase() : Base() {}$/;"	f	class:Eigen::ArrayBase	access:protected	signature:()
Eigen::ArrayBase::ArrayBase	../include/Eigen/src/Core/ArrayBase.h	/^    ArrayBase(Index,Index);$/;"	p	class:Eigen::ArrayBase	access:private	signature:(Index,Index)
Eigen::ArrayBase::ArrayBase	../include/Eigen/src/Core/ArrayBase.h	/^    explicit ArrayBase(Index);$/;"	p	class:Eigen::ArrayBase	access:private	signature:(Index)
Eigen::ArrayBase::ArrayBase	../include/Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> explicit ArrayBase(const ArrayBase<OtherDerived>&);$/;"	p	class:Eigen::ArrayBase	access:private	signature:(const ArrayBase<OtherDerived>&)
Eigen::ArrayBase::array	../include/Eigen/src/Core/ArrayBase.h	/^    ArrayBase<Derived>& array() { return *this; }$/;"	f	class:Eigen::ArrayBase	access:public	signature:()
Eigen::ArrayBase::array	../include/Eigen/src/Core/ArrayBase.h	/^    const ArrayBase<Derived>& array() const { return *this; }$/;"	f	class:Eigen::ArrayBase	access:public	signature:() const
Eigen::ArrayBase::Base	../include/Eigen/src/Core/ArrayBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::CoeffReturnType	../include/Eigen/src/Core/ArrayBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::ConstantReturnType	../include/Eigen/src/Core/ArrayBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl	../include/Eigen/src/Core/ArrayBase.h	/^    typedef ArrayBase Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl;$/;"	t	class:Eigen::ArrayBase	access:public
EIGEN_ARRAYBASE_H	../include/Eigen/src/Core/ArrayBase.h	26;"	d
Eigen::ArrayBase	../include/Eigen/src/Core/ArrayBase.h	/^template<typename Derived> class ArrayBase$/;"	c	namespace:Eigen	inherits:DenseBase
Eigen::Array::Base	../include/Eigen/src/Core/Array.h	/^    typedef PlainObjectBase<Array> Base;$/;"	t	class:Eigen::Array	access:public
Eigen::ArrayBase::Index	../include/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::matrix	../include/Eigen/src/Core/ArrayBase.h	/^    const MatrixWrapper<const Derived> matrix() const { return derived(); }$/;"	f	class:Eigen::ArrayBase	access:public	signature:() const
Eigen::ArrayBase::matrix	../include/Eigen/src/Core/ArrayBase.h	/^    MatrixWrapper<Derived> matrix() { return derived(); }$/;"	f	class:Eigen::ArrayBase	access:public	signature:()
Eigen::ArrayBase::operator -=	../include/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator-=(const ArrayBase<OtherDerived> &other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived> &other)
Eigen::ArrayBase::operator /=	../include/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator\/=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator *=	../include/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator*=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator +=	../include/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator+=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator -=	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator-=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator /=	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator\/=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator *=	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator*=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator +=	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator+=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
Eigen::ArrayBase::operator =	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator=(const ArrayBase& other)$/;"	f	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase& other)
Eigen::ArrayBase::operator -=	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator-=(const Scalar& scalar)$/;"	f	class:Eigen::ArrayBase	access:public	signature:(const Scalar& scalar)
Eigen::ArrayBase::operator +=	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator+=(const Scalar& scalar)$/;"	f	class:Eigen::ArrayBase	access:public	signature:(const Scalar& scalar)
Eigen::ArrayBase::operator -=	../include/Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator-=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase	access:protected	signature:(const MatrixBase<OtherDerived>& )
Eigen::ArrayBase::operator +=	../include/Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator+=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase	access:protected	signature:(const MatrixBase<OtherDerived>& )
Eigen::ArrayBase::PacketScalar	../include/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::PlainObject	../include/Eigen/src/Core/ArrayBase.h	/^          > PlainObject;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::RealScalar	../include/Eigen/src/Core/ArrayBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::Scalar	../include/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::StorageBaseType	../include/Eigen/src/Core/ArrayBase.h	/^    typedef ArrayBase StorageBaseType;$/;"	t	class:Eigen::ArrayBase	access:public
Eigen::ArrayBase::StorageKind	../include/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::ArrayBase	access:public
EIGEN_ARRAY_CWISE_OPERATORS_H	../include/Eigen/src/Eigen2Support/CwiseOperators.h	26;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_EIGEN_UNARY	../include/Eigen/src/Core/GlobalFunctions.h	36;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_STD_UNARY	../include/Eigen/src/Core/GlobalFunctions.h	29;"	d
EIGEN_ARRAY_H	../include/Eigen/src/Core/Array.h	26;"	d
Eigen::Array	../include/Eigen/src/Core/Array.h	/^class Array$/;"	c	namespace:Eigen	inherits:PlainObjectBase
Eigen::Array::innerStride	../include/Eigen/src/Core/Array.h	/^    inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Array	access:public	signature:() const
Eigen::Array::operator =	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::Array	access:public	signature:(const ArrayBase<OtherDerived>& other)
Eigen::Array::operator =	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const Array& other)$/;"	f	class:Eigen::Array	access:public	signature:(const Array& other)
Eigen::Array::operator =	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::Array::Options	../include/Eigen/src/Core/Array.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Array::__anon278
Eigen::Array::outerStride	../include/Eigen/src/Core/Array.h	/^    inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Array	access:public	signature:() const
Eigen::Array::PlainObject	../include/Eigen/src/Core/Array.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Array	access:public
Eigen::Array::swap	../include/Eigen/src/Core/Array.h	/^    void swap(ArrayBase<OtherDerived> const & other)$/;"	f	class:Eigen::Array	access:public	signature:(ArrayBase<OtherDerived> const & other)
Eigen::ArrayWrapper::ArrayWrapper	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline ArrayWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(ExpressionType& matrix)
Eigen::ArrayWrapper::Base	../include/Eigen/src/Core/ArrayWrapper.h	/^    typedef ArrayBase<ArrayWrapper> Base;$/;"	t	class:Eigen::ArrayWrapper	access:public
Eigen::ArrayWrapper::coeff	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index) const
Eigen::ArrayWrapper::coeff	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index row, Index col) const
Eigen::ArrayWrapper::coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index) const
Eigen::ArrayWrapper::coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index row, Index col) const
Eigen::ArrayWrapper::coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index)
Eigen::ArrayWrapper::coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index row, Index col)
Eigen::ArrayWrapper::cols	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
Eigen::ArrayWrapper::data	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
Eigen::ArrayWrapper::data	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:()
Eigen::ArrayWrapper::evalTo	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline void evalTo(Dest& dst) const { dst = m_expression; }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Dest& dst) const
EIGEN_ARRAYWRAPPER_H	../include/Eigen/src/Core/ArrayWrapper.h	26;"	d
Eigen::ArrayWrapper	../include/Eigen/src/Core/ArrayWrapper.h	/^class ArrayWrapper : public ArrayBase<ArrayWrapper<ExpressionType> >$/;"	c	namespace:Eigen	inherits:ArrayBase
Eigen::ArrayWrapper::innerStride	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
Eigen::ArrayWrapper::m_expression	../include/Eigen/src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::ArrayWrapper	access:protected
Eigen::ArrayWrapper::nestedExpression	../include/Eigen/src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
Eigen::ArrayWrapper::NestedExpressionType	../include/Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;$/;"	t	class:Eigen::ArrayWrapper	access:public
Eigen::ArrayWrapper::outerStride	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
Eigen::ArrayWrapper::packet	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index) const
Eigen::ArrayWrapper::packet	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index row, Index col) const
Eigen::ArrayWrapper::rows	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
Eigen::ArrayWrapper::ScalarWithConstIfNotLvalue	../include/Eigen/src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::ArrayWrapper	access:public
Eigen::ArrayWrapper::writePacket	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index, const PacketScalar& x)
Eigen::ArrayWrapper::writePacket	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index row, Index col, const PacketScalar& x)
Eigen::ArrayXpr	../include/Eigen/src/Core/util/Constants.h	/^struct ArrayXpr {};$/;"	s	namespace:Eigen
EIGEN_ASM_COMMENT	../include/Eigen/src/Core/util/Macros.h	259;"	d
eigen_assert	../include/Eigen/src/Core/util/Macros.h	222;"	d
EIGEN_ASSIGN_H	../include/Eigen/src/Core/Assign.h	28;"	d
EIGEN_ASSIGN_VML_H	../include/Eigen/src/Core/Assign_MKL.h	34;"	d
Eigen::AutoAlign	../include/Eigen/src/Core/util/Constants.h	/^  AutoAlign = 0,$/;"	e	enum:Eigen::__anon212
EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS	../include/Eigen/src/Core/arch/SSE/PacketMath.h	248;"	d
EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS	../include/Eigen/src/Core/arch/SSE/PacketMath.h	251;"	d
EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS	../include/Eigen/src/Core/arch/SSE/PacketMath.h	253;"	d
Eigen::Ax_lBx	../include/Eigen/src/Core/util/Constants.h	/^  Ax_lBx              = 0x100,$/;"	e	enum:Eigen::DecompositionOptions
EIGEN_BANDMATRIX_H	../include/Eigen/src/Core/BandMatrix.h	26;"	d
Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl	../include/Eigen/src/Core/ArrayBase.h	/^    typedef ArrayBase Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl;$/;"	t	class:Eigen::ArrayBase	access:public
EigenBase	../include/Eigen/src/Core/EigenBase.h	/^template<typename Derived> struct EigenBase$/;"	s	namespace:Eigen
EIGEN_BASIC_PRECONDITIONERS_H	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	26;"	d
Eigen::BAx_lx	../include/Eigen/src/Core/util/Constants.h	/^  BAx_lx              = 0x400,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::BiCGSTAB::Base	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef IterativeSolverBase<BiCGSTAB> Base;$/;"	t	class:Eigen::BiCGSTAB	access:private
Eigen::BiCGSTAB::BiCGSTAB	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  BiCGSTAB() : Base() {}$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:()
Eigen::BiCGSTAB::BiCGSTAB	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  BiCGSTAB(const MatrixType& A) : Base(A) {}$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const MatrixType& A)
Eigen::BiCGSTAB::~BiCGSTAB	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  ~BiCGSTAB() {}$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:()
EIGEN_BICGSTAB_H	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	27;"	d
Eigen::BiCGSTAB	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^class BiCGSTAB : public IterativeSolverBase<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen	inherits:IterativeSolverBase
Eigen::BiCGSTAB::Index	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::BiCGSTAB	access:public
Eigen::BiCGSTAB::MatrixType	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::BiCGSTAB	access:public
Eigen::BiCGSTAB::Preconditioner	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::BiCGSTAB	access:public
Eigen::BiCGSTAB::RealScalar	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::BiCGSTAB	access:public
Eigen::BiCGSTAB::Scalar	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::BiCGSTAB	access:public
Eigen::BiCGSTAB::_solve	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const Rhs& b, Dest& x) const
Eigen::BiCGSTAB::solveWithGuess	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const MatrixBase<Rhs>& b, const Guess& x0) const
Eigen::BiCGSTAB::_solveWithGuess	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const Rhs& b, Dest& x) const
EIGEN_BIDIAGONALIZATION_H	../include/Eigen/src/SVD/UpperBidiagonalization.h	26;"	d
EIGEN_BLASUTIL_H	../include/Eigen/src/Core/util/BlasUtil.h	26;"	d
EIGEN_BLOCK2_H	../include/Eigen/src/Eigen2Support/Block.h	27;"	d
Eigen::Block::Base	../include/Eigen/src/Core/Block.h	/^    typedef MapBase<Block> Base;$/;"	t	class:Eigen::Block	access:public
Eigen::Block::Base	../include/Eigen/src/Core/Block.h	/^    typedef typename internal::dense_xpr_base<Block>::type Base;$/;"	t	class:Eigen::Block	access:public
Eigen::Block::Block	../include/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)$/;"	f	class:Eigen::Block	access:protected	signature:(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
Eigen::Block::Block	../include/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr,$/;"	f	class:Eigen::Block	access:public	signature:(XprType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)
Eigen::Block::Block	../include/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, Index i)$/;"	f	class:Eigen::Block	access:public	signature:(XprType& xpr, Index i)
Eigen::Block::Block	../include/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, Index startRow, Index startCol)$/;"	f	class:Eigen::Block	access:public	signature:(XprType& xpr, Index startRow, Index startCol)
Eigen::Block::coeff	../include/Eigen/src/Core/Block.h	/^    EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Block	access:public	signature:(Index row, Index col) const
Eigen::Block::coeff	../include/Eigen/src/Core/Block.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Block	access:public	signature:(Index index) const
Eigen::Block::coeffRef	../include/Eigen/src/Core/Block.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::Block	access:public	signature:(Index index) const
Eigen::Block::coeffRef	../include/Eigen/src/Core/Block.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::Block	access:public	signature:(Index row, Index col) const
Eigen::Block::coeffRef	../include/Eigen/src/Core/Block.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Block	access:public	signature:(Index index)
Eigen::Block::coeffRef	../include/Eigen/src/Core/Block.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Block	access:public	signature:(Index row, Index col)
Eigen::Block::cols	../include/Eigen/src/Core/Block.h	/^    inline Index cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::Block	access:public	signature:() const
Eigen::Block::data	../include/Eigen/src/Core/Block.h	/^    inline const Scalar* data() const;$/;"	p	class:Eigen::Block	access:public	signature:() const
EIGEN_BLOCK_H	../include/Eigen/src/Core/Block.h	27;"	d
EIGEN_BLOCK_HOUSEHOLDER_H	../include/Eigen/src/Householder/BlockHouseholder.h	27;"	d
Eigen::Block	../include/Eigen/src/Core/Block.h	/^class Block<XprType,BlockRows,BlockCols, InnerPanel,true>$/;"	c	namespace:Eigen	inherits:MapBase
Eigen::Block	../include/Eigen/src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, bool HasDirectAccess> class Block$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::Block::init	../include/Eigen/src/Core/Block.h	/^    void init()$/;"	f	class:Eigen::Block	access:protected	signature:()
Eigen::Block::innerStride	../include/Eigen/src/Core/Block.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Block	access:public	signature:() const
Eigen::Block::innerStride	../include/Eigen/src/Core/Block.h	/^    inline Index innerStride() const;$/;"	p	class:Eigen::Block	access:public	signature:() const
Eigen::Block::m_blockCols	../include/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::Block	access:protected
Eigen::Block::m_blockRows	../include/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::Block	access:protected
EIGEN_BLOCKMETHODS_H	../include/Eigen/src/plugins/BlockMethods.h	27;"	d
Eigen::Block::m_outerStride	../include/Eigen/src/Core/Block.h	/^    Index m_outerStride;$/;"	m	class:Eigen::Block	access:protected
Eigen::Block::m_startCol	../include/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::Block	access:protected
Eigen::Block::m_startRow	../include/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::Block	access:protected
Eigen::Block::m_xpr	../include/Eigen/src/Core/Block.h	/^    const typename XprType::Nested m_xpr;$/;"	m	class:Eigen::Block	access:protected
Eigen::Block::m_xpr	../include/Eigen/src/Core/Block.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::Block	access:protected
Eigen::Block::nestedExpression	../include/Eigen/src/Core/Block.h	/^    const typename internal::remove_all<typename XprType::Nested>::type& nestedExpression() const $/;"	f	class:Eigen::Block	access:public	signature:() const
Eigen::Block::outerStride	../include/Eigen/src/Core/Block.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Block	access:public	signature:() const
Eigen::Block::outerStride	../include/Eigen/src/Core/Block.h	/^    inline Index outerStride() const;$/;"	p	class:Eigen::Block	access:public	signature:() const
Eigen::Block::packet	../include/Eigen/src/Core/Block.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::Block	access:public	signature:(Index index) const
Eigen::Block::packet	../include/Eigen/src/Core/Block.h	/^    inline PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Block	access:public	signature:(Index row, Index col) const
Eigen::Block::rows	../include/Eigen/src/Core/Block.h	/^    inline Index rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::Block	access:public	signature:() const
Eigen::Block::startCol	../include/Eigen/src/Core/Block.h	/^    Index startCol() const $/;"	f	class:Eigen::Block	access:public	signature:() const
Eigen::Block::startRow	../include/Eigen/src/Core/Block.h	/^    Index startRow() const $/;"	f	class:Eigen::Block	access:public	signature:() const
Eigen::Block::writePacket	../include/Eigen/src/Core/Block.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Block	access:public	signature:(Index index, const PacketScalar& x)
Eigen::Block::writePacket	../include/Eigen/src/Core/Block.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Block	access:public	signature:(Index row, Index col, const PacketScalar& x)
Eigen::BothDirections	../include/Eigen/src/Core/util/Constants.h	/^  BothDirections $/;"	e	enum:Eigen::DirectionType
Eigen::BottomLeft	../include/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
Eigen::BottomRight	../include/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
Eigen::BuiltIn	../include/Eigen/src/Core/util/Constants.h	/^  BuiltIn$/;"	e	enum:Eigen::__anon211
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	33;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	../include/Eigen/src/Core/arch/Default/Settings.h	46;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	../include/Eigen/src/Core/arch/NEON/PacketMath.h	35;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	../include/Eigen/src/Core/arch/SSE/PacketMath.h	33;"	d
EIGEN_CAT2	../include/Eigen/src/Core/util/Macros.h	126;"	d
EIGEN_CAT	../include/Eigen/src/Core/util/Macros.h	127;"	d
Eigen::cdiv	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^std::complex<Scalar> cdiv(Scalar xr, Scalar xi, Scalar yr, Scalar yi)$/;"	f	namespace:Eigen	signature:(Scalar xr, Scalar xi, Scalar yr, Scalar yi)
EIGEN_CHECK_BINARY_COMPATIBILIY	../include/Eigen/src/Core/CwiseBinaryOp.h	111;"	d
Eigen::CholmodAuto	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
Eigen::CholmodBase::analyzePattern	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodBase::CholMatrixType	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef MatrixType CholMatrixType;$/;"	t	class:Eigen::CholmodBase	access:public
Eigen::CholmodBase::CholmodBase	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodBase(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodBase::~CholmodBase	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodBase()$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
Eigen::CholmodBase::CholmodBase	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodBase()$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
Eigen::CholmodBase::cholmod	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    cholmod_common& cholmod() { return m_cholmod; }$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
Eigen::CholmodBase::cols	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    inline Index cols() const { return m_cholmodFactor->n; }$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
Eigen::CholmodBase::compute	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& compute(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodBase::derived	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
Eigen::CholmodBase::derived	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::CholmodBase	access:public	signature:()
Eigen::CholmodBase::dumpMemory	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(Stream& s)
Eigen::CholmodBase::factorize	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodBase	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::CholmodBase::Index	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::CholmodBase	access:public
Eigen::CholmodBase::info	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
Eigen::CholmodBase::m_analysisIsOk	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::MatrixType	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodBase	access:public
Eigen::CholmodBase::m_cholmodFactor	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    cholmod_factor* m_cholmodFactor;$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::m_cholmod	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    mutable cholmod_common m_cholmod;$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::m_factorizationIsOk	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::m_info	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::m_isInitialized	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::CholmodBase	access:protected
Eigen::CholmodBase::RealScalar	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::CholmodBase	access:public
Eigen::CholmodBase::rows	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    inline Index rows() const { return m_cholmodFactor->n; }$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
Eigen::CholmodBase::Scalar	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::CholmodBase	access:public
Eigen::CholmodBase::solve	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::CholmodBase::solve	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
Eigen::CholmodBase::_solve	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
Eigen::CholmodBase::_solve	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void _solve(const SparseMatrix<RhsScalar,RhsOptions,RhsIndex> &b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const SparseMatrix<RhsScalar,RhsOptions,RhsIndex> &b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
Eigen::CholmodBase::UpLo	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::CholmodBase::__anon3
Eigen::CholmodDecomposition::Base	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodDecomposition> Base;$/;"	t	class:Eigen::CholmodDecomposition	access:private
Eigen::CholmodDecomposition::CholmodDecomposition	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition() : Base() { init(); }$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:()
Eigen::CholmodDecomposition::CholmodDecomposition	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodDecomposition::~CholmodDecomposition	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodDecomposition() {}$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:()
Eigen::CholmodDecomposition	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodDecomposition : public CholmodBase<_MatrixType, _UpLo, CholmodDecomposition<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
Eigen::CholmodDecomposition::init	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodDecomposition	access:protected	signature:()
Eigen::CholmodDecomposition::MatrixType	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodDecomposition	access:public
Eigen::CholmodDecomposition::setMode	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void setMode(CholmodMode mode)$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:(CholmodMode mode)
Eigen::CholmodLDLt	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
Eigen::CholmodMode	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^enum CholmodMode {$/;"	g	namespace:Eigen
Eigen::CholmodSimplicialLDLT::Base	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLDLT	access:private
Eigen::CholmodSimplicialLDLT::CholmodSimplicialLDLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:public	signature:()
Eigen::CholmodSimplicialLDLT::CholmodSimplicialLDLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodSimplicialLDLT::~CholmodSimplicialLDLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLDLT() {}$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:public	signature:()
Eigen::CholmodSimplicialLDLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLDLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
Eigen::CholmodSimplicialLDLT::init	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:protected	signature:()
Eigen::CholmodSimplicialLDLT::MatrixType	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLDLT	access:public
Eigen::CholmodSimplicialLLT::Base	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLLT	access:private
Eigen::CholmodSimplicialLLT::CholmodSimplicialLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLLT	access:public	signature:()
Eigen::CholmodSimplicialLLT::CholmodSimplicialLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLLT	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodSimplicialLLT::~CholmodSimplicialLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLLT() {}$/;"	f	class:Eigen::CholmodSimplicialLLT	access:public	signature:()
Eigen::CholmodSimplicialLLt	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
Eigen::CholmodSimplicialLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
Eigen::CholmodSimplicialLLT::init	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLLT	access:protected	signature:()
Eigen::CholmodSimplicialLLT::MatrixType	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLLT	access:public
Eigen::CholmodSupernodalLLT::Base	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT> Base;$/;"	t	class:Eigen::CholmodSupernodalLLT	access:private
Eigen::CholmodSupernodalLLT::CholmodSupernodalLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSupernodalLLT	access:public	signature:()
Eigen::CholmodSupernodalLLT::CholmodSupernodalLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSupernodalLLT	access:public	signature:(const MatrixType& matrix)
Eigen::CholmodSupernodalLLT::~CholmodSupernodalLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSupernodalLLT() {}$/;"	f	class:Eigen::CholmodSupernodalLLT	access:public	signature:()
Eigen::CholmodSupernodalLLt	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
Eigen::CholmodSupernodalLLT	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSupernodalLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:CholmodBase
Eigen::CholmodSupernodalLLT::init	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSupernodalLLT	access:protected	signature:()
Eigen::CholmodSupernodalLLT::MatrixType	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSupernodalLLT	access:public
EIGEN_CHOLMODSUPPORT_H	../include/Eigen/src/CholmodSupport/CholmodSupport.h	26;"	d
Eigen::CoeffBasedProduct::Base	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef MatrixBase<CoeffBasedProduct> Base;$/;"	t	class:Eigen::CoeffBasedProduct	access:public
Eigen::CoeffBasedProduct::CanVectorizeInner	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeInner = internal::traits<CoeffBasedProduct>::CanVectorizeInner$/;"	e	enum:Eigen::CoeffBasedProduct::__anon88
Eigen::CoeffBasedProduct::CoeffBasedProduct	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    inline CoeffBasedProduct(const CoeffBasedProduct& other)$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(const CoeffBasedProduct& other)
Eigen::CoeffBasedProduct::CoeffBasedProduct	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    inline CoeffBasedProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::CoeffBasedProduct::coeff	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index index) const
Eigen::CoeffBasedProduct::coeff	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index row, Index col) const
Eigen::CoeffBasedProduct::cols	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::diagonal	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,0> diagonal() const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::diagonal	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,DiagonalIndex> diagonal() const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::diagonal	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,Dynamic> diagonal(Index index) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index index) const
EIGEN_COEFFBASED_PRODUCT_H	../include/Eigen/src/Core/products/CoeffBasedProduct.h	27;"	d
Eigen::CoeffBasedProduct	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^class CoeffBasedProduct$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,MatrixBase
Eigen::CoeffBasedProduct::InnerSize	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      InnerSize  = internal::traits<CoeffBasedProduct>::InnerSize,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon88
Eigen::CoeffBasedProduct::LazyCoeffBasedProductType	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef CoeffBasedProduct<LhsNested,RhsNested,NestByRefBit> LazyCoeffBasedProductType;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
Eigen::CoeffBasedProduct::lhs	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::_LhsNested	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef typename internal::traits<CoeffBasedProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
Eigen::CoeffBasedProduct::m_lhs	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typename internal::add_const_on_value_type<LhsNested>::type m_lhs;$/;"	m	class:Eigen::CoeffBasedProduct	access:protected
Eigen::CoeffBasedProductMode	../include/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon215
Eigen::CoeffBasedProduct::m_result	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    mutable PlainObject m_result;$/;"	m	class:Eigen::CoeffBasedProduct	access:protected
Eigen::CoeffBasedProduct::m_rhs	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typename internal::add_const_on_value_type<RhsNested>::type m_rhs;$/;"	m	class:Eigen::CoeffBasedProduct	access:protected
Eigen::CoeffBasedProduct::operator const PlainObject&	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE operator const PlainObject& () const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::packet	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index row, Index col) const
Eigen::CoeffBasedProduct::PacketSize	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon88
Eigen::CoeffBasedProduct::PlainObject	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::CoeffBasedProduct	access:public
Eigen::CoeffBasedProduct::rhs	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::_RhsNested	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef typename internal::traits<CoeffBasedProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
Eigen::CoeffBasedProduct::rows	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Eigen::CoeffBasedProduct::ScalarCoeffImpl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^                                   _LhsNested, _RhsNested, Scalar> ScalarCoeffImpl;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
Eigen::CoeffBasedProduct::Unroll	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      Unroll = CoeffReadCost != Dynamic && CoeffReadCost <= EIGEN_UNROLLING_LIMIT,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon88
Eigen::CoherentAccessPattern	../include/Eigen/src/SparseCore/SparseUtil.h	/^const int CoherentAccessPattern     = 0x1;$/;"	m	namespace:Eigen
Eigen::ColMajor	../include/Eigen/src/Core/util/Constants.h	/^  ColMajor = 0,$/;"	e	enum:Eigen::__anon212
Eigen::ColPivHouseholderQR::absDeterminant	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typename MatrixType::RealScalar absDeterminant() const;$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::absDeterminant	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR	signature:() const
Eigen::ColPivHouseholderQR::ColPivHouseholderQR	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
Eigen::ColPivHouseholderQR::ColPivHouseholderQR	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR()$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:()
Eigen::ColPivHouseholderQR::ColPivHouseholderQR	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(Index rows, Index cols)
Eigen::ColPivHouseholderQR::ColsAtCompileTime	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon4
Eigen::ColPivHouseholderQR::cols	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::colsPermutation	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::compute	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& compute(const MatrixType& matrix);$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
Eigen::ColPivHouseholderQR::compute	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^ColPivHouseholderQR<MatrixType>& ColPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR	signature:(const MatrixType& matrix)
Eigen::ColPivHouseholderQR::dimensionOfKernel	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::hCoeffs	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::HCoeffsType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::householderQ	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^  ::householderQ() const$/;"	f	class:Eigen::ColPivHouseholderQR	signature:() const
Eigen::ColPivHouseholderQR::householderQ	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    HouseholderSequenceType householderQ(void) const;$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:(void) const
Eigen::ColPivHouseholderQR::HouseholderSequenceType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename HouseholderSequence<MatrixType,HCoeffsType>::ConjugateReturnType HouseholderSequenceType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^template<typename _MatrixType> class ColPivHouseholderQR$/;"	c	namespace:Eigen
Eigen::ColPivHouseholderQR::Index	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::IntRowVectorType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::inverse	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inverse() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::isInjective	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::isInvertible	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::isSurjective	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::logAbsDeterminant	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR	signature:() const
Eigen::ColPivHouseholderQR::logAbsDeterminant	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typename MatrixType::RealScalar logAbsDeterminant() const;$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::matrixQR	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::MatrixQType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, Options, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::MatrixType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::MaxColsAtCompileTime	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon4
Eigen::ColPivHouseholderQR::maxPivot	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::MaxRowsAtCompileTime	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon4
Eigen::ColPivHouseholderQR::m_colsPermutation	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    PermutationType m_colsPermutation;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_colSqNorms	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealRowVectorType m_colSqNorms;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_colsTranspositions	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_det_pq	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_hCoeffs	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_isInitialized	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_maxpivot	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_nonzero_pivots	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_prescribedThreshold	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_qr	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_temp	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::m_usePrescribedThreshold	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
Eigen::ColPivHouseholderQR::nonzeroPivots	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::Options	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon4
Eigen::ColPivHouseholderQR::PermutationType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQRPreconditioner	../include/Eigen/src/Core/util/Constants.h	/^  ColPivHouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
Eigen::ColPivHouseholderQR::rank	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::RealRowVectorType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, RealScalar>::type RealRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::RealScalar	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::RowsAtCompileTime	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon4
Eigen::ColPivHouseholderQR::rows	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
Eigen::ColPivHouseholderQR::RowVectorType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::Scalar	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Eigen::ColPivHouseholderQR::setThreshold	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(const RealScalar& threshold)
Eigen::ColPivHouseholderQR::setThreshold	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(Default_t)
Eigen::ColPivHouseholderQR::solve	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::ColPivHouseholderQR::threshold	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
EIGEN_COLPIVOTINGHOUSEHOLDERQR_H	../include/Eigen/src/QR/ColPivHouseholderQR.h	27;"	d
EIGEN_COLPIVOTINGHOUSEHOLDERQR_MKL_H	../include/Eigen/src/QR/ColPivHouseholderQR_MKL.h	35;"	d
Eigen::CommaInitializer::~CommaInitializer	../include/Eigen/src/Core/CommaInitializer.h	/^  inline ~CommaInitializer()$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:()
Eigen::CommaInitializer::CommaInitializer	../include/Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(XprType& xpr, const DenseBase<OtherDerived>& other)
Eigen::CommaInitializer::CommaInitializer	../include/Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(XprType& xpr, const Scalar& s)
Eigen::CommaInitializer::finished	../include/Eigen/src/Core/CommaInitializer.h	/^  inline XprType& finished() { return m_xpr; }$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:()
EIGEN_COMMAINITIALIZER_H	../include/Eigen/src/Core/CommaInitializer.h	27;"	d
Eigen::CommaInitializer	../include/Eigen/src/Core/CommaInitializer.h	/^struct CommaInitializer$/;"	s	namespace:Eigen
Eigen::CommaInitializer::Index	../include/Eigen/src/Core/CommaInitializer.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::CommaInitializer	access:public
Eigen::CommaInitializer::m_col	../include/Eigen/src/Core/CommaInitializer.h	/^  Index m_col;              \/\/ current col id$/;"	m	struct:Eigen::CommaInitializer	access:public
Eigen::CommaInitializer::m_currentBlockRows	../include/Eigen/src/Core/CommaInitializer.h	/^  Index m_currentBlockRows; \/\/ current block height$/;"	m	struct:Eigen::CommaInitializer	access:public
Eigen::CommaInitializer::m_row	../include/Eigen/src/Core/CommaInitializer.h	/^  Index m_row;              \/\/ current row id$/;"	m	struct:Eigen::CommaInitializer	access:public
Eigen::CommaInitializer::m_xpr	../include/Eigen/src/Core/CommaInitializer.h	/^  XprType& m_xpr;   \/\/ target expression$/;"	m	struct:Eigen::CommaInitializer	access:public
Eigen::CommaInitializer::operator ,	../include/Eigen/src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::CommaInitializer::operator ,	../include/Eigen/src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(const Scalar& s)
Eigen::CommaInitializer::Scalar	../include/Eigen/src/Core/CommaInitializer.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::CommaInitializer	access:public
Eigen::CompleteUnrolling	../include/Eigen/src/Core/util/Constants.h	/^  CompleteUnrolling$/;"	e	enum:Eigen::__anon210
EIGEN_COMPLEX_ALTIVEC_H	../include/Eigen/src/Core/arch/AltiVec/Complex.h	26;"	d
Eigen::ComplexEigenSolver::ColsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon43
Eigen::ComplexEigenSolver::ComplexEigenSolver	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      ComplexEigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
Eigen::ComplexEigenSolver::ComplexEigenSolver	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver()$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:()
Eigen::ComplexEigenSolver::ComplexEigenSolver	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver(Index size)$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:(Index size)
Eigen::ComplexEigenSolver::ComplexScalar	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::compute	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver& compute(const MatrixType& matrix, bool computeEigenvectors = true);$/;"	p	class:Eigen::ComplexEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
Eigen::ComplexEigenSolver::compute	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^ComplexEigenSolver<MatrixType>& ComplexEigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver	signature:(const MatrixType& matrix, bool computeEigenvectors)
Eigen::ComplexEigenSolver::doComputeEigenvectors	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::doComputeEigenvectors(RealScalar matrixnorm)$/;"	f	class:Eigen::ComplexEigenSolver	signature:(RealScalar matrixnorm)
Eigen::ComplexEigenSolver::doComputeEigenvectors	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    void doComputeEigenvectors(RealScalar matrixnorm);$/;"	p	class:Eigen::ComplexEigenSolver	access:private	signature:(RealScalar matrixnorm)
Eigen::ComplexEigenSolver::eigenvalues	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:() const
Eigen::ComplexEigenSolver::EigenvalueType	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options&(~RowMajor), MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::eigenvectors	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvectorType& eigenvectors() const$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:() const
Eigen::ComplexEigenSolver::EigenvectorType	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorType;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
EIGEN_COMPLEX_EIGEN_SOLVER_H	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	28;"	d
Eigen::ComplexEigenSolver	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^template<typename _MatrixType> class ComplexEigenSolver$/;"	c	namespace:Eigen
Eigen::ComplexEigenSolver::Index	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::info	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:() const
Eigen::ComplexEigenSolver::MatrixType	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::MaxColsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexEigenSolver::__anon43
Eigen::ComplexEigenSolver::MaxRowsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon43
Eigen::ComplexEigenSolver::m_eigenvectorsOk	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
Eigen::ComplexEigenSolver::m_eivalues	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
Eigen::ComplexEigenSolver::m_eivec	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_eivec;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
Eigen::ComplexEigenSolver::m_isInitialized	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
Eigen::ComplexEigenSolver::m_matX	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_matX;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
Eigen::ComplexEigenSolver::m_schur	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexSchur<MatrixType> m_schur;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
Eigen::ComplexEigenSolver::Options	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon43
Eigen::ComplexEigenSolver::RealScalar	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::RowsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon43
Eigen::ComplexEigenSolver::Scalar	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::ComplexEigenSolver::sortEigenvalues	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::sortEigenvalues(bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver	signature:(bool computeEigenvectors)
Eigen::ComplexEigenSolver::sortEigenvalues	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    void sortEigenvalues(bool computeEigenvectors);$/;"	p	class:Eigen::ComplexEigenSolver	access:private	signature:(bool computeEigenvectors)
EIGEN_COMPLEX_NEON_H	../include/Eigen/src/Core/arch/NEON/Complex.h	26;"	d
Eigen::ComplexSchur::ColsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon41
Eigen::ComplexSchur::ComplexMatrixType	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> ComplexMatrixType;$/;"	t	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::ComplexScalar	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::ComplexSchur	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur(const MatrixType& matrix, bool computeU = true)$/;"	f	class:Eigen::ComplexSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
Eigen::ComplexSchur::ComplexSchur	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::ComplexSchur	access:public	signature:(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)
Eigen::ComplexSchur::compute	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur& compute(const MatrixType& matrix, bool computeU = true);$/;"	p	class:Eigen::ComplexSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
Eigen::ComplexSchur::compute	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)$/;"	f	class:Eigen::ComplexSchur	signature:(const MatrixType& matrix, bool computeU)
Eigen::ComplexSchur::computeShift	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexScalar computeShift(Index iu, Index iter);$/;"	p	class:Eigen::ComplexSchur	access:private	signature:(Index iu, Index iter)
Eigen::ComplexSchur::computeShift	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^typename ComplexSchur<MatrixType>::ComplexScalar ComplexSchur<MatrixType>::computeShift(Index iu, Index iter)$/;"	f	class:Eigen::ComplexSchur	signature:(Index iu, Index iter)
EIGEN_COMPLEX_SCHUR_H	../include/Eigen/src/Eigenvalues/ComplexSchur.h	28;"	d
Eigen::ComplexSchur	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^template<typename _MatrixType> class ComplexSchur$/;"	c	namespace:Eigen
Eigen::ComplexSchur::Index	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::info	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexSchur	access:public	signature:() const
Eigen::ComplexSchur::matrixT	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixT() const$/;"	f	class:Eigen::ComplexSchur	access:public	signature:() const
Eigen::ComplexSchur::MatrixType	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::matrixU	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixU() const$/;"	f	class:Eigen::ComplexSchur	access:public	signature:() const
Eigen::ComplexSchur::MaxColsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexSchur::__anon41
Eigen::ComplexSchur::MaxRowsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon41
Eigen::ComplexSchur::m_hess	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::ComplexSchur	access:protected
Eigen::ComplexSchur::m_info	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::ComplexSchur	access:protected
Eigen::ComplexSchur::m_isInitialized	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexSchur	access:protected
EIGEN_COMPLEX_SCHUR_MKL_H	../include/Eigen/src/Eigenvalues/ComplexSchur_MKL.h	34;"	d
Eigen::ComplexSchur::m_matT	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur	access:protected
Eigen::ComplexSchur::m_matU	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur	access:protected
Eigen::ComplexSchur::m_matUisUptodate	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::ComplexSchur	access:protected
Eigen::ComplexSchur::m_maxIterations	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    static const int m_maxIterations = 30;$/;"	m	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::Options	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexSchur::__anon41
Eigen::ComplexSchur::RealScalar	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::reduceToTriangularForm	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^void ComplexSchur<MatrixType>::reduceToTriangularForm(bool computeU)$/;"	f	class:Eigen::ComplexSchur	signature:(bool computeU)
Eigen::ComplexSchur::reduceToTriangularForm	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    void reduceToTriangularForm(bool computeU);$/;"	p	class:Eigen::ComplexSchur	access:private	signature:(bool computeU)
Eigen::ComplexSchur::RowsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon41
Eigen::ComplexSchur::Scalar	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexSchur	access:public
Eigen::ComplexSchur::subdiagonalEntryIsNeglegible	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool subdiagonalEntryIsNeglegible(Index i);$/;"	p	class:Eigen::ComplexSchur	access:private	signature:(Index i)
Eigen::ComplexSchur::subdiagonalEntryIsNeglegible	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^inline bool ComplexSchur<MatrixType>::subdiagonalEntryIsNeglegible(Index i)$/;"	f	class:Eigen::ComplexSchur	signature:(Index i)
EIGEN_COMPLEX_SSE_H	../include/Eigen/src/Core/arch/SSE/Complex.h	26;"	d
EIGEN_COMPRESSED_STORAGE_H	../include/Eigen/src/SparseCore/CompressedStorage.h	26;"	d
Eigen::ComputationInfo	../include/Eigen/src/Core/util/Constants.h	/^enum ComputationInfo {$/;"	g	namespace:Eigen
Eigen::ComputeEigenvectors	../include/Eigen/src/Core/util/Constants.h	/^  ComputeEigenvectors = 0x80,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::ComputeFullU	../include/Eigen/src/Core/util/Constants.h	/^  ComputeFullU        = 0x04,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::ComputeFullV	../include/Eigen/src/Core/util/Constants.h	/^  ComputeFullV        = 0x10,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::ComputeThinU	../include/Eigen/src/Core/util/Constants.h	/^  ComputeThinU        = 0x08,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::ComputeThinV	../include/Eigen/src/Core/util/Constants.h	/^  ComputeThinV        = 0x20,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::ConjugateGradient::Base	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef IterativeSolverBase<ConjugateGradient> Base;$/;"	t	class:Eigen::ConjugateGradient	access:private
Eigen::ConjugateGradient::ConjugateGradient	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ConjugateGradient() : Base() {}$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:()
Eigen::ConjugateGradient::ConjugateGradient	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ConjugateGradient(const MatrixType& A) : Base(A) {}$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const MatrixType& A)
Eigen::ConjugateGradient::~ConjugateGradient	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ~ConjugateGradient() {}$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:()
EIGEN_CONJUGATE_GRADIENT_H	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	26;"	d
Eigen::ConjugateGradient	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^class ConjugateGradient : public IterativeSolverBase<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	c	namespace:Eigen	inherits:IterativeSolverBase
Eigen::ConjugateGradient::Index	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ConjugateGradient	access:public
Eigen::ConjugateGradient::MatrixType	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ConjugateGradient	access:public
Eigen::ConjugateGradient::Preconditioner	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::ConjugateGradient	access:public
Eigen::ConjugateGradient::RealScalar	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ConjugateGradient	access:public
Eigen::ConjugateGradient::Scalar	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ConjugateGradient	access:public
Eigen::ConjugateGradient::_solve	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const Rhs& b, Dest& x) const
Eigen::ConjugateGradient::solveWithGuess	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const MatrixBase<Rhs>& b, const Guess& x0) const
Eigen::ConjugateGradient::_solveWithGuess	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const Rhs& b, Dest& x) const
Eigen::ConjugateGradient::UpLo	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^    UpLo = _UpLo$/;"	e	enum:Eigen::ConjugateGradient::__anon10
EIGEN_CONSERVATIVESPARSESPARSEPRODUCT_H	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	26;"	d
EIGEN_CONSTANTS_H	../include/Eigen/src/Core/util/Constants.h	27;"	d
EIGEN_COREITERATORS_H	../include/Eigen/src/SparseCore/CoreIterators.h	26;"	d
Eigen::CornerType	../include/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	g	namespace:Eigen
EIGEN_CPUID	../include/Eigen/src/Core/util/Memory.h	755;"	d
EIGEN_CPUID	../include/Eigen/src/Core/util/Memory.h	759;"	d
EIGEN_CPUID	../include/Eigen/src/Core/util/Memory.h	764;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	../include/Eigen/src/Core/ArrayBase.h	121;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	../include/Eigen/src/Core/ArrayBase.h	131;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	../include/Eigen/src/Core/DenseBase.h	501;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	../include/Eigen/src/Core/DenseBase.h	506;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	../include/Eigen/src/Core/MatrixBase.h	150;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	../include/Eigen/src/Core/MatrixBase.h	158;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	../include/Eigen/src/SparseCore/SparseMatrixBase.h	149;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	../include/Eigen/src/SparseCore/SparseMatrixBase.h	157;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	../include/Eigen/src/SparseCore/SparseMatrixBase.h	158;"	d
Eigen::Cwise::abs2	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_abs2_op)     abs2() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::abs2	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::abs2() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::abs	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_abs_op)      abs() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::abs	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::abs() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::CwiseBinaryOp::Base	../include/Eigen/src/Core/CwiseBinaryOp.h	/^                                         typename internal::traits<Rhs>::StorageKind>::ret>::Base Base;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
Eigen::CwiseBinaryOp::cols	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const {$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
Eigen::CwiseBinaryOp::CwiseBinaryOp	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE CwiseBinaryOp(const Lhs& lhs, const Rhs& rhs, const BinaryOp& func = BinaryOp())$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:(const Lhs& lhs, const Rhs& rhs, const BinaryOp& func = BinaryOp())
Eigen::CwiseBinaryOp::functor	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    const BinaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
EIGEN_CWISE_BINARY_OP_H	../include/Eigen/src/Core/CwiseBinaryOp.h	27;"	d
Eigen::CwiseBinaryOpImpl::Base	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::type Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl	access:public
Eigen::CwiseBinaryOpImpl::coeff	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index index) const
Eigen::CwiseBinaryOpImpl::coeff	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index row, Index col) const
Eigen::CwiseBinaryOpImpl::CwiseBinaryOpImpl	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CwiseBinaryOpImpl()$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:()
Eigen::CwiseBinaryOpImpl::Derived	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl	access:private
Eigen::CwiseBinaryOpImpl::Derived	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl	access:public
Eigen::CwiseBinaryOpImpl	../include/Eigen/src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Dense>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::CwiseBinaryOpImpl	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::CwiseBinaryOpImpl::InnerIterator::Base	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^      BinaryOp,Lhs,Rhs, InnerIterator> Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl::InnerIterator	access:public
Eigen::CwiseBinaryOpImpl::InnerIterator	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp,Lhs,Rhs,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseBinaryOpImpl	inherits:internal::sparse_cwise_binary_op_inner_iterator_selector
Eigen::CwiseBinaryOpImpl::InnerIterator::Index	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::CwiseBinaryOpImpl::InnerIterator	access:public
Eigen::CwiseBinaryOpImpl::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseBinaryOpImpl& binOp, typename CwiseBinaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseBinaryOpImpl::InnerIterator	access:public	signature:(const CwiseBinaryOpImpl& binOp, typename CwiseBinaryOpImpl::Index outer)
Eigen::CwiseBinaryOpImpl::packet	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index index) const
Eigen::CwiseBinaryOpImpl::packet	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index row, Index col) const
Eigen::CwiseBinaryOp	../include/Eigen/src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,CwiseBinaryOpImpl
Eigen::CwiseBinaryOp::lhs	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
Eigen::CwiseBinaryOp::LhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::nested<Lhs>::type LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
Eigen::CwiseBinaryOp::_LhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
Eigen::CwiseBinaryOp::m_functor	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    const BinaryOp m_functor;$/;"	m	class:Eigen::CwiseBinaryOp	access:protected
Eigen::CwiseBinaryOp::m_lhs	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::CwiseBinaryOp	access:protected
Eigen::CwiseBinaryOp::m_rhs	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::CwiseBinaryOp	access:protected
Eigen::CwiseBinaryOp::rhs	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
Eigen::CwiseBinaryOp::RhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::nested<Rhs>::type RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
Eigen::CwiseBinaryOp::_RhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
Eigen::CwiseBinaryOp::rows	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const {$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
EIGEN_CWISE_BINOP_RETURN_TYPE	../include/Eigen/src/Eigen2Support/Cwise.h	33;"	d
EIGEN_CWISE_COMP_TO_SCALAR_RETURN_TYPE	../include/Eigen/src/Eigen2Support/Cwise.h	43;"	d
Eigen::Cwise::cos	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_cos_op)      cos() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::cos	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::cos() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::cube	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_cube_op)     cube() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::cube	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::cube() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::Cwise	../include/Eigen/src/Eigen2Support/Cwise.h	/^    inline Cwise(const ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Cwise	access:public	signature:(const ExpressionType& matrix)
Eigen::Cwise::exp	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_exp_op)      exp() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::exp	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::exp() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::_expression	../include/Eigen/src/Eigen2Support/Cwise.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::ExpressionTypeNested	../include/Eigen/src/Eigen2Support/Cwise.h	/^        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::Cwise	access:public
EIGEN_CWISE_H	../include/Eigen/src/Eigen2Support/Cwise.h	27;"	d
Eigen::Cwise	../include/Eigen/src/Eigen2Support/Cwise.h	/^template<typename ExpressionType> class Cwise$/;"	c	namespace:Eigen
Eigen::Cwise::inverse	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_inverse_op)  inverse() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::inverse	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::inverse() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::log	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_log_op)      log() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::log	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::log() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::m_matrix	../include/Eigen/src/Eigen2Support/Cwise.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::Cwise	access:protected
Eigen::CwiseNullaryOp::Base	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseNullaryOp>::type Base;$/;"	t	class:Eigen::CwiseNullaryOp	access:public
Eigen::CwiseNullaryOp::coeff	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index index) const
Eigen::CwiseNullaryOp::coeff	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index rows, Index cols) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index rows, Index cols) const
Eigen::CwiseNullaryOp::cols	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:() const
Eigen::CwiseNullaryOp::CwiseNullaryOp	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    CwiseNullaryOp(Index rows, Index cols, const NullaryOp& func = NullaryOp())$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index rows, Index cols, const NullaryOp& func = NullaryOp())
Eigen::CwiseNullaryOp::functor	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    const NullaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:() const
EIGEN_CWISE_NULLARY_OP_H	../include/Eigen/src/Core/CwiseNullaryOp.h	26;"	d
Eigen::CwiseNullaryOp	../include/Eigen/src/Core/CwiseNullaryOp.h	/^class CwiseNullaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
Eigen::CwiseNullaryOp::m_cols	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::CwiseNullaryOp	access:protected
Eigen::CwiseNullaryOp::m_functor	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    const NullaryOp m_functor;$/;"	m	class:Eigen::CwiseNullaryOp	access:protected
Eigen::CwiseNullaryOp::m_rows	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::CwiseNullaryOp	access:protected
Eigen::CwiseNullaryOp::packet	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index index) const
Eigen::CwiseNullaryOp::packet	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index row, Index col) const
Eigen::CwiseNullaryOp::rows	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:() const
Eigen::Cwise::operator -=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    ExpressionType& operator-=(const Scalar& scalar);$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar)
Eigen::Cwise::operator +=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    ExpressionType& operator+=(const Scalar& scalar);$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar)
Eigen::Cwise::operator /=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    inline ExpressionType& operator\/=(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Cwise::operator *=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    inline ExpressionType& operator*=(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Cwise::operator <=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator<=(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Cwise::operator <	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator<(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Cwise::operator ==	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator==(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Cwise::operator >=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator>=(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Cwise::operator >	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator>(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Cwise::operator !=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator!=(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Cwise::operator /	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator\/(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator *	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator*(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator +	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator+(const Scalar& scalar, const Cwise& mat)$/;"	f	class:Eigen::Cwise	access:friend	signature:(const Scalar& scalar, const Cwise& mat)
Eigen::Cwise::operator -	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator-(const Scalar& scalar) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar) const
Eigen::Cwise::operator +	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator+(const Scalar& scalar) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar) const
Eigen::Cwise::operator <=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator<=(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
Eigen::Cwise::operator <	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator<(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
Eigen::Cwise::operator ==	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator==(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
Eigen::Cwise::operator >=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator>=(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
Eigen::Cwise::operator >	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator>(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
Eigen::Cwise::operator !=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator!=(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
Eigen::Cwise::operator <=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator <	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator ==	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator==(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator >=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator >	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator !=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator!=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator /	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator\/(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator *	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Cwise::operator -	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator-(const Scalar& scalar) const$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar) const
Eigen::Cwise::operator +	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator+(const Scalar& scalar) const$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar) const
Eigen::Cwise::operator <=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<=(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
Eigen::Cwise::operator <	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
Eigen::Cwise::operator ==	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator==(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
Eigen::Cwise::operator >=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>=(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
Eigen::Cwise::operator >	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
Eigen::Cwise::operator !=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator!=(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
Eigen::Cwise::operator /=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator\/=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Cwise::operator *=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator*=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Cwise::operator -=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator-=(const Scalar& scalar)$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar)
Eigen::Cwise::operator +=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator+=(const Scalar& scalar)$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar)
Eigen::Cwise::pow	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_pow_op)      pow(const Scalar& exponent) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& exponent) const
Eigen::Cwise::pow	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::pow(const Scalar& exponent) const$/;"	f	class:Eigen::Cwise	signature:(const Scalar& exponent) const
EIGEN_CWISE_PRODUCT_RETURN_TYPE	../include/Eigen/src/Core/util/Macros.h	415;"	d
Eigen::Cwise::ScalarAddReturnType	../include/Eigen/src/Eigen2Support/Cwise.h	/^    typedef CwiseUnaryOp<internal::scalar_add_op<Scalar>, ExpressionType> ScalarAddReturnType;$/;"	t	class:Eigen::Cwise	access:public
Eigen::Cwise::Scalar	../include/Eigen/src/Eigen2Support/Cwise.h	/^    typedef typename internal::traits<ExpressionType>::Scalar Scalar;$/;"	t	class:Eigen::Cwise	access:public
Eigen::Cwise::scalar_max_op	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_BINOP_RETURN_TYPE(internal::scalar_max_op)$/;"	f	class:Eigen::Cwise	access:public	signature:(max) const
Eigen::Cwise::scalar_min_op	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_BINOP_RETURN_TYPE(internal::scalar_min_op)$/;"	f	class:Eigen::Cwise	access:public	signature:(min) const
Eigen::Cwise::sin	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_sin_op)      sin() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::sin	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::sin() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::sqrt	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_sqrt_op)     sqrt() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::sqrt	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::sqrt() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::Cwise::square	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_square_op)   square() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
Eigen::Cwise::square	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::square() const$/;"	f	class:Eigen::Cwise	signature:() const
Eigen::CwiseUnaryOp::Base	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp, XprType,typename internal::traits<XprType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryOp	access:public
Eigen::CwiseUnaryOp::cols	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
Eigen::CwiseUnaryOp::CwiseUnaryOp	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    inline CwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:(const XprType& xpr, const UnaryOp& func = UnaryOp())
Eigen::CwiseUnaryOp::functor	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    const UnaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
EIGEN_CWISE_UNARY_OP_H	../include/Eigen/src/Core/CwiseUnaryOp.h	27;"	d
Eigen::CwiseUnaryOpImpl::Base	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:public
Eigen::CwiseUnaryOpImpl::coeff	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index index) const
Eigen::CwiseUnaryOpImpl::coeff	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index row, Index col) const
Eigen::CwiseUnaryOpImpl::Derived	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, XprType> Derived;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:public
Eigen::CwiseUnaryOpImpl::Derived	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:public
Eigen::CwiseUnaryOpImpl	../include/Eigen/src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,XprType,Dense>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::CwiseUnaryOpImpl	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::CwiseUnaryOpImpl::InnerIterator::Base	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::MatrixTypeIterator Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:private
Eigen::CwiseUnaryOpImpl::InnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseUnaryOpImpl	inherits:CwiseUnaryOpImpl::MatrixTypeIterator
Eigen::CwiseUnaryOpImpl::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:public	signature:(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)
Eigen::CwiseUnaryOpImpl::InnerIterator::m_functor	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:protected
Eigen::CwiseUnaryOpImpl::InnerIterator::operator ++	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:public	signature:()
Eigen::CwiseUnaryOpImpl::InnerIterator::Scalar	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:private
Eigen::CwiseUnaryOpImpl::InnerIterator::value	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryOpImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:public	signature:() const
Eigen::CwiseUnaryOpImpl::InnerIterator::valueRef	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typename CwiseUnaryOpImpl::Scalar& valueRef();$/;"	p	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:private	signature:()
Eigen::CwiseUnaryOpImpl::MatrixTypeIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::InnerIterator MatrixTypeIterator;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:protected
Eigen::CwiseUnaryOpImpl::_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename internal::traits<Derived>::_XprTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:protected
Eigen::CwiseUnaryOpImpl::MatrixTypeReverseIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator MatrixTypeReverseIterator;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:protected
Eigen::CwiseUnaryOpImpl::packet	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index index) const
Eigen::CwiseUnaryOpImpl::packet	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index row, Index col) const
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::Base	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::MatrixTypeReverseIterator Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:private
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::CwiseUnaryOpImpl	inherits:CwiseUnaryOpImpl::MatrixTypeReverseIterator
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::m_functor	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:protected
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::operator --	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:public	signature:()
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:public	signature:(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::Scalar	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:private
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::value	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryOpImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::CwiseUnaryOpImpl::ReverseInnerIterator::valueRef	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typename CwiseUnaryOpImpl::Scalar& valueRef();$/;"	p	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:private	signature:()
Eigen::CwiseUnaryOp	../include/Eigen/src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,CwiseUnaryOpImpl
Eigen::CwiseUnaryOp::m_functor	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOp	access:protected
Eigen::CwiseUnaryOp::m_xpr	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::CwiseUnaryOp	access:protected
Eigen::CwiseUnaryOp::nestedExpression	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
Eigen::CwiseUnaryOp::nestedExpression	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    nestedExpression() { return m_xpr.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:()
Eigen::CwiseUnaryOp::rows	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
Eigen::CwiseUnaryView::Base	../include/Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp, MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryView	access:public
Eigen::CwiseUnaryView::cols	../include/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
Eigen::CwiseUnaryView::CwiseUnaryView	../include/Eigen/src/Core/CwiseUnaryView.h	/^    inline CwiseUnaryView(const MatrixType& mat, const ViewOp& func = ViewOp())$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:(const MatrixType& mat, const ViewOp& func = ViewOp())
Eigen::CwiseUnaryView::functor	../include/Eigen/src/Core/CwiseUnaryView.h	/^    const ViewOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
EIGEN_CWISE_UNARY_VIEW_H	../include/Eigen/src/Core/CwiseUnaryView.h	26;"	d
Eigen::CwiseUnaryViewImpl::Base	../include/Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename internal::dense_xpr_base< CwiseUnaryView<ViewOp, MatrixType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:public
Eigen::CwiseUnaryViewImpl::coeff	../include/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index index) const
Eigen::CwiseUnaryViewImpl::coeff	../include/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index row, Index col) const
Eigen::CwiseUnaryViewImpl::coeffRef	../include/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index index)
Eigen::CwiseUnaryViewImpl::coeffRef	../include/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:(Index row, Index col)
Eigen::CwiseUnaryViewImpl::Derived	../include/Eigen/src/Core/CwiseUnaryView.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:public
Eigen::CwiseUnaryViewImpl::Derived	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:public
Eigen::CwiseUnaryViewImpl	../include/Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Dense>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::CwiseUnaryViewImpl	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::CwiseUnaryViewImpl::InnerIterator::Base	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::MatrixTypeIterator Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:private
Eigen::CwiseUnaryViewImpl::InnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseUnaryViewImpl	inherits:CwiseUnaryViewImpl::MatrixTypeIterator
Eigen::CwiseUnaryViewImpl::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)
Eigen::CwiseUnaryViewImpl::InnerIterator::m_functor	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:protected
Eigen::CwiseUnaryViewImpl::InnerIterator::operator ++	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:()
Eigen::CwiseUnaryViewImpl::InnerIterator::Scalar	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:private
Eigen::CwiseUnaryViewImpl::InnerIterator::value	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:() const
Eigen::CwiseUnaryViewImpl::InnerIterator::valueRef	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:()
Eigen::CwiseUnaryViewImpl::innerStride	../include/Eigen/src/Core/CwiseUnaryView.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:() const
Eigen::CwiseUnaryViewImpl::MatrixTypeIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::InnerIterator MatrixTypeIterator;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:protected
Eigen::CwiseUnaryViewImpl::_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename internal::traits<Derived>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:protected
Eigen::CwiseUnaryViewImpl::MatrixTypeReverseIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator MatrixTypeReverseIterator;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:protected
Eigen::CwiseUnaryViewImpl::outerStride	../include/Eigen/src/Core/CwiseUnaryView.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:() const
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::Base	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::MatrixTypeReverseIterator Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:private
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::CwiseUnaryViewImpl	inherits:CwiseUnaryViewImpl::MatrixTypeReverseIterator
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::m_functor	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:protected
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::operator --	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:()
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::Scalar	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:private
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::value	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::CwiseUnaryViewImpl::ReverseInnerIterator::valueRef	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:()
Eigen::CwiseUnaryView	../include/Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryView : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,CwiseUnaryViewImpl
Eigen::CwiseUnaryView::m_functor	../include/Eigen/src/Core/CwiseUnaryView.h	/^    ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryView	access:protected
Eigen::CwiseUnaryView::m_matrix	../include/Eigen/src/Core/CwiseUnaryView.h	/^    typename internal::nested<MatrixType>::type m_matrix;$/;"	m	class:Eigen::CwiseUnaryView	access:protected
Eigen::CwiseUnaryView::nestedExpression	../include/Eigen/src/Core/CwiseUnaryView.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
Eigen::CwiseUnaryView::nestedExpression	../include/Eigen/src/Core/CwiseUnaryView.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:()
Eigen::CwiseUnaryView::rows	../include/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
EIGEN_CWISE_UNOP_RETURN_TYPE	../include/Eigen/src/Eigen2Support/Cwise.h	38;"	d
EIGEN_DBG_SPARSE	../include/Eigen/src/SparseCore/SparseUtil.h	31;"	d
Eigen::dcomplex	../include/Eigen/src/Core/util/MKL_support.h	/^typedef std::complex<double> dcomplex;$/;"	t	namespace:Eigen
EIGEN_DEBUG_ALIGNED_LOAD	../include/Eigen/src/Core/GenericPacketMath.h	42;"	d
EIGEN_DEBUG_ALIGNED_STORE	../include/Eigen/src/Core/GenericPacketMath.h	50;"	d
EIGEN_DEBUG_UNALIGNED_LOAD	../include/Eigen/src/Core/GenericPacketMath.h	46;"	d
EIGEN_DEBUG_UNALIGNED_STORE	../include/Eigen/src/Core/GenericPacketMath.h	54;"	d
EIGEN_DEBUG_VAR	../include/Eigen/src/Core/util/Macros.h	123;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4f	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	55;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4f	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4f(ZERO, 0);$/;"	p	namespace:Eigen::internal	signature:(ZERO, 0)
_EIGEN_DECLARE_CONST_FAST_Packet4i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	58;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(MINUS1,-1);$/;"	p	namespace:Eigen::internal	signature:(MINUS1,-1)
_EIGEN_DECLARE_CONST_FAST_Packet4i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(MINUS16,-16);$/;"	p	namespace:Eigen::internal	signature:(MINUS16,-16)
_EIGEN_DECLARE_CONST_FAST_Packet4i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(ONE,1);$/;"	p	namespace:Eigen::internal	signature:(ONE,1)
_EIGEN_DECLARE_CONST_FAST_Packet4i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(ZERO, 0);$/;"	p	namespace:Eigen::internal	signature:(ZERO, 0)
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	64;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	../include/Eigen/src/Core/arch/NEON/PacketMath.h	51;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	../include/Eigen/src/Core/arch/SSE/PacketMath.h	66;"	d
_EIGEN_DECLARE_CONST_Packet4f	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	61;"	d
_EIGEN_DECLARE_CONST_Packet4f	../include/Eigen/src/Core/arch/NEON/PacketMath.h	48;"	d
_EIGEN_DECLARE_CONST_Packet4f	../include/Eigen/src/Core/arch/SSE/PacketMath.h	63;"	d
_EIGEN_DECLARE_CONST_Packet4i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	67;"	d
_EIGEN_DECLARE_CONST_Packet4i	../include/Eigen/src/Core/arch/NEON/PacketMath.h	54;"	d
_EIGEN_DECLARE_CONST_Packet4i	../include/Eigen/src/Core/arch/SSE/PacketMath.h	69;"	d
EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS	../include/Eigen/src/Core/util/Macros.h	173;"	d
Eigen::DecompositionOptions	../include/Eigen/src/Core/util/Constants.h	/^enum DecompositionOptions {$/;"	g	namespace:Eigen
EIGEN_DEFAULT_DENSE_INDEX_TYPE	../include/Eigen/src/Core/util/Macros.h	111;"	d
Eigen::Default	../include/Eigen/src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	e	enum:Eigen::Default_t
EIGEN_DEFAULT_IO_FORMAT	../include/Eigen/src/Core/util/Macros.h	307;"	d
EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION	../include/Eigen/src/Core/util/Macros.h	105;"	d
EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION	../include/Eigen/src/Core/util/Macros.h	107;"	d
EIGEN_DEFAULT_SETTINGS_H	../include/Eigen/src/Core/arch/Default/Settings.h	32;"	d
Eigen::Default_t	../include/Eigen/src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	g	namespace:Eigen
Eigen::DefaultTraversal	../include/Eigen/src/Core/util/Constants.h	/^  DefaultTraversal,$/;"	e	enum:Eigen::__anon209
EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS	../include/Eigen/src/Core/util/Macros.h	174;"	d
EIGEN_DEFINE_STL_DEQUE_SPECIALIZATION	../include/Eigen/src/StlSupport/StdDeque.h	43;"	d
EIGEN_DEFINE_STL_LIST_SPECIALIZATION	../include/Eigen/src/StlSupport/StdList.h	42;"	d
EIGEN_DEFINE_STL_VECTOR_SPECIALIZATION	../include/Eigen/src/StlSupport/StdVector.h	36;"	d
Eigen::DenseBase::all	../include/Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::all() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::all	../include/Eigen/src/Core/DenseBase.h	/^    bool all(void) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(void) const
Eigen::DenseBase::any	../include/Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::any() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::any	../include/Eigen/src/Core/DenseBase.h	/^    bool any(void) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(void) const
Eigen::DenseBase::Base	../include/Eigen/src/Core/DenseBase.h	/^    typedef DenseCoeffsBase<Derived> Base;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::checkTransposeAliasing	../include/Eigen/src/Core/DenseBase.h	/^    void checkTransposeAliasing(const OtherDerived& other) const;$/;"	p	class:Eigen::DenseBase	access:protected	signature:(const OtherDerived& other) const
Eigen::DenseBase::checkTransposeAliasing	../include/Eigen/src/Core/Transpose.h	/^void DenseBase<Derived>::checkTransposeAliasing(const OtherDerived& other) const$/;"	f	class:Eigen::DenseBase	signature:(const OtherDerived& other) const
Eigen::DenseBase::CoeffReadCost	../include/Eigen/src/Core/DenseBase.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::CoeffReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ColsAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::colwise	../include/Eigen/src/Core/DenseBase.h	/^    ColwiseReturnType colwise();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::colwise	../include/Eigen/src/Core/DenseBase.h	/^    ConstColwiseReturnType colwise() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::colwise	../include/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::colwise	../include/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::ColwiseReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::Constant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& value)
Eigen::DenseBase::Constant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index rows, Index cols, const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols, const Scalar& value)
Eigen::DenseBase::Constant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index size, const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const Scalar& value)
Eigen::DenseBase::Constant	../include/Eigen/src/Core/DenseBase.h	/^    Constant(const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value)
Eigen::DenseBase::Constant	../include/Eigen/src/Core/DenseBase.h	/^    Constant(Index rows, Index cols, const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols, const Scalar& value)
Eigen::DenseBase::Constant	../include/Eigen/src/Core/DenseBase.h	/^    Constant(Index size, const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const Scalar& value)
Eigen::DenseBase::ConstantReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ConstColwiseReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ConstFixedSegmentReturnType	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	s	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ConstFixedSegmentReturnType::Type	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	t	struct:Eigen::DenseBase::ConstFixedSegmentReturnType	access:public
Eigen::DenseBase::ConstReverseReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef const Reverse<const Derived, BothDirections> ConstReverseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ConstRowwiseReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ConstSegmentReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef const VectorBlock<const Derived> ConstSegmentReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::ConstTransposeReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef const Transpose<const Derived> ConstTransposeReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::corner	../include/Eigen/src/Core/DenseBase.h	/^    Block<Derived> corner(CornerType type, Index cRows, Index cCols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type, Index cRows, Index cCols)
Eigen::DenseBase::corner	../include/Eigen/src/Core/DenseBase.h	/^    Block<Derived, CRows, CCols> corner(CornerType type);$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type)
Eigen::DenseBase::corner	../include/Eigen/src/Core/DenseBase.h	/^    const Block<Derived> corner(CornerType type, Index cRows, Index cCols) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type, Index cRows, Index cCols) const
Eigen::DenseBase::corner	../include/Eigen/src/Core/DenseBase.h	/^    const Block<Derived, CRows, CCols> corner(CornerType type) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(CornerType type) const
Eigen::DenseBase::corner	../include/Eigen/src/Eigen2Support/Block.h	/^  ::corner(CornerType type, Index cRows, Index cCols)$/;"	f	class:Eigen::DenseBase	signature:(CornerType type, Index cRows, Index cCols)
Eigen::DenseBase::corner	../include/Eigen/src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type) const$/;"	f	class:Eigen::DenseBase	signature:(CornerType type) const
Eigen::DenseBase::corner	../include/Eigen/src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type)$/;"	f	class:Eigen::DenseBase	signature:(CornerType type)
Eigen::DenseBase::corner	../include/Eigen/src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type, Index cRows, Index cCols) const$/;"	f	class:Eigen::DenseBase	signature:(CornerType type, Index cRows, Index cCols) const
Eigen::DenseBase::count	../include/Eigen/src/Core/BooleanRedux.h	/^inline typename DenseBase<Derived>::Index DenseBase<Derived>::count() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::count	../include/Eigen/src/Core/DenseBase.h	/^    Index count() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::DenseBase	../include/Eigen/src/Core/DenseBase.h	/^    DenseBase()$/;"	f	class:Eigen::DenseBase	access:protected	signature:()
Eigen::DenseBase::DenseBase	../include/Eigen/src/Core/DenseBase.h	/^    DenseBase(int,int);$/;"	p	class:Eigen::DenseBase	access:private	signature:(int,int)
Eigen::DenseBase::DenseBase	../include/Eigen/src/Core/DenseBase.h	/^    explicit DenseBase(int);$/;"	p	class:Eigen::DenseBase	access:private	signature:(int)
Eigen::DenseBase::DenseBase	../include/Eigen/src/Core/DenseBase.h	/^    template<typename OtherDerived> explicit DenseBase(const DenseBase<OtherDerived>&);$/;"	p	class:Eigen::DenseBase	access:private	signature:(const DenseBase<OtherDerived>&)
Eigen::DenseBase::EigenvaluesReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::traits<Derived>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::eval	../include/Eigen/src/Core/DenseBase.h	/^    EIGEN_STRONG_INLINE EvalReturnType eval() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::EvalReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::add_const_on_value_type<typename internal::eval<Derived>::type>::type EvalReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::evalTo	../include/Eigen/src/Core/DenseBase.h	/^    template<typename Dest> inline void evalTo(Dest& ) const$/;"	f	class:Eigen::DenseBase	access:public	signature:(Dest& ) const
Eigen::DenseBase::fill	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE void DenseBase<Derived>::fill(const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& value)
Eigen::DenseBase::fill	../include/Eigen/src/Core/DenseBase.h	/^    void fill(const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value)
Eigen::DenseBase::FixedSegmentReturnType	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	s	class:Eigen::DenseBase	access:public
Eigen::DenseBase::FixedSegmentReturnType::Type	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	t	struct:Eigen::DenseBase::FixedSegmentReturnType	access:public
Eigen::DenseBase::flagged	../include/Eigen/src/Core/DenseBase.h	/^    const Flagged<Derived, Added, Removed> flagged() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::flagged	../include/Eigen/src/Core/Flagged.h	/^DenseBase<Derived>::flagged() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::Flags	../include/Eigen/src/Core/DenseBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::forceAlignedAccessIf	../include/Eigen/src/Core/DenseBase.h	/^    template<bool Enable> inline const typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::forceAlignedAccessIf	../include/Eigen/src/Core/DenseBase.h	/^    template<bool Enable> inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::forceAlignedAccess	../include/Eigen/src/Core/DenseBase.h	/^    inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::forceAlignedAccess	../include/Eigen/src/Core/DenseBase.h	/^    inline ForceAlignedAccess<Derived> forceAlignedAccess();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::format	../include/Eigen/src/Core/DenseBase.h	/^    inline const WithFormat<Derived> format(const IOFormat& fmt) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const IOFormat& fmt) const
Eigen::DenseBase::format	../include/Eigen/src/Core/IO.h	/^DenseBase<Derived>::format(const IOFormat& fmt) const$/;"	f	class:Eigen::DenseBase	signature:(const IOFormat& fmt) const
Eigen::DenseBase::head	../include/Eigen/src/Core/DenseBase.h	/^    SegmentReturnType head(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
Eigen::DenseBase::head	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> typename ConstFixedSegmentReturnType<Size>::Type head() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::head	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> typename FixedSegmentReturnType<Size>::Type head();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::head	../include/Eigen/src/Core/DenseBase.h	/^    typename DenseBase::ConstSegmentReturnType head(Index size) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size) const
Eigen::DenseBase::head	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::head() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::head	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::head()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::head	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::head(Index size) const$/;"	f	class:Eigen::DenseBase	signature:(Index size) const
Eigen::DenseBase::head	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::head(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
EIGEN_DENSEBASE_H	../include/Eigen/src/Core/DenseBase.h	27;"	d
Eigen::DenseBase	../include/Eigen/src/Core/DenseBase.h	/^template<typename Derived> class DenseBase$/;"	c	namespace:Eigen	inherits:internal::special_scalar_op_base
Eigen::DenseBase::Index	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Index Index; $/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::InnerIterator::col	../include/Eigen/src/SparseCore/CoreIterators.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
Eigen::DenseBase::InnerIterator	../include/Eigen/src/SparseCore/CoreIterators.h	/^template<typename Derived> class DenseBase<Derived>::InnerIterator$/;"	c	class:Eigen::DenseBase
Eigen::DenseBase::InnerIterator::index	../include/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_inner; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
Eigen::DenseBase::InnerIterator::Index	../include/Eigen/src/SparseCore/CoreIterators.h	/^    typedef typename Derived::Index Index;$/;"	t	class:Eigen::DenseBase::InnerIterator	access:protected
Eigen::DenseBase::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE InnerIterator(const Derived& expr, Index outer)$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:(const Derived& expr, Index outer)
Eigen::DenseBase::InnerIterator::IsRowMajor	../include/Eigen/src/SparseCore/CoreIterators.h	/^    enum { IsRowMajor = (Derived::Flags&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::DenseBase::InnerIterator::__anon34
Eigen::DenseBase::InnerIterator::m_end	../include/Eigen/src/SparseCore/CoreIterators.h	/^    const Index m_end;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
Eigen::DenseBase::InnerIterator::m_expression	../include/Eigen/src/SparseCore/CoreIterators.h	/^    const Derived& m_expression;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
Eigen::DenseBase::InnerIterator::m_inner	../include/Eigen/src/SparseCore/CoreIterators.h	/^    Index m_inner;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
Eigen::DenseBase::InnerIterator::m_outer	../include/Eigen/src/SparseCore/CoreIterators.h	/^    const Index m_outer;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
Eigen::DenseBase::InnerIterator::operator bool	../include/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_inner < m_end && m_inner>=0; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
Eigen::DenseBase::InnerIterator::operator ++	../include/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++() { m_inner++; return *this; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:()
Eigen::DenseBase::InnerIterator::row	../include/Eigen/src/SparseCore/CoreIterators.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
Eigen::DenseBase::InnerIterator::Scalar	../include/Eigen/src/SparseCore/CoreIterators.h	/^    typedef typename Derived::Scalar Scalar;$/;"	t	class:Eigen::DenseBase::InnerIterator	access:protected
Eigen::DenseBase::InnerIterator::value	../include/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
Eigen::DenseBase::InnerSizeAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::innerSize	../include/Eigen/src/Core/DenseBase.h	/^    Index innerSize() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::InnerStrideAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::isApprox	../include/Eigen/src/Core/DenseBase.h	/^    bool isApprox(const DenseBase<OtherDerived>& other,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::isApprox	../include/Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isApprox($/;"	f	class:Eigen::DenseBase	signature:( const DenseBase<OtherDerived>& other, RealScalar prec ) const
Eigen::DenseBase::isApproxToConstant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isApproxToConstant$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& value, RealScalar prec) const
Eigen::DenseBase::isApproxToConstant	../include/Eigen/src/Core/DenseBase.h	/^    bool isApproxToConstant(const Scalar& value, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::isConstant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isConstant$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& value, RealScalar prec) const
Eigen::DenseBase::isConstant	../include/Eigen/src/Core/DenseBase.h	/^    bool isConstant(const Scalar& value, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::isMuchSmallerThan	../include/Eigen/src/Core/DenseBase.h	/^    bool isMuchSmallerThan(const DenseBase<OtherDerived>& other,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::isMuchSmallerThan	../include/Eigen/src/Core/DenseBase.h	/^    bool isMuchSmallerThan(const RealScalar& other,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const RealScalar& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::isMuchSmallerThan	../include/Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isMuchSmallerThan($/;"	f	class:Eigen::DenseBase	signature:( const DenseBase<OtherDerived>& other, RealScalar prec ) const
Eigen::DenseBase::isMuchSmallerThan	../include/Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isMuchSmallerThan($/;"	f	class:Eigen::DenseBase	signature:( const typename NumTraits<Scalar>::Real& other, RealScalar prec ) const
Eigen::DenseBase::isOnes	../include/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isOnes$/;"	f	class:Eigen::DenseBase	signature:(RealScalar prec) const
Eigen::DenseBase::isOnes	../include/Eigen/src/Core/DenseBase.h	/^    bool isOnes(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::IsRowMajor	../include/Eigen/src/Core/DenseBase.h	/^      IsRowMajor = int(Flags) & RowMajorBit, \/**< True if this expression has row-major storage order. *\/$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::IsVectorAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::isZero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isZero(RealScalar prec) const$/;"	f	class:Eigen::DenseBase	signature:(RealScalar prec) const
Eigen::DenseBase::isZero	../include/Eigen/src/Core/DenseBase.h	/^    bool isZero(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::DenseBase::lazyAssign	../include/Eigen/src/Core/Assign.h	/^  ::lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<OtherDerived>& other)
Eigen::DenseBase::lazyAssign	../include/Eigen/src/Core/DenseBase.h	/^    Derived& lazyAssign(const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::DenseBase::LinSpaced	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Sequential_t, const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Sequential_t, Index size, const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	../include/Eigen/src/Core/DenseBase.h	/^    LinSpaced(const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	../include/Eigen/src/Core/DenseBase.h	/^    LinSpaced(Index size, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	../include/Eigen/src/Core/DenseBase.h	/^    LinSpaced(Sequential_t, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Sequential_t, const Scalar& low, const Scalar& high)
Eigen::DenseBase::LinSpaced	../include/Eigen/src/Core/DenseBase.h	/^    LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Sequential_t, Index size, const Scalar& low, const Scalar& high)
Eigen::DenseBase::lpNorm	../include/Eigen/src/Core/DenseBase.h	/^    template<int p> RealScalar lpNorm() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::maxCoeff	../include/Eigen/src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar maxCoeff() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::maxCoeff	../include/Eigen/src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* index) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* index) const
Eigen::DenseBase::maxCoeff	../include/Eigen/src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* row, IndexType* col) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* row, IndexType* col) const
Eigen::DenseBase::maxCoeff	../include/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::maxCoeff() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::maxCoeff	../include/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* index) const
Eigen::DenseBase::maxCoeff	../include/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* row, IndexType* col) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* row, IndexType* col) const
Eigen::DenseBase::MaxColsAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::MaxRowsAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::MaxSizeAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::mean	../include/Eigen/src/Core/DenseBase.h	/^    Scalar mean() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::mean	../include/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::mean() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::minCoeff	../include/Eigen/src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar minCoeff() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::minCoeff	../include/Eigen/src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar minCoeff(IndexType* index) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* index) const
Eigen::DenseBase::minCoeff	../include/Eigen/src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar minCoeff(IndexType* row, IndexType* col) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* row, IndexType* col) const
Eigen::DenseBase::minCoeff	../include/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::minCoeff() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::minCoeff	../include/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* index) const
Eigen::DenseBase::minCoeff	../include/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* row, IndexType* col) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* row, IndexType* col) const
Eigen::DenseBase::nestByValue	../include/Eigen/src/Core/DenseBase.h	/^    inline const NestByValue<Derived> nestByValue() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::nestByValue	../include/Eigen/src/Core/NestByValue.h	/^DenseBase<Derived>::nestByValue() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::nonZeros	../include/Eigen/src/Core/DenseBase.h	/^    inline Index nonZeros() const { return size(); }$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::NullaryExpr	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase	signature:(const CustomNullaryOp& func)
Eigen::DenseBase::NullaryExpr	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols, const CustomNullaryOp& func)
Eigen::DenseBase::NullaryExpr	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index size, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const CustomNullaryOp& func)
Eigen::DenseBase::NullaryExpr	../include/Eigen/src/Core/DenseBase.h	/^    NullaryExpr(const CustomNullaryOp& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const CustomNullaryOp& func)
Eigen::DenseBase::NullaryExpr	../include/Eigen/src/Core/DenseBase.h	/^    NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols, const CustomNullaryOp& func)
Eigen::DenseBase::NullaryExpr	../include/Eigen/src/Core/DenseBase.h	/^    NullaryExpr(Index size, const CustomNullaryOp& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const CustomNullaryOp& func)
Eigen::DenseBase::Ones	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::Ones	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols)
Eigen::DenseBase::Ones	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
Eigen::DenseBase::Ones	../include/Eigen/src/Core/DenseBase.h	/^    static const ConstantReturnType Ones(Index rows, Index cols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Eigen::DenseBase::Ones	../include/Eigen/src/Core/DenseBase.h	/^    static const ConstantReturnType Ones(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
Eigen::DenseBase::Ones	../include/Eigen/src/Core/DenseBase.h	/^    static const ConstantReturnType Ones();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::operator =	../include/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<OtherDerived>& other)
Eigen::DenseBase::operator =	../include/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase& other)
Eigen::DenseBase::operator <<	../include/Eigen/src/Core/CommaInitializer.h	/^DenseBase<Derived>::operator<<(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<OtherDerived>& other)
Eigen::DenseBase::operator <<	../include/Eigen/src/Core/CommaInitializer.h	/^inline CommaInitializer<Derived> DenseBase<Derived>::operator<< (const Scalar& s)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& s)
Eigen::DenseBase::operator <<	../include/Eigen/src/Core/DenseBase.h	/^    CommaInitializer<Derived> operator<< (const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::DenseBase::operator <<	../include/Eigen/src/Core/DenseBase.h	/^    CommaInitializer<Derived> operator<< (const Scalar& s);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& s)
Eigen::DenseBase::operator =	../include/Eigen/src/Core/DenseBase.h	/^    Derived& operator=(const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::DenseBase::operator =	../include/Eigen/src/Core/DenseBase.h	/^    Derived& operator=(const DenseBase& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase& other)
Eigen::DenseBase::operator =	../include/Eigen/src/Core/DenseBase.h	/^    Derived& operator=(const EigenBase<OtherDerived> &other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::DenseBase::operator -=	../include/Eigen/src/Core/DenseBase.h	/^    Derived& operator-=(const EigenBase<OtherDerived> &other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::DenseBase::operator +=	../include/Eigen/src/Core/DenseBase.h	/^    Derived& operator+=(const EigenBase<OtherDerived> &other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::DenseBase::operator =	../include/Eigen/src/Core/DenseBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const ReturnByValue<OtherDerived>& func)
Eigen::DenseBase::operator /=	../include/Eigen/src/Core/DenseBase.h	/^    inline Derived& operator\/=(const Scalar& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& other)
Eigen::DenseBase::operator *=	../include/Eigen/src/Core/DenseBase.h	/^    inline Derived& operator*=(const Scalar& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& other)
Eigen::DenseBase::operator =	../include/Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase	signature:(const EigenBase<OtherDerived> &other)
Eigen::DenseBase::operator -=	../include/Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator-=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase	signature:(const EigenBase<OtherDerived> &other)
Eigen::DenseBase::operator +=	../include/Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator+=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase	signature:(const EigenBase<OtherDerived> &other)
Eigen::DenseBase::operator =	../include/Eigen/src/Core/ReturnByValue.h	/^Derived& DenseBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::DenseBase::operator /=	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^inline Derived& DenseBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& other)
Eigen::DenseBase::operator *=	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^inline Derived& DenseBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& other)
Eigen::DenseBase::outerSize	../include/Eigen/src/Core/DenseBase.h	/^    Index outerSize() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::OuterStrideAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::PacketScalar	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::prod	../include/Eigen/src/Core/DenseBase.h	/^    Scalar prod() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::prod	../include/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::prod() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::RandomAccessLinSpacedReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,true>,Derived> RandomAccessLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::Random	../include/Eigen/src/Core/DenseBase.h	/^    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random(Index rows, Index cols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Eigen::DenseBase::Random	../include/Eigen/src/Core/DenseBase.h	/^    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
Eigen::DenseBase::Random	../include/Eigen/src/Core/DenseBase.h	/^    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::Random	../include/Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::Random	../include/Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols)
Eigen::DenseBase::Random	../include/Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
Eigen::DenseBase::RealScalar	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::redux	../include/Eigen/src/Core/DenseBase.h	/^    redux(const BinaryOp& func) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const BinaryOp& func) const
Eigen::DenseBase::redux	../include/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::redux(const Func& func) const$/;"	f	class:Eigen::DenseBase	signature:(const Func& func) const
Eigen::DenseBase::replicate	../include/Eigen/src/Core/DenseBase.h	/^    const Replicate<Derived,Dynamic,Dynamic> replicate(Index rowFacor,Index colFactor) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rowFacor,Index colFactor) const
Eigen::DenseBase::replicate	../include/Eigen/src/Core/DenseBase.h	/^    const Replicate<Derived,RowFactor,ColFactor> replicate() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::replicate	../include/Eigen/src/Core/Replicate.h	/^DenseBase<Derived>::replicate() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::replicate	../include/Eigen/src/Core/Replicate.h	/^DenseBase<Derived>::replicate(Index rowFactor,Index colFactor) const$/;"	f	class:Eigen::DenseBase	signature:(Index rowFactor,Index colFactor) const
Eigen::DenseBase::resize	../include/Eigen/src/Core/DenseBase.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Eigen::DenseBase::resize	../include/Eigen/src/Core/DenseBase.h	/^    void resize(Index size)$/;"	f	class:Eigen::DenseBase	access:public	signature:(Index size)
Eigen::DenseBase::reverse	../include/Eigen/src/Core/DenseBase.h	/^    ConstReverseReturnType reverse() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::reverse	../include/Eigen/src/Core/DenseBase.h	/^    ReverseReturnType reverse();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::reverse	../include/Eigen/src/Core/Reverse.h	/^DenseBase<Derived>::reverse() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::reverse	../include/Eigen/src/Core/Reverse.h	/^DenseBase<Derived>::reverse()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::reverseInPlace	../include/Eigen/src/Core/DenseBase.h	/^    void reverseInPlace();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::reverseInPlace	../include/Eigen/src/Core/Reverse.h	/^inline void DenseBase<Derived>::reverseInPlace()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::ReverseReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef Reverse<Derived, BothDirections> ReverseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::RowsAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::rowwise	../include/Eigen/src/Core/DenseBase.h	/^    ConstRowwiseReturnType rowwise() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::rowwise	../include/Eigen/src/Core/DenseBase.h	/^    RowwiseReturnType rowwise();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::rowwise	../include/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::rowwise	../include/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::RowwiseReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::Scalar	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::segment	../include/Eigen/src/Core/DenseBase.h	/^    SegmentReturnType segment(Index start, Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index start, Index size)
Eigen::DenseBase::segment	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> typename ConstFixedSegmentReturnType<Size>::Type segment(Index start) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index start) const
Eigen::DenseBase::segment	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> typename FixedSegmentReturnType<Size>::Type segment(Index start);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index start)
Eigen::DenseBase::segment	../include/Eigen/src/Core/DenseBase.h	/^    typename DenseBase::ConstSegmentReturnType segment(Index start, Index size) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index start, Index size) const
Eigen::DenseBase::segment	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::segment(Index start) const$/;"	f	class:Eigen::DenseBase	signature:(Index start) const
Eigen::DenseBase::segment	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::segment(Index start)$/;"	f	class:Eigen::DenseBase	signature:(Index start)
Eigen::DenseBase::segment	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::segment(Index start, Index size) const$/;"	f	class:Eigen::DenseBase	signature:(Index start, Index size) const
Eigen::DenseBase::segment	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::segment(Index start, Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index start, Index size)
Eigen::DenseBase::SegmentReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef VectorBlock<Derived> SegmentReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::select	../include/Eigen/src/Core/DenseBase.h	/^    select(const DenseBase<ThenDerived>& thenMatrix,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<ThenDerived>& thenMatrix, const DenseBase<ElseDerived>& elseMatrix) const
Eigen::DenseBase::select	../include/Eigen/src/Core/DenseBase.h	/^    select(const DenseBase<ThenDerived>& thenMatrix, typename ThenDerived::Scalar elseScalar) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<ThenDerived>& thenMatrix, typename ThenDerived::Scalar elseScalar) const
Eigen::DenseBase::select	../include/Eigen/src/Core/DenseBase.h	/^    select(typename ElseDerived::Scalar thenScalar, const DenseBase<ElseDerived>& elseMatrix) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(typename ElseDerived::Scalar thenScalar, const DenseBase<ElseDerived>& elseMatrix) const
Eigen::DenseBase::select	../include/Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<ThenDerived>& thenMatrix, const DenseBase<ElseDerived>& elseMatrix) const
Eigen::DenseBase::select	../include/Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<ThenDerived>& thenMatrix, typename ThenDerived::Scalar elseScalar) const
Eigen::DenseBase::select	../include/Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(typename ElseDerived::Scalar thenScalar,$/;"	f	class:Eigen::DenseBase	signature:(typename ElseDerived::Scalar thenScalar, const DenseBase<ElseDerived>& elseMatrix) const
Eigen::DenseBase::SequentialLinSpacedReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,false>,Derived> SequentialLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::setConstant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setConstant(const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& value)
Eigen::DenseBase::setConstant	../include/Eigen/src/Core/DenseBase.h	/^    Derived& setConstant(const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value)
Eigen::DenseBase::setLinSpaced	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& low, const Scalar& high)
Eigen::DenseBase::setLinSpaced	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const Scalar& low, const Scalar& high)
Eigen::DenseBase::setLinSpaced	../include/Eigen/src/Core/DenseBase.h	/^    Derived& setLinSpaced(const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& low, const Scalar& high)
Eigen::DenseBase::setLinSpaced	../include/Eigen/src/Core/DenseBase.h	/^    Derived& setLinSpaced(Index size, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const Scalar& low, const Scalar& high)
Eigen::DenseBase::setOnes	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setOnes()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::setOnes	../include/Eigen/src/Core/DenseBase.h	/^    Derived& setOnes();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::setRandom	../include/Eigen/src/Core/DenseBase.h	/^    Derived& setRandom();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::setRandom	../include/Eigen/src/Core/Random.h	/^inline Derived& DenseBase<Derived>::setRandom()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::setZero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setZero()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::setZero	../include/Eigen/src/Core/DenseBase.h	/^    Derived& setZero();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::SizeAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon216
Eigen::DenseBase::StorageKind	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseBase	access:public
Eigen::DenseBase::sum	../include/Eigen/src/Core/DenseBase.h	/^    Scalar sum() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::sum	../include/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::sum() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::swap	../include/Eigen/src/Core/DenseBase.h	/^    void swap(const DenseBase<OtherDerived>& other,$/;"	f	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other, int = OtherDerived::ThisConstantIsPrivateInPlainObjectBase)
Eigen::DenseBase::swap	../include/Eigen/src/Core/DenseBase.h	/^    void swap(PlainObjectBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	access:public	signature:(PlainObjectBase<OtherDerived>& other)
Eigen::DenseBase::tail	../include/Eigen/src/Core/DenseBase.h	/^    SegmentReturnType tail(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
Eigen::DenseBase::tail	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> typename ConstFixedSegmentReturnType<Size>::Type tail() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::tail	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> typename FixedSegmentReturnType<Size>::Type tail();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::tail	../include/Eigen/src/Core/DenseBase.h	/^    typename DenseBase::ConstSegmentReturnType tail(Index size) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size) const
Eigen::DenseBase::tail	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::tail() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::tail	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::tail()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::tail	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::tail(Index size) const$/;"	f	class:Eigen::DenseBase	signature:(Index size) const
Eigen::DenseBase::tail	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::tail(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
Eigen::DenseBase::ThisConstantIsPrivateInPlainObjectBase	../include/Eigen/src/Core/DenseBase.h	/^    enum { ThisConstantIsPrivateInPlainObjectBase };$/;"	e	enum:Eigen::DenseBase::__anon217
Eigen::DenseBase::trace	../include/Eigen/src/Core/DenseBase.h	/^    Scalar trace() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::transpose	../include/Eigen/src/Core/DenseBase.h	/^    ConstTransposeReturnType transpose() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::transpose	../include/Eigen/src/Core/DenseBase.h	/^    Eigen::Transpose<Derived> transpose();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::transpose	../include/Eigen/src/Core/Transpose.h	/^DenseBase<Derived>::transpose() const$/;"	f	class:Eigen::DenseBase	signature:() const
Eigen::DenseBase::transpose	../include/Eigen/src/Core/Transpose.h	/^DenseBase<Derived>::transpose()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::transposeInPlace	../include/Eigen/src/Core/DenseBase.h	/^    void transposeInPlace();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseBase::transposeInPlace	../include/Eigen/src/Core/Transpose.h	/^inline void DenseBase<Derived>::transposeInPlace()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::value	../include/Eigen/src/Core/DenseBase.h	/^    CoeffReturnType value() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
Eigen::DenseBase::visit	../include/Eigen/src/Core/DenseBase.h	/^    void visit(Visitor& func) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Visitor& func) const
Eigen::DenseBase::visit	../include/Eigen/src/Core/Visitor.h	/^void DenseBase<Derived>::visit(Visitor& visitor) const$/;"	f	class:Eigen::DenseBase	signature:(Visitor& visitor) const
Eigen::DenseBase::Zero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero()$/;"	f	class:Eigen::DenseBase	signature:()
Eigen::DenseBase::Zero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols)
Eigen::DenseBase::Zero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
Eigen::DenseBase::Zero	../include/Eigen/src/Core/DenseBase.h	/^    static const ConstantReturnType Zero(Index rows, Index cols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Eigen::DenseBase::Zero	../include/Eigen/src/Core/DenseBase.h	/^    static const ConstantReturnType Zero(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
Eigen::DenseBase::Zero	../include/Eigen/src/Core/DenseBase.h	/^    static const ConstantReturnType Zero();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Eigen::DenseCoeffsBase::Base	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::Base	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, WriteAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::Base	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::coeffByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeffByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
Eigen::DenseCoeffsBase::coeff	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    coeff(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
Eigen::DenseCoeffsBase::coeff	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col) const
Eigen::DenseCoeffsBase::coeffRefByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    coeffRefByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner)
Eigen::DenseCoeffsBase::coeffRefByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void coeffRefByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::coeffRef	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    coeffRef(Index index)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index)
Eigen::DenseCoeffsBase::coeffRef	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col)
Eigen::DenseCoeffsBase::coeffRef	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void coeffRef();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::CoeffReturnType	../include/Eigen/src/Core/DenseCoeffsBase.h	/^                     >::type CoeffReturnType;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::colIndexByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
Eigen::DenseCoeffsBase::colStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index colStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::colStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void colStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::copyCoeffByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeffByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner, const DenseBase<OtherDerived>& other)
Eigen::DenseCoeffsBase::copyCoeffByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void copyCoeffByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::copyCoeff	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
Eigen::DenseCoeffsBase::copyCoeff	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
Eigen::DenseCoeffsBase::copyCoeff	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void copyCoeff();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::copyPacketByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacketByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner, const DenseBase<OtherDerived>& other)
Eigen::DenseCoeffsBase::copyPacketByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void copyPacketByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::copyPacket	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
Eigen::DenseCoeffsBase::copyPacket	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
Eigen::DenseCoeffsBase::copyPacket	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void copyPacket();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
EIGEN_DENSECOEFFSBASE_H	../include/Eigen/src/Core/DenseCoeffsBase.h	26;"	d
Eigen::DenseCoeffsBase	../include/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen	inherits:DenseCoeffsBase
Eigen::DenseCoeffsBase	../include/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectWriteAccessors>$/;"	c	namespace:Eigen	inherits:DenseCoeffsBase
Eigen::DenseCoeffsBase	../include/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived,ReadOnlyAccessors> : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::DenseCoeffsBase	../include/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, WriteAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen	inherits:DenseCoeffsBase
Eigen::DenseCoeffsBase::Index	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::innerStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::innerStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void innerStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::operator ()	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType operator()(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col) const
Eigen::DenseCoeffsBase::operator ()	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
Eigen::DenseCoeffsBase::operator []	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    operator[](Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
Eigen::DenseCoeffsBase::operator ()	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index index)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index)
Eigen::DenseCoeffsBase::operator []	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    operator[](Index index)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index)
Eigen::DenseCoeffsBase::operator ()	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col)
Eigen::DenseCoeffsBase::outerStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::outerStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void outerStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::packetByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packetByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
Eigen::DenseCoeffsBase::packet	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
Eigen::DenseCoeffsBase::packet	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col) const
Eigen::DenseCoeffsBase::PacketReturnType	../include/Eigen/src/Core/DenseCoeffsBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::PacketScalar	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::RealScalar	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::rowIndexByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
Eigen::DenseCoeffsBase::rowStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index rowStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::rowStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void rowStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::Scalar	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::StorageKind	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Eigen::DenseCoeffsBase::stride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index stride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::stride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void stride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::w	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    w() const { return (*this)[3]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::w	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    w() { return (*this)[3]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
Eigen::DenseCoeffsBase::writePacketByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacketByOuterInner$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner, const typename internal::packet_traits<Scalar>::type& x)
Eigen::DenseCoeffsBase::writePacketByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void writePacketByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::writePacket	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacket$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index, const typename internal::packet_traits<Scalar>::type& x)
Eigen::DenseCoeffsBase::writePacket	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacket$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col, const typename internal::packet_traits<Scalar>::type& x)
Eigen::DenseCoeffsBase::writePacket	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void writePacket();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Eigen::DenseCoeffsBase::x	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    x() const { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::x	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    x() { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
Eigen::DenseCoeffsBase::y	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    y() const { return (*this)[1]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::y	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    y() { return (*this)[1]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
Eigen::DenseCoeffsBase::z	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    z() const { return (*this)[2]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
Eigen::DenseCoeffsBase::z	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    z() { return (*this)[2]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
Eigen::Dense	../include/Eigen/src/Core/util/Constants.h	/^struct Dense {};$/;"	s	namespace:Eigen
Eigen::DenseIndex	../include/Eigen/src/Core/util/XprHelper.h	/^typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE DenseIndex;$/;"	t	namespace:Eigen
EIGEN_DENSE_PUBLIC_INTERFACE	../include/Eigen/src/Core/util/Macros.h	356;"	d
Eigen::DenseSparseProductReturnType	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs, int InnerSize> struct DenseSparseProductReturnType$/;"	s	namespace:Eigen
Eigen::DenseSparseProductReturnType	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs> struct DenseSparseProductReturnType<Lhs,Rhs,1>$/;"	s	namespace:Eigen
Eigen::DenseSparseProductReturnType::Type	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef DenseTimeSparseProduct<Lhs,Rhs> Type;$/;"	t	struct:Eigen::DenseSparseProductReturnType	access:public
Eigen::DenseSparseProductReturnType::Type	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef SparseDenseOuterProduct<Rhs,Lhs,true> Type;$/;"	t	struct:Eigen::DenseSparseProductReturnType	access:public
EIGEN_DENSESTORAGEBASE_H	../include/Eigen/src/Core/PlainObjectBase.h	27;"	d
Eigen::DenseStorage::cols	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseIndex cols(void) const {return _Cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
Eigen::DenseStorage::cols	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseIndex cols(void) const {return m_cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
Eigen::DenseStorage::cols	../include/Eigen/src/Core/DenseStorage.h	/^    static inline DenseIndex cols(void) {return _Cols;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void)
Eigen::DenseStorage::conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex, DenseIndex, DenseIndex cols) { m_cols = cols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex, DenseIndex cols)
Eigen::DenseStorage::conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex,DenseIndex,DenseIndex)
Eigen::DenseStorage::conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex, DenseIndex rows, DenseIndex cols) { m_rows = rows; m_cols = cols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex rows, DenseIndex cols)
Eigen::DenseStorage::conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex, DenseIndex rows, DenseIndex) { m_rows = rows; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex rows, DenseIndex)
Eigen::DenseStorage::conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex size, DenseIndex, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex, DenseIndex cols)
Eigen::DenseStorage::conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex size, DenseIndex rows, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex rows, DenseIndex cols)
Eigen::DenseStorage::conservativeResize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex size, DenseIndex rows, DenseIndex)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex rows, DenseIndex)
Eigen::DenseStorage::data	../include/Eigen/src/Core/DenseStorage.h	/^    inline const T *data() const { return 0; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
Eigen::DenseStorage::data	../include/Eigen/src/Core/DenseStorage.h	/^    inline const T *data() const { return m_data.array; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
Eigen::DenseStorage::data	../include/Eigen/src/Core/DenseStorage.h	/^    inline const T *data() const { return m_data; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:() const
Eigen::DenseStorage::data	../include/Eigen/src/Core/DenseStorage.h	/^    inline T *data() { return 0; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::data	../include/Eigen/src/Core/DenseStorage.h	/^    inline T *data() { return m_data.array; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::data	../include/Eigen/src/Core/DenseStorage.h	/^    inline T *data() { return m_data; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex, DenseIndex, DenseIndex cols) : m_cols(cols) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex, DenseIndex cols)
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex,DenseIndex,DenseIndex)
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex, DenseIndex rows, DenseIndex cols) : m_rows(rows), m_cols(cols) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex rows, DenseIndex cols)
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex, DenseIndex rows, DenseIndex) : m_rows(rows) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex rows, DenseIndex)
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex size, DenseIndex, DenseIndex cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_cols(cols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex, DenseIndex cols)
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex size, DenseIndex rows, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex rows, DenseIndex cols)
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex size, DenseIndex rows, DenseIndex) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex rows, DenseIndex)
Eigen::DenseStorage::~DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::~DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::~DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(internal::constructor_without_unaligned_array_assert) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_rows(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:()
Eigen::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, 0, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen	inherits:DenseStorage
Eigen::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, Dynamic, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, 0, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen	inherits:DenseStorage
Eigen::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Cols, int _Options> class DenseStorage<T, 0, _Rows, _Cols, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, 0, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen	inherits:DenseStorage
Eigen::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, Dynamic, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Cols, int _Options> class DenseStorage<T, Size, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Options> class DenseStorage<T, Size, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage$/;"	c	namespace:Eigen
Eigen::DenseStorage	../include/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Options> class DenseStorage<T, Size, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
Eigen::DenseStorage::m_cols	../include/Eigen/src/Core/DenseStorage.h	/^    DenseIndex m_cols;$/;"	m	class:Eigen::DenseStorage	access:private
Eigen::DenseStorage::m_data	../include/Eigen/src/Core/DenseStorage.h	/^    internal::plain_array<T,Size,_Options> m_data;$/;"	m	class:Eigen::DenseStorage	access:private
Eigen::DenseStorage::m_data	../include/Eigen/src/Core/DenseStorage.h	/^    T *m_data;$/;"	m	class:Eigen::DenseStorage	access:private
Eigen::DenseStorage::m_rows	../include/Eigen/src/Core/DenseStorage.h	/^    DenseIndex m_rows;$/;"	m	class:Eigen::DenseStorage	access:private
Eigen::DenseStorage::resize	../include/Eigen/src/Core/DenseStorage.h	/^    EIGEN_STRONG_INLINE void resize(DenseIndex size, DenseIndex, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex, DenseIndex cols)
Eigen::DenseStorage::resize	../include/Eigen/src/Core/DenseStorage.h	/^    EIGEN_STRONG_INLINE void resize(DenseIndex size, DenseIndex rows, DenseIndex)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex rows, DenseIndex)
Eigen::DenseStorage::resize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void resize(DenseIndex, DenseIndex, DenseIndex cols) { m_cols = cols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex, DenseIndex cols)
Eigen::DenseStorage::resize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void resize(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex,DenseIndex,DenseIndex)
Eigen::DenseStorage::resize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void resize(DenseIndex, DenseIndex rows, DenseIndex cols) { m_rows = rows; m_cols = cols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex rows, DenseIndex cols)
Eigen::DenseStorage::resize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void resize(DenseIndex, DenseIndex rows, DenseIndex) { m_rows = rows; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex rows, DenseIndex)
Eigen::DenseStorage::resize	../include/Eigen/src/Core/DenseStorage.h	/^    void resize(DenseIndex size, DenseIndex rows, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex rows, DenseIndex cols)
Eigen::DenseStorage::rows	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseIndex rows(void) const {return m_rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
Eigen::DenseStorage::rows	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseIndex rows(void) const {return _Rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
Eigen::DenseStorage::rows	../include/Eigen/src/Core/DenseStorage.h	/^    static inline DenseIndex rows(void) {return _Rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void)
Eigen::DenseStorage::swap	../include/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& ) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& )
Eigen::DenseStorage::swap	../include/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& other)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
Eigen::DenseStorage::swap	../include/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
Eigen::DenseStorage::swap	../include/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
Eigen::DenseStorage::swap	../include/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
Eigen::DenseTimeSparseProduct::DenseTimeSparseProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    DenseTimeSparseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::DenseTimeSparseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::DenseTimeSparseProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^class DenseTimeSparseProduct$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::DenseTimeSparseProduct::operator =	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    DenseTimeSparseProduct& operator=(const DenseTimeSparseProduct&);$/;"	p	class:Eigen::DenseTimeSparseProduct	access:private	signature:(const DenseTimeSparseProduct&)
Eigen::DenseTimeSparseProduct::scaleAndAddTo	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	class:Eigen::DenseTimeSparseProduct	access:public	signature:(Dest& dest, Scalar alpha) const
Eigen::DenseTimeSparseSelfAdjointProduct::DenseTimeSparseSelfAdjointProduct	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    DenseTimeSparseSelfAdjointProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::DenseTimeSparseSelfAdjointProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::DenseTimeSparseSelfAdjointProduct	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class DenseTimeSparseSelfAdjointProduct$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::DenseTimeSparseSelfAdjointProduct::operator =	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    DenseTimeSparseSelfAdjointProduct& operator=(const DenseTimeSparseSelfAdjointProduct&);$/;"	p	class:Eigen::DenseTimeSparseSelfAdjointProduct	access:private	signature:(const DenseTimeSparseSelfAdjointProduct&)
Eigen::DenseTimeSparseSelfAdjointProduct::scaleAndAddTo	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename Dest> void scaleAndAddTo(Dest& \/*dest*\/, Scalar \/*alpha*\/) const$/;"	f	class:Eigen::DenseTimeSparseSelfAdjointProduct	access:public	signature:(Dest& , Scalar ) const
EIGEN_DEPRECATED	../include/Eigen/src/Core/util/Macros.h	239;"	d
EIGEN_DETERMINANT_H	../include/Eigen/src/LU/Determinant.h	26;"	d
Eigen::DiagonalBase::addTo	../include/Eigen/src/Core/DiagonalMatrix.h	/^    void addTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
Eigen::DiagonalBase::ColsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^      ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon279
Eigen::DiagonalBase::cols	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline Index cols() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
Eigen::DiagonalBase::DenseMatrixType	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime, 0, MaxRowsAtCompileTime, MaxColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::DenseType	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::derived	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
Eigen::DiagonalBase::derived	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:()
Eigen::DiagonalBase::diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
Eigen::DiagonalBase::diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:()
Eigen::DiagonalBase::DiagonalVectorType	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::evalTo	../include/Eigen/src/Core/DiagonalMatrix.h	/^void DiagonalBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase	signature:(MatrixBase<DenseDerived> &other) const
Eigen::DiagonalBase::evalTo	../include/Eigen/src/Core/DiagonalMatrix.h	/^    void evalTo(MatrixBase<DenseDerived> &other) const;$/;"	p	class:Eigen::DiagonalBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
Eigen::DiagonalBase::Flags	../include/Eigen/src/Core/DiagonalMatrix.h	/^      Flags = 0$/;"	e	enum:Eigen::DiagonalBase::__anon279
Eigen::DiagonalBase	../include/Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::DiagonalBase::Index	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::inverse	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inverse() const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
Eigen::DiagonalBase::isApprox	../include/Eigen/src/Core/DiagonalMatrix.h	/^    bool isApprox(const DiagonalBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(const DiagonalBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
Eigen::DiagonalBase::isApprox	../include/Eigen/src/Core/DiagonalMatrix.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
Eigen::DiagonalBase::IsVectorAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^      IsVectorAtCompileTime = 0,$/;"	e	enum:Eigen::DiagonalBase::__anon279
Eigen::DiagonalBase::MaxColsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^      MaxColsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon279
Eigen::DiagonalBase::MaxRowsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^      MaxRowsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon279
Eigen::DiagonalBase::operator *	../include/Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const MatrixBase<MatrixDerived> &matrix) const;$/;"	p	class:Eigen::DiagonalBase	access:public	signature:(const MatrixBase<MatrixDerived> &matrix) const
Eigen::DiagonalBase::operator *	../include/Eigen/src/Core/DiagonalProduct.h	/^DiagonalBase<DiagonalDerived>::operator*(const MatrixBase<MatrixDerived> &matrix) const$/;"	f	class:Eigen::DiagonalBase	signature:(const MatrixBase<MatrixDerived> &matrix) const
Eigen::DiagonalBase::PlainObject	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalMatrix<Scalar,DiagonalVectorType::SizeAtCompileTime,DiagonalVectorType::MaxSizeAtCompileTime> PlainObject;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::RowsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^      RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon279
Eigen::DiagonalBase::rows	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline Index rows() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
Eigen::DiagonalBase::Scalar	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::StorageKind	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalBase	access:public
Eigen::DiagonalBase::subTo	../include/Eigen/src/Core/DiagonalMatrix.h	/^    void subTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
Eigen::DiagonalBase::toDenseMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return derived(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
EIGEN_DIAGONAL_H	../include/Eigen/src/Core/Diagonal.h	27;"	d
Eigen::DiagonalMatrix::diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:() const
Eigen::DiagonalMatrix::diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
Eigen::DiagonalMatrix::DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    explicit inline DiagonalMatrix(const MatrixBase<OtherDerived>& other) : m_diagonal(other)$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::DiagonalMatrix::DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalBase<OtherDerived>& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalBase<OtherDerived>& other)
Eigen::DiagonalMatrix::DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalMatrix& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalMatrix& other)
Eigen::DiagonalMatrix::DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y, const Scalar& z) : m_diagonal(x,y,z) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z)
Eigen::DiagonalMatrix::DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y) : m_diagonal(x,y) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::DiagonalMatrix::DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix() {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
Eigen::DiagonalMatrix::DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(Index dim) : m_diagonal(dim) {}$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index dim)
Eigen::DiagonalMatrix::DiagonalVectorType	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalMatrix	access:public
EIGEN_DIAGONALMATRIX_H	../include/Eigen/src/Core/DiagonalMatrix.h	27;"	d
Eigen::DiagonalMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalMatrix$/;"	c	namespace:Eigen	inherits:DiagonalBase
Eigen::DiagonalMatrix::Index	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::Index Index;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Eigen::DiagonalMatrix::m_diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalVectorType m_diagonal;$/;"	m	class:Eigen::DiagonalMatrix	access:protected
Eigen::DiagonalMatrix::Nested	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef const DiagonalMatrix& Nested;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Eigen::DiagonalMatrix::operator =	../include/Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalBase<OtherDerived>& other)
Eigen::DiagonalMatrix::operator =	../include/Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalMatrix& other)$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalMatrix& other)
Eigen::DiagonalMatrix::resize	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline void resize(Index size) { m_diagonal.resize(size); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index size)
Eigen::DiagonalMatrix::Scalar	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Eigen::DiagonalMatrix::setIdentity	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setIdentity(Index size) { m_diagonal.setOnes(size); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index size)
Eigen::DiagonalMatrix::setIdentity	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setIdentity() { m_diagonal.setOnes(); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
Eigen::DiagonalMatrix::setZero	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setZero(Index size) { m_diagonal.setZero(size); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index size)
Eigen::DiagonalMatrix::setZero	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setZero() { m_diagonal.setZero(); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
Eigen::DiagonalMatrix::StorageKind	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Eigen::DiagonalPreconditioner::analyzePattern	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& analyzePattern(const MatrixType& )$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatrixType& )
Eigen::DiagonalPreconditioner::cols	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index cols() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:() const
Eigen::DiagonalPreconditioner::compute	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& compute(const MatrixType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatrixType& mat)
Eigen::DiagonalPreconditioner::DiagonalPreconditioner	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner(const MatrixType& mat) : m_invdiag(mat.cols())$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatrixType& mat)
Eigen::DiagonalPreconditioner::DiagonalPreconditioner	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner() : m_isInitialized(false) {}$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:()
Eigen::DiagonalPreconditioner::factorize	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& factorize(const MatrixType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatrixType& mat)
Eigen::DiagonalPreconditioner	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class DiagonalPreconditioner$/;"	c	namespace:Eigen
Eigen::DiagonalPreconditioner::Index	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef typename Vector::Index Index;$/;"	t	class:Eigen::DiagonalPreconditioner	access:private
Eigen::DiagonalPreconditioner::MatrixType	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::DiagonalPreconditioner	access:public
Eigen::DiagonalPreconditioner::m_invdiag	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Vector m_invdiag;$/;"	m	class:Eigen::DiagonalPreconditioner	access:protected
Eigen::DiagonalPreconditioner::m_isInitialized	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::DiagonalPreconditioner	access:protected
Eigen::DiagonalPreconditioner::rows	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index rows() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:() const
Eigen::DiagonalPreconditioner::Scalar	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalPreconditioner	access:private
Eigen::DiagonalPreconditioner::solve	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::DiagonalPreconditioner::_solve	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const Rhs& b, Dest& x) const
Eigen::DiagonalPreconditioner::Vector	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::DiagonalPreconditioner	access:private
Eigen::DiagonalProduct::Base	../include/Eigen/src/Core/DiagonalProduct.h	/^    typedef MatrixBase<DiagonalProduct> Base;$/;"	t	class:Eigen::DiagonalProduct	access:public
Eigen::DiagonalProduct::coeff	../include/Eigen/src/Core/DiagonalProduct.h	/^    const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(Index row, Index col) const
Eigen::DiagonalProduct::cols	../include/Eigen/src/Core/DiagonalProduct.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:() const
Eigen::DiagonalProduct::DiagonalProduct	../include/Eigen/src/Core/DiagonalProduct.h	/^    inline DiagonalProduct(const MatrixType& matrix, const DiagonalType& diagonal)$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(const MatrixType& matrix, const DiagonalType& diagonal)
EIGEN_DIAGONALPRODUCT_H	../include/Eigen/src/Core/DiagonalProduct.h	27;"	d
Eigen::DiagonalProduct	../include/Eigen/src/Core/DiagonalProduct.h	/^class DiagonalProduct : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,MatrixBase
Eigen::DiagonalProduct::m_diagonal	../include/Eigen/src/Core/DiagonalProduct.h	/^    typename DiagonalType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalProduct	access:protected
Eigen::DiagonalProduct::m_matrix	../include/Eigen/src/Core/DiagonalProduct.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::DiagonalProduct	access:protected
Eigen::DiagonalProduct::packet_impl	../include/Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet_impl(Index row, Index col, Index id, internal::false_type) const$/;"	f	class:Eigen::DiagonalProduct	access:protected	signature:(Index row, Index col, Index id, internal::false_type) const
Eigen::DiagonalProduct::packet_impl	../include/Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet_impl(Index row, Index col, Index id, internal::true_type) const$/;"	f	class:Eigen::DiagonalProduct	access:protected	signature:(Index row, Index col, Index id, internal::true_type) const
Eigen::DiagonalProduct::packet	../include/Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(Index row, Index col) const
Eigen::DiagonalProduct::rows	../include/Eigen/src/Core/DiagonalProduct.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:() const
Eigen::DiagonalWrapper::diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalWrapper	access:public	signature:() const
Eigen::DiagonalWrapper::DiagonalVectorType	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalWrapper	access:public
Eigen::DiagonalWrapper::DiagonalWrapper	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalWrapper(DiagonalVectorType& diagonal) : m_diagonal(diagonal) {}$/;"	f	class:Eigen::DiagonalWrapper	access:public	signature:(DiagonalVectorType& diagonal)
Eigen::DiagonalWrapper	../include/Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalWrapper$/;"	c	namespace:Eigen	inherits:DiagonalBase,internal::no_assignment_operator
Eigen::DiagonalWrapper::m_diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typename DiagonalVectorType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalWrapper	access:protected
Eigen::DiagonalWrapper::Nested	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalWrapper Nested;$/;"	t	class:Eigen::DiagonalWrapper	access:public
Eigen::DirectAccessBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int DirectAccessBit = 0x40;$/;"	m	namespace:Eigen
Eigen::DirectAccessors	../include/Eigen/src/Core/util/Constants.h	/^  DirectAccessors, $/;"	e	enum:Eigen::AccessorLevels
Eigen::DirectionType	../include/Eigen/src/Core/util/Constants.h	/^enum DirectionType { $/;"	g	namespace:Eigen
Eigen::DirectWriteAccessors	../include/Eigen/src/Core/util/Constants.h	/^  DirectWriteAccessors$/;"	e	enum:Eigen::AccessorLevels
EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT	../include/Eigen/src/Core/util/Macros.h	100;"	d
Eigen::DontAlignCols	../include/Eigen/src/Core/IO.h	/^enum { DontAlignCols = 1 };$/;"	e	enum:Eigen::__anon54
Eigen::DontAlign	../include/Eigen/src/Core/util/Constants.h	/^  DontAlign = 0x2$/;"	e	enum:Eigen::__anon212
EIGEN_DONT_ALIGN_STATICALLY	../include/Eigen/src/Core/util/Macros.h	86;"	d
EIGEN_DONT_INLINE	../include/Eigen/src/Core/util/Macros.h	162;"	d
EIGEN_DONT_INLINE	../include/Eigen/src/Core/util/Macros.h	164;"	d
EIGEN_DONT_INLINE	../include/Eigen/src/Core/util/Macros.h	166;"	d
EIGEN_DOT_H	../include/Eigen/src/Core/Dot.h	26;"	d
Eigen::Dynamic	../include/Eigen/src/Core/util/Constants.h	/^const int Dynamic = -1;$/;"	m	namespace:Eigen
Eigen::ei_abs2	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_abs2(const T& x) { return internal::abs2(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_abs	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_abs (const T& x) { return internal::abs(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_aligned_delete	../include/Eigen/src/Eigen2Support/Memory.h	/^template<typename T> inline void ei_aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen	signature:(T *ptr, size_t size)
Eigen::ei_aligned_free	../include/Eigen/src/Eigen2Support/Memory.h	/^inline void  ei_aligned_free(void *ptr) { internal::aligned_free(ptr); }$/;"	f	namespace:Eigen	signature:(void *ptr)
Eigen::ei_aligned_malloc	../include/Eigen/src/Eigen2Support/Memory.h	/^inline void* ei_aligned_malloc(size_t size) { return internal::aligned_malloc(size); }$/;"	f	namespace:Eigen	signature:(size_t size)
Eigen::ei_aligned_new	../include/Eigen/src/Eigen2Support/Memory.h	/^template<typename T> inline T* ei_aligned_new(size_t size)$/;"	f	namespace:Eigen	signature:(size_t size)
Eigen::ei_aligned_realloc	../include/Eigen/src/Eigen2Support/Memory.h	/^inline void* ei_aligned_realloc(void *ptr, size_t new_size, size_t old_size) { return internal::aligned_realloc(ptr, new_size, old_size); }$/;"	f	namespace:Eigen	signature:(void *ptr, size_t new_size, size_t old_size)
Eigen::ei_atan2	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_atan2(const T& x,const T& y) { return internal::atan2(x,y); }$/;"	f	namespace:Eigen	signature:(const T& x,const T& y)
Eigen::ei_cleantype	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T>   { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
Eigen::ei_cleantype	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T*>  { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
Eigen::ei_cleantype	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T&>  { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
Eigen::ei_cleantype	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T*>        { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
Eigen::ei_cleantype	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T&>        { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
Eigen::ei_cleantype	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_cleantype::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T>   { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
Eigen::ei_cleantype::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T*>  { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
Eigen::ei_cleantype::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T&>  { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
Eigen::ei_cleantype::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T*>        { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
Eigen::ei_cleantype::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T&>        { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
Eigen::ei_cleantype::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype { typedef T type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
Eigen::ei_conditional_aligned_free	../include/Eigen/src/Eigen2Support/Memory.h	/^template<bool Align> inline void ei_conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen	signature:(void *ptr)
Eigen::ei_conditional_aligned_malloc	../include/Eigen/src/Eigen2Support/Memory.h	/^template<bool Align> inline void* ei_conditional_aligned_malloc(size_t size)$/;"	f	namespace:Eigen	signature:(size_t size)
Eigen::ei_conditional_aligned_realloc	../include/Eigen/src/Eigen2Support/Memory.h	/^template<bool Align> inline void* ei_conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen	signature:(void* ptr, size_t new_size, size_t old_size)
Eigen::ei_conj	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_conj(const T& x) { return internal::conj(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_cos	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_cos (const T& x) { return internal::cos(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_exp	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_exp (const T& x) { return internal::exp(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::EigenBase::addTo	../include/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void addTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
Eigen::EigenBase::applyThisOnTheLeft	../include/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
Eigen::EigenBase::applyThisOnTheRight	../include/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
Eigen::EigenBase::cols	../include/Eigen/src/Core/EigenBase.h	/^  inline Index cols() const { return derived().cols(); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
Eigen::EigenBase::const_cast_derived	../include/Eigen/src/Core/EigenBase.h	/^  inline Derived& const_cast_derived() const$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
Eigen::EigenBase::const_derived	../include/Eigen/src/Core/EigenBase.h	/^  inline const Derived& const_derived() const$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
Eigen::EigenBase::derived	../include/Eigen/src/Core/EigenBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
Eigen::EigenBase::derived	../include/Eigen/src/Core/EigenBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:()
Eigen::EigenBase::evalTo	../include/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
EIGEN_EIGENBASE_H	../include/Eigen/src/Core/EigenBase.h	27;"	d
Eigen::EigenBase	../include/Eigen/src/Core/EigenBase.h	/^template<typename Derived> struct EigenBase$/;"	s	namespace:Eigen
Eigen::EigenBase::Index	../include/Eigen/src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::Index Index;$/;"	t	struct:Eigen::EigenBase	access:public
Eigen::EigenBase::rows	../include/Eigen/src/Core/EigenBase.h	/^  inline Index rows() const { return derived().rows(); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
Eigen::EigenBase::size	../include/Eigen/src/Core/EigenBase.h	/^  inline Index size() const { return rows() * cols(); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
Eigen::EigenBase::StorageKind	../include/Eigen/src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	struct:Eigen::EigenBase	access:public
Eigen::EigenBase::subTo	../include/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void subTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
Eigen::EigenSolver::ColsAtCompileTime	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon44
Eigen::EigenSolver::ColumnVectorType	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::ComplexScalar	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenSolver::compute	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver& compute(const MatrixType& matrix, bool computeEigenvectors = true);$/;"	p	class:Eigen::EigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
Eigen::EigenSolver::compute	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^EigenSolver<MatrixType>& EigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::EigenSolver	signature:(const MatrixType& matrix, bool computeEigenvectors)
Eigen::EigenSolver::doComputeEigenvectors	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    void doComputeEigenvectors();$/;"	p	class:Eigen::EigenSolver	access:private	signature:()
Eigen::EigenSolver::doComputeEigenvectors	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^void EigenSolver<MatrixType>::doComputeEigenvectors()$/;"	f	class:Eigen::EigenSolver	signature:()
Eigen::EigenSolver::EigenSolver	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::EigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
Eigen::EigenSolver::EigenSolver	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver(Index size)$/;"	f	class:Eigen::EigenSolver	access:public	signature:(Index size)
Eigen::EigenSolver::EigenSolver	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^ EigenSolver() : m_eivec(), m_eivalues(), m_isInitialized(false), m_realSchur(), m_matT(), m_tmp() {}$/;"	f	class:Eigen::EigenSolver	access:public	signature:()
Eigen::EigenSolver::eigenvalues	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::EigenSolver	access:public	signature:() const
Eigen::EigenSolver::EigenvalueType	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenSolver::eigenvectors	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenvectorsType eigenvectors() const;$/;"	p	class:Eigen::EigenSolver	access:public	signature:() const
Eigen::EigenSolver::eigenvectors	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^typename EigenSolver<MatrixType>::EigenvectorsType EigenSolver<MatrixType>::eigenvectors() const$/;"	f	class:Eigen::EigenSolver	signature:() const
Eigen::EigenSolver::EigenvectorsType	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::EigenSolver	access:public
EIGEN_EIGENSOLVER_H	../include/Eigen/src/Eigenvalues/EigenSolver.h	27;"	d
Eigen::EigenSolver	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^template<typename _MatrixType> class EigenSolver$/;"	c	namespace:Eigen
Eigen::EigenSolver::Index	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenSolver::info	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::EigenSolver	access:public	signature:() const
Eigen::EigenSolver::MatrixType	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenSolver::MaxColsAtCompileTime	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::EigenSolver::__anon44
Eigen::EigenSolver::MaxRowsAtCompileTime	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon44
Eigen::EigenSolver::m_eigenvectorsOk	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::m_eivalues	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::m_eivec	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::m_isInitialized	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::m_matT	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::m_realSchur	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    RealSchur<MatrixType> m_realSchur;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::m_tmp	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    ColumnVectorType m_tmp;$/;"	m	class:Eigen::EigenSolver	access:protected
Eigen::EigenSolver::Options	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::EigenSolver::__anon44
Eigen::EigenSolver::pseudoEigenvalueMatrix	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^MatrixType EigenSolver<MatrixType>::pseudoEigenvalueMatrix() const$/;"	f	class:Eigen::EigenSolver	signature:() const
Eigen::EigenSolver::pseudoEigenvalueMatrix	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType pseudoEigenvalueMatrix() const;$/;"	p	class:Eigen::EigenSolver	access:public	signature:() const
Eigen::EigenSolver::pseudoEigenvectors	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    const MatrixType& pseudoEigenvectors() const$/;"	f	class:Eigen::EigenSolver	access:public	signature:() const
Eigen::EigenSolver::RealScalar	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenSolver::RowsAtCompileTime	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon44
Eigen::EigenSolver::Scalar	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::EigenSolver	access:public
Eigen::EigenvaluesOnly	../include/Eigen/src/Core/util/Constants.h	/^  EigenvaluesOnly     = 0x40,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::EigVecMask	../include/Eigen/src/Core/util/Constants.h	/^  EigVecMask = EigenvaluesOnly | ComputeEigenvectors,$/;"	e	enum:Eigen::DecompositionOptions
Eigen::ei_handmade_aligned_free	../include/Eigen/src/Eigen2Support/Memory.h	/^inline void  ei_handmade_aligned_free(void *ptr) { internal::handmade_aligned_free(ptr); }$/;"	f	namespace:Eigen	signature:(void *ptr)
Eigen::ei_handmade_aligned_malloc	../include/Eigen/src/Eigen2Support/Memory.h	/^inline void* ei_handmade_aligned_malloc(size_t size) { return internal::handmade_aligned_malloc(size); }$/;"	f	namespace:Eigen	signature:(size_t size)
Eigen::ei_imag	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_imag(const T& x) { return internal::imag(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_isApprox	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^inline bool ei_isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
Eigen::ei_isApproxOrLessThan	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^inline bool ei_isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
Eigen::ei_isMuchSmallerThan	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^inline bool ei_isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen	signature:(const Scalar& x, const OtherScalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
Eigen::ei_is_same_type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_is_same_type<T,T> { enum { ret = 1 }; };$/;"	s	namespace:Eigen
Eigen::ei_is_same_type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T, typename U> struct ei_is_same_type { enum { ret = 0 }; };$/;"	s	namespace:Eigen
Eigen::ei_is_same_type::ret	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_is_same_type<T,T> { enum { ret = 1 }; };$/;"	e	enum:Eigen::ei_is_same_type::__anon428
Eigen::ei_is_same_type::ret	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T, typename U> struct ei_is_same_type { enum { ret = 0 }; };$/;"	e	enum:Eigen::ei_is_same_type::__anon427
Eigen::ei_log	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_log (const T& x) { return internal::log(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_meta_false	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_false { enum { ret = 0 }; };$/;"	s	namespace:Eigen
Eigen::ei_meta_false::ret	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_false { enum { ret = 0 }; };$/;"	e	enum:Eigen::ei_meta_false::__anon426
Eigen::ei_meta_if	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if <false, Then, Else> { typedef Else ret; };$/;"	s	namespace:Eigen
Eigen::ei_meta_if	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if { typedef Then ret; };$/;"	s	namespace:Eigen
Eigen::ei_meta_if::ret	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if <false, Then, Else> { typedef Else ret; };$/;"	t	struct:Eigen::ei_meta_if	access:public
Eigen::ei_meta_if::ret	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if { typedef Then ret; };$/;"	t	struct:Eigen::ei_meta_if	access:public
Eigen::ei_meta_true	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_true {  enum { ret = 1 }; };$/;"	s	namespace:Eigen
Eigen::ei_meta_true::ret	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_true {  enum { ret = 1 }; };$/;"	e	enum:Eigen::ei_meta_true::__anon425
Eigen::ei_pow	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_pow (const T& x,const T& y) { return internal::pow(x,y); }$/;"	f	namespace:Eigen	signature:(const T& x,const T& y)
Eigen::ei_quaternion_assign_impl	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^struct ei_quaternion_assign_impl<Other,3,3>$/;"	s	namespace:Eigen
Eigen::ei_quaternion_assign_impl	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^struct ei_quaternion_assign_impl<Other,4,1>$/;"	s	namespace:Eigen
Eigen::ei_quaternion_assign_impl::run	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  static inline void run(Quaternion<Scalar>& q, const Other& mat)$/;"	f	struct:Eigen::ei_quaternion_assign_impl	access:public	signature:(Quaternion<Scalar>& q, const Other& mat)
Eigen::ei_quaternion_assign_impl::run	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  static inline void run(Quaternion<Scalar>& q, const Other& vec)$/;"	f	struct:Eigen::ei_quaternion_assign_impl	access:public	signature:(Quaternion<Scalar>& q, const Other& vec)
Eigen::ei_quaternion_assign_impl::Scalar	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::ei_quaternion_assign_impl	access:public
Eigen::ei_quaternion_product	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^ei_quaternion_product(const Quaternion<Scalar>& a, const Quaternion<Scalar>& b)$/;"	f	namespace:Eigen	signature:(const Quaternion<Scalar>& a, const Quaternion<Scalar>& b)
Eigen::ei_random	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_random (const T& x, const T& y) { return internal::random(x, y); }$/;"	f	namespace:Eigen	signature:(const T& x, const T& y)
Eigen::ei_random	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_random () { return internal::random<T>(); }$/;"	f	namespace:Eigen	signature:()
Eigen::ei_real	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_real(const T& x) { return internal::real(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_sin	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_sin (const T& x) { return internal::sin(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_sqrt	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_sqrt(const T& x) { return internal::sqrt(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
Eigen::ei_toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^static inline const MatrixBase<OtherDerived>& ei_toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen	signature:(const MatrixBase<OtherDerived>& mat)
Eigen::ei_toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^static inline Matrix<Scalar,2,2> ei_toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen	signature:(const Scalar& s)
Eigen::ei_toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^static inline Matrix<Scalar,Dim,Dim> ei_toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen	signature:(const RotationBase<OtherDerived,Dim>& r)
Eigen::ei_traits	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^template<typename _Scalar> struct ei_traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen
Eigen::ei_traits	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^template<typename _Scalar> struct ei_traits<Quaternion<_Scalar> >$/;"	s	namespace:Eigen
Eigen::ei_traits	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^template<typename _Scalar> struct ei_traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen
Eigen::ei_traits	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_traits : internal::traits<T>$/;"	s	namespace:Eigen	inherits:internal::traits
Eigen::ei_traits::Scalar	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits	access:public
Eigen::ei_traits::Scalar	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits	access:public
Eigen::ei_traits::Scalar	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits	access:public
Eigen::ei_transform_product_impl	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, Dim,1>$/;"	s	namespace:Eigen
Eigen::ei_transform_product_impl	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen
Eigen::ei_transform_product_impl	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, HDim,1>$/;"	s	namespace:Eigen
Eigen::ei_transform_product_impl	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen
Eigen::ei_transform_product_impl::MatrixType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::ResultType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::ResultType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::ResultType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef typename ProductReturnType<MatrixType,Other>::Type ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::run	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  static ResultType run(const TransformType& tr, const Other& other)$/;"	f	struct:Eigen::ei_transform_product_impl	access:public	signature:(const TransformType& tr, const Other& other)
Eigen::ei_transform_product_impl::Scalar	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::TransformType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_transform_product_impl::TransformType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim> TransformType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Eigen::ei_unconst	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<const T> { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unconst	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const *> { typedef T * type; };$/;"	s	namespace:Eigen
Eigen::ei_unconst	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const &> { typedef T & type; };$/;"	s	namespace:Eigen
Eigen::ei_unconst	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unconst::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<const T> { typedef T type; };$/;"	t	struct:Eigen::ei_unconst	access:public
Eigen::ei_unconst::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const *> { typedef T * type; };$/;"	t	struct:Eigen::ei_unconst	access:public
Eigen::ei_unconst::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const &> { typedef T & type; };$/;"	t	struct:Eigen::ei_unconst	access:public
Eigen::ei_unconst::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst { typedef T type; };$/;"	t	struct:Eigen::ei_unconst	access:public
Eigen::ei_unpointer	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unpointer	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*> { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unpointer	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unpointer::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer	access:public
Eigen::ei_unpointer::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*> { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer	access:public
Eigen::ei_unpointer::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer	access:public
Eigen::ei_unref	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref<T&> { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unref	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref { typedef T type; };$/;"	s	namespace:Eigen
Eigen::ei_unref::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref<T&> { typedef T type; };$/;"	t	struct:Eigen::ei_unref	access:public
Eigen::ei_unref::type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref { typedef T type; };$/;"	t	struct:Eigen::ei_unref	access:public
EIGEN_EMPTY	../include/Eigen/src/Core/util/Macros.h	314;"	d
EIGEN_EMPTY_STRUCT_CTOR	../include/Eigen/src/Core/util/XprHelper.h	33;"	d
EIGEN_EMPTY_STRUCT_CTOR	../include/Eigen/src/Core/util/XprHelper.h	37;"	d
EIGEN_EULERANGLES_H	../include/Eigen/src/Geometry/EulerAngles.h	26;"	d
Eigen::EvalBeforeAssigningBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int EvalBeforeAssigningBit = 0x4;$/;"	m	namespace:Eigen
Eigen::EvalBeforeNestingBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int EvalBeforeNestingBit = 0x2;$/;"	m	namespace:Eigen
EIGEN_EXPLICIT_STL_DEQUE_INSTANTIATION	../include/Eigen/src/StlSupport/StdDeque.h	33;"	d
EIGEN_EXPLICIT_STL_DEQUE_INSTANTIATION	../include/Eigen/src/StlSupport/StdDeque.h	35;"	d
EIGEN_EXPLICIT_STL_LIST_INSTANTIATION	../include/Eigen/src/StlSupport/StdList.h	32;"	d
EIGEN_EXPLICIT_STL_LIST_INSTANTIATION	../include/Eigen/src/StlSupport/StdList.h	34;"	d
EIGEN_FAST_MATH	../include/Eigen/src/Core/util/Macros.h	120;"	d
Eigen::fitHyperplane	../include/Eigen/src/Eigen2Support/LeastSquares.h	/^void fitHyperplane(int numPoints,$/;"	f	namespace:Eigen	signature:(int numPoints, VectorType **points, HyperplaneType *result, typename NumTraits<typename VectorType::Scalar>::Real* soundness = 0)
Eigen::Flagged::Base	../include/Eigen/src/Core/Flagged.h	/^    typedef MatrixBase<Flagged> Base;$/;"	t	class:Eigen::Flagged	access:public
Eigen::Flagged::coeff	../include/Eigen/src/Core/Flagged.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index) const
Eigen::Flagged::coeff	../include/Eigen/src/Core/Flagged.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col) const
Eigen::Flagged::coeffRef	../include/Eigen/src/Core/Flagged.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index) const
Eigen::Flagged::coeffRef	../include/Eigen/src/Core/Flagged.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col) const
Eigen::Flagged::coeffRef	../include/Eigen/src/Core/Flagged.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index)
Eigen::Flagged::coeffRef	../include/Eigen/src/Core/Flagged.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col)
Eigen::Flagged::cols	../include/Eigen/src/Core/Flagged.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
Eigen::Flagged::_expression	../include/Eigen/src/Core/Flagged.h	/^    const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
Eigen::Flagged::ExpressionTypeNested	../include/Eigen/src/Core/Flagged.h	/^        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::Flagged	access:public
Eigen::Flagged::Flagged	../include/Eigen/src/Core/Flagged.h	/^    inline Flagged(const ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Flagged	access:public	signature:(const ExpressionType& matrix)
EIGEN_FLAGGED_H	../include/Eigen/src/Core/Flagged.h	26;"	d
Eigen::Flagged	../include/Eigen/src/Core/Flagged.h	/^template<typename ExpressionType, unsigned int Added, unsigned int Removed> class Flagged$/;"	c	namespace:Eigen	inherits:MatrixBase
Eigen::Flagged::InnerIterator	../include/Eigen/src/Core/Flagged.h	/^    typedef typename ExpressionType::InnerIterator InnerIterator;$/;"	t	class:Eigen::Flagged	access:public
Eigen::Flagged::innerStride	../include/Eigen/src/Core/Flagged.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
Eigen::Flagged::m_matrix	../include/Eigen/src/Core/Flagged.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::Flagged	access:protected
Eigen::Flagged::outerStride	../include/Eigen/src/Core/Flagged.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
Eigen::Flagged::packet	../include/Eigen/src/Core/Flagged.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index) const
Eigen::Flagged::packet	../include/Eigen/src/Core/Flagged.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col) const
Eigen::Flagged::rows	../include/Eigen/src/Core/Flagged.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
Eigen::Flagged::solveTriangular	../include/Eigen/src/Core/Flagged.h	/^    typename ExpressionType::PlainObject solveTriangular(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Flagged	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Flagged::solveTriangular	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^Flagged<ExpressionType,Added,Removed>::solveTriangular(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::Flagged	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Flagged::solveTriangularInPlace	../include/Eigen/src/Core/Flagged.h	/^    void solveTriangularInPlace(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Flagged	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Flagged::solveTriangularInPlace	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^void Flagged<ExpressionType,Added,Removed>::solveTriangularInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::Flagged	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::Flagged::writePacket	../include/Eigen/src/Core/Flagged.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index, const PacketScalar& x)
Eigen::Flagged::writePacket	../include/Eigen/src/Core/Flagged.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col, const PacketScalar& x)
EIGEN_FLATTEN_ATTRIB	../include/Eigen/src/Core/util/Macros.h	134;"	d
EIGEN_FLATTEN_ATTRIB	../include/Eigen/src/Core/util/Macros.h	136;"	d
Eigen::ForceAlignedAccess::Base	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    typedef typename internal::dense_xpr_base<ForceAlignedAccess>::type Base;$/;"	t	class:Eigen::ForceAlignedAccess	access:public
Eigen::ForceAlignedAccess::coeff	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index) const
Eigen::ForceAlignedAccess::coeff	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col) const
Eigen::ForceAlignedAccess::coeffRef	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index)
Eigen::ForceAlignedAccess::coeffRef	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col)
Eigen::ForceAlignedAccess::cols	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
Eigen::ForceAlignedAccess::ForceAlignedAccess	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline ForceAlignedAccess(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(const ExpressionType& matrix)
EIGEN_FORCEALIGNEDACCESS_H	../include/Eigen/src/Core/ForceAlignedAccess.h	26;"	d
Eigen::ForceAlignedAccess	../include/Eigen/src/Core/ForceAlignedAccess.h	/^template<typename ExpressionType> class ForceAlignedAccess$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::ForceAlignedAccess::innerStride	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
Eigen::ForceAlignedAccess::m_expression	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    const ExpressionType& m_expression;$/;"	m	class:Eigen::ForceAlignedAccess	access:protected
Eigen::ForceAlignedAccess::operator const ExpressionType&	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
Eigen::ForceAlignedAccess::operator =	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    ForceAlignedAccess& operator=(const ForceAlignedAccess&);$/;"	p	class:Eigen::ForceAlignedAccess	access:private	signature:(const ForceAlignedAccess&)
Eigen::ForceAlignedAccess::outerStride	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
Eigen::ForceAlignedAccess::packet	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index) const
Eigen::ForceAlignedAccess::packet	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col) const
Eigen::ForceAlignedAccess::rows	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
Eigen::ForceAlignedAccess::writePacket	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index, const PacketScalar& x)
Eigen::ForceAlignedAccess::writePacket	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col, const PacketScalar& x)
EIGEN_FORWARDDECLARATIONS_H	../include/Eigen/src/Core/util/ForwardDeclarations.h	27;"	d
EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED	../include/Eigen/src/Core/util/Memory.h	56;"	d
EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED	../include/Eigen/src/Core/util/Memory.h	58;"	d
Eigen::FullPivHouseholderQR::absDeterminant	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typename MatrixType::RealScalar absDeterminant() const;$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::absDeterminant	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR	signature:() const
Eigen::FullPivHouseholderQR::ColsAtCompileTime	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon6
Eigen::FullPivHouseholderQR::cols	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::colsPermutation	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::ColVectorType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::compute	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& compute(const MatrixType& matrix);$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
Eigen::FullPivHouseholderQR::compute	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^FullPivHouseholderQR<MatrixType>& FullPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR	signature:(const MatrixType& matrix)
Eigen::FullPivHouseholderQR::dimensionOfKernel	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::FullPivHouseholderQR	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
Eigen::FullPivHouseholderQR::FullPivHouseholderQR	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR()$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:()
Eigen::FullPivHouseholderQR::FullPivHouseholderQR	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(Index rows, Index cols)
Eigen::FullPivHouseholderQR::hCoeffs	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::HCoeffsType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename _MatrixType> class FullPivHouseholderQR$/;"	c	namespace:Eigen
Eigen::FullPivHouseholderQR::Index	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::IntColVectorType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::IntRowVectorType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef Matrix<Index, 1, ColsAtCompileTime, RowMajor, 1, MaxColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::inverse	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inverse() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::isInjective	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::isInvertible	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::isSurjective	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::logAbsDeterminant	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR	signature:() const
Eigen::FullPivHouseholderQR::logAbsDeterminant	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typename MatrixType::RealScalar logAbsDeterminant() const;$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::matrixQ	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^inline typename FullPivHouseholderQR<MatrixType>::MatrixQReturnType FullPivHouseholderQR<MatrixType>::matrixQ() const$/;"	f	class:Eigen::FullPivHouseholderQR	signature:() const
Eigen::FullPivHouseholderQR::matrixQ	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    MatrixQReturnType matrixQ(void) const;$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:(void) const
Eigen::FullPivHouseholderQR::MatrixQReturnType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef internal::FullPivHouseholderQRMatrixQReturnType<MatrixType> MatrixQReturnType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::matrixQR	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::MatrixType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::MaxColsAtCompileTime	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon6
Eigen::FullPivHouseholderQR::maxPivot	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::MaxRowsAtCompileTime	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon6
Eigen::FullPivHouseholderQR::m_cols_permutation	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    PermutationType m_cols_permutation;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_cols_transpositions	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    IntRowVectorType m_cols_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_det_pq	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_hCoeffs	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_isInitialized	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_maxpivot	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_nonzero_pivots	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_precision	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_precision;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_prescribedThreshold	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_qr	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_rows_transpositions	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    IntColVectorType m_rows_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_temp	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::m_usePrescribedThreshold	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
Eigen::FullPivHouseholderQR::nonzeroPivots	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::Options	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon6
Eigen::FullPivHouseholderQR::PermutationType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQRPreconditioner	../include/Eigen/src/Core/util/Constants.h	/^  FullPivHouseholderQRPreconditioner$/;"	e	enum:Eigen::QRPreconditioners
Eigen::FullPivHouseholderQR::rank	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::RealScalar	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::RowsAtCompileTime	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon6
Eigen::FullPivHouseholderQR::rows	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::rowsTranspositions	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    const IntColVectorType& rowsTranspositions() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivHouseholderQR::RowVectorType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::Scalar	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Eigen::FullPivHouseholderQR::setThreshold	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(const RealScalar& threshold)
Eigen::FullPivHouseholderQR::setThreshold	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(Default_t)
Eigen::FullPivHouseholderQR::solve	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::FullPivHouseholderQR::threshold	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Eigen::FullPivLU::ColsAtCompileTime	../include/Eigen/src/LU/FullPivLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon395
Eigen::FullPivLU::cols	../include/Eigen/src/LU/FullPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::compute	../include/Eigen/src/LU/FullPivLU.h	/^    FullPivLU& compute(const MatrixType& matrix);$/;"	p	class:Eigen::FullPivLU	access:public	signature:(const MatrixType& matrix)
Eigen::FullPivLU::compute	../include/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>& FullPivLU<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivLU	signature:(const MatrixType& matrix)
Eigen::FullPivLU::determinant	../include/Eigen/src/LU/FullPivLU.h	/^    typename internal::traits<MatrixType>::Scalar determinant() const;$/;"	p	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::determinant	../include/Eigen/src/LU/FullPivLU.h	/^typename internal::traits<MatrixType>::Scalar FullPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::FullPivLU	signature:() const
Eigen::FullPivLU::dimensionOfKernel	../include/Eigen/src/LU/FullPivLU.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^    FullPivLU(const MatrixType& matrix);$/;"	p	class:Eigen::FullPivLU	access:public	signature:(const MatrixType& matrix)
Eigen::FullPivLU::FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^    FullPivLU(Index rows, Index cols);$/;"	p	class:Eigen::FullPivLU	access:public	signature:(Index rows, Index cols)
Eigen::FullPivLU::FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivLU	signature:(const MatrixType& matrix)
Eigen::FullPivLU::FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU()$/;"	f	class:Eigen::FullPivLU	signature:()
Eigen::FullPivLU::FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(Index rows, Index cols)$/;"	f	class:Eigen::FullPivLU	signature:(Index rows, Index cols)
Eigen::FullPivLU::FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^    FullPivLU();$/;"	p	class:Eigen::FullPivLU	access:public	signature:()
Eigen::FullPivLU::image	../include/Eigen/src/LU/FullPivLU.h	/^      image(const MatrixType& originalMatrix) const$/;"	f	class:Eigen::FullPivLU	access:public	signature:(const MatrixType& originalMatrix) const
Eigen::FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^template<typename _MatrixType> class FullPivLU$/;"	c	namespace:Eigen
Eigen::FullPivLU::Index	../include/Eigen/src/LU/FullPivLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::IntColVectorType	../include/Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::IntRowVectorType	../include/Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::inverse	../include/Eigen/src/LU/FullPivLU.h	/^    inline const internal::solve_retval<FullPivLU,typename MatrixType::IdentityReturnType> inverse() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::isInjective	../include/Eigen/src/LU/FullPivLU.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::isInvertible	../include/Eigen/src/LU/FullPivLU.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::isSurjective	../include/Eigen/src/LU/FullPivLU.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::kernel	../include/Eigen/src/LU/FullPivLU.h	/^    inline const internal::kernel_retval<FullPivLU> kernel() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::matrixLU	../include/Eigen/src/LU/FullPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::MatrixType	../include/Eigen/src/LU/FullPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::MaxColsAtCompileTime	../include/Eigen/src/LU/FullPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivLU::__anon395
Eigen::FullPivLU::maxPivot	../include/Eigen/src/LU/FullPivLU.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::MaxRowsAtCompileTime	../include/Eigen/src/LU/FullPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon395
Eigen::FullPivLU::m_colsTranspositions	../include/Eigen/src/LU/FullPivLU.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_det_pq	../include/Eigen/src/LU/FullPivLU.h	/^    Index m_det_pq, m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_isInitialized	../include/Eigen/src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_lu	../include/Eigen/src/LU/FullPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_maxpivot	../include/Eigen/src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_nonzero_pivots	../include/Eigen/src/LU/FullPivLU.h	/^    Index m_det_pq, m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_p	../include/Eigen/src/LU/FullPivLU.h	/^    PermutationPType m_p;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_prescribedThreshold	../include/Eigen/src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_q	../include/Eigen/src/LU/FullPivLU.h	/^    PermutationQType m_q;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_rowsTranspositions	../include/Eigen/src/LU/FullPivLU.h	/^    IntColVectorType m_rowsTranspositions;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::m_usePrescribedThreshold	../include/Eigen/src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
Eigen::FullPivLU::nonzeroPivots	../include/Eigen/src/LU/FullPivLU.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::Options	../include/Eigen/src/LU/FullPivLU.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::FullPivLU::__anon395
Eigen::FullPivLU::permutationP	../include/Eigen/src/LU/FullPivLU.h	/^    inline const PermutationPType& permutationP() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::PermutationPType	../include/Eigen/src/LU/FullPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationPType;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::permutationQ	../include/Eigen/src/LU/FullPivLU.h	/^    inline const PermutationQType& permutationQ() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::PermutationQType	../include/Eigen/src/LU/FullPivLU.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationQType;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::rank	../include/Eigen/src/LU/FullPivLU.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::RealScalar	../include/Eigen/src/LU/FullPivLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::reconstructedMatrix	../include/Eigen/src/LU/FullPivLU.h	/^MatrixType FullPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::FullPivLU	signature:() const
Eigen::FullPivLU::reconstructedMatrix	../include/Eigen/src/LU/FullPivLU.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::RowsAtCompileTime	../include/Eigen/src/LU/FullPivLU.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon395
Eigen::FullPivLU::rows	../include/Eigen/src/LU/FullPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
Eigen::FullPivLU::Scalar	../include/Eigen/src/LU/FullPivLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::setThreshold	../include/Eigen/src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivLU	access:public	signature:(const RealScalar& threshold)
Eigen::FullPivLU::setThreshold	../include/Eigen/src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivLU	access:public	signature:(Default_t)
Eigen::FullPivLU::solve	../include/Eigen/src/LU/FullPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivLU	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::FullPivLU::StorageKind	../include/Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;$/;"	t	class:Eigen::FullPivLU	access:public
Eigen::FullPivLU::threshold	../include/Eigen/src/LU/FullPivLU.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
EIGEN_FULLPIVOTINGHOUSEHOLDERQR_H	../include/Eigen/src/QR/FullPivHouseholderQR.h	27;"	d
Eigen::FullPrecision	../include/Eigen/src/Core/IO.h	/^       FullPrecision = -2 };$/;"	e	enum:Eigen::__anon55
EIGEN_FUNCTORS_H	../include/Eigen/src/Core/Functors.h	26;"	d
EIGEN_FUZZY_H	../include/Eigen/src/Core/Fuzzy.h	27;"	d
EIGEN_GCC3_OR_OLDER	../include/Eigen/src/Core/util/Macros.h	56;"	d
EIGEN_GCC3_OR_OLDER	../include/Eigen/src/Core/util/Macros.h	58;"	d
EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT	../include/Eigen/src/Core/util/Macros.h	69;"	d
EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT	../include/Eigen/src/Core/util/Macros.h	71;"	d
Eigen::GemmProduct	../include/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon215
Eigen::GemvProduct	../include/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon215
Eigen::GenEigMask	../include/Eigen/src/Core/util/Constants.h	/^  GenEigMask = Ax_lBx | ABx_lx | BAx_lx$/;"	e	enum:Eigen::DecompositionOptions
EIGEN_GENERAL_BLOCK_PANEL_H	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	26;"	d
Eigen::GeneralizedSelfAdjointEigenSolver::Base	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef SelfAdjointEigenSolver<_MatrixType> Base;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:private
Eigen::GeneralizedSelfAdjointEigenSolver::compute	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^compute(const MatrixType& matA, const MatrixType& matB, int options)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	signature:(const MatrixType& matA, const MatrixType& matB, int options)
Eigen::GeneralizedSelfAdjointEigenSolver::compute	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver& compute(const MatrixType& matA, const MatrixType& matB,$/;"	p	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, int options = ComputeEigenvectors|Ax_lBx)
Eigen::GeneralizedSelfAdjointEigenSolver::GeneralizedSelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver() : Base() {}$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:()
Eigen::GeneralizedSelfAdjointEigenSolver::GeneralizedSelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB,$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, int options = ComputeEigenvectors|Ax_lBx)
Eigen::GeneralizedSelfAdjointEigenSolver::GeneralizedSelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:(Index size)
EIGEN_GENERALIZEDSELFADJOINTEIGENSOLVER_H	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	27;"	d
Eigen::GeneralizedSelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^class GeneralizedSelfAdjointEigenSolver : public SelfAdjointEigenSolver<_MatrixType>$/;"	c	namespace:Eigen	inherits:SelfAdjointEigenSolver
Eigen::GeneralizedSelfAdjointEigenSolver::Index	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public
Eigen::GeneralizedSelfAdjointEigenSolver::MatrixType	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public
EIGEN_GENERAL_MATRIX_MATRIX_H	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	26;"	d
EIGEN_GENERAL_MATRIX_MATRIX_MKL_H	../include/Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	34;"	d
EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_H	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	26;"	d
EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_MKL_H	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	34;"	d
EIGEN_GENERAL_MATRIX_VECTOR_H	../include/Eigen/src/Core/products/GeneralMatrixVector.h	26;"	d
EIGEN_GENERAL_MATRIX_VECTOR_MKL_H	../include/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	34;"	d
Eigen::GeneralProduct::Base	../include/Eigen/src/Core/GeneralProduct.h	/^    typedef Matrix<typename internal::scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType,1,1> Base;$/;"	t	class:Eigen::GeneralProduct	access:private
Eigen::GeneralProduct::GeneralProduct	../include/Eigen/src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::GeneralProduct::GeneralProduct	../include/Eigen/src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::GeneralProduct::GeneralProduct	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
EIGEN_GENERAL_PRODUCT_H	../include/Eigen/src/Core/GeneralProduct.h	27;"	d
Eigen::GeneralProduct	../include/Eigen/src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, GemvProduct>$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::GeneralProduct	../include/Eigen/src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, InnerProduct>$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,Matrix
Eigen::GeneralProduct	../include/Eigen/src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, OuterProduct>$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::GeneralProduct	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class GeneralProduct<Lhs, Rhs, GemmProduct>$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::GeneralProduct::LhsScalar	../include/Eigen/src/Core/GeneralProduct.h	/^    typedef typename Lhs::Scalar LhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::LhsScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename  Lhs::Scalar LhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::MatrixType	../include/Eigen/src/Core/GeneralProduct.h	/^    typedef typename internal::conditional<int(Side)==OnTheRight,_LhsNested,_RhsNested>::type MatrixType;$/;"	t	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::MaxDepthAtCompileTime	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      MaxDepthAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(Lhs::MaxColsAtCompileTime,Rhs::MaxRowsAtCompileTime)$/;"	e	enum:Eigen::GeneralProduct::__anon109
Eigen::GeneralProduct::operator const typename Base::Scalar	../include/Eigen/src/Core/GeneralProduct.h	/^    operator const typename Base::Scalar() const {$/;"	f	class:Eigen::GeneralProduct	access:public	signature:() const
Eigen::GeneralProduct::ResScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef           Scalar      ResScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::RhsScalar	../include/Eigen/src/Core/GeneralProduct.h	/^    typedef typename Rhs::Scalar RhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::RhsScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename  Rhs::Scalar RhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
Eigen::GeneralProduct::scaleAndAddTo	../include/Eigen/src/Core/GeneralProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dest, Scalar alpha) const
Eigen::GeneralProduct::scaleAndAddTo	../include/Eigen/src/Core/GeneralProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dst, Scalar alpha) const
Eigen::GeneralProduct::scaleAndAddTo	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dst, Scalar alpha) const
Eigen::GeneralProduct::Side	../include/Eigen/src/Core/GeneralProduct.h	/^    enum { Side = Lhs::IsVectorAtCompileTime ? OnTheLeft : OnTheRight };$/;"	e	enum:Eigen::GeneralProduct::__anon147
Eigen::GenericNumTraits::AddCost	../include/Eigen/src/Core/NumTraits.h	/^    AddCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon277
Eigen::GenericNumTraits	../include/Eigen/src/Core/NumTraits.h	/^template<typename T> struct GenericNumTraits$/;"	s	namespace:Eigen
Eigen::GenericNumTraits::IsComplex	../include/Eigen/src/Core/NumTraits.h	/^    IsComplex = 0,$/;"	e	enum:Eigen::GenericNumTraits::__anon277
Eigen::GenericNumTraits::IsInteger	../include/Eigen/src/Core/NumTraits.h	/^    IsInteger = std::numeric_limits<T>::is_integer,$/;"	e	enum:Eigen::GenericNumTraits::__anon277
Eigen::GenericNumTraits::IsSigned	../include/Eigen/src/Core/NumTraits.h	/^    IsSigned = std::numeric_limits<T>::is_signed,$/;"	e	enum:Eigen::GenericNumTraits::__anon277
Eigen::GenericNumTraits::MulCost	../include/Eigen/src/Core/NumTraits.h	/^    MulCost = 1$/;"	e	enum:Eigen::GenericNumTraits::__anon277
Eigen::GenericNumTraits::ReadCost	../include/Eigen/src/Core/NumTraits.h	/^    ReadCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon277
Eigen::GenericNumTraits::Real	../include/Eigen/src/Core/NumTraits.h	/^  typedef T Real;$/;"	t	struct:Eigen::GenericNumTraits	access:public
Eigen::GenericNumTraits::RequireInitialization	../include/Eigen/src/Core/NumTraits.h	/^    RequireInitialization = internal::is_arithmetic<T>::value ? 0 : 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon277
EIGEN_GENERIC_PACKET_MATH_H	../include/Eigen/src/Core/GenericPacketMath.h	27;"	d
EIGEN_GENERIC_PUBLIC_INTERFACE	../include/Eigen/src/Core/util/Macros.h	340;"	d
EIGEN_GEOMETRY_SSE_H	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	27;"	d
Eigen::GetAction	../include/Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED	../include/Eigen/src/Core/util/Memory.h	46;"	d
EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED	../include/Eigen/src/Core/util/Memory.h	48;"	d
EIGEN_GLOBAL_FUNCTIONS_H	../include/Eigen/src/Core/GlobalFunctions.h	27;"	d
EIGEN_GNUC_AT_LEAST	../include/Eigen/src/Core/util/Macros.h	37;"	d
EIGEN_GNUC_AT_LEAST	../include/Eigen/src/Core/util/Macros.h	39;"	d
EIGEN_GNUC_AT_MOST	../include/Eigen/src/Core/util/Macros.h	43;"	d
EIGEN_GNUC_AT_MOST	../include/Eigen/src/Core/util/Macros.h	45;"	d
EIGEN_HAS_FUSE_CJMADD	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	37;"	d
EIGEN_HAS_MM_MALLOC	../include/Eigen/src/Core/util/Memory.h	78;"	d
EIGEN_HAS_MM_MALLOC	../include/Eigen/src/Core/util/Memory.h	80;"	d
EIGEN_HAS_POSIX_MEMALIGN	../include/Eigen/src/Core/util/Memory.h	72;"	d
EIGEN_HAS_POSIX_MEMALIGN	../include/Eigen/src/Core/util/Memory.h	74;"	d
Eigen::HereditaryBits	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int HereditaryBits = RowMajorBit$/;"	m	namespace:Eigen
Eigen::HessenbergDecomposition::CoeffVectorType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Eigen::HessenbergDecomposition::compute	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition& compute(const MatrixType& matrix)$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:(const MatrixType& matrix)
Eigen::HessenbergDecomposition::_compute	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    static void _compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp);$/;"	p	class:Eigen::HessenbergDecomposition	access:private	signature:(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)
Eigen::HessenbergDecomposition::_compute	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^void HessenbergDecomposition<MatrixType>::_compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)$/;"	f	class:Eigen::HessenbergDecomposition	signature:(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)
Eigen::HessenbergDecomposition::HessenbergDecomposition	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition(const MatrixType& matrix)$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:(const MatrixType& matrix)
Eigen::HessenbergDecomposition::HessenbergDecomposition	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:(Index size = Size==Dynamic ? 2 : Size)
EIGEN_HESSENBERGDECOMPOSITION_H	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	27;"	d
Eigen::HessenbergDecomposition::householderCoefficients	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const CoeffVectorType& householderCoefficients() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
Eigen::HessenbergDecomposition::HouseholderSequenceType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename HouseholderSequence<MatrixType,CoeffVectorType>::ConjugateReturnType HouseholderSequenceType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Eigen::HessenbergDecomposition	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^template<typename _MatrixType> class HessenbergDecomposition$/;"	c	namespace:Eigen
Eigen::HessenbergDecomposition::Index	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Eigen::HessenbergDecomposition::matrixH	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixHReturnType matrixH() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
Eigen::HessenbergDecomposition::MatrixHReturnType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef internal::HessenbergDecompositionMatrixHReturnType<MatrixType> MatrixHReturnType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Eigen::HessenbergDecomposition::matrixQ	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
Eigen::HessenbergDecomposition::MatrixType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Eigen::HessenbergDecomposition::MaxSize	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon45
Eigen::HessenbergDecomposition::MaxSizeMinusOne	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : MaxSize - 1$/;"	e	enum:Eigen::HessenbergDecomposition::__anon45
Eigen::HessenbergDecomposition::m_hCoeffs	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
Eigen::HessenbergDecomposition::m_isInitialized	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
Eigen::HessenbergDecomposition::m_matrix	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
Eigen::HessenbergDecomposition::m_temp	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    VectorType m_temp;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
Eigen::HessenbergDecomposition::Options	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon45
Eigen::HessenbergDecomposition::packedMatrix	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const MatrixType& packedMatrix() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
Eigen::HessenbergDecomposition::RealScalar	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::HessenbergDecomposition	access:private
Eigen::HessenbergDecomposition::Scalar	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Eigen::HessenbergDecomposition::Size	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon45
Eigen::HessenbergDecomposition::SizeMinusOne	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : Size - 1,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon45
Eigen::HessenbergDecomposition::VectorType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, 1, Size, Options | RowMajor, 1, MaxSize> VectorType;$/;"	t	class:Eigen::HessenbergDecomposition	access:private
Eigen::Homogeneous::Base	../include/Eigen/src/Geometry/Homogeneous.h	/^    typedef MatrixBase<Homogeneous> Base;$/;"	t	class:Eigen::Homogeneous	access:public
Eigen::Homogeneous::coeff	../include/Eigen/src/Geometry/Homogeneous.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Homogeneous	access:public	signature:(Index row, Index col) const
Eigen::Homogeneous::cols	../include/Eigen/src/Geometry/Homogeneous.h	/^    inline Index cols() const { return m_matrix.cols() + (int(Direction)==Horizontal ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous	access:public	signature:() const
Eigen::Homogeneous::Direction	../include/Eigen/src/Geometry/Homogeneous.h	/^    enum { Direction = _Direction };$/;"	e	enum:Eigen::Homogeneous::__anon391
EIGEN_HOMOGENEOUS_H	../include/Eigen/src/Geometry/Homogeneous.h	26;"	d
Eigen::Homogeneous::Homogeneous	../include/Eigen/src/Geometry/Homogeneous.h	/^    inline Homogeneous(const MatrixType& matrix)$/;"	f	class:Eigen::Homogeneous	access:public	signature:(const MatrixType& matrix)
Eigen::Homogeneous	../include/Eigen/src/Geometry/Homogeneous.h	/^template<typename MatrixType,int _Direction> class Homogeneous$/;"	c	namespace:Eigen	inherits:MatrixBase
Eigen::Homogeneous::m_matrix	../include/Eigen/src/Geometry/Homogeneous.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Homogeneous	access:protected
Eigen::Homogeneous::operator *	../include/Eigen/src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Lhs>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous	access:friend	signature:(const MatrixBase<Lhs>& lhs, const Homogeneous& rhs)
Eigen::Homogeneous::operator *	../include/Eigen/src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Rhs>& rhs) const$/;"	f	class:Eigen::Homogeneous	access:public	signature:(const MatrixBase<Rhs>& rhs) const
Eigen::Homogeneous::operator *	../include/Eigen/src/Geometry/Homogeneous.h	/^    operator* (const Transform<Scalar,Dim,Mode,Options>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous	access:friend	signature:(const Transform<Scalar,Dim,Mode,Options>& lhs, const Homogeneous& rhs)
Eigen::Homogeneous::rows	../include/Eigen/src/Geometry/Homogeneous.h	/^    inline Index rows() const { return m_matrix.rows() + (int(Direction)==Vertical   ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous	access:public	signature:() const
Eigen::Horizontal	../include/Eigen/src/Core/util/Constants.h	/^  Horizontal, $/;"	e	enum:Eigen::DirectionType
EIGEN_HOUSEHOLDER_H	../include/Eigen/src/Householder/Householder.h	27;"	d
Eigen::HouseholderQR::absDeterminant	../include/Eigen/src/QR/HouseholderQR.h	/^    typename MatrixType::RealScalar absDeterminant() const;$/;"	p	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::absDeterminant	../include/Eigen/src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::HouseholderQR	signature:() const
Eigen::HouseholderQR::ColsAtCompileTime	../include/Eigen/src/QR/HouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon5
Eigen::HouseholderQR::cols	../include/Eigen/src/QR/HouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::compute	../include/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR& compute(const MatrixType& matrix);$/;"	p	class:Eigen::HouseholderQR	access:public	signature:(const MatrixType& matrix)
Eigen::HouseholderQR::compute	../include/Eigen/src/QR/HouseholderQR.h	/^HouseholderQR<MatrixType>& HouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::HouseholderQR	signature:(const MatrixType& matrix)
Eigen::HouseholderQR::hCoeffs	../include/Eigen/src/QR/HouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::HCoeffsType	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::householderQ	../include/Eigen/src/QR/HouseholderQR.h	/^    HouseholderSequenceType householderQ() const$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::HouseholderQR	../include/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::HouseholderQR	access:public	signature:(const MatrixType& matrix)
Eigen::HouseholderQR::HouseholderQR	../include/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::HouseholderQR	access:public	signature:(Index rows, Index cols)
Eigen::HouseholderQR::HouseholderQR	../include/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR() : m_qr(), m_hCoeffs(), m_temp(), m_isInitialized(false) {}$/;"	f	class:Eigen::HouseholderQR	access:public	signature:()
Eigen::HouseholderQR::HouseholderSequenceType	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef typename HouseholderSequence<MatrixType,HCoeffsType>::ConjugateReturnType HouseholderSequenceType;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR	../include/Eigen/src/QR/HouseholderQR.h	/^template<typename _MatrixType> class HouseholderQR$/;"	c	namespace:Eigen
Eigen::HouseholderQR::Index	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::logAbsDeterminant	../include/Eigen/src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::HouseholderQR	signature:() const
Eigen::HouseholderQR::logAbsDeterminant	../include/Eigen/src/QR/HouseholderQR.h	/^    typename MatrixType::RealScalar logAbsDeterminant() const;$/;"	p	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::matrixQR	../include/Eigen/src/QR/HouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::MatrixQType	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, (MatrixType::Flags&RowMajorBit) ? RowMajor : ColMajor, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::MatrixType	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::MaxColsAtCompileTime	../include/Eigen/src/QR/HouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderQR::__anon5
Eigen::HouseholderQR::MaxRowsAtCompileTime	../include/Eigen/src/QR/HouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon5
Eigen::HouseholderQR::m_hCoeffs	../include/Eigen/src/QR/HouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::HouseholderQR	access:protected
Eigen::HouseholderQR::m_isInitialized	../include/Eigen/src/QR/HouseholderQR.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HouseholderQR	access:protected
Eigen::HouseholderQR::m_qr	../include/Eigen/src/QR/HouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::HouseholderQR	access:protected
Eigen::HouseholderQR::m_temp	../include/Eigen/src/QR/HouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::HouseholderQR	access:protected
Eigen::HouseholderQR::Options	../include/Eigen/src/QR/HouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HouseholderQR::__anon5
Eigen::HouseholderQRPreconditioner	../include/Eigen/src/Core/util/Constants.h	/^  HouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
Eigen::HouseholderQR::RealScalar	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::RowsAtCompileTime	../include/Eigen/src/QR/HouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon5
Eigen::HouseholderQR::rows	../include/Eigen/src/QR/HouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
Eigen::HouseholderQR::RowVectorType	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::Scalar	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HouseholderQR	access:public
Eigen::HouseholderQR::solve	../include/Eigen/src/QR/HouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::HouseholderQR	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::HouseholderSequence::adjoint	../include/Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType adjoint() const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::applyThisOnTheLeft	../include/Eigen/src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheLeft(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst, Workspace& workspace) const
Eigen::HouseholderSequence::applyThisOnTheLeft	../include/Eigen/src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst) const
Eigen::HouseholderSequence::applyThisOnTheRight	../include/Eigen/src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheRight(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst, Workspace& workspace) const
Eigen::HouseholderSequence::applyThisOnTheRight	../include/Eigen/src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst) const
Eigen::HouseholderSequence::ColsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^      ColsAtCompileTime = internal::traits<HouseholderSequence>::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon8
Eigen::HouseholderSequence::cols	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Index cols() const { return rows(); }$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::conjugate	../include/Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType conjugate() const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::ConjugateReturnType	../include/Eigen/src/Householder/HouseholderSequence.h	/^    > ConjugateReturnType;$/;"	t	class:Eigen::HouseholderSequence	access:public
Eigen::HouseholderSequence::essentialVector	../include/Eigen/src/Householder/HouseholderSequence.h	/^    const EssentialVectorType essentialVector(Index k) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Index k) const
Eigen::HouseholderSequence::EssentialVectorType	../include/Eigen/src/Householder/HouseholderSequence.h	/^            EssentialVectorType;$/;"	t	class:Eigen::HouseholderSequence	access:private
Eigen::HouseholderSequence::evalTo	../include/Eigen/src/Householder/HouseholderSequence.h	/^    template<typename DestType> inline void evalTo(DestType& dst) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(DestType& dst) const
Eigen::HouseholderSequence::evalTo	../include/Eigen/src/Householder/HouseholderSequence.h	/^    void evalTo(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst, Workspace& workspace) const
EIGEN_HOUSEHOLDER_SEQUENCE_H	../include/Eigen/src/Householder/HouseholderSequence.h	27;"	d
Eigen::HouseholderSequence::HouseholderSequence	../include/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const HouseholderSequence& other)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(const HouseholderSequence& other)
Eigen::HouseholderSequence::HouseholderSequence	../include/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(const VectorsType& v, const CoeffsType& h)
Eigen::householderSequence	../include/Eigen/src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType> householderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen	signature:(const VectorsType& v, const CoeffsType& h)
Eigen::HouseholderSequence	../include/Eigen/src/Householder/HouseholderSequence.h	/^template<typename VectorsType, typename CoeffsType, int Side> class HouseholderSequence$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::HouseholderSequence::Index	../include/Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename VectorsType::Index Index;$/;"	t	class:Eigen::HouseholderSequence	access:private
Eigen::HouseholderSequence::inverse	../include/Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType inverse() const { return adjoint(); }$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::length	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Index length() const { return m_length; }  \/**< \\brief Returns the length of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::MaxColsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^      MaxColsAtCompileTime = internal::traits<HouseholderSequence>::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderSequence::__anon8
Eigen::HouseholderSequence::MaxRowsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^      MaxRowsAtCompileTime = internal::traits<HouseholderSequence>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon8
Eigen::HouseholderSequence::m_coeffs	../include/Eigen/src/Householder/HouseholderSequence.h	/^    typename CoeffsType::Nested m_coeffs;$/;"	m	class:Eigen::HouseholderSequence	access:protected
Eigen::HouseholderSequence::m_length	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Index m_length;$/;"	m	class:Eigen::HouseholderSequence	access:protected
Eigen::HouseholderSequence::m_shift	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Index m_shift;$/;"	m	class:Eigen::HouseholderSequence	access:protected
Eigen::HouseholderSequence::m_trans	../include/Eigen/src/Householder/HouseholderSequence.h	/^    bool m_trans;$/;"	m	class:Eigen::HouseholderSequence	access:protected
Eigen::HouseholderSequence::m_vectors	../include/Eigen/src/Householder/HouseholderSequence.h	/^    typename VectorsType::Nested m_vectors;$/;"	m	class:Eigen::HouseholderSequence	access:protected
Eigen::HouseholderSequence::operator *	../include/Eigen/src/Householder/HouseholderSequence.h	/^    typename internal::matrix_type_times_scalar_type<Scalar, OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::HouseholderSequence::RowsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^      RowsAtCompileTime = internal::traits<HouseholderSequence>::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon8
Eigen::HouseholderSequence::rows	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Index rows() const { return Side==OnTheLeft ? m_vectors.rows() : m_vectors.cols(); }$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::Scalar	../include/Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename internal::traits<HouseholderSequence>::Scalar Scalar;$/;"	t	class:Eigen::HouseholderSequence	access:private
Eigen::HouseholderSequence::setLength	../include/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setLength(Index length)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Index length)
Eigen::HouseholderSequence::setShift	../include/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setShift(Index shift)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Index shift)
Eigen::HouseholderSequence::setTrans	../include/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setTrans(bool trans)$/;"	f	class:Eigen::HouseholderSequence	access:protected	signature:(bool trans)
Eigen::HouseholderSequence::shift	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Index shift() const { return m_shift; }    \/**< \\brief Returns the shift of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::HouseholderSequence::trans	../include/Eigen/src/Householder/HouseholderSequence.h	/^    bool trans() const { return m_trans; }     \/**< \\brief Returns the transpose flag. *\/$/;"	f	class:Eigen::HouseholderSequence	access:protected	signature:() const
Eigen::HouseholderSequence::transpose	../include/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence transpose() const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Eigen::Hyperplane::absDistance	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar absDistance(const VectorType& p) const { return ei_abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
Eigen::Hyperplane::absDistance	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Scalar absDistance(const VectorType& p) const { return internal::abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
Eigen::Hyperplane::AmbientDimAtCompileTime	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::Hyperplane::__anon439
Eigen::Hyperplane::AmbientDimAtCompileTime	../include/Eigen/src/Geometry/Hyperplane.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::Hyperplane::__anon393
Eigen::Hyperplane::cast	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::cast	../include/Eigen/src/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::Coefficients	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^                        : int(AmbientDimAtCompileTime)+1,1> Coefficients;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::Coefficients	../include/Eigen/src/Geometry/Hyperplane.h	/^                        : Index(AmbientDimAtCompileTime)+1,1,Options> Coefficients;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::coeffs	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::coeffs	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::coeffs	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::coeffs	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::ConstNormalReturnType	../include/Eigen/src/Geometry/Hyperplane.h	/^  typedef const Block<const Coefficients,AmbientDimAtCompileTime,1> ConstNormalReturnType;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::dim	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline int dim() const { return int(AmbientDimAtCompileTime)==Dynamic ? m_coeffs.size()-1 : int(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::dim	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_coeffs.size()-1 : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
EIGEN_HYPERPLANE_H	../include/Eigen/src/Geometry/Hyperplane.h	27;"	d
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)
Eigen::Hyperplane::~Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime>& other)
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(int _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:(int _dim)
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, const VectorType& e)
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, Scalar d)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, Scalar d)
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  Hyperplane(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)
Eigen::Hyperplane::~Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(Index _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:(Index _dim)
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, const VectorType& e)
Eigen::Hyperplane::Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, Scalar d)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, Scalar d)
Eigen::Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
Eigen::Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
Eigen::Hyperplane::Index	../include/Eigen/src/Geometry/Hyperplane.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::intersection	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  VectorType intersection(const Hyperplane& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane& other)
Eigen::Hyperplane::intersection	../include/Eigen/src/Geometry/Hyperplane.h	/^  VectorType intersection(const Hyperplane& other) const$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane& other) const
Eigen::Hyperplane::isApprox	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  bool isApprox(const Hyperplane& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::Hyperplane::isApprox	../include/Eigen/src/Geometry/Hyperplane.h	/^  bool isApprox(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::Hyperplane::m_coeffs	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane	access:protected
Eigen::Hyperplane::m_coeffs	../include/Eigen/src/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane	access:protected
Eigen::Hyperplane::normal	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const NormalReturnType normal() const { return NormalReturnType(*const_cast<Coefficients*>(&m_coeffs),0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::normal	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::normal	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline ConstNormalReturnType normal() const { return ConstNormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::normal	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::normalize	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  void normalize(void)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(void)
Eigen::Hyperplane::normalize	../include/Eigen/src/Geometry/Hyperplane.h	/^  void normalize(void)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(void)
Eigen::Hyperplane::NormalReturnType	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::NormalReturnType	../include/Eigen/src/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::offset	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::offset	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::offset	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
Eigen::Hyperplane::offset	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Eigen::Hyperplane::Options	../include/Eigen/src/Geometry/Hyperplane.h	/^    Options = _Options$/;"	e	enum:Eigen::Hyperplane::__anon393
Eigen::Hyperplane::projection	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
Eigen::Hyperplane::projection	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
Eigen::Hyperplane::RealScalar	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::RealScalar	../include/Eigen/src/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::Scalar	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::Scalar	../include/Eigen/src/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::signedDistance	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar signedDistance(const VectorType& p) const { return p.eigen2_dot(normal()) + offset(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
Eigen::Hyperplane::signedDistance	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Scalar signedDistance(const VectorType& p) const { return normal().dot(p) + offset(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
Eigen::Hyperplane::Through	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1, const VectorType& p2)
Eigen::Hyperplane::Through	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1)
Eigen::Hyperplane::Through	../include/Eigen/src/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1, const VectorType& p2)
Eigen::Hyperplane::Through	../include/Eigen/src/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1)
Eigen::Hyperplane::transform	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)
Eigen::Hyperplane::transform	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime>& t,$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Transform<Scalar,AmbientDimAtCompileTime>& t, TransformTraits traits = Affine)
Eigen::Hyperplane::transform	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)
Eigen::Hyperplane::transform	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t,$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t, TransformTraits traits = Affine)
Eigen::Hyperplane::VectorType	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::Hyperplane::VectorType	../include/Eigen/src/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane	access:public
Eigen::IdentityPreconditioner::analyzePattern	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& analyzePattern(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
Eigen::IdentityPreconditioner::compute	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& compute(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
Eigen::IdentityPreconditioner::factorize	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& factorize(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
Eigen::IdentityPreconditioner::IdentityPreconditioner	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner(const MatrixType& ) {}$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
Eigen::IdentityPreconditioner::IdentityPreconditioner	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner() {}$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:()
Eigen::IdentityPreconditioner	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class IdentityPreconditioner$/;"	c	namespace:Eigen
Eigen::IdentityPreconditioner::solve	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    inline const Rhs& solve(const Rhs& b) const { return b; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const Rhs& b) const
EIGEN_IMPLIES	../include/Eigen/src/Core/util/Macros.h	404;"	d
Eigen	../include/Eigen/src/Cholesky/LDLT.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Cholesky/LLT.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Cholesky/LLT_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/arch/NEON/Complex.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/arch/SSE/Complex.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/ArrayBase.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Array.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/ArrayWrapper.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Assign.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/Assign_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/BandMatrix.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Block.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/BooleanRedux.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/CommaInitializer.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/CwiseBinaryOp.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/CwiseNullaryOp.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/CwiseUnaryOp.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/CwiseUnaryView.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/DenseBase.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/DenseCoeffsBase.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/DenseStorage.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/Diagonal.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/DiagonalMatrix.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/DiagonalProduct.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Dot.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/EigenBase.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/Flagged.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/ForceAlignedAccess.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/Functors.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/Fuzzy.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/GeneralProduct.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/GenericPacketMath.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/GlobalFunctions.h	/^namespace Eigen$/;"	n
Eigen	../include/Eigen/src/Core/IO.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/MapBase.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Map.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/MatrixBase.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/Matrix.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/NestByValue.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/NoAlias.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/NumTraits.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/PermutationMatrix.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/PlainObjectBase.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/ProductBase.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/Parallelizer.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Random.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Redux.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Replicate.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/ReturnByValue.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/Reverse.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Select.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/SelfAdjointView.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/SolveTriangular.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/StableNorm.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Stride.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Swap.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Transpose.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Transpositions.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/TriangularMatrix.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/util/BlasUtil.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/util/Constants.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/util/Macros.h	/^    namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/util/Memory.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/util/Meta.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/util/MKL_support.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/util/StaticAssert.h	/^    namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/util/XprHelper.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Core/VectorBlock.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/VectorwiseOp.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Core/Visitor.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Block.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Cwise.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Lazy.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/LeastSquares.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/LU.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Memory.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Meta.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/Minor.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/QR.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/SVD.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigenvalues/ComplexSchur_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigenvalues/RealSchur.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigenvalues/RealSchur_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/AlignedBox.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/AngleAxis.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/EulerAngles.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/Homogeneous.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/Hyperplane.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/OrthoMethods.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/ParametrizedLine.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/Quaternion.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/Rotation2D.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/RotationBase.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/Scaling.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/Transform.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/Translation.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Geometry/Umeyama.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Householder/BlockHouseholder.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Householder/Householder.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Householder/HouseholderSequence.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/Jacobi/Jacobi.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/LU/Determinant.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/LU/FullPivLU.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/LU/Inverse.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/LU/PartialPivLU.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/LU/PartialPivLU_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/misc/Image.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/misc/Kernel.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/misc/Solve.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/misc/SparseSolve.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/OrderingMethods/Amd.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/QR/ColPivHouseholderQR_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/QR/HouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/QR/HouseholderQR_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/AmbiVector.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/CompressedStorage.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/CoreIterators.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseBlock.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseDot.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparsePermutation.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseProduct.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseRedux.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseTranspose.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseUtil.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseVector.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/SparseView.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SparseCore/TriangularSolver.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/StlSupport/details.h	/^namespace Eigen {$/;"	n
Eigen	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SVD/JacobiSVD.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SVD/JacobiSVD_MKL.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^namespace Eigen { $/;"	n
Eigen	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^namespace Eigen { $/;"	n
Eigen::IncompleteLUT::analyzePattern	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void analyzePattern(const MatrixType& amat);$/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& amat)
Eigen::IncompleteLUT::analyzePattern	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::analyzePattern(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT	signature:(const _MatrixType& amat)
Eigen::IncompleteLUT::cols	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:() const
Eigen::IncompleteLUT::compute	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT<Scalar>& compute(const MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& amat)
Eigen::IncompleteLUT::factorize	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void factorize(const MatrixType& amat);$/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& amat)
Eigen::IncompleteLUT::factorize	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::factorize(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT	signature:(const _MatrixType& amat)
Eigen::IncompleteLUT::FactorType	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,RowMajor> FactorType;$/;"	t	class:Eigen::IncompleteLUT	access:private
EIGEN_INCOMPLETE_LUT_H	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	26;"	d
Eigen::IncompleteLUT	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^class IncompleteLUT : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::IncompleteLUT::IncompleteLUT	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT(const MatrixType& mat, RealScalar droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& mat, RealScalar droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)
Eigen::IncompleteLUT::IncompleteLUT	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT()$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:()
Eigen::IncompleteLUT::Index	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename FactorType::Index Index;$/;"	t	class:Eigen::IncompleteLUT	access:private
Eigen::IncompleteLUT::info	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:() const
Eigen::IncompleteLUT::keep_diag	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    struct keep_diag {$/;"	s	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::keep_diag::operator ()	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::IncompleteLUT::keep_diag	access:public	signature:(const Index& row, const Index& col, const Scalar&) const
Eigen::IncompleteLUT::m_analysisIsOk	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::MatrixType	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::IncompleteLUT	access:public
Eigen::IncompleteLUT::m_droptol	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    RealScalar m_droptol;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_factorizationIsOk	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_fillfactor	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    int m_fillfactor;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_info	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_isInitialized	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_lu	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    FactorType m_lu;$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_P	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_P;     \/\/ Fill-reducing permutation$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::m_Pinv	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_Pinv;  \/\/ Inverse permutation$/;"	m	class:Eigen::IncompleteLUT	access:protected
Eigen::IncompleteLUT::PermutType	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,ColMajor> PermutType;$/;"	t	class:Eigen::IncompleteLUT	access:private
Eigen::IncompleteLUT::QuickSplit	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^int IncompleteLUT<Scalar>::QuickSplit(VectorV &row, VectorI &ind, int ncut)$/;"	f	class:Eigen::IncompleteLUT	signature:(VectorV &row, VectorI &ind, int ncut)
Eigen::IncompleteLUT::QuickSplit	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    int QuickSplit(VectorV &row, VectorI &ind, int ncut);$/;"	p	class:Eigen::IncompleteLUT	access:protected	signature:(VectorV &row, VectorI &ind, int ncut)
Eigen::IncompleteLUT::RealScalar	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::IncompleteLUT	access:private
Eigen::IncompleteLUT::rows	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:() const
Eigen::IncompleteLUT::Scalar	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::IncompleteLUT	access:private
Eigen::IncompleteLUT::setDroptol	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::setDroptol(RealScalar droptol)$/;"	f	class:Eigen::IncompleteLUT	signature:(RealScalar droptol)
Eigen::IncompleteLUT::setDroptol	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void setDroptol(RealScalar droptol); $/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(RealScalar droptol)
Eigen::IncompleteLUT::setFillfactor	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::setFillfactor(int fillfactor)$/;"	f	class:Eigen::IncompleteLUT	signature:(int fillfactor)
Eigen::IncompleteLUT::setFillfactor	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void setFillfactor(int fillfactor); $/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(int fillfactor)
Eigen::IncompleteLUT::solve	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^     solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::IncompleteLUT::_solve	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const Rhs& b, Dest& x) const
Eigen::IncompleteLUT::Vector	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::IncompleteLUT	access:private
Eigen::Infinity	../include/Eigen/src/Core/util/Constants.h	/^const int Infinity = -1;$/;"	m	namespace:Eigen
EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR	../include/Eigen/src/Core/util/Macros.h	317;"	d
EIGEN_INHERIT_ASSIGNMENT_OPERATORS	../include/Eigen/src/Core/util/Macros.h	329;"	d
EIGEN_INITIALIZE_BY_ZERO_IF_THAT_OPTION_IS_ENABLED	../include/Eigen/src/Core/PlainObjectBase.h	30;"	d
EIGEN_INITIALIZE_BY_ZERO_IF_THAT_OPTION_IS_ENABLED	../include/Eigen/src/Core/PlainObjectBase.h	32;"	d
EIGEN_INIT_NEON_PACKET2	../include/Eigen/src/Core/arch/NEON/PacketMath.h	59;"	d
EIGEN_INIT_NEON_PACKET2	../include/Eigen/src/Core/arch/NEON/PacketMath.h	63;"	d
EIGEN_INIT_NEON_PACKET4	../include/Eigen/src/Core/arch/NEON/PacketMath.h	60;"	d
EIGEN_INIT_NEON_PACKET4	../include/Eigen/src/Core/arch/NEON/PacketMath.h	64;"	d
Eigen::initParallel	../include/Eigen/src/Core/products/Parallelizer.h	/^inline void initParallel()$/;"	f	namespace:Eigen	signature:()
Eigen::InnerProduct	../include/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon215
Eigen::InnerRandomAccessPattern	../include/Eigen/src/SparseCore/SparseUtil.h	/^const int InnerRandomAccessPattern  = 0x2 | CoherentAccessPattern;$/;"	m	namespace:Eigen
Eigen::InnerStride::Base	../include/Eigen/src/Core/Stride.h	/^    typedef Stride<0, Value> Base;$/;"	t	class:Eigen::InnerStride	access:private
Eigen::InnerStride	../include/Eigen/src/Core/Stride.h	/^class InnerStride : public Stride<0, Value>$/;"	c	namespace:Eigen	inherits:Stride
Eigen::InnerStride::Index	../include/Eigen/src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::InnerStride	access:public
Eigen::InnerStride::InnerStride	../include/Eigen/src/Core/Stride.h	/^    InnerStride() : Base() {}$/;"	f	class:Eigen::InnerStride	access:public	signature:()
Eigen::InnerStride::InnerStride	../include/Eigen/src/Core/Stride.h	/^    InnerStride(Index v) : Base(0, v) {}$/;"	f	class:Eigen::InnerStride	access:public	signature:(Index v)
Eigen::InnerUnrolling	../include/Eigen/src/Core/util/Constants.h	/^  InnerUnrolling,$/;"	e	enum:Eigen::__anon210
Eigen::InnerVectorizedTraversal	../include/Eigen/src/Core/util/Constants.h	/^  InnerVectorizedTraversal,$/;"	e	enum:Eigen::__anon209
Eigen::internal::abs2_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct abs2_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::abs2_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct abs2_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::abs2_impl::RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs2_impl	access:public
Eigen::internal::abs2_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs2_impl	access:public	signature:(const Scalar& x)
Eigen::internal::abs2_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::abs2_impl	access:public	signature:(const std::complex<RealScalar>& x)
Eigen::internal::abs2	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(abs2, Scalar) abs2(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
Eigen::internal::abs2_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct abs2_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::abs2_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::abs2_retval	access:public
Eigen::internal::abs_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct abs_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::abs_impl::RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs_impl	access:public
Eigen::internal::abs_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs_impl	access:public	signature:(const Scalar& x)
Eigen::internal::abs	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(abs, Scalar) abs(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
Eigen::internal::abs_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct abs_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::abs_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::abs_retval	access:public
Eigen::internal::accessors_level::has_direct_access	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^  enum { has_direct_access = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon206
Eigen::internal::accessors_level::has_write_access	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^         has_write_access = (traits<Derived>::Flags & LvalueBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon206
Eigen::internal::accessors_level	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct accessors_level$/;"	s	namespace:Eigen::internal
Eigen::internal::accessors_level::value	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^         value = has_direct_access ? (has_write_access ? DirectWriteAccessors : DirectAccessors)$/;"	e	enum:Eigen::internal::accessors_level::__anon206
Eigen::internal::add_const	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type_if_arithmetic	../include/Eigen/src/Core/DenseCoeffsBase.h	/^template<typename T> struct add_const_on_value_type_if_arithmetic$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type_if_arithmetic::type	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  typedef typename conditional<is_arithmetic<T>::value, T, typename add_const_on_value_type<T>::type>::type type;$/;"	t	struct:Eigen::internal::add_const_on_value_type_if_arithmetic	access:public
Eigen::internal::add_const_on_value_type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	s	namespace:Eigen::internal
Eigen::internal::add_const_on_value_type::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
Eigen::internal::add_const_on_value_type::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
Eigen::internal::add_const_on_value_type::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
Eigen::internal::add_const_on_value_type::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
Eigen::internal::add_const_on_value_type::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
Eigen::internal::add_const::type	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	t	struct:Eigen::internal::add_const	access:public
Eigen::internal::add_const::type	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	t	struct:Eigen::internal::add_const	access:public
Eigen::internal::aligned_delete	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> inline void aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
Eigen::internal::aligned_free	../include/Eigen/src/Core/util/Memory.h	/^inline void aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
Eigen::internal::aligned_free	../include/Eigen/src/Core/util/Memory.h	/^void  aligned_free(void *ptr);$/;"	p	namespace:Eigen::internal	signature:(void *ptr)
Eigen::internal::aligned_malloc	../include/Eigen/src/Core/util/Memory.h	/^inline void* aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::aligned_malloc	../include/Eigen/src/Core/util/Memory.h	/^void* aligned_malloc(size_t size);$/;"	p	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::aligned_new	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> inline T* aligned_new(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::aligned_realloc	../include/Eigen/src/Core/util/Memory.h	/^inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(void *ptr, size_t new_size, size_t old_size)
Eigen::internal::aligned_stack_memory_handler::~aligned_stack_memory_handler	../include/Eigen/src/Core/util/Memory.h	/^    ~aligned_stack_memory_handler()$/;"	f	class:Eigen::internal::aligned_stack_memory_handler	access:public	signature:()
Eigen::internal::aligned_stack_memory_handler::aligned_stack_memory_handler	../include/Eigen/src/Core/util/Memory.h	/^    aligned_stack_memory_handler(T* ptr, size_t size, bool dealloc)$/;"	f	class:Eigen::internal::aligned_stack_memory_handler	access:public	signature:(T* ptr, size_t size, bool dealloc)
Eigen::internal::aligned_stack_memory_handler	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> class aligned_stack_memory_handler$/;"	c	namespace:Eigen::internal
Eigen::internal::aligned_stack_memory_handler::m_deallocate	../include/Eigen/src/Core/util/Memory.h	/^    bool m_deallocate;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler	access:protected
Eigen::internal::aligned_stack_memory_handler::m_ptr	../include/Eigen/src/Core/util/Memory.h	/^    T* m_ptr;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler	access:protected
Eigen::internal::aligned_stack_memory_handler::m_size	../include/Eigen/src/Core/util/Memory.h	/^    size_t m_size;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler	access:protected
Eigen::internal::all_unroller::col	../include/Eigen/src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::all_unroller::__anon226
Eigen::internal::all_unroller	../include/Eigen/src/Core/BooleanRedux.h	/^struct all_unroller<Derived, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::all_unroller	../include/Eigen/src/Core/BooleanRedux.h	/^struct all_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
Eigen::internal::all_unroller	../include/Eigen/src/Core/BooleanRedux.h	/^struct all_unroller$/;"	s	namespace:Eigen::internal
Eigen::internal::all_unroller::row	../include/Eigen/src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::all_unroller::__anon226
Eigen::internal::all_unroller::run	../include/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::all_unroller	access:public	signature:(const Derived &mat)
Eigen::internal::all_unroller::run	../include/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat) { return mat.coeff(0, 0); }$/;"	f	struct:Eigen::internal::all_unroller	access:public	signature:(const Derived &mat)
Eigen::internal::all_unroller::run	../include/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::all_unroller	access:public	signature:(const Derived &)
Eigen::internal::always_void	../include/Eigen/src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::always_void::type	../include/Eigen/src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	t	struct:Eigen::internal::always_void	access:public
Eigen::internal::AmbiVector::~AmbiVector	../include/Eigen/src/SparseCore/AmbiVector.h	/^    ~AmbiVector() { delete[] m_buffer; }$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:()
Eigen::internal::AmbiVector::AmbiVector	../include/Eigen/src/SparseCore/AmbiVector.h	/^    AmbiVector(Index size)$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:(Index size)
Eigen::internal::AmbiVector::coeff	../include/Eigen/src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_Index>::coeff(_Index i)$/;"	f	class:Eigen::internal::AmbiVector	signature:(_Index i)
Eigen::internal::AmbiVector::coeff	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar& coeff(Index i);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(Index i)
Eigen::internal::AmbiVector::coeffRef	../include/Eigen/src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_Index>::coeffRef(_Index i)$/;"	f	class:Eigen::internal::AmbiVector	signature:(_Index i)
Eigen::internal::AmbiVector::coeffRef	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar& coeffRef(Index i);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(Index i)
Eigen::internal::AmbiVector	../include/Eigen/src/SparseCore/AmbiVector.h	/^class AmbiVector$/;"	c	namespace:Eigen::internal
Eigen::internal::AmbiVector::Index	../include/Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::AmbiVector	access:public
Eigen::internal::AmbiVector::init	../include/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::init(double estimatedDensity)$/;"	f	class:Eigen::internal::AmbiVector	signature:(double estimatedDensity)
Eigen::internal::AmbiVector::init	../include/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::init(int mode)$/;"	f	class:Eigen::internal::AmbiVector	signature:(int mode)
Eigen::internal::AmbiVector::init	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void init(double estimatedDensity);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(double estimatedDensity)
Eigen::internal::AmbiVector::init	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void init(int mode);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(int mode)
Eigen::internal::AmbiVector::Iterator	../include/Eigen/src/SparseCore/AmbiVector.h	/^class AmbiVector<_Scalar,_Index>::Iterator$/;"	c	class:Eigen::internal::AmbiVector
Eigen::internal::AmbiVector::Iterator::index	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index index() const { return m_cachedIndex; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:() const
Eigen::internal::AmbiVector::Iterator::Iterator	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Iterator(const AmbiVector& vec, RealScalar epsilon = 0)$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:(const AmbiVector& vec, RealScalar epsilon = 0)
Eigen::internal::AmbiVector::Iterator::m_cachedIndex	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_cachedIndex;          \/\/ current coordinate$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
Eigen::internal::AmbiVector::Iterator::m_cachedValue	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar m_cachedValue;       \/\/ current value$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
Eigen::internal::AmbiVector::Iterator::m_currentEl	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_currentEl;            \/\/ the current element in sparse\/linked-list mode$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
Eigen::internal::AmbiVector::Iterator::m_epsilon	../include/Eigen/src/SparseCore/AmbiVector.h	/^    RealScalar m_epsilon;       \/\/ epsilon used to prune zero coefficients$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
Eigen::internal::AmbiVector::Iterator::m_isDense	../include/Eigen/src/SparseCore/AmbiVector.h	/^    bool m_isDense;             \/\/ mode of the vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
Eigen::internal::AmbiVector::Iterator::m_vector	../include/Eigen/src/SparseCore/AmbiVector.h	/^    const AmbiVector& m_vector; \/\/ the target vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
Eigen::internal::AmbiVector::Iterator::operator bool	../include/Eigen/src/SparseCore/AmbiVector.h	/^    operator bool() const { return m_cachedIndex>=0; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:() const
Eigen::internal::AmbiVector::Iterator::operator ++	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Iterator& operator++()$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:()
Eigen::internal::AmbiVector::Iterator::RealScalar	../include/Eigen/src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator	access:public
Eigen::internal::AmbiVector::Iterator::Scalar	../include/Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator	access:public
Eigen::internal::AmbiVector::Iterator::value	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar value() const { return m_cachedValue; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:() const
Eigen::internal::AmbiVector::ListEl	../include/Eigen/src/SparseCore/AmbiVector.h	/^    struct ListEl$/;"	s	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::ListEl::index	../include/Eigen/src/SparseCore/AmbiVector.h	/^      Index index;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl	access:public
Eigen::internal::AmbiVector::ListEl::next	../include/Eigen/src/SparseCore/AmbiVector.h	/^      Index next;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl	access:public
Eigen::internal::AmbiVector::ListEl::value	../include/Eigen/src/SparseCore/AmbiVector.h	/^      Scalar value;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl	access:public
Eigen::internal::AmbiVector::m_allocatedElements	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_allocatedElements;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_allocatedSize	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_allocatedSize;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_buffer	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar* m_buffer;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_end	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_end;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_llCurrent	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_llCurrent;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_llSize	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_llSize;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_llStart	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_llStart;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_mode	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_mode;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_size	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_size;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_start	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_start;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::m_zero	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar m_zero;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
Eigen::internal::AmbiVector::nonZeros	../include/Eigen/src/SparseCore/AmbiVector.h	/^_Index AmbiVector<_Scalar,_Index>::nonZeros() const$/;"	f	class:Eigen::internal::AmbiVector	signature:() const
Eigen::internal::AmbiVector::nonZeros	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index nonZeros() const;$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:() const
Eigen::internal::AmbiVector::reallocate	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void reallocate(Index size)$/;"	f	class:Eigen::internal::AmbiVector	access:protected	signature:(Index size)
Eigen::internal::AmbiVector::reallocateSparse	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void reallocateSparse()$/;"	f	class:Eigen::internal::AmbiVector	access:protected	signature:()
Eigen::internal::AmbiVector::RealScalar	../include/Eigen/src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector	access:public
Eigen::internal::AmbiVector::resize	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void resize(Index size)$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:(Index size)
Eigen::internal::AmbiVector::restart	../include/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::restart()$/;"	f	class:Eigen::internal::AmbiVector	signature:()
Eigen::internal::AmbiVector::restart	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void restart();$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:()
Eigen::internal::AmbiVector::Scalar	../include/Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector	access:public
Eigen::internal::AmbiVector::setBounds	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void setBounds(Index start, Index end) { m_start = start; m_end = end; }$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:(Index start, Index end)
Eigen::internal::AmbiVector::setZero	../include/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::setZero()$/;"	f	class:Eigen::internal::AmbiVector	signature:()
Eigen::internal::AmbiVector::setZero	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void setZero();$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:()
Eigen::internal::AmbiVector::size	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index size() const { return m_size; }$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:() const
Eigen::internal::amd_flip	../include/Eigen/src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_flip(const T& i) { return -i-2; }$/;"	f	namespace:Eigen::internal	signature:(const T& i)
Eigen::internal::amd_marked	../include/Eigen/src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline bool amd_marked(const T0* w, const T1& j) { return w[j]<0; }$/;"	f	namespace:Eigen::internal	signature:(const T0* w, const T1& j)
Eigen::internal::amd_mark	../include/Eigen/src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline void amd_mark(const T0* w, const T1& j) { return w[j] = amd_flip(w[j]); }$/;"	f	namespace:Eigen::internal	signature:(const T0* w, const T1& j)
Eigen::internal::amd_unflip	../include/Eigen/src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_unflip(const T& i) { return i<0 ? amd_flip(i) : i; }$/;"	f	namespace:Eigen::internal	signature:(const T& i)
Eigen::internal::any_unroller::col	../include/Eigen/src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::any_unroller::__anon227
Eigen::internal::any_unroller	../include/Eigen/src/Core/BooleanRedux.h	/^struct any_unroller<Derived, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::any_unroller	../include/Eigen/src/Core/BooleanRedux.h	/^struct any_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
Eigen::internal::any_unroller	../include/Eigen/src/Core/BooleanRedux.h	/^struct any_unroller$/;"	s	namespace:Eigen::internal
Eigen::internal::any_unroller::row	../include/Eigen/src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::any_unroller::__anon227
Eigen::internal::any_unroller::run	../include/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::any_unroller	access:public	signature:(const Derived &mat)
Eigen::internal::any_unroller::run	../include/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat) { return mat.coeff(0, 0); }$/;"	f	struct:Eigen::internal::any_unroller	access:public	signature:(const Derived &mat)
Eigen::internal::any_unroller::run	../include/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::any_unroller	access:public	signature:(const Derived &)
Eigen::internal::apply_block_householder_on_the_left	../include/Eigen/src/Householder/BlockHouseholder.h	/^void apply_block_householder_on_the_left(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs)
Eigen::internal::apply_rotation_in_the_plane	../include/Eigen/src/Jacobi/Jacobi.h	/^void apply_rotation_in_the_plane(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j);$/;"	p	namespace:Eigen::internal	signature:(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)
Eigen::internal::apply_rotation_in_the_plane	../include/Eigen/src/Jacobi/Jacobi.h	/^void \/*EIGEN_DONT_INLINE*\/ apply_rotation_in_the_plane(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)$/;"	f	namespace:Eigen::internal	signature:(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)
eigen_internal_assert	../include/Eigen/src/Core/util/Macros.h	226;"	d
Eigen::internal::assign_conj_scalar_eig2mkl	../include/Eigen/src/Core/util/MKL_support.h	/^inline void assign_conj_scalar_eig2mkl<MKL_Complex16,dcomplex>(MKL_Complex16& mklScalar, const dcomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex16& mklScalar, const dcomplex& eigenScalar)
Eigen::internal::assign_conj_scalar_eig2mkl	../include/Eigen/src/Core/util/MKL_support.h	/^inline void assign_conj_scalar_eig2mkl<MKL_Complex8,scomplex>(MKL_Complex8& mklScalar, const scomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex8& mklScalar, const scomplex& eigenScalar)
Eigen::internal::assign_conj_scalar_eig2mkl	../include/Eigen/src/Core/util/MKL_support.h	/^static inline void assign_conj_scalar_eig2mkl(MKLType& mklScalar, const EigenType& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKLType& mklScalar, const EigenType& eigenScalar)
Eigen::internal::assign_DefaultTraversal_CompleteUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_DefaultTraversal_CompleteUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::inner	../include/Eigen/src/Core/Assign.h	/^    inner = Index % Derived1::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::__anon224
Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::outer	../include/Eigen/src/Core/Assign.h	/^    outer = Index \/ Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::__anon224
Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling	access:public	signature:(Derived1 &, const Derived2 &)
Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::assign_DefaultTraversal_InnerUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_InnerUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_DefaultTraversal_InnerUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_InnerUnrolling$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_DefaultTraversal_InnerUnrolling::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &, int) {}$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_InnerUnrolling	access:public	signature:(Derived1 &, const Derived2 &, int)
Eigen::internal::assign_DefaultTraversal_InnerUnrolling::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src, int outer)$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_InnerUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src, int outer)
Eigen::internal::assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, InnerUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, InnerUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InvalidTraversal, Unrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl	../include/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, SliceVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_impl::Index	../include/Eigen/src/Core/Assign.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::assign_impl	access:public
Eigen::internal::assign_impl::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_impl	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::assign_impl::run	../include/Eigen/src/Core/Assign.h	/^  static inline void run(Derived1 &, const Derived2 &) { }$/;"	f	struct:Eigen::internal::assign_impl	access:public	signature:(Derived1 &, const Derived2 &)
Eigen::internal::assign_impl::run	../include/Eigen/src/Core/Assign.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_impl	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::assign_innervec_CompleteUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_innervec_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_innervec_CompleteUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_innervec_CompleteUnrolling$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_innervec_CompleteUnrolling::inner	../include/Eigen/src/Core/Assign.h	/^    inner = Index % Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon225
Eigen::internal::assign_innervec_CompleteUnrolling::JointAlignment	../include/Eigen/src/Core/Assign.h	/^    JointAlignment = assign_traits<Derived1,Derived2>::JointAlignment$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon225
Eigen::internal::assign_innervec_CompleteUnrolling::outer	../include/Eigen/src/Core/Assign.h	/^    outer = Index \/ Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon225
Eigen::internal::assign_innervec_CompleteUnrolling::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_innervec_CompleteUnrolling	access:public	signature:(Derived1 &, const Derived2 &)
Eigen::internal::assign_innervec_CompleteUnrolling::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_innervec_CompleteUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::assign_innervec_InnerUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_innervec_InnerUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_innervec_InnerUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_innervec_InnerUnrolling$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_innervec_InnerUnrolling::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &, int) {}$/;"	f	struct:Eigen::internal::assign_innervec_InnerUnrolling	access:public	signature:(Derived1 &, const Derived2 &, int)
Eigen::internal::assign_innervec_InnerUnrolling::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src, int outer)$/;"	f	struct:Eigen::internal::assign_innervec_InnerUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src, int outer)
Eigen::internal::assign_LinearTraversal_CompleteUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_LinearTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_LinearTraversal_CompleteUnrolling	../include/Eigen/src/Core/Assign.h	/^struct assign_LinearTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_LinearTraversal_CompleteUnrolling::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_LinearTraversal_CompleteUnrolling	access:public	signature:(Derived1 &, const Derived2 &)
Eigen::internal::assign_LinearTraversal_CompleteUnrolling::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_LinearTraversal_CompleteUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::assign_scalar_eig2mkl	../include/Eigen/src/Core/util/MKL_support.h	/^inline void assign_scalar_eig2mkl<MKL_Complex16,dcomplex>(MKL_Complex16& mklScalar, const dcomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex16& mklScalar, const dcomplex& eigenScalar)
Eigen::internal::assign_scalar_eig2mkl	../include/Eigen/src/Core/util/MKL_support.h	/^inline void assign_scalar_eig2mkl<MKL_Complex8,scomplex>(MKL_Complex8& mklScalar, const scomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKL_Complex8& mklScalar, const scomplex& eigenScalar)
Eigen::internal::assign_scalar_eig2mkl	../include/Eigen/src/Core/util/MKL_support.h	/^static inline void assign_scalar_eig2mkl(MKLType& mklScalar, const EigenType& eigenScalar) {$/;"	f	namespace:Eigen::internal	signature:(MKLType& mklScalar, const EigenType& eigenScalar)
Eigen::internal::assign_selector	../include/Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,false,false> {$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_selector	../include/Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,false,true> {$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_selector	../include/Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,true,false> {$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_selector	../include/Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,true,true> {$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_selector::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
Eigen::internal::assign_selector::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.eval()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
Eigen::internal::assign_selector::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose().eval()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
Eigen::internal::assign_selector::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
Eigen::internal::assign_traits::debug	../include/Eigen/src/Core/Assign.h	/^  static void debug()$/;"	f	struct:Eigen::internal::assign_traits	access:public	signature:()
Eigen::internal::assign_traits::DstHasDirectAccess	../include/Eigen/src/Core/Assign.h	/^    DstHasDirectAccess = Derived::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon218
Eigen::internal::assign_traits::DstIsAligned	../include/Eigen/src/Core/Assign.h	/^    DstIsAligned = Derived::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon218
Eigen::internal::assign_traits	../include/Eigen/src/Core/Assign.h	/^struct assign_traits$/;"	s	namespace:Eigen::internal
Eigen::internal::assign_traits::InnerMaxSize	../include/Eigen/src/Core/Assign.h	/^    InnerMaxSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::assign_traits::__anon219
Eigen::internal::assign_traits::InnerSize	../include/Eigen/src/Core/Assign.h	/^    InnerSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::assign_traits::__anon219
Eigen::internal::assign_traits::JointAlignment	../include/Eigen/src/Core/Assign.h	/^    JointAlignment = bool(DstIsAligned) && bool(SrcIsAligned) ? Aligned : Unaligned$/;"	e	enum:Eigen::internal::assign_traits::__anon218
Eigen::internal::assign_traits::MaxSizeAtCompileTime	../include/Eigen/src/Core/Assign.h	/^    MaxSizeAtCompileTime = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_traits::__anon219
Eigen::internal::assign_traits::MayInnerVectorize	../include/Eigen/src/Core/Assign.h	/^    MayInnerVectorize  = MightVectorize && int(InnerSize)!=Dynamic && int(InnerSize)%int(PacketSize)==0$/;"	e	enum:Eigen::internal::assign_traits::__anon220
Eigen::internal::assign_traits::MayLinearize	../include/Eigen/src/Core/Assign.h	/^    MayLinearize = StorageOrdersAgree && (int(Derived::Flags) & int(OtherDerived::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::assign_traits::__anon220
Eigen::internal::assign_traits::MayLinearVectorize	../include/Eigen/src/Core/Assign.h	/^    MayLinearVectorize = MightVectorize && MayLinearize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::assign_traits::__anon220
Eigen::internal::assign_traits::MaySliceVectorize	../include/Eigen/src/Core/Assign.h	/^    MaySliceVectorize  = MightVectorize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::assign_traits::__anon220
Eigen::internal::assign_traits::MayUnrollCompletely	../include/Eigen/src/Core/Assign.h	/^    MayUnrollCompletely = int(Derived::SizeAtCompileTime) != Dynamic$/;"	e	enum:Eigen::internal::assign_traits::__anon222
Eigen::internal::assign_traits::MayUnrollInner	../include/Eigen/src/Core/Assign.h	/^    MayUnrollInner      = int(InnerSize) != Dynamic$/;"	e	enum:Eigen::internal::assign_traits::__anon222
Eigen::internal::assign_traits::MightVectorize	../include/Eigen/src/Core/Assign.h	/^    MightVectorize = StorageOrdersAgree$/;"	e	enum:Eigen::internal::assign_traits::__anon220
Eigen::internal::assign_traits::PacketSize	../include/Eigen/src/Core/Assign.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size$/;"	e	enum:Eigen::internal::assign_traits::__anon219
Eigen::internal::assign_traits::SrcIsAligned	../include/Eigen/src/Core/Assign.h	/^    SrcIsAligned = OtherDerived::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon218
Eigen::internal::assign_traits::StorageOrdersAgree	../include/Eigen/src/Core/Assign.h	/^    StorageOrdersAgree = (int(Derived::IsRowMajor) == int(OtherDerived::IsRowMajor)),$/;"	e	enum:Eigen::internal::assign_traits::__anon220
Eigen::internal::assign_traits::Traversal	../include/Eigen/src/Core/Assign.h	/^    Traversal = int(MayInnerVectorize)  ? int(InnerVectorizedTraversal)$/;"	e	enum:Eigen::internal::assign_traits::__anon221
Eigen::internal::assign_traits::Unrolling	../include/Eigen/src/Core/Assign.h	/^    Unrolling = (int(Traversal) == int(InnerVectorizedTraversal) || int(Traversal) == int(DefaultTraversal))$/;"	e	enum:Eigen::internal::assign_traits::__anon223
Eigen::internal::assign_traits::UnrollingLimit	../include/Eigen/src/Core/Assign.h	/^    UnrollingLimit      = EIGEN_UNROLLING_LIMIT * (Vectorized ? int(PacketSize) : 1),$/;"	e	enum:Eigen::internal::assign_traits::__anon222
Eigen::internal::assign_traits::Vectorized	../include/Eigen/src/Core/Assign.h	/^    Vectorized = int(Traversal) == InnerVectorizedTraversal$/;"	e	enum:Eigen::internal::assign_traits::__anon221
Eigen::internal::asSluMatrix	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^SluMatrix asSluMatrix(MatrixType& mat)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat)
Eigen::internal::atan2_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct atan2_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::atan2_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct atan2_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::atan2_default_impl::retval	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar retval;$/;"	t	struct:Eigen::internal::atan2_default_impl	access:public
Eigen::internal::atan2_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar&, const Scalar&)$/;"	f	struct:Eigen::internal::atan2_default_impl	access:public	signature:(const Scalar&, const Scalar&)
Eigen::internal::atan2_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::atan2_default_impl	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::atan2_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct atan2_impl : atan2_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:atan2_default_impl
Eigen::internal::atan2	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(atan2, Scalar) atan2(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::atan2_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct atan2_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::atan2_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::atan2_retval	access:public
Eigen::internal::BandMatrix::BandMatrix	../include/Eigen/src/Core/BandMatrix.h	/^    inline BandMatrix(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)
Eigen::internal::BandMatrixBase::Base	../include/Eigen/src/Core/BandMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Eigen::internal::BandMatrixBase::CoefficientsType	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Eigen::internal::BandMatrixBase::CoeffReadCost	../include/Eigen/src/Core/BandMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Eigen::internal::BandMatrixBase::coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:()
Eigen::internal::BandMatrixBase::coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
Eigen::internal::BandMatrixBase::col	../include/Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,Dynamic,1> col(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Index i)
Eigen::internal::BandMatrixBase::ColsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Eigen::internal::BandMatrixBase::DataRowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^      DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic))$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon79
Eigen::internal::BandMatrixBase::DenseMatrixType	../include/Eigen/src/Core/BandMatrix.h	/^    typedef Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Eigen::internal::BandMatrixBase::diagonal	../include/Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,Dynamic> diagonal(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Index i)
Eigen::internal::BandMatrixBase::diagonal	../include/Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,SizeAtCompileTime> diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:()
Eigen::internal::BandMatrixBase::diagonal	../include/Eigen/src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,Dynamic> diagonal(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Index i) const
Eigen::internal::BandMatrixBase::diagonal	../include/Eigen/src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,SizeAtCompileTime> diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
Eigen::internal::BandMatrixBase::diagonal	../include/Eigen/src/Core/BandMatrix.h	/^    template<int N> inline const typename DiagonalIntReturnType<N>::Type diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
Eigen::internal::BandMatrixBase::diagonal	../include/Eigen/src/Core/BandMatrix.h	/^    template<int N> inline typename DiagonalIntReturnType<N>::Type diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:()
Eigen::internal::BandMatrixBase::DiagonalIntReturnType::ActualIndex	../include/Eigen/src/Core/BandMatrix.h	/^        ActualIndex = ReturnOpposite ? -Index : Index,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon80
Eigen::internal::BandMatrixBase::DiagonalIntReturnType::BuildType	../include/Eigen/src/Core/BandMatrix.h	/^      typedef Block<CoefficientsType,1, DiagonalSize> BuildType;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType	access:public
Eigen::internal::BandMatrixBase::DiagonalIntReturnType::Conjugate	../include/Eigen/src/Core/BandMatrix.h	/^        Conjugate = ReturnOpposite && NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon80
Eigen::internal::BandMatrixBase::DiagonalIntReturnType::DiagonalSize	../include/Eigen/src/Core/BandMatrix.h	/^        DiagonalSize = (RowsAtCompileTime==Dynamic || ColsAtCompileTime==Dynamic)$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon80
Eigen::internal::BandMatrixBase::DiagonalIntReturnType	../include/Eigen/src/Core/BandMatrix.h	/^    template<int Index> struct DiagonalIntReturnType {$/;"	s	class:Eigen::internal::BandMatrixBase	access:public
Eigen::internal::BandMatrixBase::DiagonalIntReturnType::ReturnOpposite	../include/Eigen/src/Core/BandMatrix.h	/^        ReturnOpposite = (Options&SelfAdjoint) && (((Index)>0 && Supers==0) || ((Index)<0 && Subs==0)),$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon80
Eigen::internal::BandMatrixBase::DiagonalIntReturnType::Type	../include/Eigen/src/Core/BandMatrix.h	/^                 BuildType>::type Type;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType	access:public
Eigen::internal::BandMatrixBase::diagonalLength	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index diagonalLength(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase	access:protected	signature:(Index i) const
Eigen::internal::BandMatrixBase::evalTo	../include/Eigen/src/Core/BandMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Dest& dst) const
Eigen::internal::BandMatrixBase::Flags	../include/Eigen/src/Core/BandMatrix.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Eigen::internal::BandMatrixBase	../include/Eigen/src/Core/BandMatrix.h	/^class BandMatrixBase : public EigenBase<Derived>$/;"	c	namespace:Eigen::internal	inherits:EigenBase
Eigen::internal::BandMatrixBase::Index	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename DenseMatrixType::Index Index;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Eigen::internal::BandMatrixBase::MaxColsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Eigen::internal::BandMatrixBase::MaxRowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Eigen::internal::BandMatrixBase::Options	../include/Eigen/src/Core/BandMatrix.h	/^      Options = internal::traits<Derived>::Options$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Eigen::internal::BandMatrixBase::RowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Eigen::internal::BandMatrixBase::Scalar	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Eigen::internal::BandMatrixBase::SizeAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^      SizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime)$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon79
Eigen::internal::BandMatrixBase::subs	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return derived().subs(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
Eigen::internal::BandMatrixBase::Subs	../include/Eigen/src/Core/BandMatrix.h	/^      Subs   = internal::traits<Derived>::Subs,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Eigen::internal::BandMatrixBase::supers	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return derived().supers(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
Eigen::internal::BandMatrixBase::Supers	../include/Eigen/src/Core/BandMatrix.h	/^      Supers = internal::traits<Derived>::Supers,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Eigen::internal::BandMatrixBase::toDenseMatrix	../include/Eigen/src/Core/BandMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
Eigen::internal::BandMatrix::CoefficientsType	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrix	access:public
Eigen::internal::BandMatrix::coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:()
Eigen::internal::BandMatrix::coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
Eigen::internal::BandMatrix::cols	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
Eigen::internal::BandMatrix	../include/Eigen/src/Core/BandMatrix.h	/^class BandMatrix : public BandMatrixBase<BandMatrix<_Scalar,Rows,Cols,Supers,Subs,Options> >$/;"	c	namespace:Eigen::internal	inherits:BandMatrixBase
Eigen::internal::BandMatrix::Index	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Index Index;$/;"	t	class:Eigen::internal::BandMatrix	access:public
Eigen::internal::BandMatrix::m_coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    CoefficientsType m_coeffs;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
Eigen::internal::BandMatrix::m_rows	../include/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
Eigen::internal::BandMatrix::m_subs	../include/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
Eigen::internal::BandMatrix::m_supers	../include/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
Eigen::internal::BandMatrix::rows	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
Eigen::internal::BandMatrix::Scalar	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrix	access:public
Eigen::internal::BandMatrix::subs	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
Eigen::internal::BandMatrix::supers	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
Eigen::internal::BandMatrixWrapper::BandMatrixWrapper	../include/Eigen/src/Core/BandMatrix.h	/^    inline BandMatrixWrapper(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)
Eigen::internal::BandMatrixWrapper::CoefficientsType	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixWrapper	access:public
Eigen::internal::BandMatrixWrapper::coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
Eigen::internal::BandMatrixWrapper::cols	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
Eigen::internal::BandMatrixWrapper	../include/Eigen/src/Core/BandMatrix.h	/^class BandMatrixWrapper : public BandMatrixBase<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	c	namespace:Eigen::internal	inherits:BandMatrixBase
Eigen::internal::BandMatrixWrapper::Index	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Index Index;$/;"	t	class:Eigen::internal::BandMatrixWrapper	access:public
Eigen::internal::BandMatrixWrapper::m_coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    const CoefficientsType& m_coeffs;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
Eigen::internal::BandMatrixWrapper::m_rows	../include/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
Eigen::internal::BandMatrixWrapper::m_subs	../include/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
Eigen::internal::BandMatrixWrapper::m_supers	../include/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
Eigen::internal::BandMatrixWrapper::rows	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
Eigen::internal::BandMatrixWrapper::Scalar	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixWrapper	access:public
Eigen::internal::BandMatrixWrapper::subs	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
Eigen::internal::BandMatrixWrapper::supers	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
Eigen::internal::bicgstab	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^bool bicgstab(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, const Rhs& rhs, Dest& x, const Preconditioner& precond, int& iters, typename Dest::RealScalar& tol_error)
Eigen::internal::binary_result_of_select	../include/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_std_result_type)>$/;"	s	namespace:Eigen::internal
Eigen::internal::binary_result_of_select	../include/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_tr1_result)>$/;"	s	namespace:Eigen::internal
Eigen::internal::binary_result_of_select	../include/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select {typedef ArgType0 type;};$/;"	s	namespace:Eigen::internal
Eigen::internal::binary_result_of_select::type	../include/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select {typedef ArgType0 type;};$/;"	t	struct:Eigen::internal::binary_result_of_select	access:public
Eigen::internal::binary_result_of_select::type	../include/Eigen/src/Core/util/Meta.h	/^{typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select	access:public
Eigen::internal::binary_result_of_select::type	../include/Eigen/src/Core/util/Meta.h	/^{typedef typename Func::template result<Func(ArgType0,ArgType1)>::type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select	access:public
Eigen::internal::blas_data_mapper::blas_data_mapper	../include/Eigen/src/Core/util/BlasUtil.h	/^    blas_data_mapper(Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::blas_data_mapper	access:public	signature:(Scalar* data, Index stride)
Eigen::internal::blas_data_mapper	../include/Eigen/src/Core/util/BlasUtil.h	/^class blas_data_mapper$/;"	c	namespace:Eigen::internal
Eigen::internal::blas_data_mapper::m_data	../include/Eigen/src/Core/util/BlasUtil.h	/^    Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::blas_data_mapper	access:protected
Eigen::internal::blas_data_mapper::m_stride	../include/Eigen/src/Core/util/BlasUtil.h	/^    Index m_stride;$/;"	m	class:Eigen::internal::blas_data_mapper	access:protected
Eigen::internal::blas_data_mapper::operator ()	../include/Eigen/src/Core/util/BlasUtil.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i, Index j)$/;"	f	class:Eigen::internal::blas_data_mapper	access:public	signature:(Index i, Index j)
Eigen::internal::blas_traits::Base	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef blas_traits<NestedXpr> Base;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::DirectLinearAccessType	../include/Eigen/src/Core/util/BlasUtil.h	/^    >::type DirectLinearAccessType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::extract	../include/Eigen/src/Core/Transpose.h	/^  static inline const XprType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
Eigen::internal::blas_traits::extract	../include/Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
Eigen::internal::blas_traits::extract	../include/Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
Eigen::internal::blas_traits::extractScalarFactor	../include/Eigen/src/Core/util/BlasUtil.h	/^  static inline const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType&)
Eigen::internal::blas_traits::extractScalarFactor	../include/Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x)$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
Eigen::internal::blas_traits::extractScalarFactor	../include/Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return Base::extractScalarFactor(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
Eigen::internal::blas_traits::extractScalarFactor	../include/Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return conj(Base::extractScalarFactor(x.nestedExpression())); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
Eigen::internal::blas_traits::ExtractType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef const XprType& ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::ExtractType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType>  ExtractType; \/\/ const to get rid of a compile error; anyway blas traits are only used on the RHS$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::_ExtractType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType> _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::ExtractType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename Base::ExtractType ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::_ExtractType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef XprType _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::HasUsableDirectAccess	../include/Eigen/src/Core/util/BlasUtil.h	/^    HasUsableDirectAccess = (    (int(XprType::Flags)&DirectAccessBit)$/;"	e	enum:Eigen::internal::blas_traits::__anon202
Eigen::internal::blas_traits	../include/Eigen/src/Core/Transpose.h	/^struct blas_traits<SelfCwiseBinaryOp<BinOp,NestedXpr,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
Eigen::internal::blas_traits	../include/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<const T>$/;"	s	namespace:Eigen::internal	inherits:blas_traits
Eigen::internal::blas_traits	../include/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
Eigen::internal::blas_traits	../include/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_multiple_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
Eigen::internal::blas_traits	../include/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
Eigen::internal::blas_traits	../include/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<Transpose<NestedXpr> >$/;"	s	namespace:Eigen::internal	inherits:blas_traits
Eigen::internal::blas_traits	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename XprType> struct blas_traits$/;"	s	namespace:Eigen::internal
Eigen::internal::blas_traits::IsComplex	../include/Eigen/src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon202
Eigen::internal::blas_traits::IsComplex	../include/Eigen/src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon203
Eigen::internal::blas_traits::IsTransposed	../include/Eigen/src/Core/util/BlasUtil.h	/^    IsTransposed = Base::IsTransposed ? 0 : 1$/;"	e	enum:Eigen::internal::blas_traits::__anon204
Eigen::internal::blas_traits::IsTransposed	../include/Eigen/src/Core/util/BlasUtil.h	/^    IsTransposed = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon202
Eigen::internal::blas_traits::NeedToConjugate	../include/Eigen/src/Core/util/BlasUtil.h	/^    NeedToConjugate = Base::NeedToConjugate ? 0 : IsComplex$/;"	e	enum:Eigen::internal::blas_traits::__anon203
Eigen::internal::blas_traits::NeedToConjugate	../include/Eigen/src/Core/util/BlasUtil.h	/^    NeedToConjugate = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon202
Eigen::internal::blas_traits::Scalar	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename NestedXpr::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::Scalar	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::XprType	../include/Eigen/src/Core/Transpose.h	/^  typedef SelfCwiseBinaryOp<BinOp,NestedXpr,Rhs> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::XprType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::XprType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_multiple_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::XprType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::blas_traits::XprType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Eigen::internal::bruteforce_det3_helper	../include/Eigen/src/LU/Determinant.h	/^inline const typename Derived::Scalar bruteforce_det3_helper$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<Derived>& matrix, int a, int b, int c)
Eigen::internal::bruteforce_det4_helper	../include/Eigen/src/LU/Determinant.h	/^const typename Derived::Scalar bruteforce_det4_helper$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<Derived>& matrix, int j, int k, int m, int n)
Eigen::internal::cast_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct cast_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::cast_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline NewType run(const OldType& x)$/;"	f	struct:Eigen::internal::cast_impl	access:public	signature:(const OldType& x)
Eigen::internal::cast	../include/Eigen/src/Core/MathFunctions.h	/^inline NewType cast(const OldType& x)$/;"	f	namespace:Eigen::internal	signature:(const OldType& x)
Eigen::internal::check_rows_cols_for_overflow	../include/Eigen/src/Core/PlainObjectBase.h	/^EIGEN_ALWAYS_INLINE void check_rows_cols_for_overflow(Index rows, Index cols)$/;"	f	namespace:Eigen::internal	signature:(Index rows, Index cols)
Eigen::internal::check_size_for_overflow	../include/Eigen/src/Core/util/Memory.h	/^EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::check_that_malloc_is_allowed	../include/Eigen/src/Core/util/Memory.h	/^inline void check_that_malloc_is_allowed()$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::check_transpose_aliasing_compile_time_selector	../include/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector<DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
Eigen::internal::check_transpose_aliasing_compile_time_selector	../include/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::check_transpose_aliasing_compile_time_selector::ret	../include/Eigen/src/Core/Transpose.h	/^  enum { ret =    bool(blas_traits<DerivedA>::IsTransposed) != DestIsTransposed$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon75
Eigen::internal::check_transpose_aliasing_compile_time_selector::ret	../include/Eigen/src/Core/Transpose.h	/^  enum { ret = bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed };$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon74
Eigen::internal::checkTransposeAliasing_impl	../include/Eigen/src/Core/Transpose.h	/^struct checkTransposeAliasing_impl<Derived, OtherDerived, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::checkTransposeAliasing_impl	../include/Eigen/src/Core/Transpose.h	/^struct checkTransposeAliasing_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::checkTransposeAliasing_impl::run	../include/Eigen/src/Core/Transpose.h	/^    static void run(const Derived&, const OtherDerived&)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl	access:public	signature:(const Derived&, const OtherDerived&)
Eigen::internal::checkTransposeAliasing_impl::run	../include/Eigen/src/Core/Transpose.h	/^    static void run(const Derived& dst, const OtherDerived& other)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl	access:public	signature:(const Derived& dst, const OtherDerived& other)
Eigen::internal::check_transpose_aliasing_run_time_selector	../include/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
Eigen::internal::check_transpose_aliasing_run_time_selector	../include/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::check_transpose_aliasing_run_time_selector::run	../include/Eigen/src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector	access:public	signature:(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)
Eigen::internal::check_transpose_aliasing_run_time_selector::run	../include/Eigen/src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const OtherDerived& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector	access:public	signature:(const Scalar* dest, const OtherDerived& src)
Eigen::internal::cholmod_configure_matrix	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^void cholmod_configure_matrix(CholmodType& mat)$/;"	f	namespace:Eigen::internal	signature:(CholmodType& mat)
Eigen::internal::coeff_visitor::col	../include/Eigen/src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor	access:public
Eigen::internal::coeff_visitor	../include/Eigen/src/Core/Visitor.h	/^struct coeff_visitor$/;"	s	namespace:Eigen::internal
Eigen::internal::coeff_visitor::Index	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::coeff_visitor	access:public
Eigen::internal::coeff_visitor::init	../include/Eigen/src/Core/Visitor.h	/^  inline void init(const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::coeff_visitor	access:public	signature:(const Scalar& value, Index i, Index j)
Eigen::internal::coeff_visitor::res	../include/Eigen/src/Core/Visitor.h	/^  Scalar res;$/;"	m	struct:Eigen::internal::coeff_visitor	access:public
Eigen::internal::coeff_visitor::row	../include/Eigen/src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor	access:public
Eigen::internal::coeff_visitor::Scalar	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::coeff_visitor	access:public
Eigen::internal::cofactor_3x3	../include/Eigen/src/LU/Inverse.h	/^inline typename MatrixType::Scalar cofactor_3x3(const MatrixType& m)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& m)
Eigen::internal::cofactor_4x4	../include/Eigen/src/LU/Inverse.h	/^inline typename MatrixType::Scalar cofactor_4x4(const MatrixType& matrix)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& matrix)
EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE	../include/Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::complex_schur_reduce_to_hessenberg	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg<MatrixType, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::complex_schur_reduce_to_hessenberg	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg$/;"	s	namespace:Eigen::internal
Eigen::internal::complex_schur_reduce_to_hessenberg::run	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^  static void run(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)$/;"	f	struct:Eigen::internal::complex_schur_reduce_to_hessenberg	access:public	signature:(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)
Eigen::internal::CompressedStorage::allocatedSize	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline size_t allocatedSize() const { return m_allocatedSize; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:() const
Eigen::internal::CompressedStorage::append	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    void append(const Scalar& v, Index i)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const Scalar& v, Index i)
Eigen::internal::CompressedStorage::at	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar at(Index key, Scalar defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index key, Scalar defaultValue = Scalar(0)) const
Eigen::internal::CompressedStorage::atInRange	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar atInRange(size_t start, size_t end, Index key, Scalar defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t start, size_t end, Index key, Scalar defaultValue = Scalar(0)) const
Eigen::internal::CompressedStorage::atWithInsertion	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar& atWithInsertion(Index key, Scalar defaultValue = Scalar(0))$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index key, Scalar defaultValue = Scalar(0))
Eigen::internal::CompressedStorage::clear	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline void clear() { m_size = 0; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
Eigen::internal::CompressedStorage::CompressedStorage	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const CompressedStorage& other)
Eigen::internal::CompressedStorage::~CompressedStorage	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    ~CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
Eigen::internal::CompressedStorage::CompressedStorage	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
Eigen::internal::CompressedStorage::CompressedStorage	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t size)
Eigen::internal::CompressedStorage	../include/Eigen/src/SparseCore/CompressedStorage.h	/^class CompressedStorage$/;"	c	namespace:Eigen::internal
Eigen::internal::CompressedStorage::index	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline const Index& index(size_t i) const { return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i) const
Eigen::internal::CompressedStorage::index	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index& index(size_t i) { return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i)
Eigen::internal::CompressedStorage::Index	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::CompressedStorage	access:public
Eigen::internal::CompressedStorage::m_allocatedSize	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    size_t m_allocatedSize;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
Eigen::internal::CompressedStorage::Map	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    static CompressedStorage Map(Index* indices, Scalar* values, size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index* indices, Scalar* values, size_t size)
Eigen::internal::CompressedStorage::m_indices	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    Index* m_indices;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
Eigen::internal::CompressedStorage::m_size	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    size_t m_size;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
Eigen::internal::CompressedStorage::m_values	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    Scalar* m_values;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
Eigen::internal::CompressedStorage::operator =	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage& operator=(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const CompressedStorage& other)
Eigen::internal::CompressedStorage::prune	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    void prune(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())
Eigen::internal::CompressedStorage::reallocate	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline void reallocate(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:protected	signature:(size_t size)
Eigen::internal::CompressedStorage::RealScalar	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::CompressedStorage	access:protected
Eigen::internal::CompressedStorage::reserve	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    void reserve(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t size)
Eigen::internal::CompressedStorage::resize	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    void resize(size_t size, float reserveSizeFactor = 0)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t size, float reserveSizeFactor = 0)
Eigen::internal::CompressedStorage::Scalar	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::CompressedStorage	access:public
Eigen::internal::CompressedStorage::searchLowerIndex	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(Index key) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index key) const
Eigen::internal::CompressedStorage::searchLowerIndex	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(size_t start, size_t end, Index key) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t start, size_t end, Index key) const
Eigen::internal::CompressedStorage::size	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline size_t size() const { return m_size; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:() const
Eigen::internal::CompressedStorage::squeeze	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    void squeeze()$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
Eigen::internal::CompressedStorage::swap	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    void swap(CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(CompressedStorage& other)
Eigen::internal::CompressedStorage::value	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline const Scalar& value(size_t i) const { return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i) const
Eigen::internal::CompressedStorage::value	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar& value(size_t i) { return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i)
Eigen::internal::compute_inverse_and_det_with_check	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_and_det_with_check	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_and_det_with_check	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_and_det_with_check	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_and_det_with_check	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check { \/* nothing! general case not supported. *\/ };$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_and_det_with_check::run	../include/Eigen/src/LU/Inverse.h	/^  static inline void run($/;"	f	struct:Eigen::internal::compute_inverse_and_det_with_check	access:public	signature:( const MatrixType& matrix, const typename MatrixType::RealScalar& absDeterminantThreshold, ResultType& inverse, typename ResultType::Scalar& determinant, bool& invertible )
Eigen::internal::compute_inverse_and_det_with_check::run	../include/Eigen/src/LU/Inverse.h	/^  static inline void run($/;"	f	struct:Eigen::internal::compute_inverse_and_det_with_check	access:public	signature:( const MatrixType& matrix, const typename MatrixType::RealScalar& absDeterminantThreshold, ResultType& result, typename ResultType::Scalar& determinant, bool& invertible )
Eigen::internal::compute_inverse	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal	inherits:compute_inverse_size4
Eigen::internal::compute_inverse	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse::run	../include/Eigen/src/LU/Inverse.h	/^  static inline void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse	access:public	signature:(const MatrixType& matrix, ResultType& result)
Eigen::internal::compute_inverse_size2_helper	../include/Eigen/src/LU/Inverse.h	/^inline void compute_inverse_size2_helper($/;"	f	namespace:Eigen::internal	signature:( const MatrixType& matrix, const typename ResultType::Scalar& invdet, ResultType& result)
Eigen::internal::compute_inverse_size3_helper	../include/Eigen/src/LU/Inverse.h	/^inline void compute_inverse_size3_helper($/;"	f	namespace:Eigen::internal	signature:( const MatrixType& matrix, const typename ResultType::Scalar& invdet, const Matrix<typename ResultType::Scalar,3,1>& cofactors_col0, ResultType& result)
Eigen::internal::compute_inverse_size4	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, double, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_size4	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, float, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_size4	../include/Eigen/src/LU/Inverse.h	/^struct compute_inverse_size4$/;"	s	namespace:Eigen::internal
Eigen::internal::compute_inverse_size4::MatrixAlignment	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment     = bool(MatrixType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon398
Eigen::internal::compute_inverse_size4::MatrixAlignment	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment = bool(MatrixType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon399
Eigen::internal::compute_inverse_size4::ResultAlignment	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^    ResultAlignment     = bool(ResultType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon398
Eigen::internal::compute_inverse_size4::ResultAlignment	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^    ResultAlignment = bool(ResultType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon399
Eigen::internal::compute_inverse_size4::run	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4	access:public	signature:(const MatrixType& matrix, ResultType& result)
Eigen::internal::compute_inverse_size4::run	../include/Eigen/src/LU/Inverse.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4	access:public	signature:(const MatrixType& matrix, ResultType& result)
Eigen::internal::compute_inverse_size4::StorageOrdersMatch	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon398
Eigen::internal::compute_inverse_size4::StorageOrdersMatch	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon399
Eigen::internal::computeProductBlockingSizes	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void computeProductBlockingSizes(std::ptrdiff_t& k, std::ptrdiff_t& m, std::ptrdiff_t& n)$/;"	f	namespace:Eigen::internal	signature:(std::ptrdiff_t& k, std::ptrdiff_t& m, std::ptrdiff_t& n)
Eigen::internal::computeProductBlockingSizes	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^void computeProductBlockingSizes(std::ptrdiff_t& k, std::ptrdiff_t& m, std::ptrdiff_t& n)$/;"	f	namespace:Eigen::internal	signature:(std::ptrdiff_t& k, std::ptrdiff_t& m, std::ptrdiff_t& n)
Eigen::internal::conditional_aligned_delete_auto	../include/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline void conditional_aligned_delete_auto(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
Eigen::internal::conditional_aligned_delete	../include/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline void conditional_aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
Eigen::internal::conditional_aligned_free	../include/Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
Eigen::internal::conditional_aligned_free	../include/Eigen/src/Core/util/Memory.h	/^template<> inline void conditional_aligned_free<false>(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
Eigen::internal::conditional_aligned_malloc	../include/Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::conditional_aligned_malloc	../include/Eigen/src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_malloc<false>(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::conditional_aligned_new_auto	../include/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_new_auto(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::conditional_aligned_new	../include/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_new(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::conditional_aligned_realloc	../include/Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t new_size, size_t old_size)
Eigen::internal::conditional_aligned_realloc	../include/Eigen/src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t new_size, size_t)
Eigen::internal::conditional_aligned_realloc_new_auto	../include/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new_auto(T* pts, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(T* pts, size_t new_size, size_t old_size)
Eigen::internal::conditional_aligned_realloc_new	../include/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new(T* pts, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(T* pts, size_t new_size, size_t old_size)
Eigen::internal::conditional	../include/Eigen/src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::conditional	../include/Eigen/src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::conditional::type	../include/Eigen/src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	t	struct:Eigen::internal::conditional	access:public
Eigen::internal::conditional::type	../include/Eigen/src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	t	struct:Eigen::internal::conditional	access:public
Eigen::internal::conj_expr_if	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^template<bool Cond, typename T> struct conj_expr_if$/;"	s	namespace:Eigen::internal	inherits:conditional
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet2d, false,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet4f, false,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2d, Packet1cd, false,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet4f, Packet2cf, false,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<RealScalar, std::complex<RealScalar>, false,Conj>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<std::complex<RealScalar>, RealScalar, Conj,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, false,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename Scalar> struct conj_helper<Scalar,Scalar,false,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_helper::pmadd	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
Eigen::internal::conj_helper::pmadd	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
Eigen::internal::conj_helper::pmadd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
Eigen::internal::conj_helper::pmadd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const
Eigen::internal::conj_helper::pmadd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const
Eigen::internal::conj_helper::pmadd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
Eigen::internal::conj_helper::pmadd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const
Eigen::internal::conj_helper::pmadd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const
Eigen::internal::conj_helper::pmadd	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const RealScalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const RealScalar& x, const Scalar& y, const Scalar& c) const
Eigen::internal::conj_helper::pmadd	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const RealScalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const RealScalar& y, const Scalar& c) const
Eigen::internal::conj_helper::pmadd	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& c) const
Eigen::internal::conj_helper::pmadd	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const { return internal::pmadd(x,y,c); }$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& c) const
Eigen::internal::conj_helper::pmul	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& a, const Packet2cf& b) const
Eigen::internal::conj_helper::pmul	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& a, const Packet2cf& b) const
Eigen::internal::conj_helper::pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& a, const Packet1cd& b) const
Eigen::internal::conj_helper::pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& x, const Packet2d& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& x, const Packet2d& y) const
Eigen::internal::conj_helper::pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet2d& x, const Packet1cd& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2d& x, const Packet1cd& y) const
Eigen::internal::conj_helper::pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& a, const Packet2cf& b) const
Eigen::internal::conj_helper::pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& x, const Packet4f& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet4f& y) const
Eigen::internal::conj_helper::pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet4f& x, const Packet2cf& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet4f& x, const Packet2cf& y) const
Eigen::internal::conj_helper::pmul	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const RealScalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const RealScalar& x, const Scalar& y) const
Eigen::internal::conj_helper::pmul	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const RealScalar& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const RealScalar& y) const
Eigen::internal::conj_helper::pmul	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y) const
Eigen::internal::conj_helper::pmul	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const { return internal::pmul(x,y); }$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y) const
Eigen::internal::conj_helper::Scalar	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef std::complex<RealScalar> Scalar;$/;"	t	struct:Eigen::internal::conj_helper	access:public
Eigen::internal::conj_if	../include/Eigen/src/Core/util/BlasUtil.h	/^template<> struct conj_if<false> {$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_if	../include/Eigen/src/Core/util/BlasUtil.h	/^template<> struct conj_if<true> {$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_if::operator ()	../include/Eigen/src/Core/util/BlasUtil.h	/^  inline const T& operator()(const T& x) { return x; }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
Eigen::internal::conj_if::operator ()	../include/Eigen/src/Core/util/BlasUtil.h	/^  inline T operator()(const T& x) { return conj(x); }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
Eigen::internal::conj_if::pconj	../include/Eigen/src/Core/util/BlasUtil.h	/^  inline const T& pconj(const T& x) { return x; }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
Eigen::internal::conj_if::pconj	../include/Eigen/src/Core/util/BlasUtil.h	/^  inline T pconj(const T& x) { return internal::pconj(x); }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
Eigen::internal::conj_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct conj_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct conj_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::conj_impl	access:public	signature:(const Scalar& x)
Eigen::internal::conj_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline std::complex<RealScalar> run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::conj_impl	access:public	signature:(const std::complex<RealScalar>& x)
Eigen::internal::conj	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(conj, Scalar) conj(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
Eigen::internal::conj_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct conj_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::conj_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::conj_retval	access:public
Eigen::internal::conjugate_gradient	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^void conjugate_gradient(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, const Rhs& rhs, Dest& x, const Preconditioner& precond, int& iters, typename Dest::RealScalar& tol_error)
Eigen::internal::conservative_resize_like_impl	../include/Eigen/src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl<Derived,OtherDerived,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_resize_like_impl	../include/Eigen/src/Core/PlainObjectBase.h	/^struct internal::conservative_resize_like_impl$/;"	s	class:Eigen::internal
Eigen::internal::conservative_resize_like_impl::Index	../include/Eigen/src/Core/PlainObjectBase.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::conservative_resize_like_impl	access:public
Eigen::internal::conservative_resize_like_impl::run	../include/Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl	access:public	signature:(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)
Eigen::internal::conservative_resize_like_impl::run	../include/Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index rows, Index cols)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl	access:public	signature:(DenseBase<Derived>& _this, Index rows, Index cols)
Eigen::internal::conservative_resize_like_impl::run	../include/Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index size)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl	access:public	signature:(DenseBase<Derived>& _this, Index size)
Eigen::internal::conservative_sparse_sparse_product_impl	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^static void conservative_sparse_sparse_product_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	namespace:Eigen::internal	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res)
Eigen::internal::conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::conservative_sparse_sparse_product_selector::LhsCleaned	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public
Eigen::internal::conservative_sparse_sparse_product_selector::run	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res)
Eigen::internal::conservative_sparse_sparse_product_selector::Scalar	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename LhsCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public
Eigen::internal::conservative_sparse_sparse_product_selector::Scalar	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public
Eigen::internal::const_blas_data_mapper::const_blas_data_mapper	../include/Eigen/src/Core/util/BlasUtil.h	/^    const_blas_data_mapper(const Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::const_blas_data_mapper	access:public	signature:(const Scalar* data, Index stride)
Eigen::internal::const_blas_data_mapper	../include/Eigen/src/Core/util/BlasUtil.h	/^class const_blas_data_mapper$/;"	c	namespace:Eigen::internal
Eigen::internal::const_blas_data_mapper::m_data	../include/Eigen/src/Core/util/BlasUtil.h	/^    const Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::const_blas_data_mapper	access:protected
Eigen::internal::const_blas_data_mapper::m_stride	../include/Eigen/src/Core/util/BlasUtil.h	/^    Index m_stride;$/;"	m	class:Eigen::internal::const_blas_data_mapper	access:protected
Eigen::internal::const_blas_data_mapper::operator ()	../include/Eigen/src/Core/util/BlasUtil.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i, Index j) const$/;"	f	class:Eigen::internal::const_blas_data_mapper	access:public	signature:(Index i, Index j) const
Eigen::internal::construct_elements_of_array	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
Eigen::internal::constructor_without_unaligned_array_assert	../include/Eigen/src/Core/DenseStorage.h	/^struct constructor_without_unaligned_array_assert {};$/;"	s	namespace:Eigen::internal
Eigen::internal::copy_bool	../include/Eigen/src/Core/util/Macros.h	/^    inline bool copy_bool(bool b) { return b; }$/;"	f	namespace:Eigen::internal	signature:(bool b)
Eigen::internal::cpuid_is_vendor	../include/Eigen/src/Core/util/Memory.h	/^inline bool cpuid_is_vendor(int abcd[4], const char* vendor)$/;"	f	namespace:Eigen::internal	signature:(int abcd[4], const char* vendor)
Eigen::internal::cross3_impl	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct cross3_impl<Architecture::SSE,VectorLhs,VectorRhs,float,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::cross3_impl	../include/Eigen/src/Geometry/OrthoMethods.h	/^struct cross3_impl {$/;"	s	namespace:Eigen::internal
Eigen::internal::cross3_impl::run	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl	access:public	signature:(const VectorLhs& lhs, const VectorRhs& rhs)
Eigen::internal::cross3_impl::run	../include/Eigen/src/Geometry/OrthoMethods.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl	access:public	signature:(const VectorLhs& lhs, const VectorRhs& rhs)
Eigen::internal::cs_tdfs	../include/Eigen/src/OrderingMethods/Amd.h	/^Index cs_tdfs(Index j, Index k, Index *head, const Index *next, Index *post, Index *stack)$/;"	f	namespace:Eigen::internal	signature:(Index j, Index k, Index *head, const Index *next, Index *post, Index *stack)
Eigen::internal::cs_wclear	../include/Eigen/src/OrderingMethods/Amd.h	/^static int cs_wclear (Index mark, Index lemax, Index *w, Index n)$/;"	f	namespace:Eigen::internal	signature:(Index mark, Index lemax, Index *w, Index n)
Eigen::internal::c_to_fortran_numbering	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void c_to_fortran_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat)
Eigen::internal::decrement_size	../include/Eigen/src/Householder/Householder.h	/^template<int n> struct decrement_size$/;"	s	namespace:Eigen::internal
Eigen::internal::decrement_size::ret	../include/Eigen/src/Householder/Householder.h	/^    ret = n==Dynamic ? n : n-1$/;"	e	enum:Eigen::internal::decrement_size::__anon9
Eigen::internal::default_packet_traits::HasAbs2	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs2   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasAbs	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasACos	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasACos   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasAdd	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasASin	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasASin   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasATan	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasATan   = 0$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasConj	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasConj   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasCos	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasCos    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasDiv	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasDiv    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasExp	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasExp    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasLog	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasLog    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasMax	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasMax    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasMin	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasMin    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasMul	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasNegate	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasPow	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasPow    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasSetLinear	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasSetLinear = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasSin	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasSin    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasSqrt	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasSqrt   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasSub	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits::HasTan	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasTan    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
Eigen::internal::default_packet_traits	../include/Eigen/src/Core/GenericPacketMath.h	/^struct default_packet_traits$/;"	s	namespace:Eigen::internal
EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN	../include/Eigen/src/Core/DenseStorage.h	31;"	d
EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN	../include/Eigen/src/Core/DenseStorage.h	33;"	d
Eigen::internal::dense_xpr_base_dispatcher_for_doxygen	../include/Eigen/src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal	inherits:ArrayBase
Eigen::internal::dense_xpr_base_dispatcher_for_doxygen	../include/Eigen/src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal	inherits:MatrixBase
Eigen::internal::destruct_elements_of_array	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal	signature:(T *ptr, size_t size)
Eigen::internal::determinant_impl	../include/Eigen/src/LU/Determinant.h	/^> struct determinant_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::determinant_impl	../include/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::determinant_impl	../include/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 2>$/;"	s	namespace:Eigen::internal
Eigen::internal::determinant_impl	../include/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 3>$/;"	s	namespace:Eigen::internal
Eigen::internal::determinant_impl	../include/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 4>$/;"	s	namespace:Eigen::internal
Eigen::internal::determinant_impl::run	../include/Eigen/src/LU/Determinant.h	/^  static inline typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl	access:public	signature:(const Derived& m)
Eigen::internal::determinant_impl::run	../include/Eigen/src/LU/Determinant.h	/^  static typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl	access:public	signature:(const Derived& m)
Eigen::internal::direct_selfadjoint_eigenvalues::computeRoots	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void computeRoots(const MatrixType& m, VectorType& roots)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(const MatrixType& m, VectorType& roots)
Eigen::internal::direct_selfadjoint_eigenvalues	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType,int Size,bool IsComplex> struct direct_selfadjoint_eigenvalues$/;"	s	namespace:Eigen::internal
Eigen::internal::direct_selfadjoint_eigenvalues	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,2,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::direct_selfadjoint_eigenvalues	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,3,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::direct_selfadjoint_eigenvalues::MatrixType	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
Eigen::internal::direct_selfadjoint_eigenvalues::run	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& eig, const typename SolverType::MatrixType& A, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(SolverType& eig, const typename SolverType::MatrixType& A, int options)
Eigen::internal::direct_selfadjoint_eigenvalues::run	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& solver, const MatrixType& mat, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(SolverType& solver, const MatrixType& mat, int options)
Eigen::internal::direct_selfadjoint_eigenvalues::Scalar	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::Scalar Scalar;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
Eigen::internal::direct_selfadjoint_eigenvalues::VectorType	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::RealVectorType VectorType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
Eigen::internal::dot_nocheck	../include/Eigen/src/Core/Dot.h	/^struct dot_nocheck$/;"	s	namespace:Eigen::internal
Eigen::internal::dot_nocheck	../include/Eigen/src/Core/Dot.h	/^struct dot_nocheck<T, U, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::dot_nocheck::ResScalar	../include/Eigen/src/Core/Dot.h	/^  typedef typename scalar_product_traits<typename traits<T>::Scalar,typename traits<U>::Scalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::dot_nocheck	access:public
Eigen::internal::dot_nocheck::run	../include/Eigen/src/Core/Dot.h	/^  static inline ResScalar run(const MatrixBase<T>& a, const MatrixBase<U>& b)$/;"	f	struct:Eigen::internal::dot_nocheck	access:public	signature:(const MatrixBase<T>& a, const MatrixBase<U>& b)
Eigen::internal::eigen2_part_return_type	../include/Eigen/src/Core/TriangularMatrix.h	/^struct eigen2_part_return_type<MatrixType, SelfAdjoint>$/;"	s	namespace:Eigen::internal
Eigen::internal::eigen2_part_return_type	../include/Eigen/src/Core/TriangularMatrix.h	/^struct eigen2_part_return_type$/;"	s	namespace:Eigen::internal
Eigen::internal::eigen2_part_return_type::type	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef SelfAdjointView<MatrixType, Upper> type;$/;"	t	struct:Eigen::internal::eigen2_part_return_type	access:public
Eigen::internal::eigen2_part_return_type::type	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef TriangularView<MatrixType, Mode> type;$/;"	t	struct:Eigen::internal::eigen2_part_return_type	access:public
Eigen::internal::_EIGEN_DECLARE_CONST_FAST_Packet4f	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4f(ZERO, 0);$/;"	p	namespace:Eigen::internal	signature:(ZERO, 0)
Eigen::internal::_EIGEN_DECLARE_CONST_FAST_Packet4i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(MINUS1,-1);$/;"	p	namespace:Eigen::internal	signature:(MINUS1,-1)
Eigen::internal::_EIGEN_DECLARE_CONST_FAST_Packet4i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(MINUS16,-16);$/;"	p	namespace:Eigen::internal	signature:(MINUS16,-16)
Eigen::internal::_EIGEN_DECLARE_CONST_FAST_Packet4i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(ONE,1);$/;"	p	namespace:Eigen::internal	signature:(ONE,1)
Eigen::internal::_EIGEN_DECLARE_CONST_FAST_Packet4i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static _EIGEN_DECLARE_CONST_FAST_Packet4i(ZERO, 0);$/;"	p	namespace:Eigen::internal	signature:(ZERO, 0)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(all, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(all, (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(any, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(any, (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(blueNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(blueNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(count, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(count, (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(hypotNorm, (Size-1) * functor_traits<scalar_hypot_op<Scalar> >::Cost );$/;"	p	namespace:Eigen::internal	signature:(hypotNorm, (Size-1) * functor_traits<scalar_hypot_op<Scalar> >::Cost )
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(maxCoeff, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(maxCoeff, (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(mean, (Size-1)*NumTraits<Scalar>::AddCost + NumTraits<Scalar>::MulCost);$/;"	p	namespace:Eigen::internal	signature:(mean, (Size-1)*NumTraits<Scalar>::AddCost + NumTraits<Scalar>::MulCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(minCoeff, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(minCoeff, (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(norm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(norm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(prod, (Size-1)*NumTraits<Scalar>::MulCost);$/;"	p	namespace:Eigen::internal	signature:(prod, (Size-1)*NumTraits<Scalar>::MulCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(squaredNorm, Size * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(squaredNorm, Size * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(stableNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(stableNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(sum, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(sum, (Size-1)*NumTraits<Scalar>::AddCost)
Eigen::internal::eigen_pastix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, double *vals, int *perm, int * invp, double *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, double *vals, int *perm, int * invp, double *x, int nbrhs, int *iparm, double *dparm)
Eigen::internal::eigen_pastix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, float *vals, int *perm, int * invp, float *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, float *vals, int *perm, int * invp, float *x, int nbrhs, int *iparm, double *dparm)
Eigen::internal::eigen_pastix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<double> *vals, int *perm, int * invp, std::complex<double> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<double> *vals, int *perm, int * invp, std::complex<double> *x, int nbrhs, int *iparm, double *dparm)
Eigen::internal::eigen_pastix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<float> *vals, int *perm, int * invp, std::complex<float> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<float> *vals, int *perm, int * invp, std::complex<float> *x, int nbrhs, int *iparm, double *dparm)
Eigen::internal::eigenvalues_selector	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector<Derived, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::eigenvalues_selector	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::eigenvalues_selector::MatrixBase::run	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^  run(const MatrixBase<Derived>& m)$/;"	f	class:Eigen::internal::eigenvalues_selector::MatrixBase	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::internal::enable_if	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct enable_if<true,T>$/;"	s	namespace:Eigen::internal
Eigen::internal::enable_if::type	../include/Eigen/src/Core/util/Meta.h	/^{ typedef T type; };$/;"	t	struct:Eigen::internal::enable_if	access:public
EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT	../include/Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::eval	../include/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct eval<T,Sparse>$/;"	s	namespace:Eigen::internal	inherits:sparse_eval
Eigen::internal::extract_data	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename T> const typename T::Scalar* extract_data(const T& m)$/;"	f	namespace:Eigen::internal	signature:(const T& m)
Eigen::internal::extract_data_selector	../include/Eigen/src/Core/util/BlasUtil.h	/^struct extract_data_selector {$/;"	s	namespace:Eigen::internal
Eigen::internal::extract_data_selector	../include/Eigen/src/Core/util/BlasUtil.h	/^struct extract_data_selector<T,false> {$/;"	s	namespace:Eigen::internal
Eigen::internal::extract_data_selector::run	../include/Eigen/src/Core/util/BlasUtil.h	/^  static const typename T::Scalar* run(const T& m)$/;"	f	struct:Eigen::internal::extract_data_selector	access:public	signature:(const T& m)
Eigen::internal::extract_data_selector::run	../include/Eigen/src/Core/util/BlasUtil.h	/^  static typename T::Scalar* run(const T&) { return 0; }$/;"	f	struct:Eigen::internal::extract_data_selector	access:public	signature:(const T&)
Eigen::internal::false_type	../include/Eigen/src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::false_type::value	../include/Eigen/src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::false_type::__anon174
Eigen::internal::first_aligned_impl	../include/Eigen/src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl<Derived, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::first_aligned_impl	../include/Eigen/src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::first_aligned_impl::run	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  static inline typename Derived::Index run(const Derived&)$/;"	f	struct:Eigen::internal::first_aligned_impl	access:public	signature:(const Derived&)
Eigen::internal::first_aligned_impl::run	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  static inline typename Derived::Index run(const Derived& m)$/;"	f	struct:Eigen::internal::first_aligned_impl	access:public	signature:(const Derived& m)
Eigen::internal::first_aligned	../include/Eigen/src/Core/DenseCoeffsBase.h	/^static inline typename Derived::Index first_aligned(const Derived& m)$/;"	f	namespace:Eigen::internal	signature:(const Derived& m)
Eigen::internal::first_aligned	../include/Eigen/src/Core/util/Memory.h	/^static inline Index first_aligned(const Scalar* array, Index size)$/;"	f	namespace:Eigen::internal	signature:(const Scalar* array, Index size)
Eigen::internal::floor_log2_bogus	../include/Eigen/src/Core/MathFunctions.h	/^  floor_log2_bogus$/;"	e	enum:Eigen::internal::__anon262
Eigen::internal::floor_log2	../include/Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_bogus>$/;"	s	namespace:Eigen::internal
Eigen::internal::floor_log2	../include/Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_move_down>$/;"	s	namespace:Eigen::internal
Eigen::internal::floor_log2	../include/Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_move_up>$/;"	s	namespace:Eigen::internal
Eigen::internal::floor_log2	../include/Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_terminate>$/;"	s	namespace:Eigen::internal
Eigen::internal::floor_log2	../include/Eigen/src/Core/MathFunctions.h	/^struct floor_log2 {};$/;"	s	namespace:Eigen::internal
Eigen::internal::floor_log2_move_down	../include/Eigen/src/Core/MathFunctions.h	/^  floor_log2_move_down,$/;"	e	enum:Eigen::internal::__anon262
Eigen::internal::floor_log2_move_up	../include/Eigen/src/Core/MathFunctions.h	/^  floor_log2_move_up,$/;"	e	enum:Eigen::internal::__anon262
Eigen::internal::floor_log2_selector	../include/Eigen/src/Core/MathFunctions.h	/^template<unsigned int n, int lower, int upper> struct floor_log2_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::floor_log2_selector::middle	../include/Eigen/src/Core/MathFunctions.h	/^  enum { middle = (lower + upper) \/ 2,$/;"	e	enum:Eigen::internal::floor_log2_selector::__anon263
Eigen::internal::floor_log2_selector::value	../include/Eigen/src/Core/MathFunctions.h	/^         value = (upper <= lower + 1) ? int(floor_log2_terminate)$/;"	e	enum:Eigen::internal::floor_log2_selector::__anon263
Eigen::internal::floor_log2_terminate	../include/Eigen/src/Core/MathFunctions.h	/^  floor_log2_terminate,$/;"	e	enum:Eigen::internal::__anon262
Eigen::internal::floor_log2::value	../include/Eigen/src/Core/MathFunctions.h	/^  enum { value = floor_log2<n, floor_log2_selector<n, lower, upper>::middle, upper>::value };$/;"	e	enum:Eigen::internal::floor_log2::__anon265
Eigen::internal::floor_log2::value	../include/Eigen/src/Core/MathFunctions.h	/^  enum { value = floor_log2<n, lower, floor_log2_selector<n, lower, upper>::middle>::value };$/;"	e	enum:Eigen::internal::floor_log2::__anon264
Eigen::internal::floor_log2::value	../include/Eigen/src/Core/MathFunctions.h	/^  enum { value = (n >= ((unsigned int)(1) << (lower+1))) ? lower+1 : lower };$/;"	e	enum:Eigen::internal::floor_log2::__anon266
Eigen::internal::fortran_to_c_numbering	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void fortran_to_c_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat)
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::cols	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index cols() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:() const
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::evalTo	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:(ResultType& result) const
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::evalTo	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result, WorkVectorType& workspace) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:(ResultType& result, WorkVectorType& workspace) const
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::FullPivHouseholderQRMatrixQReturnType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  FullPivHouseholderQRMatrixQReturnType(const MatrixType&       qr,$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:(const MatrixType& qr, const HCoeffsType& hCoeffs, const IntColVectorType& rowsTranspositions)
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::HCoeffsType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
Eigen::internal::FullPivHouseholderQRMatrixQReturnType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename MatrixType> struct FullPivHouseholderQRMatrixQReturnType$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::Index	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::IntColVectorType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::m_hCoeffs	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typename HCoeffsType::Nested m_hCoeffs;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:protected
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::m_qr	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typename MatrixType::Nested m_qr;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:protected
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::m_rowsTranspositions	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typename IntColVectorType::Nested m_rowsTranspositions;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:protected
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::rows	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:() const
Eigen::internal::FullPivHouseholderQRMatrixQReturnType::WorkVectorType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^                 MatrixType::MaxRowsAtCompileTime> WorkVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
Eigen::internal::functor_allows_mixing_real_and_complex	../include/Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_allows_mixing_real_and_complex { enum { ret = 0 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_allows_mixing_real_and_complex	../include/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_allows_mixing_real_and_complex	../include/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_allows_mixing_real_and_complex::ret	../include/Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_allows_mixing_real_and_complex { enum { ret = 0 }; };$/;"	e	enum:Eigen::internal::functor_allows_mixing_real_and_complex::__anon324
Eigen::internal::functor_allows_mixing_real_and_complex::ret	../include/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_allows_mixing_real_and_complex::__anon326
Eigen::internal::functor_allows_mixing_real_and_complex::ret	../include/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_allows_mixing_real_and_complex::__anon325
Eigen::internal::functor_has_linear_access	../include/Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_has_linear_access	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_has_linear_access::ret	../include/Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon322
Eigen::internal::functor_has_linear_access::ret	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon323
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 2 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon301
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon328
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon329
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon330
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon331
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon332
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon333
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon302
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon303
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<LhsScalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon295
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost)\/2, \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon293
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon291
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon296
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon297
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon300
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon304
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon305
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::IsComplex ? NumTraits<Scalar>::AddCost : 0,$/;"	e	enum:Eigen::internal::functor_traits::__anon307
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon309
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon310
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon311
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon312
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon356
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon357
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon358
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon359
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon354
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon355
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon343
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon344
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon345
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon346
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon347
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon348
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon349
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon350
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon351
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon321
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon319
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon318
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon337
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon298
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon299
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon334
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon313
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon314
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon361
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon360
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon352
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon353
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon308
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon316
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon320
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon327
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon306
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon335
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon315
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon317
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon336
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon340
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon341
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon342
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon338
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon339
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon365
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon52
Eigen::internal::functor_traits::Cost	../include/Eigen/src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon53
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_abs2_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_abs_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_acos_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_add_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_asin_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_binary_pow_op<Scalar,OtherScalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cast_op<Scalar,NewType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_conj_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_conjugate_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_constant_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cos_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cube_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_difference_op<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_exp_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_hypot_op<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_identity_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_imag_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_imag_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_inverse_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_log_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_max_op<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_min_op<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_multiple2_op<Scalar1,Scalar2> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_multiple_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_opposite_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_pow_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_quotient1_impl<Scalar,false> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_quotient1_impl<Scalar,true> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_quotient1_op<Scalar> >$/;"	s	namespace:Eigen::internal	inherits:functor_traits
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_quotient_op<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_real_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_real_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_sin_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_sqrt_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_square_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_sum_op<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_tan_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::binary_compose<T0,T1,T2> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::binary_negate<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::binder1st<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::binder2nd<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::divides<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::equal_to<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::greater_equal<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::greater<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::less_equal<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::less<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::logical_and<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::logical_not<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::logical_or<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::minus<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::multiplies<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::negate<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::not_equal_to<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::plus<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::project1st<T0,T1> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::project2nd<T0,T1> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::select1st<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::select2nd<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::unary_compose<T0,T1> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::unary_negate<T> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^template<> struct functor_traits<scalar_boolean_and_op> {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^template<> struct functor_traits<scalar_boolean_or_op> {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Functors.h	/^template <typename Scalar, bool RandomAccess> struct functor_traits< linspaced_op<Scalar,RandomAccess> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Random.h	/^struct functor_traits<scalar_random_op<Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Visitor.h	/^struct functor_traits<max_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits	../include/Eigen/src/Core/Visitor.h	/^struct functor_traits<min_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::functor_traits::IsRepeatable	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon321
Eigen::internal::functor_traits::IsRepeatable	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon319
Eigen::internal::functor_traits::IsRepeatable	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon320
Eigen::internal::functor_traits::IsRepeatable	../include/Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon365
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon309
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon310
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon311
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon312
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon356
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon357
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon358
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon359
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon354
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon355
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon343
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon344
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon345
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon346
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon347
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon348
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon349
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon350
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon351
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon321
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon319
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon318
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon337
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon298
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon299
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon334
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon313
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon314
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon361
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon360
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon352
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon353
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon308
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon316
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon320
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon327
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon306
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon335
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon315
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon317
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon336
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon340
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon341
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon342
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon338
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon339
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon302
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon303
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMul$/;"	e	enum:Eigen::internal::functor_traits::__anon295
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasAbs$/;"	e	enum:Eigen::internal::functor_traits::__anon305
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasACos$/;"	e	enum:Eigen::internal::functor_traits::__anon332
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasAdd$/;"	e	enum:Eigen::internal::functor_traits::__anon291
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasASin$/;"	e	enum:Eigen::internal::functor_traits::__anon333
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasConj$/;"	e	enum:Eigen::internal::functor_traits::__anon307
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasCos$/;"	e	enum:Eigen::internal::functor_traits::__anon329
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasDiv$/;"	e	enum:Eigen::internal::functor_traits::__anon301
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasMax$/;"	e	enum:Eigen::internal::functor_traits::__anon297
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasMin$/;"	e	enum:Eigen::internal::functor_traits::__anon296
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasNegate };$/;"	e	enum:Eigen::internal::functor_traits::__anon304
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSin$/;"	e	enum:Eigen::internal::functor_traits::__anon330
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSqrt$/;"	e	enum:Eigen::internal::functor_traits::__anon328
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSub$/;"	e	enum:Eigen::internal::functor_traits::__anon300
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasTan$/;"	e	enum:Eigen::internal::functor_traits::__anon331
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = scalar_product_op<LhsScalar,RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon293
Eigen::internal::functor_traits::PacketAccess	../include/Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon365
Eigen::internal::gebp_kernel::AccPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::AccPacket AccPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Eigen::internal::gebp_kernel	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gebp_kernel$/;"	s	namespace:Eigen::internal
Eigen::internal::gebp_kernel::LhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::LhsPacket LhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Eigen::internal::gebp_kernel::LhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress   = Traits::LhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon99
Eigen::internal::gebp_kernel::operator ()	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha,$/;"	f	struct:Eigen::internal::gebp_kernel	access:public	signature:(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0, RhsScalar* unpackedB = 0)
Eigen::internal::gebp_kernel::ResPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResPacket ResPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Eigen::internal::gebp_kernel::ResPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Traits::ResPacketSize$/;"	e	enum:Eigen::internal::gebp_kernel::__anon99
Eigen::internal::gebp_kernel::ResScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Eigen::internal::gebp_kernel::RhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::RhsPacket RhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Eigen::internal::gebp_kernel::RhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress   = Traits::RhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon99
Eigen::internal::gebp_kernel::Traits	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> Traits;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
Eigen::internal::gebp_kernel::Vectorizable	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable  = Traits::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon99
Eigen::internal::gebp_madd	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void gebp_madd(const CJ& cj, A& a, B& b, C& c, T& t)$/;"	f	namespace:Eigen::internal	signature:(const CJ& cj, A& a, B& b, C& c, T& t)
Eigen::internal::gebp_madd_selector	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename A, typename B, typename C, typename T> struct gebp_madd_selector {$/;"	s	namespace:Eigen::internal
Eigen::internal::gebp_madd_selector	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename T> struct gebp_madd_selector<CJ,T,T,T,T> {$/;"	s	namespace:Eigen::internal
Eigen::internal::gebp_madd_selector::run	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, A& a, B& b, C& c, T& \/*t*\/)$/;"	f	struct:Eigen::internal::gebp_madd_selector	access:public	signature:(const CJ& cj, A& a, B& b, C& c, T& )
Eigen::internal::gebp_madd_selector::run	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, T& a, T& b, T& c, T& t)$/;"	f	struct:Eigen::internal::gebp_madd_selector	access:public	signature:(const CJ& cj, T& a, T& b, T& c, T& t)
Eigen::internal::gebp_traits::acc	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const
Eigen::internal::gebp_traits::acc	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const DoublePacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const DoublePacket& c, const ResPacket& alpha, ResPacket& r) const
Eigen::internal::gebp_traits::acc	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const Scalar& c, const Scalar& alpha, Scalar& r) const { r += alpha * c; }$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const Scalar& c, const Scalar& alpha, Scalar& r) const
Eigen::internal::gebp_traits::AccPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef ResPacket AccPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::AccPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type AccPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::cj	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<LhsScalar,RhsScalar,ConjLhs,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits	access:protected
Eigen::internal::gebp_traits::cj	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,ConjLhs,false> cj;$/;"	m	class:Eigen::internal::gebp_traits	access:protected
Eigen::internal::gebp_traits::cj	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,false,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits	access:protected
Eigen::internal::gebp_traits::ConjLhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Eigen::internal::gebp_traits::ConjLhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Eigen::internal::gebp_traits::ConjLhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
Eigen::internal::gebp_traits::ConjLhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Eigen::internal::gebp_traits::ConjRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Eigen::internal::gebp_traits::ConjRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
Eigen::internal::gebp_traits::ConjRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Eigen::internal::gebp_traits::ConjRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Eigen::internal::gebp_traits::DoublePacket::first	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacket first;$/;"	m	struct:Eigen::internal::gebp_traits::DoublePacket	access:public
Eigen::internal::gebp_traits::DoublePacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  struct DoublePacket$/;"	s	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::DoublePacket::second	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacket second;$/;"	m	struct:Eigen::internal::gebp_traits::DoublePacket	access:public
Eigen::internal::gebp_traits	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits$/;"	c	namespace:Eigen::internal
Eigen::internal::gebp_traits	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<RealScalar, std::complex<RealScalar>, false, _ConjRhs >$/;"	c	namespace:Eigen::internal
Eigen::internal::gebp_traits	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, RealScalar, _ConjLhs, false>$/;"	c	namespace:Eigen::internal
Eigen::internal::gebp_traits	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, std::complex<RealScalar>, _ConjLhs, _ConjRhs >$/;"	c	namespace:Eigen::internal
Eigen::internal::gebp_traits::initAcc	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(AccPacket& p)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(AccPacket& p)
Eigen::internal::gebp_traits::initAcc	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(DoublePacket& p)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(DoublePacket& p)
Eigen::internal::gebp_traits::initAcc	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(Scalar& p) { p = Scalar(0); }$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(Scalar& p)
Eigen::internal::gebp_traits::LhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::LhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,RealPacket,  Scalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::_LhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::LhsPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Eigen::internal::gebp_traits::LhsPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Eigen::internal::gebp_traits::LhsPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Eigen::internal::gebp_traits::LhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Eigen::internal::gebp_traits::LhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Eigen::internal::gebp_traits::LhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
Eigen::internal::gebp_traits::LhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Eigen::internal::gebp_traits::LhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::LhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::LhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::LhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar> LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::loadLhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhs(const LhsScalar* a, LhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsScalar* a, LhsPacket& dest) const
Eigen::internal::gebp_traits::loadRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, DoublePacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const RhsScalar* b, DoublePacket& dest) const
Eigen::internal::gebp_traits::loadRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, ResPacket& dest) const { dest = *b; }$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const RhsScalar* b, ResPacket& dest) const
Eigen::internal::gebp_traits::loadRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, RhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const RhsScalar* b, RhsPacket& dest) const
Eigen::internal::gebp_traits::madd_impl	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const
Eigen::internal::gebp_traits::madd_impl	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& \/*tmp*\/, const false_type&) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& , const false_type&) const
Eigen::internal::gebp_traits::madd	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, AccPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, AccPacket& c, AccPacket& tmp) const
Eigen::internal::gebp_traits::madd	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const
Eigen::internal::gebp_traits::madd	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, DoublePacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, DoublePacket& c, RhsPacket& ) const
Eigen::internal::gebp_traits::madd	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& ) const
Eigen::internal::gebp_traits::mr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Eigen::internal::gebp_traits::mr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Eigen::internal::gebp_traits::mr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
Eigen::internal::gebp_traits::mr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2*ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Eigen::internal::gebp_traits::nr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 2,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
Eigen::internal::gebp_traits::nr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Eigen::internal::gebp_traits::nr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = NumberOfRegisters\/4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Eigen::internal::gebp_traits::nr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = NumberOfRegisters\/4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Eigen::internal::gebp_traits::NumberOfRegisters	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Eigen::internal::gebp_traits::NumberOfRegisters	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Eigen::internal::gebp_traits::NumberOfRegisters	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Eigen::internal::gebp_traits::RealPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RealScalar>::type RealPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RealPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacketSize  = Vectorizable ? packet_traits<RealScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
Eigen::internal::gebp_traits::ResPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::ResPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,ScalarPacket,Scalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::_ResPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::ResPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Eigen::internal::gebp_traits::ResPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Eigen::internal::gebp_traits::ResPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize   = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
Eigen::internal::gebp_traits::ResPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Eigen::internal::gebp_traits::ResScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      ResScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::ResScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  ResScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::ResScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::_RhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RhsPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Eigen::internal::gebp_traits::RhsPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Eigen::internal::gebp_traits::RhsPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Eigen::internal::gebp_traits::RhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = ResPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Eigen::internal::gebp_traits::RhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = RhsPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Eigen::internal::gebp_traits::RhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = RhsPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Eigen::internal::gebp_traits::RhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = Vectorizable ? 2*ResPacketSize : 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
Eigen::internal::gebp_traits::RhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::RhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::Scalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  Scalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::ScalarPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type     ScalarPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Eigen::internal::gebp_traits::unpackRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void unpackRhs(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)
Eigen::internal::gebp_traits::unpackRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void unpackRhs(DenseIndex n, const Scalar* rhs, Scalar* b)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(DenseIndex n, const Scalar* rhs, Scalar* b)
Eigen::internal::gebp_traits::Vectorizable	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Eigen::internal::gebp_traits::Vectorizable	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Eigen::internal::gebp_traits::Vectorizable	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
Eigen::internal::gebp_traits::Vectorizable	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Eigen::internal::gebp_traits::WorkSpaceFactor	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr * RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Eigen::internal::gebp_traits::WorkSpaceFactor	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr*RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Eigen::internal::gebp_traits::WorkSpaceFactor	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr*RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Eigen::internal::gebp_traits::WorkSpaceFactor	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = Vectorizable ? 2*nr*RealPacketSize : nr,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
Eigen::internal::gemm_blocking_space::ActualCols	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      ActualCols = Transpose ? MaxRows : MaxCols$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon106
Eigen::internal::gemm_blocking_space::ActualRows	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      ActualRows = Transpose ? MaxCols : MaxRows,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon106
Eigen::internal::gemm_blocking_space::allocateA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateA() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateA()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateAll	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateAll() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateAll	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateAll()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateB() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateB()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateW() {}$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::allocateW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateW()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space::gemm_blocking_space	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(DenseIndex \/*rows*\/, DenseIndex \/*cols*\/, DenseIndex \/*depth*\/)$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:(DenseIndex , DenseIndex , DenseIndex )
Eigen::internal::gemm_blocking_space::gemm_blocking_space	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(DenseIndex rows, DenseIndex cols, DenseIndex depth)$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:(DenseIndex rows, DenseIndex cols, DenseIndex depth)
Eigen::internal::gemm_blocking_space::~gemm_blocking_space	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    ~gemm_blocking_space()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
Eigen::internal::gemm_blocking_space	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, false>$/;"	c	namespace:Eigen::internal	inherits:level3_blocking
Eigen::internal::gemm_blocking_space	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, true>$/;"	c	namespace:Eigen::internal	inherits:level3_blocking
Eigen::internal::gemm_blocking_space::LhsScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_RhsScalar,_LhsScalar>::type LhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::m_sizeA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeA;$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::m_sizeB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeB;$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::m_sizeW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeW;$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::m_staticA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 LhsScalar m_staticA[SizeA];$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::m_staticB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 RhsScalar m_staticB[SizeB];$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::m_staticW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 RhsScalar m_staticW[SizeW];$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::RhsScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_LhsScalar,_RhsScalar>::type RhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::SizeA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeA = ActualRows * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon107
Eigen::internal::gemm_blocking_space::SizeB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeB = ActualCols * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon107
Eigen::internal::gemm_blocking_space::SizeW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeW = MaxDepth * Traits::WorkSpaceFactor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon107
Eigen::internal::gemm_blocking_space::Traits	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef gebp_traits<LhsScalar,RhsScalar> Traits;$/;"	t	class:Eigen::internal::gemm_blocking_space	access:private
Eigen::internal::gemm_blocking_space::Transpose	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon106
Eigen::internal::gemm_blocking_space::Transpose	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon108
Eigen::internal::gemm_functor::gemm_functor	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  gemm_functor(const Lhs& lhs, const Rhs& rhs, Dest& dest, Scalar actualAlpha,$/;"	f	struct:Eigen::internal::gemm_functor	access:public	signature:(const Lhs& lhs, const Rhs& rhs, Dest& dest, Scalar actualAlpha, BlockingType& blocking)
Eigen::internal::gemm_functor	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct gemm_functor$/;"	s	namespace:Eigen::internal
Eigen::internal::gemm_functor::initParallelSession	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  void initParallelSession() const$/;"	f	struct:Eigen::internal::gemm_functor	access:public	signature:() const
Eigen::internal::gemm_functor::m_actualAlpha	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Scalar m_actualAlpha;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
Eigen::internal::gemm_functor::m_blocking	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    BlockingType& m_blocking;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
Eigen::internal::gemm_functor::m_dest	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Dest& m_dest;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
Eigen::internal::gemm_functor::m_lhs	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    const Lhs& m_lhs;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
Eigen::internal::gemm_functor::m_rhs	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    const Rhs& m_rhs;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
Eigen::internal::gemm_functor::operator ()	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  void operator() (Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const$/;"	f	struct:Eigen::internal::gemm_functor	access:public	signature:(Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const
Eigen::internal::gemm_pack_lhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_lhs$/;"	s	namespace:Eigen::internal
Eigen::internal::gemm_pack_lhs::operator ()	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_DONT_INLINE void operator()(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows,$/;"	f	struct:Eigen::internal::gemm_pack_lhs	access:public	signature:(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows, Index stride=0, Index offset=0)
Eigen::internal::gemm_pack_rhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, nr, ColMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemm_pack_rhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, nr, RowMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemm_pack_rhs::operator ()	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_DONT_INLINE void operator()(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols,$/;"	f	struct:Eigen::internal::gemm_pack_rhs	access:public	signature:(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols, Index stride=0, Index offset=0)
Eigen::internal::gemm_pack_rhs::Packet	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::gemm_pack_rhs	access:public
Eigen::internal::gemm_pack_rhs::PacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon100
Eigen::internal::gemm_pack_rhs::PacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon101
Eigen::internal::GemmParallelInfo::GemmParallelInfo	../include/Eigen/src/Core/products/Parallelizer.h	/^  GemmParallelInfo() : sync(-1), users(0), rhs_start(0), rhs_length(0) {}$/;"	f	struct:Eigen::internal::GemmParallelInfo	access:public	signature:()
Eigen::internal::GemmParallelInfo	../include/Eigen/src/Core/products/Parallelizer.h	/^template<typename Index> struct GemmParallelInfo$/;"	s	namespace:Eigen::internal
Eigen::internal::GemmParallelInfo::rhs_length	../include/Eigen/src/Core/products/Parallelizer.h	/^  Index rhs_length;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
Eigen::internal::GemmParallelInfo::rhs_start	../include/Eigen/src/Core/products/Parallelizer.h	/^  Index rhs_start;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
Eigen::internal::GemmParallelInfo::sync	../include/Eigen/src/Core/products/Parallelizer.h	/^  int volatile sync;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
Eigen::internal::GemmParallelInfo::users	../include/Eigen/src/Core/products/Parallelizer.h	/^  int volatile users;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
Eigen::internal::gemv_selector	../include/Eigen/src/Core/GeneralProduct.h	/^struct gemv_selector<OnTheLeft,StorageOrder,BlasCompatible>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,ColMajor,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,ColMajor,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,RowMajor,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,RowMajor,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_selector::run	../include/Eigen/src/Core/GeneralProduct.h	/^  static inline void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)$/;"	f	struct:Eigen::internal::gemv_selector	access:public	signature:(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)
Eigen::internal::gemv_selector::run	../include/Eigen/src/Core/GeneralProduct.h	/^  static void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)$/;"	f	struct:Eigen::internal::gemv_selector	access:public	signature:(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)
Eigen::internal::gemv_static_vector_if::data	../include/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE  Scalar* data() { eigen_internal_assert(false && "should never be called"); return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if	access:public	signature:()
Eigen::internal::gemv_static_vector_if::data	../include/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if	access:public	signature:()
Eigen::internal::gemv_static_vector_if::data	../include/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return m_data.array; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if	access:public	signature:()
Eigen::internal::gemv_static_vector_if	../include/Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,Dynamic,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_static_vector_if	../include/Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_static_vector_if	../include/Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::gemv_static_vector_if::m_data	../include/Eigen/src/Core/GeneralProduct.h	/^  internal::plain_array<Scalar,EIGEN_SIZE_MIN_PREFER_FIXED(Size,MaxSize),0> m_data;$/;"	m	struct:Eigen::internal::gemv_static_vector_if	access:public
Eigen::internal::general_det3_helper	../include/Eigen/src/LU/Inverse.h	/^inline const typename Derived::Scalar general_det3_helper$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<Derived>& matrix, int i1, int i2, int i3, int j1, int j2, int j3)
Eigen::internal::general_matrix_matrix_product	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::general_matrix_matrix_product	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::general_matrix_matrix_product::ResScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product	access:public
Eigen::internal::general_matrix_matrix_product::ResScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product	access:public
Eigen::internal::general_matrix_matrix_product::run	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::general_matrix_matrix_product	access:public	signature:( Index rows, Index cols, Index depth, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha, level3_blocking<RhsScalar,LhsScalar>& blocking, GemmParallelInfo<Index>* info = 0)
Eigen::internal::general_matrix_matrix_product::run	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^static void run(Index rows, Index cols, Index depth,$/;"	f	struct:Eigen::internal::general_matrix_matrix_product	access:public	signature:(Index rows, Index cols, Index depth, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha, level3_blocking<LhsScalar,RhsScalar>& blocking, GemmParallelInfo<Index>* info = 0)
Eigen::internal::general_matrix_matrix_rankupdate	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^struct general_matrix_matrix_rankupdate :$/;"	s	namespace:Eigen::internal	inherits:general_matrix_matrix_triangular_product
Eigen::internal::general_matrix_matrix_triangular_product	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::general_matrix_matrix_triangular_product	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::general_matrix_matrix_triangular_product::ResScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_triangular_product	access:public
Eigen::internal::general_matrix_matrix_triangular_product::run	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product	access:public	signature:(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha)
Eigen::internal::general_matrix_matrix_triangular_product::run	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product	access:public	signature:(Index size, Index depth,const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha)
Eigen::internal::general_matrix_vector_product_gemv	../include/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^struct general_matrix_vector_product_gemv :$/;"	s	namespace:Eigen::internal	inherits:general_matrix_vector_product
Eigen::internal::general_matrix_vector_product	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,ColMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::general_matrix_vector_product	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,RowMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::general_matrix_vector_product::LhsPacket	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::_LhsPacket	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::LhsPacketSize	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon91
Eigen::internal::general_matrix_vector_product::LhsPacketSize	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon92
Eigen::internal::general_matrix_vector_product::ResPacket	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::_ResPacket	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::ResPacketSize	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon91
Eigen::internal::general_matrix_vector_product::ResPacketSize	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon92
Eigen::internal::general_matrix_vector_product::ResScalar	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::RhsPacket	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::_RhsPacket	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
Eigen::internal::general_matrix_vector_product::RhsPacketSize	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon91
Eigen::internal::general_matrix_vector_product::RhsPacketSize	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon92
Eigen::internal::general_matrix_vector_product::run	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE static void run($/;"	f	struct:Eigen::internal::general_matrix_vector_product	access:public	signature:( Index rows, Index cols, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsIncr, ResScalar* res, Index resIncr, ResScalar alpha)
Eigen::internal::general_matrix_vector_product::run	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE static void run($/;"	f	struct:Eigen::internal::general_matrix_vector_product	access:public	signature:( Index rows, Index cols, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsIncr, ResScalar* res, Index resIncr , RhsScalar alpha)
Eigen::internal::general_matrix_vector_product::Vectorizable	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon91
Eigen::internal::general_matrix_vector_product::Vectorizable	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon92
Eigen::internal::generic_aligned_realloc	../include/Eigen/src/Core/util/Memory.h	/^inline void* generic_aligned_realloc(void* ptr, size_t size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t size, size_t old_size)
Eigen::internal::get_factor	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename From,typename To> struct get_factor {$/;"	s	namespace:Eigen::internal
Eigen::internal::get_factor	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename Scalar> struct get_factor<Scalar,typename NumTraits<Scalar>::Real> {$/;"	s	namespace:Eigen::internal
Eigen::internal::get_factor::run	../include/Eigen/src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE To run(const From& x) { return x; }$/;"	f	struct:Eigen::internal::get_factor	access:public	signature:(const From& x)
Eigen::internal::get_factor::run	../include/Eigen/src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE typename NumTraits<Scalar>::Real run(const Scalar& x) { return real(x); }$/;"	f	struct:Eigen::internal::get_factor	access:public	signature:(const Scalar& x)
Eigen::internal::global_math_functions_filtering_base	../include/Eigen/src/Core/MathFunctions.h	/^struct global_math_functions_filtering_base$/;"	s	namespace:Eigen::internal
Eigen::internal::global_math_functions_filtering_base::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base	access:public
Eigen::internal::global_math_functions_filtering_base::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base	access:public
Eigen::internal::handmade_aligned_free	../include/Eigen/src/Core/util/Memory.h	/^inline void handmade_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
Eigen::internal::handmade_aligned_malloc	../include/Eigen/src/Core/util/Memory.h	/^inline void* handmade_aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
Eigen::internal::handmade_aligned_realloc	../include/Eigen/src/Core/util/Memory.h	/^inline void* handmade_aligned_realloc(void* ptr, size_t size, size_t = 0)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t size, size_t = 0)
Eigen::internal::has_direct_access	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct has_direct_access$/;"	s	namespace:Eigen::internal
Eigen::internal::has_direct_access::ret	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^  enum { ret = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0 };$/;"	e	enum:Eigen::internal::has_direct_access::__anon205
Eigen::internal::has_none::a	../include/Eigen/src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	m	struct:Eigen::internal::has_none	access:public
Eigen::internal::has_none	../include/Eigen/src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	s	namespace:Eigen::internal
Eigen::internal::has_std_result_type::a	../include/Eigen/src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	m	struct:Eigen::internal::has_std_result_type	access:public
Eigen::internal::has_std_result_type	../include/Eigen/src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	s	namespace:Eigen::internal
Eigen::internal::has_tr1_result::a	../include/Eigen/src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	m	struct:Eigen::internal::has_tr1_result	access:public
Eigen::internal::has_tr1_result	../include/Eigen/src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	s	namespace:Eigen::internal
Eigen::internal::HessenbergDecompositionMatrixHReturnType::cols	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    Index cols() const { return m_hess.packedMatrix().cols(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:() const
Eigen::internal::HessenbergDecompositionMatrixHReturnType::evalTo	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:(ResultType& result) const
Eigen::internal::HessenbergDecompositionMatrixHReturnType::HessenbergDecompositionMatrixHReturnType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecompositionMatrixHReturnType(const HessenbergDecomposition<MatrixType>& hess) : m_hess(hess) { }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:(const HessenbergDecomposition<MatrixType>& hess)
Eigen::internal::HessenbergDecompositionMatrixHReturnType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^template<typename MatrixType> struct HessenbergDecompositionMatrixHReturnType$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::HessenbergDecompositionMatrixHReturnType::Index	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public
Eigen::internal::HessenbergDecompositionMatrixHReturnType::m_hess	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const HessenbergDecomposition<MatrixType>& m_hess;$/;"	m	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:protected
Eigen::internal::HessenbergDecompositionMatrixHReturnType::rows	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    Index rows() const { return m_hess.packedMatrix().rows(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:() const
Eigen::internal::homogeneous_left_product_impl::cols	../include/Eigen/src/Geometry/Homogeneous.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:() const
Eigen::internal::homogeneous_left_product_impl::evalTo	../include/Eigen/src/Geometry/Homogeneous.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:(Dest& dst) const
Eigen::internal::homogeneous_left_product_impl::homogeneous_left_product_impl	../include/Eigen/src/Geometry/Homogeneous.h	/^  homogeneous_left_product_impl(const Lhs& lhs, const MatrixType& rhs)$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:(const Lhs& lhs, const MatrixType& rhs)
Eigen::internal::homogeneous_left_product_impl	../include/Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs>$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::homogeneous_left_product_impl::Index	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Eigen::internal::homogeneous_left_product_impl::LhsMatrixTypeCleaned	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Eigen::internal::homogeneous_left_product_impl::LhsMatrixType	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename traits<homogeneous_left_product_impl>::LhsMatrixType LhsMatrixType;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Eigen::internal::homogeneous_left_product_impl::LhsMatrixTypeNested	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename LhsMatrixTypeCleaned::Nested>::type LhsMatrixTypeNested;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Eigen::internal::homogeneous_left_product_impl::m_lhs	../include/Eigen/src/Geometry/Homogeneous.h	/^  typename LhsMatrixTypeCleaned::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Eigen::internal::homogeneous_left_product_impl::m_rhs	../include/Eigen/src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Eigen::internal::homogeneous_left_product_impl::rows	../include/Eigen/src/Geometry/Homogeneous.h	/^  inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:() const
Eigen::internal::homogeneous_right_product_impl::cols	../include/Eigen/src/Geometry/Homogeneous.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:() const
Eigen::internal::homogeneous_right_product_impl::evalTo	../include/Eigen/src/Geometry/Homogeneous.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:(Dest& dst) const
Eigen::internal::homogeneous_right_product_impl::homogeneous_right_product_impl	../include/Eigen/src/Geometry/Homogeneous.h	/^  homogeneous_right_product_impl(const MatrixType& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:(const MatrixType& lhs, const Rhs& rhs)
Eigen::internal::homogeneous_right_product_impl	../include/Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs>$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::homogeneous_right_product_impl::Index	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl	access:public
Eigen::internal::homogeneous_right_product_impl::m_lhs	../include/Eigen/src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl	access:public
Eigen::internal::homogeneous_right_product_impl::m_rhs	../include/Eigen/src/Geometry/Homogeneous.h	/^  typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl	access:public
Eigen::internal::homogeneous_right_product_impl::RhsNested	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNested;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl	access:public
Eigen::internal::homogeneous_right_product_impl::rows	../include/Eigen/src/Geometry/Homogeneous.h	/^  inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:() const
Eigen::internal::householder_qr_inplace_blocked	../include/Eigen/src/QR/HouseholderQR.h	/^void householder_qr_inplace_blocked(MatrixQR& mat, HCoeffs& hCoeffs,$/;"	f	namespace:Eigen::internal	signature:(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Index maxBlockSize=32, typename MatrixQR::Scalar* tempData = 0)
Eigen::internal::householder_qr_inplace_unblocked	../include/Eigen/src/QR/HouseholderQR.h	/^void householder_qr_inplace_unblocked(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)$/;"	f	namespace:Eigen::internal	signature:(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)
Eigen::internal::hseq_side_dependent_impl::essentialVector	../include/Eigen/src/Householder/HouseholderSequence.h	/^  static inline const EssentialVectorType essentialVector(const HouseholderSequenceType& h, Index k)$/;"	f	struct:Eigen::internal::hseq_side_dependent_impl	access:public	signature:(const HouseholderSequenceType& h, Index k)
Eigen::internal::hseq_side_dependent_impl::EssentialVectorType	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef Block<const VectorsType, Dynamic, 1> EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
Eigen::internal::hseq_side_dependent_impl::EssentialVectorType	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef Transpose<Block<const VectorsType, 1, Dynamic> > EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
Eigen::internal::hseq_side_dependent_impl::HouseholderSequenceType	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheLeft> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
Eigen::internal::hseq_side_dependent_impl::HouseholderSequenceType	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheRight> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
Eigen::internal::hseq_side_dependent_impl	../include/Eigen/src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::hseq_side_dependent_impl	../include/Eigen/src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl<VectorsType, CoeffsType, OnTheRight>$/;"	s	namespace:Eigen::internal
Eigen::internal::hseq_side_dependent_impl::Index	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Index Index;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
Eigen::internal::hypot_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct hypot_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::hypot_impl::RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::hypot_impl	access:public
Eigen::internal::hypot_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::hypot_impl	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::hypot	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(hypot, Scalar) hypot(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::hypot_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct hypot_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::hypot_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::hypot_retval	access:public
Eigen::internal::image_retval_base::Base	../include/Eigen/src/misc/Image.h	/^  typedef ReturnByValue<image_retval_base> Base;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
Eigen::internal::image_retval_base::cols	../include/Eigen/src/misc/Image.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
Eigen::internal::image_retval_base::dec	../include/Eigen/src/misc/Image.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
Eigen::internal::image_retval_base::DecompositionType	../include/Eigen/src/misc/Image.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
Eigen::internal::image_retval_base::evalTo	../include/Eigen/src/misc/Image.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:(Dest& dst) const
Eigen::internal::image_retval_base::image_retval_base	../include/Eigen/src/misc/Image.h	/^  image_retval_base(const DecompositionType& dec, const MatrixType& originalMatrix)$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:(const DecompositionType& dec, const MatrixType& originalMatrix)
Eigen::internal::image_retval_base	../include/Eigen/src/misc/Image.h	/^template<typename _DecompositionType> struct image_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::image_retval_base::Index	../include/Eigen/src/misc/Image.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
Eigen::internal::image_retval_base::MatrixType	../include/Eigen/src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
Eigen::internal::image_retval_base::m_cols	../include/Eigen/src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
Eigen::internal::image_retval_base::m_dec	../include/Eigen/src/misc/Image.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
Eigen::internal::image_retval_base::m_originalMatrix	../include/Eigen/src/misc/Image.h	/^    const MatrixType& m_originalMatrix;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
Eigen::internal::image_retval_base::m_rank	../include/Eigen/src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
Eigen::internal::image_retval_base::originalMatrix	../include/Eigen/src/misc/Image.h	/^  inline const MatrixType& originalMatrix() const { return m_originalMatrix; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
Eigen::internal::image_retval_base::rank	../include/Eigen/src/misc/Image.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
Eigen::internal::image_retval_base::rows	../include/Eigen/src/misc/Image.h	/^  inline Index rows() const { return m_dec.rows(); }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
Eigen::internal::image_retval::evalTo	../include/Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval	access:public	signature:(Dest& dst) const
Eigen::internal::image_retval	../include/Eigen/src/LU/FullPivLU.h	/^struct image_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:image_retval_base
Eigen::internal::image_retval::MaxSmallDimAtCompileTime	../include/Eigen/src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::image_retval::__anon397
Eigen::internal::imag_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::imag_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::imag_impl::RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_impl	access:public
Eigen::internal::imag_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_impl	access:public	signature:(const Scalar&)
Eigen::internal::imag_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::imag_impl	access:public	signature:(const std::complex<RealScalar>& x)
Eigen::internal::imag	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag, Scalar) imag(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
Eigen::internal::imag_ref_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::imag_ref_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::imag_ref_default_impl::RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_ref_default_impl	access:public
Eigen::internal::imag_ref_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(const Scalar& x)
Eigen::internal::imag_ref_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline const Scalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(const Scalar&)
Eigen::internal::imag_ref_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(Scalar& x)
Eigen::internal::imag_ref_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(Scalar&)
Eigen::internal::imag_ref_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_impl : imag_ref_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal	inherits:imag_ref_default_impl
Eigen::internal::imag_ref	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) imag_ref(Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(Scalar& x)
Eigen::internal::imag_ref	../include/Eigen/src/Core/MathFunctions.h	/^inline typename add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) >::type imag_ref(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
Eigen::internal::imag_ref_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::imag_ref_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::imag_ref_retval	access:public
Eigen::internal::imag_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::imag_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::imag_retval	access:public
Eigen::internal	../include/Eigen/src/Cholesky/LDLT.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Cholesky/LLT.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Cholesky/LLT.h	/^namespace internal{$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Cholesky/LLT_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/arch/NEON/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/arch/SSE/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Array.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/ArrayWrapper.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Assign.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Assign_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/BandMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Block.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/BooleanRedux.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/CwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/CwiseNullaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/CwiseUnaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/CwiseUnaryView.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/DenseCoeffsBase.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/DenseStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Diagonal.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/DiagonalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/DiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Dot.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Flagged.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/ForceAlignedAccess.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Functors.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Fuzzy.h	/^namespace internal$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/GeneralProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/GenericPacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/GlobalFunctions.h	/^  namespace internal$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/IO.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Map.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Matrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/NestByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/PermutationMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/PlainObjectBase.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/ProductBase.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/Parallelizer.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Random.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Redux.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Replicate.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/ReturnByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Reverse.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Select.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/SelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/SolveTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/StableNorm.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Swap.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Transpose.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Transpositions.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/TriangularMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/util/BlasUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/util/Macros.h	/^    namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/util/Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/util/Meta.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/util/MKL_support.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/util/StaticAssert.h	/^    namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/util/XprHelper.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/VectorBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/VectorwiseOp.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Core/Visitor.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Eigen2Support/Minor.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Geometry/AngleAxis.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Geometry/Homogeneous.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Geometry/OrthoMethods.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Geometry/Quaternion.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Geometry/Rotation2D.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Geometry/RotationBase.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Geometry/Transform.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Geometry/Umeyama.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Householder/BlockHouseholder.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Householder/Householder.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Householder/HouseholderSequence.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/Jacobi/Jacobi.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/LU/Determinant.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/LU/FullPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/LU/Inverse.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/LU/PartialPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/LU/PartialPivLU_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/misc/Image.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/misc/Kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/misc/Solve.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/misc/SparseSolve.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/OrderingMethods/Amd.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace internal$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace internal$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/QR/HouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/QR/HouseholderQR_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/AmbiVector.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/CompressedStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparseBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparsePermutation.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparseUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparseVector.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/SparseView.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SparseCore/TriangularSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/StlSupport/details.h	/^  namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SVD/JacobiSVD.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
Eigen::internal::inner_stride_at_compile_time	../include/Eigen/src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::inner_stride_at_compile_time	../include/Eigen/src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time$/;"	s	namespace:Eigen::internal
Eigen::internal::inner_stride_at_compile_time::ret	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon367
Eigen::internal::inner_stride_at_compile_time::ret	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::InnerStrideAtCompileTime };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon366
Eigen::internal::inplace_transpose_selector	../include/Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,false> { \/\/ non square matrix$/;"	s	namespace:Eigen::internal
Eigen::internal::inplace_transpose_selector	../include/Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,true> { \/\/ square matrix$/;"	s	namespace:Eigen::internal
Eigen::internal::inplace_transpose_selector::run	../include/Eigen/src/Core/Transpose.h	/^  static void run(MatrixType& m) {$/;"	f	struct:Eigen::internal::inplace_transpose_selector	access:public	signature:(MatrixType& m)
Eigen::internal::inverse_impl::cols	../include/Eigen/src/LU/Inverse.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:() const
Eigen::internal::inverse_impl::evalTo	../include/Eigen/src/LU/Inverse.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:(Dest& dst) const
Eigen::internal::inverse_impl	../include/Eigen/src/LU/Inverse.h	/^struct inverse_impl : public ReturnByValue<inverse_impl<MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::inverse_impl::Index	../include/Eigen/src/LU/Inverse.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::inverse_impl	access:public
Eigen::internal::inverse_impl::inverse_impl	../include/Eigen/src/LU/Inverse.h	/^  inverse_impl(const MatrixType& matrix)$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:(const MatrixType& matrix)
Eigen::internal::inverse_impl::MatrixTypeNestedCleaned	../include/Eigen/src/LU/Inverse.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::inverse_impl	access:public
Eigen::internal::inverse_impl::MatrixTypeNested	../include/Eigen/src/LU/Inverse.h	/^  typedef typename internal::eval<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::inverse_impl	access:public
Eigen::internal::inverse_impl::m_matrix	../include/Eigen/src/LU/Inverse.h	/^  MatrixTypeNested m_matrix;$/;"	m	struct:Eigen::internal::inverse_impl	access:public
Eigen::internal::inverse_impl::rows	../include/Eigen/src/LU/Inverse.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:() const
Eigen::internal::isApprox	../include/Eigen/src/Core/MathFunctions.h	/^inline bool isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
Eigen::internal::isApproxOrLessThan	../include/Eigen/src/Core/MathFunctions.h	/^inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
Eigen::internal::isApprox_selector	../include/Eigen/src/Core/Fuzzy.h	/^struct isApprox_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::isApprox_selector	../include/Eigen/src/Core/Fuzzy.h	/^struct isApprox_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::isApprox_selector::run	../include/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, typename Derived::RealScalar)$/;"	f	struct:Eigen::internal::isApprox_selector	access:public	signature:(const Derived& x, const OtherDerived& y, typename Derived::RealScalar)
Eigen::internal::isApprox_selector::run	../include/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, typename Derived::RealScalar prec)$/;"	f	struct:Eigen::internal::isApprox_selector	access:public	signature:(const Derived& x, const OtherDerived& y, typename Derived::RealScalar prec)
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon243
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon241
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon242
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon181
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon182
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon179
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon178
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon180
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon183
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon187
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon189
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon185
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon184
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon188
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon190
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon186
Eigen::internal::is_arithmetic::value	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon177
Eigen::internal::is_const	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_const	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_const::value	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_const::__anon191
Eigen::internal::is_const::value	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_const::__anon192
Eigen::internal::isfinite	../include/Eigen/src/Core/MathFunctions.h	/^template<typename T> bool isfinite(const T& x)$/;"	f	namespace:Eigen::internal	signature:(const T& x)
Eigen::internal::is_malloc_allowed_impl	../include/Eigen/src/Core/util/Memory.h	/^inline bool is_malloc_allowed_impl(bool update, bool new_value = false)$/;"	f	namespace:Eigen::internal	signature:(bool update, bool new_value = false)
Eigen::internal::is_malloc_allowed	../include/Eigen/src/Core/util/Memory.h	/^inline bool is_malloc_allowed() { return is_malloc_allowed_impl(false); }$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::isMuchSmallerThan	../include/Eigen/src/Core/MathFunctions.h	/^inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const OtherScalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
Eigen::internal::isMuchSmallerThan_object_selector	../include/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::isMuchSmallerThan_object_selector	../include/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::isMuchSmallerThan_object_selector::run	../include/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived&, typename Derived::RealScalar)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector	access:public	signature:(const Derived& x, const OtherDerived&, typename Derived::RealScalar)
Eigen::internal::isMuchSmallerThan_object_selector::run	../include/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, typename Derived::RealScalar prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector	access:public	signature:(const Derived& x, const OtherDerived& y, typename Derived::RealScalar prec)
Eigen::internal::isMuchSmallerThan_scalar_selector	../include/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector<Derived, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::isMuchSmallerThan_scalar_selector	../include/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::isMuchSmallerThan_scalar_selector::run	../include/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar&, typename Derived::RealScalar)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector	access:public	signature:(const Derived& x, const typename Derived::RealScalar&, typename Derived::RealScalar)
Eigen::internal::isMuchSmallerThan_scalar_selector::run	../include/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar& y, typename Derived::RealScalar prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector	access:public	signature:(const Derived& x, const typename Derived::RealScalar& y, typename Derived::RealScalar prec)
Eigen::internal::is_same	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_same	../include/Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::is_same::value	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_same::__anon176
Eigen::internal::is_same::value	../include/Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_same::__anon175
Eigen::internal::kernel_retval_base::Base	../include/Eigen/src/misc/Kernel.h	/^  typedef ReturnByValue<kernel_retval_base> Base;$/;"	t	struct:Eigen::internal::kernel_retval_base	access:public
Eigen::internal::kernel_retval_base::cols	../include/Eigen/src/misc/Kernel.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
Eigen::internal::kernel_retval_base::dec	../include/Eigen/src/misc/Kernel.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
Eigen::internal::kernel_retval_base::DecompositionType	../include/Eigen/src/misc/Kernel.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::kernel_retval_base	access:public
Eigen::internal::kernel_retval_base::evalTo	../include/Eigen/src/misc/Kernel.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:(Dest& dst) const
Eigen::internal::kernel_retval_base	../include/Eigen/src/misc/Kernel.h	/^template<typename _DecompositionType> struct kernel_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::kernel_retval_base::Index	../include/Eigen/src/misc/Kernel.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::kernel_retval_base	access:public
Eigen::internal::kernel_retval_base::kernel_retval_base	../include/Eigen/src/misc/Kernel.h	/^  kernel_retval_base(const DecompositionType& dec)$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:(const DecompositionType& dec)
Eigen::internal::kernel_retval_base::m_cols	../include/Eigen/src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base	access:protected
Eigen::internal::kernel_retval_base::m_dec	../include/Eigen/src/misc/Kernel.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::kernel_retval_base	access:protected
Eigen::internal::kernel_retval_base::m_rank	../include/Eigen/src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base	access:protected
Eigen::internal::kernel_retval_base::rank	../include/Eigen/src/misc/Kernel.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
Eigen::internal::kernel_retval_base::rows	../include/Eigen/src/misc/Kernel.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
Eigen::internal::kernel_retval::evalTo	../include/Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval	access:public	signature:(Dest& dst) const
Eigen::internal::kernel_retval	../include/Eigen/src/LU/FullPivLU.h	/^struct kernel_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:kernel_retval_base
Eigen::internal::kernel_retval::MaxSmallDimAtCompileTime	../include/Eigen/src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::kernel_retval::__anon396
Eigen::internal::ldlt_inplace	../include/Eigen/src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Lower>$/;"	s	namespace:Eigen::internal
Eigen::internal::ldlt_inplace	../include/Eigen/src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Upper>$/;"	s	namespace:Eigen::internal
Eigen::internal::ldlt_inplace::unblocked	../include/Eigen/src/Cholesky/LDLT.h	/^  static bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, int* sign=0)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, int* sign=0)
Eigen::internal::ldlt_inplace::unblocked	../include/Eigen/src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, int* sign=0)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, int* sign=0)
Eigen::internal::ldlt_inplace::update	../include/Eigen/src/Cholesky/LDLT.h	/^  static bool update(MatrixType& mat, const TranspositionType& transpositions, Workspace& tmp, const WType& w, typename MatrixType::RealScalar sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, const TranspositionType& transpositions, Workspace& tmp, const WType& w, typename MatrixType::RealScalar sigma=1)
Eigen::internal::ldlt_inplace::update	../include/Eigen/src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool update(MatrixType& mat, TranspositionType& transpositions, Workspace& tmp, WType& w, typename MatrixType::RealScalar sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, TranspositionType& transpositions, Workspace& tmp, WType& w, typename MatrixType::RealScalar sigma=1)
Eigen::internal::ldlt_inplace::updateInPlace	../include/Eigen/src/Cholesky/LDLT.h	/^  static bool updateInPlace(MatrixType& mat, MatrixBase<WDerived>& w, typename MatrixType::RealScalar sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, MatrixBase<WDerived>& w, typename MatrixType::RealScalar sigma=1)
Eigen::internal::LDLT_Traits::getL	../include/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LDLT_Traits::getL	../include/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LDLT_Traits::getU	../include/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LDLT_Traits::getU	../include/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LDLT_Traits	../include/Eigen/src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
Eigen::internal::LDLT_Traits	../include/Eigen/src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
Eigen::internal::LDLT_Traits::MatrixL	../include/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
Eigen::internal::LDLT_Traits::MatrixL	../include/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
Eigen::internal::LDLT_Traits::MatrixU	../include/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
Eigen::internal::LDLT_Traits::MatrixU	../include/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
Eigen::internal::level3_blocking::blockA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline LhsScalar* blockA() { return m_blockA; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
Eigen::internal::level3_blocking::blockB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockB() { return m_blockB; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
Eigen::internal::level3_blocking::blockW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockW() { return m_blockW; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
Eigen::internal::level3_blocking	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class level3_blocking$/;"	c	namespace:Eigen::internal
Eigen::internal::level3_blocking::kc	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex kc() const { return m_kc; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:() const
Eigen::internal::level3_blocking::level3_blocking	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    level3_blocking()$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
Eigen::internal::level3_blocking::LhsScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::level3_blocking	access:private
Eigen::internal::level3_blocking::m_blockA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    LhsScalar* m_blockA;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
Eigen::internal::level3_blocking::m_blockB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockB;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
Eigen::internal::level3_blocking::m_blockW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockW;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
Eigen::internal::level3_blocking::mc	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex mc() const { return m_mc; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:() const
Eigen::internal::level3_blocking::m_kc	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_kc;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
Eigen::internal::level3_blocking::m_mc	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_mc;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
Eigen::internal::level3_blocking::m_nc	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_nc;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
Eigen::internal::level3_blocking::nc	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex nc() const { return m_nc; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:() const
Eigen::internal::level3_blocking::RhsScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::level3_blocking	access:private
Eigen::internal::linspaced_op::impl	../include/Eigen/src/Core/Functors.h	/^  const linspaced_op_impl<Scalar,RandomAccess> impl;$/;"	m	struct:Eigen::internal::linspaced_op	access:public
Eigen::internal::linspaced_op_impl	../include/Eigen/src/Core/Functors.h	/^struct linspaced_op_impl<Scalar,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::linspaced_op_impl	../include/Eigen/src/Core/Functors.h	/^struct linspaced_op_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::linspaced_op_impl::linspaced_op_impl	../include/Eigen/src/Core/Functors.h	/^  linspaced_op_impl(Scalar low, Scalar step) :$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Scalar low, Scalar step)
Eigen::internal::linspaced_op_impl::m_base	../include/Eigen/src/Core/Functors.h	/^  mutable Packet m_base;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::m_interPacket	../include/Eigen/src/Core/Functors.h	/^  const Packet m_interPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::m_low	../include/Eigen/src/Core/Functors.h	/^  const Scalar m_low;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::m_lowPacket	../include/Eigen/src/Core/Functors.h	/^  const Packet m_lowPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::m_packetStep	../include/Eigen/src/Core/Functors.h	/^  const Packet m_packetStep;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::m_step	../include/Eigen/src/Core/Functors.h	/^  const Scalar m_step;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::m_stepPacket	../include/Eigen/src/Core/Functors.h	/^  const Packet m_stepPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const { return m_low+i*m_step; }$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index i) const
Eigen::internal::linspaced_op_impl::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::linspaced_op_impl	access:public
Eigen::internal::linspaced_op_impl::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index) const { return m_base = padd(m_base,m_packetStep); }$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index) const
Eigen::internal::linspaced_op_impl::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index i) const$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index i) const
Eigen::internal::linspaced_op	../include/Eigen/src/Core/Functors.h	/^template <typename Scalar, bool RandomAccess> struct linspaced_op$/;"	s	namespace:Eigen::internal
Eigen::internal::linspaced_op::linspaced_op	../include/Eigen/src/Core/Functors.h	/^  linspaced_op(Scalar low, Scalar high, int num_steps) : impl((num_steps==1 ? high : low), (num_steps==1 ? Scalar() : (high-low)\/(num_steps-1))) {}$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Scalar low, Scalar high, int num_steps)
Eigen::internal::linspaced_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const { return impl(i); }$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index i) const
Eigen::internal::linspaced_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index row, Index col) const $/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index row, Index col) const
Eigen::internal::linspaced_op::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::linspaced_op	access:public
Eigen::internal::linspaced_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index i) const { return impl.packetOp(i); }$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index i) const
Eigen::internal::linspaced_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index row, Index col) const$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index row, Index col) const
Eigen::internal::llt_inplace::blocked	../include/Eigen/src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE typename MatrixType::Index blocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat)
Eigen::internal::llt_inplace::blocked	../include/Eigen/src/Cholesky/LLT.h	/^  static typename MatrixType::Index blocked(MatrixType& m)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& m)
Eigen::internal::llt_inplace	../include/Eigen/src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Lower>$/;"	s	namespace:Eigen::internal
Eigen::internal::llt_inplace	../include/Eigen/src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Upper>$/;"	s	namespace:Eigen::internal
Eigen::internal::llt_inplace::rankUpdate	../include/Eigen/src/Cholesky/LLT.h	/^  static typename MatrixType::Index rankUpdate(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)
Eigen::internal::llt_inplace::RealScalar	../include/Eigen/src/Cholesky/LLT.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::llt_inplace	access:public
Eigen::internal::llt_inplace::unblocked	../include/Eigen/src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE typename MatrixType::Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat)
Eigen::internal::llt_inplace::unblocked	../include/Eigen/src/Cholesky/LLT.h	/^  static typename MatrixType::Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat)
Eigen::internal::llt_rank_update_lower	../include/Eigen/src/Cholesky/LLT.h	/^static typename MatrixType::Index llt_rank_update_lower(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)
Eigen::internal::LLT_Traits::getL	../include/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LLT_Traits::getL	../include/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LLT_Traits::getU	../include/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LLT_Traits::getU	../include/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
Eigen::internal::LLT_Traits	../include/Eigen/src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
Eigen::internal::LLT_Traits	../include/Eigen/src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
Eigen::internal::LLT_Traits::inplace_decomposition	../include/Eigen/src/Cholesky/LLT.h	/^  static bool inplace_decomposition(MatrixType& m)$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(MatrixType& m)
Eigen::internal::LLT_Traits::MatrixL	../include/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
Eigen::internal::LLT_Traits::MatrixL	../include/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
Eigen::internal::LLT_Traits::MatrixU	../include/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
Eigen::internal::LLT_Traits::MatrixU	../include/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
Eigen::internal::lpNorm_selector	../include/Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::lpNorm_selector	../include/Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, 2>$/;"	s	namespace:Eigen::internal
Eigen::internal::lpNorm_selector	../include/Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, Infinity>$/;"	s	namespace:Eigen::internal
Eigen::internal::lpNorm_selector	../include/Eigen/src/Core/Dot.h	/^struct lpNorm_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::lpNorm_selector::RealScalar	../include/Eigen/src/Core/Dot.h	/^  typedef typename NumTraits<typename traits<Derived>::Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::lpNorm_selector	access:public
Eigen::internal::lpNorm_selector::run	../include/Eigen/src/Core/Dot.h	/^  static inline RealScalar run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::internal::lpNorm_selector::run	../include/Eigen/src/Core/Dot.h	/^  static inline typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::internal::make_block_householder_triangular_factor	../include/Eigen/src/Householder/BlockHouseholder.h	/^void make_block_householder_triangular_factor(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal	signature:(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)
Eigen::internal::manage_caching_sizes_helper	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t manage_caching_sizes_helper(std::ptrdiff_t a, std::ptrdiff_t b)$/;"	f	namespace:Eigen::internal	signature:(std::ptrdiff_t a, std::ptrdiff_t b)
Eigen::internal::manage_caching_sizes	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void manage_caching_sizes(Action action, std::ptrdiff_t* l1=0, std::ptrdiff_t* l2=0)$/;"	f	namespace:Eigen::internal	signature:(Action action, std::ptrdiff_t* l1=0, std::ptrdiff_t* l2=0)
Eigen::internal::manage_multi_threading	../include/Eigen/src/Core/products/Parallelizer.h	/^inline void manage_multi_threading(Action action, int* v)$/;"	f	namespace:Eigen::internal	signature:(Action action, int* v)
Eigen::internal::map_superlu	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> map_superlu(SluMatrix& sluMat)$/;"	f	namespace:Eigen::internal	signature:(SluMatrix& sluMat)
Eigen::internal::MatrixBase::diagonal	../include/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal() const$/;"	f	class:Eigen::internal::MatrixBase	signature:() const
Eigen::internal::MatrixBase::diagonal	../include/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal()$/;"	f	class:Eigen::internal::MatrixBase	signature:()
Eigen::internal::MatrixBase::diagonal	../include/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index) const$/;"	f	class:Eigen::internal::MatrixBase	signature:(Index index) const
Eigen::internal::MatrixBase::diagonal	../include/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index)$/;"	f	class:Eigen::internal::MatrixBase	signature:(Index index)
Eigen::internal::matrix_swap_impl	../include/Eigen/src/Core/PlainObjectBase.h	/^struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::matrix_swap_impl	../include/Eigen/src/Core/PlainObjectBase.h	/^struct matrix_swap_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::matrix_swap_impl::run	../include/Eigen/src/Core/PlainObjectBase.h	/^  static inline void run(MatrixTypeA& a, MatrixTypeB& b)$/;"	f	struct:Eigen::internal::matrix_swap_impl	access:public	signature:(MatrixTypeA& a, MatrixTypeB& b)
Eigen::internal::matrix_type_times_scalar_type	../include/Eigen/src/Householder/HouseholderSequence.h	/^template<typename OtherScalarType, typename MatrixType> struct matrix_type_times_scalar_type$/;"	s	namespace:Eigen::internal
Eigen::internal::matrix_type_times_scalar_type::ResultScalar	../include/Eigen/src/Householder/HouseholderSequence.h	/^    ResultScalar;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type	access:public
Eigen::internal::matrix_type_times_scalar_type::Type	../include/Eigen/src/Householder/HouseholderSequence.h	/^                 0, MatrixType::MaxRowsAtCompileTime, MatrixType::MaxColsAtCompileTime> Type;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type	access:public
Eigen::internal::max_coeff_visitor	../include/Eigen/src/Core/Visitor.h	/^struct max_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal	inherits:coeff_visitor
Eigen::internal::max_coeff_visitor::Index	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::max_coeff_visitor	access:public
Eigen::internal::max_coeff_visitor::operator ()	../include/Eigen/src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::max_coeff_visitor	access:public	signature:(const Scalar& value, Index i, Index j)
Eigen::internal::max_coeff_visitor::Scalar	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::max_coeff_visitor	access:public
Eigen::internal::member_redux::Cost	../include/Eigen/src/Core/VectorwiseOp.h	/^  template<typename _Scalar, int Size> struct Cost$/;"	s	struct:Eigen::internal::member_redux	access:public
Eigen::internal::member_redux::Cost::value	../include/Eigen/src/Core/VectorwiseOp.h	/^  { enum { value = (Size-1) * functor_traits<BinaryOp>::Cost }; };$/;"	e	enum:Eigen::internal::member_redux::Cost::__anon70
Eigen::internal::member_redux	../include/Eigen/src/Core/VectorwiseOp.h	/^struct member_redux {$/;"	s	namespace:Eigen::internal
Eigen::internal::member_redux::member_redux	../include/Eigen/src/Core/VectorwiseOp.h	/^  member_redux(const BinaryOp func) : m_functor(func) {}$/;"	f	struct:Eigen::internal::member_redux	access:public	signature:(const BinaryOp func)
Eigen::internal::member_redux::m_functor	../include/Eigen/src/Core/VectorwiseOp.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::member_redux	access:public
Eigen::internal::member_redux::operator ()	../include/Eigen/src/Core/VectorwiseOp.h	/^  inline result_type operator()(const DenseBase<Derived>& mat) const$/;"	f	struct:Eigen::internal::member_redux	access:public	signature:(const DenseBase<Derived>& mat) const
Eigen::internal::member_redux::result_type	../include/Eigen/src/Core/VectorwiseOp.h	/^                   >::type  result_type;$/;"	t	struct:Eigen::internal::member_redux	access:public
Eigen::internal::min_coeff_visitor	../include/Eigen/src/Core/Visitor.h	/^struct min_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal	inherits:coeff_visitor
Eigen::internal::min_coeff_visitor::Index	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::min_coeff_visitor	access:public
Eigen::internal::min_coeff_visitor::operator ()	../include/Eigen/src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::min_coeff_visitor	access:public	signature:(const Scalar& value, Index i, Index j)
Eigen::internal::min_coeff_visitor::Scalar	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::min_coeff_visitor	access:public
Eigen::internal::minimum_degree_ordering	../include/Eigen/src/OrderingMethods/Amd.h	/^void minimum_degree_ordering(SparseMatrix<Scalar,ColMajor,Index>& C, PermutationMatrix<Dynamic,Dynamic,Index>& perm)$/;"	f	namespace:Eigen::internal	signature:(SparseMatrix<Scalar,ColMajor,Index>& C, PermutationMatrix<Dynamic,Dynamic,Index>& perm)
Eigen::internal::nested	../include/Eigen/src/Core/ProductBase.h	/^struct nested<GeneralProduct<Lhs,Rhs,Mode>, N, PlainObject>$/;"	s	namespace:Eigen::internal
Eigen::internal::nested	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct nested<CoeffBasedProduct<Lhs,Rhs,EvalBeforeNestingBit|EvalBeforeAssigningBit>, N, PlainObject>$/;"	s	namespace:Eigen::internal
Eigen::internal::nested	../include/Eigen/src/Core/ReturnByValue.h	/^struct nested<ReturnByValue<Derived>, n, PlainObject>$/;"	s	namespace:Eigen::internal
Eigen::internal::nested::type	../include/Eigen/src/Core/ProductBase.h	/^  typedef PlainObject const& type;$/;"	t	struct:Eigen::internal::nested	access:public
Eigen::internal::nested::type	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef PlainObject const& type;$/;"	t	struct:Eigen::internal::nested	access:public
Eigen::internal::nested::type	../include/Eigen/src/Core/ReturnByValue.h	/^  typedef typename traits<Derived>::ReturnType type;$/;"	t	struct:Eigen::internal::nested	access:public
Eigen::internal::NewInf	../include/Eigen/src/Core/util/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen::internal
Eigen::internal::NewSup	../include/Eigen/src/Core/util/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen::internal
Eigen::internal::no_assignment_operator	../include/Eigen/src/Core/util/XprHelper.h	/^class no_assignment_operator$/;"	c	namespace:Eigen::internal
Eigen::internal::no_assignment_operator::operator =	../include/Eigen/src/Core/util/XprHelper.h	/^    no_assignment_operator& operator=(const no_assignment_operator&);$/;"	p	class:Eigen::internal::no_assignment_operator	access:private	signature:(const no_assignment_operator&)
Eigen::internal::noncopyable	../include/Eigen/src/Core/util/Meta.h	/^class noncopyable$/;"	c	namespace:Eigen::internal
Eigen::internal::noncopyable::noncopyable	../include/Eigen/src/Core/util/Meta.h	/^  noncopyable(const noncopyable&);$/;"	p	class:Eigen::internal::noncopyable	access:private	signature:(const noncopyable&)
Eigen::internal::noncopyable::~noncopyable	../include/Eigen/src/Core/util/Meta.h	/^  ~noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable	access:protected	signature:()
Eigen::internal::noncopyable::noncopyable	../include/Eigen/src/Core/util/Meta.h	/^  noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable	access:protected	signature:()
Eigen::internal::noncopyable::operator =	../include/Eigen/src/Core/util/Meta.h	/^  const noncopyable& operator=(const noncopyable&);$/;"	p	class:Eigen::internal::noncopyable	access:private	signature:(const noncopyable&)
Eigen::internal::norm1_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct norm1_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::norm1_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct norm1_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::norm1_default_impl::RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::norm1_default_impl	access:public
Eigen::internal::norm1_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl	access:public	signature:(const Scalar& x)
Eigen::internal::norm1_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl	access:public	signature:(const Scalar& x)
Eigen::internal::norm1_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct norm1_impl : norm1_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal	inherits:norm1_default_impl
Eigen::internal::norm1	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(norm1, Scalar) norm1(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
Eigen::internal::norm1_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct norm1_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::norm1_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::norm1_retval	access:public
Eigen::internal::outer_product_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<> struct outer_product_selector<ColMajor> {$/;"	s	namespace:Eigen::internal
Eigen::internal::outer_product_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<> struct outer_product_selector<RowMajor> {$/;"	s	namespace:Eigen::internal
Eigen::internal::outer_product_selector::run	../include/Eigen/src/Core/GeneralProduct.h	/^  static EIGEN_DONT_INLINE void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha) {$/;"	f	struct:Eigen::internal::outer_product_selector	access:public	signature:(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)
Eigen::internal::outer_stride_at_compile_time	../include/Eigen/src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::outer_stride_at_compile_time	../include/Eigen/src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time$/;"	s	namespace:Eigen::internal
Eigen::internal::outer_stride_at_compile_time::ret	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon369
Eigen::internal::outer_stride_at_compile_time::ret	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::OuterStrideAtCompileTime };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon368
Eigen::internal::p16uc_COMPLEX_IM	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_IM   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 1), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);\/\/{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_COMPLEX_RE	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_RE   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);\/\/{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_COMPLEX_REV2	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_REV2 = vec_sld(p16uc_FORWARD, p16uc_FORWARD, 8);\/\/{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_COMPLEX_REV	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_REV  = vec_sld(p16uc_REVERSE, p16uc_REVERSE, 8);\/\/{ 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_DUPLICATE	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_DUPLICATE = {0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7};$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_FORWARD	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_FORWARD = vec_lvsl(0, (float*)0);$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_PSET_HI	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_PSET_HI = (Packet16uc) vec_mergeh((Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 1));\/\/{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_PSET_LO	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_PSET_LO = (Packet16uc) vec_mergeh((Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 2), (Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 3));\/\/{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p16uc_REVERSE	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_REVERSE = {12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3};$/;"	m	namespace:Eigen::internal
Eigen::internal::p2ui_CONJ_XOR	../include/Eigen/src/Core/arch/NEON/Complex.h	/^static uint32x2_t p2ui_CONJ_XOR = EIGEN_INIT_NEON_PACKET2(0x00000000, 0x80000000);$/;"	m	namespace:Eigen::internal
Eigen::internal::p4f_COUNTDOWN	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_COUNTDOWN = { 3.0, 2.0, 1.0, 0.0 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p4f_ONE	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ONE = vec_ctf(p4i_ONE, 0);$/;"	m	namespace:Eigen::internal
Eigen::internal::p4f_ZERO_	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ZERO_ = (Packet4f) vec_sl((Packet4ui)p4i_MINUS1, (Packet4ui)p4i_MINUS1);$/;"	m	namespace:Eigen::internal
Eigen::internal::p4i_COUNTDOWN	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4i p4i_COUNTDOWN = { 3, 2, 1, 0 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p4ui_CONJ_XOR	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet4ui  p4ui_CONJ_XOR = vec_mergeh((Packet4ui)p4i_ZERO, (Packet4ui)p4f_ZERO_);\/\/{ 0x00000000, 0x80000000, 0x00000000, 0x80000000 };$/;"	m	namespace:Eigen::internal
Eigen::internal::p4ui_CONJ_XOR	../include/Eigen/src/Core/arch/NEON/Complex.h	/^static uint32x4_t p4ui_CONJ_XOR = EIGEN_INIT_NEON_PACKET4(0x00000000, 0x80000000, 0x00000000, 0x80000000);$/;"	m	namespace:Eigen::internal
Eigen::internal::pabs	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pabs	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pabs	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vabsq_f32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pabs	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vabsq_s32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pabs	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::pabs	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pabs	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pabs	../include/Eigen/src/Core/GenericPacketMath.h	/^pabs(const Packet& a) { return abs(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::Packet16uc	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned char  Packet16uc;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet1cd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Eigen::internal::Packet1cd::Packet1cd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const __m128d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd	access:public	signature:(const __m128d& a)
Eigen::internal::Packet1cd::Packet1cd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd	access:public	signature:()
Eigen::internal::Packet1cd::v	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  __m128d  v;$/;"	m	struct:Eigen::internal::Packet1cd	access:public
Eigen::internal::Packet2cf	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Eigen::internal::Packet2cf	../include/Eigen/src/Core/arch/NEON/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Eigen::internal::Packet2cf	../include/Eigen/src/Core/arch/SSE/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Eigen::internal::Packet2cf::Packet2cf	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:(const Packet4f& a)
Eigen::internal::Packet2cf::Packet2cf	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:()
Eigen::internal::Packet2cf::Packet2cf	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:(const Packet4f& a)
Eigen::internal::Packet2cf::Packet2cf	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:()
Eigen::internal::Packet2cf::Packet2cf	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const __m128& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:(const __m128& a)
Eigen::internal::Packet2cf::Packet2cf	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:()
Eigen::internal::Packet2cf::v	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf	access:public
Eigen::internal::Packet2cf::v	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf	access:public
Eigen::internal::Packet2cf::v	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  __m128  v;$/;"	m	struct:Eigen::internal::Packet2cf	access:public
Eigen::internal::Packet2d	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef __m128d Packet2d;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4bi	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector __bool int     Packet4bi;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4f	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector float          Packet4f;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4f	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef float32x4_t Packet4f;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4f	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef __m128  Packet4f;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector int            Packet4i;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4i	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef int32x4_t   Packet4i;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4i	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef __m128i Packet4i;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4ui	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned int   Packet4ui;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet4ui	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef uint32x4_t  Packet4ui;$/;"	t	namespace:Eigen::internal
Eigen::internal::Packet8i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector short int      Packet8i;$/;"	t	namespace:Eigen::internal
Eigen::internal::packet_traits::AlignedOnScalar	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::AlignedOnScalar	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
Eigen::internal::packet_traits::AlignedOnScalar	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
Eigen::internal::packet_traits::AlignedOnScalar	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::AlignedOnScalar	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
Eigen::internal::packet_traits::AlignedOnScalar	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
Eigen::internal::packet_traits::AlignedOnScalar	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::AlignedOnScalar	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::AlignedOnScalar	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
Eigen::internal::packet_traits::AlignedOnScalar	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon245
Eigen::internal::packet_traits::AlignedOnScalar	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon246
Eigen::internal::packet_traits::AlignedOnScalar	../include/Eigen/src/Core/GenericPacketMath.h	/^    AlignedOnScalar = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon230
Eigen::internal::packet_traits::HasAbs2	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::HasAbs2	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::HasAbs2	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::HasAbs2	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::HasAbs2	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
Eigen::internal::packet_traits::HasAbs	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::HasAbs	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::HasAbs	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::HasAbs	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::HasAbs	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
Eigen::internal::packet_traits::HasAdd	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::HasAdd	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::HasAdd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::HasAdd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::HasAdd	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasAdd    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
Eigen::internal::packet_traits::HasConj	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasConj   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
Eigen::internal::packet_traits::HasCos	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
Eigen::internal::packet_traits::HasCos	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
Eigen::internal::packet_traits::HasCos	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasCos  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
Eigen::internal::packet_traits::HasDiv	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::HasDiv	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::HasDiv	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
Eigen::internal::packet_traits::HasDiv	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::HasDiv	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::HasDiv	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
Eigen::internal::packet_traits::HasDiv	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasDiv    = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon245
Eigen::internal::packet_traits::HasExp	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
Eigen::internal::packet_traits::HasExp	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
Eigen::internal::packet_traits::HasExp	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
Eigen::internal::packet_traits::HasLog	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
Eigen::internal::packet_traits::HasLog	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
Eigen::internal::packet_traits::HasLog	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
Eigen::internal::packet_traits::HasMax	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::HasMax	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::HasMax	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::HasMax	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::HasMax	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
Eigen::internal::packet_traits::HasMin	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::HasMin	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::HasMin	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::HasMin	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::HasMin	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
Eigen::internal::packet_traits::HasMul	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::HasMul	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::HasMul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::HasMul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::HasMul	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasMul    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
Eigen::internal::packet_traits::HasNegate	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::HasNegate	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::HasNegate	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::HasNegate	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::HasNegate	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasNegate = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
Eigen::internal::packet_traits::HasSetLinear	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::HasSetLinear	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::HasSetLinear	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::HasSetLinear	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::HasSetLinear	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon231
Eigen::internal::packet_traits::HasSin	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
Eigen::internal::packet_traits::HasSin	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
Eigen::internal::packet_traits::HasSin	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSin  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
Eigen::internal::packet_traits::HasSqrt	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon252
Eigen::internal::packet_traits::HasSqrt	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon258
Eigen::internal::packet_traits::HasSqrt	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon244
Eigen::internal::packet_traits::HasSub	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::HasSub	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::HasSub	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::HasSub	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::HasSub	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasSub    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
Eigen::internal::packet_traits	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename T> struct packet_traits : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
Eigen::internal::packet_traits::size	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::size	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
Eigen::internal::packet_traits::size	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon253
Eigen::internal::packet_traits::size	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::size	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
Eigen::internal::packet_traits::size	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon259
Eigen::internal::packet_traits::size	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::size	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::size	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon245
Eigen::internal::packet_traits::size	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
Eigen::internal::packet_traits::size	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon246
Eigen::internal::packet_traits::size	../include/Eigen/src/Core/GenericPacketMath.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon230
Eigen::internal::packet_traits::type	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::type	../include/Eigen/src/Core/GenericPacketMath.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Eigen::internal::packet_traits::Vectorizable	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Eigen::internal::packet_traits::Vectorizable	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
Eigen::internal::packet_traits::Vectorizable	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
Eigen::internal::packet_traits::Vectorizable	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Eigen::internal::packet_traits::Vectorizable	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
Eigen::internal::packet_traits::Vectorizable	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
Eigen::internal::packet_traits::Vectorizable	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Eigen::internal::packet_traits::Vectorizable	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Eigen::internal::packet_traits::Vectorizable	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
Eigen::internal::packet_traits::Vectorizable	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon245
Eigen::internal::packet_traits::Vectorizable	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon246
Eigen::internal::packet_traits::Vectorizable	../include/Eigen/src/Core/GenericPacketMath.h	/^    Vectorizable = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon230
Eigen::internal::pacos	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet pacos(const Packet& a) { return acos(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::padd	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_add(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::padd	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_add(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::padd	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_add(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::padd	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::padd	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vaddq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::padd	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vaddq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::padd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_add_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::padd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_add_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::padd	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::padd	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_add_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::padd	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_add_epi32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::padd	../include/Eigen/src/Core/GenericPacketMath.h	/^padd(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::palign_impl	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	../include/Eigen/src/Core/arch/NEON/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	../include/Eigen/src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	../include/Eigen/src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet2d>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl	../include/Eigen/src/Core/GenericPacketMath.h	/^struct palign_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::palign_impl::run	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2cf& first, const Packet2cf& second)
Eigen::internal::palign_impl::run	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4f& first, const Packet4f& second)
Eigen::internal::palign_impl::run	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4i& first, const Packet4i& second)
Eigen::internal::palign_impl::run	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE static void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2cf& first, const Packet2cf& second)
Eigen::internal::palign_impl::run	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet1cd& , const Packet1cd& )
Eigen::internal::palign_impl::run	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2cf& first, const Packet2cf& second)
Eigen::internal::palign_impl::run	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2d& first, const Packet2d& second)
Eigen::internal::palign_impl::run	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4f& first, const Packet4f& second)
Eigen::internal::palign_impl::run	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4i& first, const Packet4i& second)
Eigen::internal::palign_impl::run	../include/Eigen/src/Core/GenericPacketMath.h	/^  static inline void run(PacketType&, const PacketType&) {}$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(PacketType&, const PacketType&)
Eigen::internal::palign	../include/Eigen/src/Core/GenericPacketMath.h	/^inline void palign(PacketType& first, const PacketType& second)$/;"	f	namespace:Eigen::internal	signature:(PacketType& first, const PacketType& second)
Eigen::internal::pand	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_and(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pand	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pand	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pand	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pand	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pand	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vandq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pand	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_and_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::pand	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_and_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pand	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_and_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pand	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_and_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pand	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_and_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pand	../include/Eigen/src/Core/GenericPacketMath.h	/^pand(const Packet& a, const Packet& b) { return a & b; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::pandnot	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_and(a.v, vec_nor(b.v,b.v))); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pandnot	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pandnot	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pandnot	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pandnot	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pandnot	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vbicq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pandnot	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_andnot_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::pandnot	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_andnot_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pandnot	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_andnot_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pandnot	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_andnot_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pandnot	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_andnot_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pandnot	../include/Eigen/src/Core/GenericPacketMath.h	/^pandnot(const Packet& a, const Packet& b) { return a & (!b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::parallelize_gemm	../include/Eigen/src/Core/products/Parallelizer.h	/^void parallelize_gemm(const Functor& func, Index rows, Index cols, bool transpose)$/;"	f	namespace:Eigen::internal	signature:(const Functor& func, Index rows, Index cols, bool transpose)
Eigen::internal::pardiso_run_selector	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector<long long int>$/;"	s	namespace:Eigen::internal
Eigen::internal::pardiso_run_selector	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::pardiso_run_selector::Index	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef long long int Index;$/;"	t	struct:Eigen::internal::pardiso_run_selector	access:public
Eigen::internal::pardiso_run_selector::run	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    static Index run( _MKL_DSS_HANDLE_t pt, Index maxfct, Index mnum, Index type, Index phase, Index n, void *a,$/;"	f	struct:Eigen::internal::pardiso_run_selector	access:public	signature:( _MKL_DSS_HANDLE_t pt, Index maxfct, Index mnum, Index type, Index phase, Index n, void *a, Index *ia, Index *ja, Index *perm, Index nrhs, Index *iparm, Index msglvl, void *b, void *x)
Eigen::internal::pardiso_traits	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLDLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::pardiso_traits	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::pardiso_traits	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::pardiso_traits::Index	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Index Index;    $/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Eigen::internal::pardiso_traits::Index	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Index Index;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Eigen::internal::pardiso_traits::MatrixType	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Eigen::internal::pardiso_traits::RealScalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Eigen::internal::pardiso_traits::Scalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Eigen::internal::partial_lu_impl::blocked_lu	../include/Eigen/src/LU/PartialPivLU.h	/^  static Index blocked_lu(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)$/;"	f	struct:Eigen::internal::partial_lu_impl	access:public	signature:(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)
Eigen::internal::partial_lu_impl::BlockType	../include/Eigen/src/LU/PartialPivLU.h	/^  typedef Block<MatrixType,Dynamic,Dynamic> BlockType;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
Eigen::internal::partial_lu_impl	../include/Eigen/src/LU/PartialPivLU.h	/^struct partial_lu_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::partial_lu_impl::Index	../include/Eigen/src/LU/PartialPivLU.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
Eigen::internal::partial_lu_impl::MapLU	../include/Eigen/src/LU/PartialPivLU.h	/^  typedef Map<Matrix<Scalar, Dynamic, Dynamic, StorageOrder> > MapLU;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
Eigen::internal::partial_lu_impl::MatrixType	../include/Eigen/src/LU/PartialPivLU.h	/^  typedef Block<MapLU, Dynamic, Dynamic> MatrixType;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
Eigen::internal::partial_lu_impl::RealScalar	../include/Eigen/src/LU/PartialPivLU.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
Eigen::internal::partial_lu_impl::unblocked_lu	../include/Eigen/src/LU/PartialPivLU.h	/^  static Index unblocked_lu(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)$/;"	f	struct:Eigen::internal::partial_lu_impl	access:public	signature:(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)
Eigen::internal::partial_lu_inplace	../include/Eigen/src/LU/PartialPivLU.h	/^void partial_lu_inplace(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::Index& nb_transpositions)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::Index& nb_transpositions)
Eigen::internal::pasin	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet pasin(const Packet& a) { return asin(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pastix_traits	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLDLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::pastix_traits	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::pastix_traits	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::pastix_traits::Index	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Index Index;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
Eigen::internal::pastix_traits::MatrixType	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
Eigen::internal::pastix_traits::RealScalar	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
Eigen::internal::pastix_traits::Scalar	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
Eigen::internal::pconj	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a) { return Packet2cf((Packet4f)vec_xor((Packet4ui)a.v, p4ui_CONJ_XOR)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pconj	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pconj	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
Eigen::internal::pconj	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pconj	../include/Eigen/src/Core/GenericPacketMath.h	/^pconj(const Packet& a) { return conj(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pcos	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f pcos<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
Eigen::internal::pcos	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet pcos(const Packet& a) { return cos(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pcplxflip	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& x)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& x)
Eigen::internal::pcplxflip	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pcplxflip	../include/Eigen/src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/*<Packet1cd>*\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& x)
Eigen::internal::pcplxflip	../include/Eigen/src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet2cf pcplxflip\/*<Packet2cf>*\/(const Packet2cf& x)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& x)
Eigen::internal::pcplxflip	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline Packet pcplxflip(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pdiv	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pdiv	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pdiv	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& , const Packet4i& )
Eigen::internal::pdiv	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pdiv	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pdiv	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& , const Packet4i& )
Eigen::internal::pdiv	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::pdiv	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pdiv	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_div_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pdiv	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_div_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pdiv	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& , const Packet4i& )
Eigen::internal::pdiv	../include/Eigen/src/Core/GenericPacketMath.h	/^pdiv(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::PermPermProduct	../include/Eigen/src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	e	enum:Eigen::internal::PermPermProduct_t
Eigen::internal::PermPermProduct_t	../include/Eigen/src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	g	namespace:Eigen::internal
Eigen::internal::permute_symm_to_fullsymm	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_fullsymm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0);$/;"	p	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0)
Eigen::internal::permute_symm_to_fullsymm	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_fullsymm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)
Eigen::internal::permute_symm_to_symm	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_symm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0);$/;"	p	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0)
Eigen::internal::permute_symm_to_symm	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_symm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)
Eigen::internal::permut_matrix_product_retval::cols	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:() const
Eigen::internal::permut_matrix_product_retval::evalTo	../include/Eigen/src/Core/PermutationMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:(Dest& dst) const
Eigen::internal::permut_matrix_product_retval	../include/Eigen/src/Core/PermutationMatrix.h	/^struct permut_matrix_product_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::permut_matrix_product_retval::MatrixTypeNestedCleaned	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::permut_matrix_product_retval	access:public
Eigen::internal::permut_matrix_product_retval::m_matrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::permut_matrix_product_retval	access:protected
Eigen::internal::permut_matrix_product_retval::m_permutation	../include/Eigen/src/Core/PermutationMatrix.h	/^    const PermutationType& m_permutation;$/;"	m	struct:Eigen::internal::permut_matrix_product_retval	access:protected
Eigen::internal::permut_matrix_product_retval::permut_matrix_product_retval	../include/Eigen/src/Core/PermutationMatrix.h	/^    permut_matrix_product_retval(const PermutationType& perm, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:(const PermutationType& perm, const MatrixType& matrix)
Eigen::internal::permut_matrix_product_retval::rows	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:() const
Eigen::internal::permut_sparsematrix_product_retval::cols	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:() const
Eigen::internal::permut_sparsematrix_product_retval::evalTo	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:(Dest& dst) const
Eigen::internal::permut_sparsematrix_product_retval	../include/Eigen/src/SparseCore/SparsePermutation.h	/^struct permut_sparsematrix_product_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::permut_sparsematrix_product_retval::Index	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeNestedCleaned::Index Index;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public
Eigen::internal::permut_sparsematrix_product_retval::MatrixTypeNestedCleaned	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public
Eigen::internal::permut_sparsematrix_product_retval::m_matrix	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::permut_sparsematrix_product_retval	access:protected
Eigen::internal::permut_sparsematrix_product_retval::MoveOuter	../include/Eigen/src/SparseCore/SparsePermutation.h	/^      MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::permut_sparsematrix_product_retval::__anon19
Eigen::internal::permut_sparsematrix_product_retval::m_permutation	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    const PermutationType& m_permutation;$/;"	m	struct:Eigen::internal::permut_sparsematrix_product_retval	access:protected
Eigen::internal::permut_sparsematrix_product_retval::permut_sparsematrix_product_retval	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    permut_sparsematrix_product_retval(const PermutationType& perm, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:(const PermutationType& perm, const MatrixType& matrix)
Eigen::internal::permut_sparsematrix_product_retval::rows	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:() const
Eigen::internal::permut_sparsematrix_product_retval::Scalar	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeNestedCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public
Eigen::internal::permut_sparsematrix_product_retval::SrcStorageOrder	../include/Eigen/src/SparseCore/SparsePermutation.h	/^      SrcStorageOrder = MatrixTypeNestedCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::permut_sparsematrix_product_retval::__anon19
Eigen::internal::pexp	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
Eigen::internal::pexp	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet pexp(const Packet& a) { return exp(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; vec_st(a, 0, x); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x[4]; vec_st(a, 0, x); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; vst1q_f32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x[4]; vst1q_s32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double x = _mm_cvtsd_f64(a); return x; }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return a.m128d_f64[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return _mm_cvtsd_f64(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float x = _mm_cvtss_f32(a); return x; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return a.m128_f32[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return _mm_cvtss_f32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int x = _mm_cvtsi128_si32(a); return x; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { return _mm_cvtsi128_si32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pfirst	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type pfirst(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::plain_array::array	../include/Eigen/src/Core/DenseStorage.h	/^  EIGEN_USER_ALIGN16 T array[1];$/;"	m	struct:Eigen::internal::plain_array	access:public
Eigen::internal::plain_array::array	../include/Eigen/src/Core/DenseStorage.h	/^  EIGEN_USER_ALIGN16 T array[Size];$/;"	m	struct:Eigen::internal::plain_array	access:public
Eigen::internal::plain_array::array	../include/Eigen/src/Core/DenseStorage.h	/^  T array[Size];$/;"	m	struct:Eigen::internal::plain_array	access:public
Eigen::internal::plain_array	../include/Eigen/src/Core/DenseStorage.h	/^struct plain_array$/;"	s	namespace:Eigen::internal
Eigen::internal::plain_array	../include/Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>$/;"	s	namespace:Eigen::internal
Eigen::internal::plain_array	../include/Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 16>$/;"	s	namespace:Eigen::internal
Eigen::internal::plain_array::plain_array	../include/Eigen/src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert) {}$/;"	f	struct:Eigen::internal::plain_array	access:public	signature:(constructor_without_unaligned_array_assert)
Eigen::internal::plain_array::plain_array	../include/Eigen/src/Core/DenseStorage.h	/^  plain_array() { EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(0xf) }$/;"	f	struct:Eigen::internal::plain_array	access:public	signature:()
Eigen::internal::plain_array::plain_array	../include/Eigen/src/Core/DenseStorage.h	/^  plain_array() {}$/;"	f	struct:Eigen::internal::plain_array	access:public	signature:()
Eigen::internal::plain_matrix_type::_Flags	../include/Eigen/src/SparseCore/SparseUtil.h	/^          _Flags = traits<T>::Flags$/;"	e	enum:Eigen::internal::plain_matrix_type::__anon14
Eigen::internal::plain_matrix_type	../include/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct plain_matrix_type<T,Sparse>$/;"	s	namespace:Eigen::internal
Eigen::internal::plain_matrix_type::_Scalar	../include/Eigen/src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::plain_matrix_type	access:public
Eigen::internal::plain_matrix_type::type	../include/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Flags> type;$/;"	t	struct:Eigen::internal::plain_matrix_type	access:public
Eigen::internal::ploaddup	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*     from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::ploaddup	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploaddup	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploaddup	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::ploaddup	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploaddup	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploaddup	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>* from)
Eigen::internal::ploaddup	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::ploaddup	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)$/;"	f	namespace:Eigen::internal	signature:(const double* from)
Eigen::internal::ploaddup	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploaddup	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploaddup	../include/Eigen/src/Core/GenericPacketMath.h	/^ploaddup(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
Eigen::internal::pload	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::pload	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) { EIGEN_DEBUG_ALIGNED_LOAD return vec_ld(0, from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::pload	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return vec_ld(0, from); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::pload	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::pload	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::pload	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*   from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::pload	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>* from)
Eigen::internal::pload	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>(&real_ref(*from))); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::pload	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }$/;"	f	namespace:Eigen::internal	signature:(const double* from)
Eigen::internal::pload	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_ps(from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::pload	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::pload	../include/Eigen/src/Core/GenericPacketMath.h	/^pload(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
Eigen::internal::ploadt	../include/Eigen/src/Core/GenericPacketMath.h	/^inline Packet ploadt(const typename unpacket_traits<Packet>::type* from)$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from) { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)   { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>(&real_ref(*from))); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }$/;"	f	namespace:Eigen::internal	signature:(const double* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal	signature:(const double* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
Eigen::internal::ploadu	../include/Eigen/src/Core/GenericPacketMath.h	/^ploadu(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
Eigen::internal::plog	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f plog<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
Eigen::internal::plog	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet plog(const Packet& a) { return log(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::plset	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a) { return vec_add(pset1<Packet4f>(a), p4f_COUNTDOWN); }$/;"	f	namespace:Eigen::internal	signature:(const float& a)
Eigen::internal::plset	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a)     { return vec_add(pset1<Packet4i>(a), p4i_COUNTDOWN); }$/;"	f	namespace:Eigen::internal	signature:(const int& a)
Eigen::internal::plset	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a)$/;"	f	namespace:Eigen::internal	signature:(const float& a)
Eigen::internal::plset	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a)$/;"	f	namespace:Eigen::internal	signature:(const int& a)
Eigen::internal::plset	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<double>(const double& a) { return _mm_add_pd(pset1<Packet2d>(a),_mm_set_pd(1,0)); }$/;"	f	namespace:Eigen::internal	signature:(const double& a)
Eigen::internal::plset	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a) { return _mm_add_ps(pset1<Packet4f>(a), _mm_set_ps(3,2,1,0)); }$/;"	f	namespace:Eigen::internal	signature:(const float& a)
Eigen::internal::plset	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a) { return _mm_add_epi32(pset1<Packet4i>(a),_mm_set_epi32(3,2,1,0)); }$/;"	f	namespace:Eigen::internal	signature:(const int& a)
Eigen::internal::plset	../include/Eigen/src/Core/GenericPacketMath.h	/^plset(const Scalar& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Scalar& a)
Eigen::internal::pmadd	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vec_madd(a, b, c); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b, const Packet4f& c)
Eigen::internal::pmadd	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b, const Packet4i& c)
Eigen::internal::pmadd	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vmlaq_f32(c,a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b, const Packet4f& c)
Eigen::internal::pmadd	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return vmlaq_s32(c,a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b, const Packet4i& c)
Eigen::internal::pmadd	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b, const Packet4i& c)
Eigen::internal::pmadd	../include/Eigen/src/Core/GenericPacketMath.h	/^pmadd(const Packet&  a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b, const Packet& c)
Eigen::internal::pmax	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmax	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmax	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmaxq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmax	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmaxq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmax	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_max_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pmax	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_max_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmax	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmax	../include/Eigen/src/Core/GenericPacketMath.h	/^pmax(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::pmin	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmin	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmin	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vminq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmin	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vminq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmin	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_min_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pmin	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_min_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmin	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmin	../include/Eigen/src/Core/GenericPacketMath.h	/^pmin(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::pmul	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pmul	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_madd(a,b,p4f_ZERO); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmul	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pmul	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmulq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmul	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmulq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pmul	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_mul_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pmul	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_mul_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pmul	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pmul	../include/Eigen/src/Core/GenericPacketMath.h	/^pmul(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::pmul	../include/Eigen/src/Core/GenericPacketMath.h	/^template<> inline std::complex<double> pmul(const std::complex<double>& a, const std::complex<double>& b)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>& a, const std::complex<double>& b)
Eigen::internal::pmul	../include/Eigen/src/Core/GenericPacketMath.h	/^template<> inline std::complex<float> pmul(const std::complex<float>& a, const std::complex<float>& b)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& a, const std::complex<float>& b)
Eigen::internal::pnegate	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pnegate	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return psub<Packet4f>(p4f_ZERO, a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pnegate	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return psub<Packet4i>(p4i_ZERO, a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pnegate	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate<Packet4f>(a.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pnegate	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return vnegq_f32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pnegate	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return vnegq_s32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pnegate	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
Eigen::internal::pnegate	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::pnegate	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::pnegate	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::pnegate	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::pnegate	../include/Eigen/src/Core/GenericPacketMath.h	/^pnegate(const Packet& a) { return -a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::por	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_or(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::por	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::por	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::por	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::por	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::por	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vorrq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::por	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_or_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::por	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_or_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::por	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_or_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::por	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_or_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::por	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_or_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::por	../include/Eigen/src/Core/GenericPacketMath.h	/^por(const Packet& a, const Packet& b) { return a | b; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::pow_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct pow_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::pow_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct pow_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::pow_default_impl::retval	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar retval;$/;"	t	struct:Eigen::internal::pow_default_impl	access:public
Eigen::internal::pow_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::pow_default_impl	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::pow_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar x, Scalar y)$/;"	f	struct:Eigen::internal::pow_default_impl	access:public	signature:(Scalar x, Scalar y)
Eigen::internal::pow_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct pow_impl : pow_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:pow_default_impl
Eigen::internal::pow	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(pow, Scalar) pow(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::pow_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct pow_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::pow_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::pow_retval	access:public
Eigen::internal::PreconditionIfMoreColsThanRows	../include/Eigen/src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon413
Eigen::internal::PreconditionIfMoreRowsThanCols	../include/Eigen/src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon413
Eigen::internal::predux	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::predux	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::predux	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
Eigen::internal::predux	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::predux	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::predux	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a) { return pfirst(_mm_hadd_pd(a, a)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::predux	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::predux_max	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_max	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_max	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_max	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_max	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::predux_max	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_max	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_max	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_max(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::predux_min	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_min	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_min	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_min	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_min	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::predux_min	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_min	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_min	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_min(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::predux_mul	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::predux_mul	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_mul	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_mul	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::predux_mul	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_mul	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_mul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
Eigen::internal::predux_mul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::predux_mul	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::predux_mul	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::predux_mul	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::predux_mul	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_mul(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::preduxp	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf* vecs)
Eigen::internal::preduxp	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f* vecs)
Eigen::internal::preduxp	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i* vecs)
Eigen::internal::preduxp	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf* vecs)
Eigen::internal::preduxp	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f* vecs)
Eigen::internal::preduxp	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i* vecs)
Eigen::internal::preduxp	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd* vecs)
Eigen::internal::preduxp	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf* vecs)
Eigen::internal::preduxp	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d* vecs)
Eigen::internal::preduxp	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f* vecs)
Eigen::internal::preduxp	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i* vecs)
Eigen::internal::preduxp	../include/Eigen/src/Core/GenericPacketMath.h	/^preduxp(const Packet* vecs) { return vecs[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet* vecs)
Eigen::internal::prefetch	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { vec_dstt((float *)addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float> * addr)
Eigen::internal::prefetch	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) { vec_dstt(addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal	signature:(const float* addr)
Eigen::internal::prefetch	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr) { vec_dstt(addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal	signature:(const int* addr)
Eigen::internal::prefetch	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { __pld((float *)addr); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float> * addr)
Eigen::internal::prefetch	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) { __pld(addr); }$/;"	f	namespace:Eigen::internal	signature:(const float* addr)
Eigen::internal::prefetch	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr) { __pld(addr); }$/;"	f	namespace:Eigen::internal	signature:(const int* addr)
Eigen::internal::prefetch	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double> * addr)
Eigen::internal::prefetch	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float> * addr)
Eigen::internal::prefetch	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const double* addr)
Eigen::internal::prefetch	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const float* addr)
Eigen::internal::prefetch	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const int* addr)
Eigen::internal::prefetch	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar> inline void prefetch(const Scalar* addr)$/;"	f	namespace:Eigen::internal	signature:(const Scalar* addr)
Eigen::internal::preverse	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::preverse	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) { return (Packet4f)vec_perm((Packet16uc)a,(Packet16uc)a, p16uc_REVERSE); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::preverse	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) { return (Packet4i)vec_perm((Packet16uc)a,(Packet16uc)a, p16uc_REVERSE); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::preverse	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::preverse	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) {$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::preverse	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) {$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::preverse	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
Eigen::internal::preverse	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a) { return Packet2cf(_mm_castpd_ps(preverse(_mm_castps_pd(a.v)))); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
Eigen::internal::preverse	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
Eigen::internal::preverse	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
Eigen::internal::preverse	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
Eigen::internal::preverse	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline Packet preverse(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::print_matrix	../include/Eigen/src/Core/IO.h	/^std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt)$/;"	f	namespace:Eigen::internal	signature:(std::ostream & s, const Derived& _m, const IOFormat& fmt)
Eigen::internal::print_matrix	../include/Eigen/src/Core/IO.h	/^std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt);$/;"	p	namespace:Eigen::internal	signature:(std::ostream & s, const Derived& _m, const IOFormat& fmt)
Eigen::internal::product_coeff_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, 0, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, Dynamic, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, Dynamic, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_impl::Index	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_impl	access:public
Eigen::internal::product_coeff_impl::Packet	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::PacketScalar Packet;$/;"	t	struct:Eigen::internal::product_coeff_impl	access:public
Eigen::internal::product_coeff_impl::PacketSize	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };$/;"	e	enum:Eigen::internal::product_coeff_impl::__anon90
Eigen::internal::product_coeff_impl::run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)
Eigen::internal::product_coeff_impl::run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar& res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar& res)
Eigen::internal::product_coeff_impl::run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
Eigen::internal::product_coeff_vectorized_dyn_selector	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,1>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_vectorized_dyn_selector	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,RhsCols>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_vectorized_dyn_selector	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,LhsRows,1>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_vectorized_dyn_selector	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_vectorized_dyn_selector::Index	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public
Eigen::internal::product_coeff_vectorized_dyn_selector::run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index , Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
Eigen::internal::product_coeff_vectorized_dyn_selector::run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index , Index , const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
Eigen::internal::product_coeff_vectorized_dyn_selector::run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
Eigen::internal::product_coeff_vectorized_dyn_selector::run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index \/*col*\/, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index row, Index , const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
Eigen::internal::product_coeff_vectorized_unroller	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_unroller<0, Lhs, Rhs, Packet>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_vectorized_unroller	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_unroller$/;"	s	namespace:Eigen::internal
Eigen::internal::product_coeff_vectorized_unroller::Index	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_vectorized_unroller	access:public
Eigen::internal::product_coeff_vectorized_unroller::PacketSize	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };$/;"	e	enum:Eigen::internal::product_coeff_vectorized_unroller::__anon89
Eigen::internal::product_coeff_vectorized_unroller::run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::PacketScalar &pres)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_unroller	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::PacketScalar &pres)
Eigen::internal::product_packet_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_packet_impl::Index	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_packet_impl	access:public
Eigen::internal::product_packet_impl::run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)$/;"	f	struct:Eigen::internal::product_packet_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)
Eigen::internal::product_packet_impl::run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet& res)$/;"	f	struct:Eigen::internal::product_packet_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet& res)
Eigen::internal::product_selfadjoint_matrix	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_selfadjoint_matrix	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,LhsSelfAdjoint,ConjugateLhs, RhsStorageOrder,RhsSelfAdjoint,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_selfadjoint_matrix	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::product_selfadjoint_matrix::run	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::product_selfadjoint_matrix	access:public	signature:( Index rows, Index cols, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, Scalar alpha)
Eigen::internal::product_selfadjoint_matrix::run	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_selfadjoint_matrix	access:public	signature:( Index rows, Index cols, const Scalar* lhs, Index lhsStride, const Scalar* rhs, Index rhsStride, Scalar* res, Index resStride, Scalar alpha)
Eigen::internal::product_size_category	../include/Eigen/src/Core/GeneralProduct.h	/^template<int Size, int MaxSize> struct product_size_category$/;"	s	namespace:Eigen::internal
Eigen::internal::product_size_category::is_large	../include/Eigen/src/Core/GeneralProduct.h	/^  enum { is_large = MaxSize == Dynamic ||$/;"	e	enum:Eigen::internal::product_size_category::__anon121
Eigen::internal::product_size_category::value	../include/Eigen/src/Core/GeneralProduct.h	/^         value = is_large  ? Large$/;"	e	enum:Eigen::internal::product_size_category::__anon121
Eigen::internal::product_triangular_matrix_matrix	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,false,$/;"	s	namespace:Eigen::internal
Eigen::internal::product_triangular_matrix_matrix	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,LhsIsTriangular,$/;"	s	namespace:Eigen::internal
Eigen::internal::product_triangular_matrix_matrix	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,true,$/;"	s	namespace:Eigen::internal
Eigen::internal::product_triangular_matrix_matrix::IsLower	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon102
Eigen::internal::product_triangular_matrix_matrix::IsLower	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon103
Eigen::internal::product_triangular_matrix_matrix::run	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::product_triangular_matrix_matrix	access:public	signature:( Index _rows, Index _cols, Index _depth, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, Scalar alpha)
Eigen::internal::product_triangular_matrix_matrix::run	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_triangular_matrix_matrix	access:public	signature:( Index rows, Index cols, Index depth, const Scalar* lhs, Index lhsStride, const Scalar* rhs, Index rhsStride, Scalar* res, Index resStride, Scalar alpha)
Eigen::internal::product_triangular_matrix_matrix::SetDiag	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon102
Eigen::internal::product_triangular_matrix_matrix::SetDiag	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon103
Eigen::internal::product_triangular_matrix_matrix::SmallPanelWidth	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = 2 * EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon102
Eigen::internal::product_triangular_matrix_matrix::SmallPanelWidth	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon103
Eigen::internal::product_triangular_matrix_matrix::Traits	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  typedef gebp_traits<Scalar,Scalar> Traits;$/;"	t	struct:Eigen::internal::product_triangular_matrix_matrix	access:public
Eigen::internal::product_triangular_matrix_matrix_trmm	../include/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^struct product_triangular_matrix_matrix_trmm :$/;"	s	namespace:Eigen::internal	inherits:product_triangular_matrix_matrix
Eigen::internal::product_type::Cols	../include/Eigen/src/Core/GeneralProduct.h	/^    Cols  = _Rhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon122
Eigen::internal::product_type::cols_select	../include/Eigen/src/Core/GeneralProduct.h	/^    cols_select = product_size_category<Cols,MaxCols>::value,$/;"	e	enum:Eigen::internal::product_type::__anon123
Eigen::internal::product_type::debug	../include/Eigen/src/Core/GeneralProduct.h	/^  static void debug()$/;"	f	struct:Eigen::internal::product_type	access:public	signature:()
Eigen::internal::product_type::Depth	../include/Eigen/src/Core/GeneralProduct.h	/^    Depth = EIGEN_SIZE_MIN_PREFER_FIXED(_Lhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon122
Eigen::internal::product_type::depth_select	../include/Eigen/src/Core/GeneralProduct.h	/^    depth_select = product_size_category<Depth,MaxDepth>::value$/;"	e	enum:Eigen::internal::product_type::__anon123
Eigen::internal::product_type	../include/Eigen/src/Core/GeneralProduct.h	/^template<typename Lhs, typename Rhs> struct product_type$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type::LargeThreshold	../include/Eigen/src/Core/GeneralProduct.h	/^    LargeThreshold = EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD$/;"	e	enum:Eigen::internal::product_type::__anon122
Eigen::internal::product_type::_Lhs	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::product_type	access:public
Eigen::internal::product_type::MaxCols	../include/Eigen/src/Core/GeneralProduct.h	/^    MaxCols  = _Rhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon122
Eigen::internal::product_type::MaxDepth	../include/Eigen/src/Core/GeneralProduct.h	/^    MaxDepth = EIGEN_SIZE_MIN_PREFER_FIXED(_Lhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon122
Eigen::internal::product_type::MaxRows	../include/Eigen/src/Core/GeneralProduct.h	/^    MaxRows  = _Lhs::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon122
Eigen::internal::product_type::_Rhs	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::product_type	access:public
Eigen::internal::product_type::Rows	../include/Eigen/src/Core/GeneralProduct.h	/^    Rows  = _Lhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon122
Eigen::internal::product_type::rows_select	../include/Eigen/src/Core/GeneralProduct.h	/^    rows_select = product_size_category<Rows,MaxRows>::value,$/;"	e	enum:Eigen::internal::product_type::__anon123
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::product_type::selector	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef product_type_selector<rows_select, cols_select, depth_select> selector;$/;"	t	struct:Eigen::internal::product_type	access:private
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon126
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon125
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon127
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon135
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon134
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon136
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon129
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon138
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon137
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon143
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon146
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon133
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon141
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon144
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon139
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon128
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon132
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon142
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon145
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon131
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon140
Eigen::internal::product_type_selector::ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon130
Eigen::internal::product_type::value	../include/Eigen/src/Core/GeneralProduct.h	/^    value = selector::ret$/;"	e	enum:Eigen::internal::product_type::__anon124
Eigen::internal::projective_transform_inverse	../include/Eigen/src/Geometry/Transform.h	/^struct projective_transform_inverse$/;"	s	namespace:Eigen::internal
Eigen::internal::projective_transform_inverse	../include/Eigen/src/Geometry/Transform.h	/^struct projective_transform_inverse<TransformType, Projective>$/;"	s	namespace:Eigen::internal
Eigen::internal::projective_transform_inverse::run	../include/Eigen/src/Geometry/Transform.h	/^  static inline void run(const TransformType& m, TransformType& res)$/;"	f	struct:Eigen::internal::projective_transform_inverse	access:public	signature:(const TransformType& m, TransformType& res)
Eigen::internal::projective_transform_inverse::run	../include/Eigen/src/Geometry/Transform.h	/^  static inline void run(const TransformType&, TransformType&)$/;"	f	struct:Eigen::internal::projective_transform_inverse	access:public	signature:(const TransformType&, TransformType&)
Eigen::internal::promote_index_type	../include/Eigen/src/Core/util/XprHelper.h	/^struct promote_index_type$/;"	s	namespace:Eigen::internal
Eigen::internal::promote_storage_type	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^template<> struct promote_storage_type<Dense,Sparse>$/;"	s	namespace:Eigen::internal
Eigen::internal::promote_storage_type	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^template<> struct promote_storage_type<Sparse,Dense>$/;"	s	namespace:Eigen::internal
Eigen::internal::promote_storage_type::ret	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^{ typedef Sparse ret; };$/;"	t	struct:Eigen::internal::promote_storage_type	access:public
Eigen::internal::pset1	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) {$/;"	f	namespace:Eigen::internal	signature:(const float& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   {$/;"	f	namespace:Eigen::internal	signature:(const int& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return vdupq_n_f32(from); }$/;"	f	namespace:Eigen::internal	signature:(const float& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   { return vdupq_n_s32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set1_pd(from); }$/;"	f	namespace:Eigen::internal	signature:(const double& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set_pd(from,from); }$/;"	f	namespace:Eigen::internal	signature:(const double& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set1_ps(from); }$/;"	f	namespace:Eigen::internal	signature:(const float& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps(from,from,from,from); }$/;"	f	namespace:Eigen::internal	signature:(const float& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set1_epi32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int& from)
Eigen::internal::pset1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set_epi32(from,from,from,from); }$/;"	f	namespace:Eigen::internal	signature:(const int& from)
Eigen::internal::pset1	../include/Eigen/src/Core/GenericPacketMath.h	/^pset1(const typename unpacket_traits<Packet>::type& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type& a)
Eigen::internal::psin	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psin<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
Eigen::internal::psin	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet psin(const Packet& a) { return sin(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::psqrt	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
Eigen::internal::psqrt	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet psqrt(const Packet& a) { return sqrt(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::pstore1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet2d>(double* to, const double& a)$/;"	f	namespace:Eigen::internal	signature:(double* to, const double& a)
Eigen::internal::pstore1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet4f>(float* to, const float& a)$/;"	f	namespace:Eigen::internal	signature:(float* to, const float& a)
Eigen::internal::pstore1	../include/Eigen/src/Core/GenericPacketMath.h	/^inline void pstore1(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)$/;"	f	namespace:Eigen::internal	signature:(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)
Eigen::internal::pstore	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
Eigen::internal::pstore	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vec_st(from, 0, to); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
Eigen::internal::pstore	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vec_st(from, 0, to); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
Eigen::internal::pstore	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
Eigen::internal::pstore	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
Eigen::internal::pstore	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
Eigen::internal::pstore	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<double> * to, const Packet1cd& from)
Eigen::internal::pstore	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore(&real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
Eigen::internal::pstore	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }$/;"	f	namespace:Eigen::internal	signature:(double* to, const Packet2d& from)
Eigen::internal::pstore	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
Eigen::internal::pstore	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_si128(reinterpret_cast<Packet4i*>(to), from); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
Eigen::internal::pstore	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> inline void pstore(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal	signature:(Scalar* to, const Packet& from)
Eigen::internal::pstoret	../include/Eigen/src/Core/GenericPacketMath.h	/^inline void pstoret(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal	signature:(Scalar* to, const Packet& from)
Eigen::internal::pstoreu	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
Eigen::internal::pstoreu	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from)$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
Eigen::internal::pstoreu	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from)$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
Eigen::internal::pstoreu	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
Eigen::internal::pstoreu	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
Eigen::internal::pstoreu	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
Eigen::internal::pstoreu	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<double> * to, const Packet1cd& from)
Eigen::internal::pstoreu	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(&real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
Eigen::internal::pstoreu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet2d& from) {$/;"	f	namespace:Eigen::internal	signature:(double* to, const Packet2d& from)
Eigen::internal::pstoreu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), _mm_castps_pd(from)); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
Eigen::internal::pstoreu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), _mm_castsi128_pd(from)); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
Eigen::internal::pstoreu	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> inline void pstoreu(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal	signature:(Scalar* to, const Packet& from)
Eigen::internal::psub	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_sub(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::psub	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_sub(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::psub	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_sub(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::psub	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::psub	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vsubq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::psub	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vsubq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::psub	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_sub_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::psub	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_sub_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::psub	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_sub_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::psub	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_sub_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::psub	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_sub_epi32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::psub	../include/Eigen/src/Core/GenericPacketMath.h	/^psub(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::ptan	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet ptan(const Packet& a) { return tan(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Eigen::internal::punpackp	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^EIGEN_STRONG_INLINE void punpackp(Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(Packet4f* vecs)
Eigen::internal::pxor	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_xor(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pxor	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pxor	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pxor	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pxor	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pxor	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return veorq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pxor	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_xor_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
Eigen::internal::pxor	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_xor_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
Eigen::internal::pxor	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_xor_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
Eigen::internal::pxor	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_xor_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
Eigen::internal::pxor	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_xor_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
Eigen::internal::pxor	../include/Eigen/src/Core/GenericPacketMath.h	/^pxor(const Packet& a, const Packet& b) { return a ^ b; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
Eigen::internal::qr_preconditioner_impl::allocate	../include/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)
Eigen::internal::qr_preconditioner_impl::allocate	../include/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)
Eigen::internal::qr_preconditioner_impl::allocate	../include/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)
Eigen::internal::qr_preconditioner_impl::allocate	../include/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, QRPreconditioner>&) {}$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(const JacobiSVD<MatrixType, QRPreconditioner>&)
Eigen::internal::qr_preconditioner_impl::ColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon416
Eigen::internal::qr_preconditioner_impl::ColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon417
Eigen::internal::qr_preconditioner_impl::ColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
Eigen::internal::qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, QRPreconditioner, Case, false>$/;"	c	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^> struct qr_preconditioner_impl {};$/;"	s	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_impl::Index	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
Eigen::internal::qr_preconditioner_impl::m_adjoint	../include/Eigen/src/SVD/JacobiSVD.h	/^  TransposeTypeWithSameStorageOrder m_adjoint;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::MaxColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon416
Eigen::internal::qr_preconditioner_impl::MaxColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon417
Eigen::internal::qr_preconditioner_impl::MaxColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
Eigen::internal::qr_preconditioner_impl::MaxRowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon415
Eigen::internal::qr_preconditioner_impl::MaxRowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon416
Eigen::internal::qr_preconditioner_impl::MaxRowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon417
Eigen::internal::qr_preconditioner_impl::MaxRowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
Eigen::internal::qr_preconditioner_impl::m_qr	../include/Eigen/src/SVD/JacobiSVD.h	/^  ColPivHouseholderQR<MatrixType> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::m_qr	../include/Eigen/src/SVD/JacobiSVD.h	/^  ColPivHouseholderQR<TransposeTypeWithSameStorageOrder> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::m_qr	../include/Eigen/src/SVD/JacobiSVD.h	/^  FullPivHouseholderQR<MatrixType> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::m_qr	../include/Eigen/src/SVD/JacobiSVD.h	/^  FullPivHouseholderQR<TransposeTypeWithSameStorageOrder> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::m_qr	../include/Eigen/src/SVD/JacobiSVD.h	/^  HouseholderQR<MatrixType> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::m_qr	../include/Eigen/src/SVD/JacobiSVD.h	/^  HouseholderQR<TransposeTypeWithSameStorageOrder> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::m_workspace	../include/Eigen/src/SVD/JacobiSVD.h	/^  typename internal::plain_col_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::m_workspace	../include/Eigen/src/SVD/JacobiSVD.h	/^  typename internal::plain_row_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::m_workspace	../include/Eigen/src/SVD/JacobiSVD.h	/^  WorkspaceType m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
Eigen::internal::qr_preconditioner_impl::Options	../include/Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon416
Eigen::internal::qr_preconditioner_impl::Options	../include/Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon417
Eigen::internal::qr_preconditioner_impl::Options	../include/Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
Eigen::internal::qr_preconditioner_impl::RowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon415
Eigen::internal::qr_preconditioner_impl::RowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon416
Eigen::internal::qr_preconditioner_impl::RowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon417
Eigen::internal::qr_preconditioner_impl::RowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
Eigen::internal::qr_preconditioner_impl::run	../include/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)
Eigen::internal::qr_preconditioner_impl::run	../include/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)
Eigen::internal::qr_preconditioner_impl::run	../include/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)
Eigen::internal::qr_preconditioner_impl::run	../include/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)
Eigen::internal::qr_preconditioner_impl::Scalar	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
Eigen::internal::qr_preconditioner_impl::TransposeTypeWithSameStorageOrder	../include/Eigen/src/SVD/JacobiSVD.h	/^          TransposeTypeWithSameStorageOrder;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
Eigen::internal::qr_preconditioner_impl::WorkspaceType	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef Matrix<Scalar, 1, RowsAtCompileTime, RowMajor, 1, MaxRowsAtCompileTime> WorkspaceType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
Eigen::internal::qr_preconditioner_should_do_anything::a	../include/Eigen/src/SVD/JacobiSVD.h	/^  enum { a = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon414
Eigen::internal::qr_preconditioner_should_do_anything::b	../include/Eigen/src/SVD/JacobiSVD.h	/^         b = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon414
Eigen::internal::qr_preconditioner_should_do_anything	../include/Eigen/src/SVD/JacobiSVD.h	/^struct qr_preconditioner_should_do_anything$/;"	s	namespace:Eigen::internal
Eigen::internal::qr_preconditioner_should_do_anything::ret	../include/Eigen/src/SVD/JacobiSVD.h	/^         ret = !( (QRPreconditioner == NoQRPreconditioner) ||$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon414
Eigen::internal::quaternionbase_assign_impl	../include/Eigen/src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,3,3>$/;"	s	namespace:Eigen::internal
Eigen::internal::quaternionbase_assign_impl	../include/Eigen/src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,4,1>$/;"	s	namespace:Eigen::internal
Eigen::internal::quaternionbase_assign_impl::Index	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl	access:public
Eigen::internal::quaternionbase_assign_impl::run	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> static inline void run(QuaternionBase<Derived>& q, const Other& mat)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl	access:public	signature:(QuaternionBase<Derived>& q, const Other& mat)
Eigen::internal::quaternionbase_assign_impl::run	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> static inline void run(QuaternionBase<Derived>& q, const Other& vec)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl	access:public	signature:(QuaternionBase<Derived>& q, const Other& vec)
Eigen::internal::quaternionbase_assign_impl::Scalar	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl	access:public
Eigen::internal::quat_product	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, double, Aligned>$/;"	s	namespace:Eigen::internal
Eigen::internal::quat_product	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, float, Aligned>$/;"	s	namespace:Eigen::internal
Eigen::internal::quat_product	../include/Eigen/src/Geometry/Quaternion.h	/^template<int Arch, class Derived1, class Derived2, typename Scalar, int _Options> struct quat_product$/;"	s	namespace:Eigen::internal
Eigen::internal::quat_product::run	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<double> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product	access:public	signature:(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)
Eigen::internal::quat_product::run	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<float> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product	access:public	signature:(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)
Eigen::internal::quat_product::run	../include/Eigen/src/Geometry/Quaternion.h	/^  static EIGEN_STRONG_INLINE Quaternion<Scalar> run(const QuaternionBase<Derived1>& a, const QuaternionBase<Derived2>& b){$/;"	f	struct:Eigen::internal::quat_product	access:public	signature:(const QuaternionBase<Derived1>& a, const QuaternionBase<Derived2>& b)
Eigen::internal::queryCacheSizes_amd	../include/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_amd(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
Eigen::internal::queryCacheSizes	../include/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
Eigen::internal::queryCacheSizes_intel_codes	../include/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_codes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
Eigen::internal::queryCacheSizes_intel_direct	../include/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_direct(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
Eigen::internal::queryCacheSizes_intel	../include/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel(int& l1, int& l2, int& l3, int max_std_funcs)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3, int max_std_funcs)
Eigen::internal::queryL1CacheSize	../include/Eigen/src/Core/util/Memory.h	/^inline int queryL1CacheSize()$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::queryTopLevelCacheSize	../include/Eigen/src/Core/util/Memory.h	/^inline int queryTopLevelCacheSize()$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::random_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::random_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::random_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::random_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl {};$/;"	s	namespace:Eigen::internal
Eigen::internal::random_default_impl::NonInteger	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::NonInteger NonInteger;$/;"	t	struct:Eigen::internal::random_default_impl	access:public
Eigen::internal::random_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::random_default_impl	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::random_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run()$/;"	f	struct:Eigen::internal::random_default_impl	access:public	signature:()
Eigen::internal::random_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct random_impl : random_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:random_default_impl
Eigen::internal::random_impl	../include/Eigen/src/Core/MathFunctions.h	/^template<> struct random_impl<bool>$/;"	s	namespace:Eigen::internal
Eigen::internal::random_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool run()$/;"	f	struct:Eigen::internal::random_impl	access:public	signature:()
Eigen::internal::random	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::random	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random()$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::random	../include/Eigen/src/Core/MathFunctions.h	/^template<typename Scalar> inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y);$/;"	p	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
Eigen::internal::random	../include/Eigen/src/Core/MathFunctions.h	/^template<typename Scalar> inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random();$/;"	p	namespace:Eigen::internal	signature:()
Eigen::internal::random_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct random_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::random_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::random_retval	access:public
Eigen::internal::real_2x2_jacobi_svd	../include/Eigen/src/SVD/JacobiSVD.h	/^void real_2x2_jacobi_svd(const MatrixType& matrix, Index p, Index q,$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& matrix, Index p, Index q, JacobiRotation<RealScalar> *j_left, JacobiRotation<RealScalar> *j_right)
Eigen::internal::real_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct real_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::real_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct real_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::real_impl::RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_impl	access:public
Eigen::internal::real_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_impl	access:public	signature:(const Scalar& x)
Eigen::internal::real_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::real_impl	access:public	signature:(const std::complex<RealScalar>& x)
Eigen::internal::real	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real, Scalar) real(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
Eigen::internal::real_ref_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct real_ref_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::real_ref_impl::RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_ref_impl	access:public
Eigen::internal::real_ref_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl	access:public	signature:(const Scalar& x)
Eigen::internal::real_ref_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl	access:public	signature:(Scalar& x)
Eigen::internal::real_ref	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) real_ref(Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(Scalar& x)
Eigen::internal::real_ref	../include/Eigen/src/Core/MathFunctions.h	/^inline typename add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) >::type real_ref(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
Eigen::internal::real_ref_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct real_ref_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::real_ref_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::real_ref_retval	access:public
Eigen::internal::real_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct real_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::real_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::real_retval	access:public
Eigen::internal::redux_impl	../include/Eigen/src/Core/Redux.h	/^struct redux_impl<Func,Derived, DefaultTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal	inherits:redux_novec_unroller
Eigen::internal::redux_impl	../include/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, DefaultTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_impl	../include/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_impl	../include/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_impl	../include/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, SliceVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_impl::Index	../include/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::redux_impl	access:public
Eigen::internal::redux_impl::PacketScalar	../include/Eigen/src/Core/Redux.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::redux_impl	access:public
Eigen::internal::redux_impl::PacketSize	../include/Eigen/src/Core/Redux.h	/^    PacketSize = packet_traits<Scalar>::size,$/;"	e	enum:Eigen::internal::redux_impl::__anon276
Eigen::internal::redux_impl::run	../include/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived& mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl	access:public	signature:(const Derived& mat, const Func& func)
Eigen::internal::redux_impl::run	../include/Eigen/src/Core/Redux.h	/^  static Scalar run(const Derived& mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl	access:public	signature:(const Derived& mat, const Func& func)
Eigen::internal::redux_impl::Scalar	../include/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_impl	access:public
Eigen::internal::redux_impl::Size	../include/Eigen/src/Core/Redux.h	/^    Size = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_impl::__anon276
Eigen::internal::redux_impl::VectorizedSize	../include/Eigen/src/Core/Redux.h	/^    VectorizedSize = (Size \/ PacketSize) * PacketSize$/;"	e	enum:Eigen::internal::redux_impl::__anon276
Eigen::internal::redux_novec_unroller::HalfLength	../include/Eigen/src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon272
Eigen::internal::redux_novec_unroller	../include/Eigen/src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 0>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_novec_unroller	../include/Eigen/src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_novec_unroller	../include/Eigen/src/Core/Redux.h	/^struct redux_novec_unroller$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_novec_unroller::inner	../include/Eigen/src/Core/Redux.h	/^    inner = Start % Derived::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon273
Eigen::internal::redux_novec_unroller::outer	../include/Eigen/src/Core/Redux.h	/^    outer = Start \/ Derived::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon273
Eigen::internal::redux_novec_unroller::run	../include/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived&, const Func&) { return Scalar(); }$/;"	f	struct:Eigen::internal::redux_novec_unroller	access:public	signature:(const Derived&, const Func&)
Eigen::internal::redux_novec_unroller::run	../include/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_novec_unroller	access:public	signature:(const Derived &mat, const Func&)
Eigen::internal::redux_novec_unroller::run	../include/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_novec_unroller	access:public	signature:(const Derived &mat, const Func& func)
Eigen::internal::redux_novec_unroller::Scalar	../include/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_novec_unroller	access:public
Eigen::internal::redux_traits::Cost	../include/Eigen/src/Core/Redux.h	/^    Cost = (  Derived::SizeAtCompileTime == Dynamic$/;"	e	enum:Eigen::internal::redux_traits::__anon270
Eigen::internal::redux_traits	../include/Eigen/src/Core/Redux.h	/^struct redux_traits$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_traits::InnerMaxSize	../include/Eigen/src/Core/Redux.h	/^    InnerMaxSize = int(Derived::IsRowMajor)$/;"	e	enum:Eigen::internal::redux_traits::__anon267
Eigen::internal::redux_traits::MayLinearVectorize	../include/Eigen/src/Core/Redux.h	/^    MayLinearVectorize = MightVectorize && (int(Derived::Flags)&LinearAccessBit),$/;"	e	enum:Eigen::internal::redux_traits::__anon268
Eigen::internal::redux_traits::MaySliceVectorize	../include/Eigen/src/Core/Redux.h	/^    MaySliceVectorize  = MightVectorize && int(InnerMaxSize)>=3*PacketSize$/;"	e	enum:Eigen::internal::redux_traits::__anon268
Eigen::internal::redux_traits::MightVectorize	../include/Eigen/src/Core/Redux.h	/^    MightVectorize = (int(Derived::Flags)&ActualPacketAccessBit)$/;"	e	enum:Eigen::internal::redux_traits::__anon268
Eigen::internal::redux_traits::PacketSize	../include/Eigen/src/Core/Redux.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_traits::__anon267
Eigen::internal::redux_traits::Traversal	../include/Eigen/src/Core/Redux.h	/^    Traversal = int(MayLinearVectorize) ? int(LinearVectorizedTraversal)$/;"	e	enum:Eigen::internal::redux_traits::__anon269
Eigen::internal::redux_traits::Unrolling	../include/Eigen/src/Core/Redux.h	/^    Unrolling = Cost != Dynamic && Cost <= UnrollingLimit$/;"	e	enum:Eigen::internal::redux_traits::__anon271
Eigen::internal::redux_traits::UnrollingLimit	../include/Eigen/src/Core/Redux.h	/^    UnrollingLimit = EIGEN_UNROLLING_LIMIT * (int(Traversal) == int(DefaultTraversal) ? 1 : int(PacketSize))$/;"	e	enum:Eigen::internal::redux_traits::__anon270
Eigen::internal::redux_vec_unroller::alignment	../include/Eigen/src/Core/Redux.h	/^    alignment = (Derived::Flags & AlignedBit) ? Aligned : Unaligned$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon275
Eigen::internal::redux_vec_unroller::HalfLength	../include/Eigen/src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon274
Eigen::internal::redux_vec_unroller	../include/Eigen/src/Core/Redux.h	/^struct redux_vec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_vec_unroller	../include/Eigen/src/Core/Redux.h	/^struct redux_vec_unroller$/;"	s	namespace:Eigen::internal
Eigen::internal::redux_vec_unroller::index	../include/Eigen/src/Core/Redux.h	/^    index = Start * packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon275
Eigen::internal::redux_vec_unroller::inner	../include/Eigen/src/Core/Redux.h	/^    inner = index % int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon275
Eigen::internal::redux_vec_unroller::outer	../include/Eigen/src/Core/Redux.h	/^    outer = index \/ int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon275
Eigen::internal::redux_vec_unroller::PacketScalar	../include/Eigen/src/Core/Redux.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller	access:public
Eigen::internal::redux_vec_unroller::PacketSize	../include/Eigen/src/Core/Redux.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon274
Eigen::internal::redux_vec_unroller::run	../include/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_vec_unroller	access:public	signature:(const Derived &mat, const Func&)
Eigen::internal::redux_vec_unroller::run	../include/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_vec_unroller	access:public	signature:(const Derived &mat, const Func& func)
Eigen::internal::redux_vec_unroller::Scalar	../include/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller	access:public
Eigen::internal::remove_all	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_all	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_all	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_all	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_all	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_all	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_all::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
Eigen::internal::remove_all::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
Eigen::internal::remove_all::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
Eigen::internal::remove_all::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
Eigen::internal::remove_all::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
Eigen::internal::remove_all::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
Eigen::internal::remove_const	../include/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_const	../include/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_const	../include/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_const	../include/Eigen/src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_const::type	../include/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const	access:public
Eigen::internal::remove_const::type	../include/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	t	struct:Eigen::internal::remove_const	access:public
Eigen::internal::remove_const::type	../include/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const	access:public
Eigen::internal::remove_const::type	../include/Eigen/src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	t	struct:Eigen::internal::remove_const	access:public
Eigen::internal::remove_pointer	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_pointer	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_pointer	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_pointer::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer	access:public
Eigen::internal::remove_pointer::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer	access:public
Eigen::internal::remove_pointer::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer	access:public
Eigen::internal::remove_reference	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_reference	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	s	namespace:Eigen::internal
Eigen::internal::remove_reference::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference	access:public
Eigen::internal::remove_reference::type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference	access:public
Eigen::internal::result_of::FunctorType	../include/Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon193
Eigen::internal::result_of::FunctorType	../include/Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon194
Eigen::internal::result_of	../include/Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType0,ArgType1)> {$/;"	s	namespace:Eigen::internal
Eigen::internal::result_of	../include/Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType)> {$/;"	s	namespace:Eigen::internal
Eigen::internal::result_of	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct result_of {};$/;"	s	namespace:Eigen::internal
Eigen::internal::result_of::testFunctor	../include/Eigen/src/Core/util/Meta.h	/^    static has_none            testFunctor(...);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(....)
Eigen::internal::result_of::testFunctor	../include/Eigen/src/Core/util/Meta.h	/^    static has_std_result_type testFunctor(T const *, typename T::result_type const * = 0);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(T const *, typename T::result_type const * = 0)
Eigen::internal::result_of::testFunctor	../include/Eigen/src/Core/util/Meta.h	/^    static has_tr1_result      testFunctor(T const *, typename T::template result<T(ArgType0,ArgType1)>::type const * = 0);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(T const *, typename T::template result<T(ArgType0,ArgType1)>::type const * = 0)
Eigen::internal::result_of::testFunctor	../include/Eigen/src/Core/util/Meta.h	/^    static has_tr1_result      testFunctor(T const *, typename T::template result<T(ArgType)>::type const * = 0);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(T const *, typename T::template result<T(ArgType)>::type const * = 0)
Eigen::internal::result_of::type	../include/Eigen/src/Core/util/Meta.h	/^    typedef typename binary_result_of_select<Func, ArgType0, ArgType1, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of	access:public
Eigen::internal::result_of::type	../include/Eigen/src/Core/util/Meta.h	/^    typedef typename unary_result_of_select<Func, ArgType, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of	access:public
Eigen::internal::ret	../include/Eigen/src/Core/util/Meta.h	/^    enum { ret = meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::internal::__anon195
Eigen::internal::reverse_packet_cond	../include/Eigen/src/Core/Reverse.h	/^template<typename PacketScalar, bool ReversePacket> struct reverse_packet_cond$/;"	s	namespace:Eigen::internal
Eigen::internal::reverse_packet_cond	../include/Eigen/src/Core/Reverse.h	/^template<typename PacketScalar> struct reverse_packet_cond<PacketScalar,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::reverse_packet_cond::run	../include/Eigen/src/Core/Reverse.h	/^  static inline PacketScalar run(const PacketScalar& x) { return preverse(x); }$/;"	f	struct:Eigen::internal::reverse_packet_cond	access:public	signature:(const PacketScalar& x)
Eigen::internal::reverse_packet_cond::run	../include/Eigen/src/Core/Reverse.h	/^  static inline PacketScalar run(const PacketScalar& x) { return x; }$/;"	f	struct:Eigen::internal::reverse_packet_cond	access:public	signature:(const PacketScalar& x)
Eigen::internal::rotation_base_generic_product_selector::Dim	../include/Eigen/src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon383
Eigen::internal::rotation_base_generic_product_selector::Dim	../include/Eigen/src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon384
Eigen::internal::rotation_base_generic_product_selector	../include/Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector< RotationDerived, DiagonalMatrix<Scalar,Dim,MaxDim>, false >$/;"	s	namespace:Eigen::internal
Eigen::internal::rotation_base_generic_product_selector	../include/Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,MatrixType,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::rotation_base_generic_product_selector	../include/Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,OtherVectorType,true>$/;"	s	namespace:Eigen::internal
Eigen::internal::rotation_base_generic_product_selector::ReturnType	../include/Eigen/src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,1> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector	access:public
Eigen::internal::rotation_base_generic_product_selector::ReturnType	../include/Eigen/src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,Dim> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector	access:public
Eigen::internal::rotation_base_generic_product_selector::ReturnType	../include/Eigen/src/Geometry/RotationBase.h	/^  typedef Transform<Scalar,Dim,Affine> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector	access:public
Eigen::internal::rotation_base_generic_product_selector::run	../include/Eigen/src/Geometry/RotationBase.h	/^  static EIGEN_STRONG_INLINE ReturnType run(const RotationDerived& r, const OtherVectorType& v)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector	access:public	signature:(const RotationDerived& r, const OtherVectorType& v)
Eigen::internal::rotation_base_generic_product_selector::run	../include/Eigen/src/Geometry/RotationBase.h	/^  static inline ReturnType run(const RotationDerived& r, const DiagonalMatrix<Scalar,Dim,MaxDim>& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector	access:public	signature:(const RotationDerived& r, const DiagonalMatrix<Scalar,Dim,MaxDim>& m)
Eigen::internal::rotation_base_generic_product_selector::run	../include/Eigen/src/Geometry/RotationBase.h	/^  static inline ReturnType run(const RotationDerived& r, const MatrixType& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector	access:public	signature:(const RotationDerived& r, const MatrixType& m)
Eigen::internal::scalar_abs2_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_abs2_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_abs2_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return internal::abs2(a); }$/;"	f	struct:Eigen::internal::scalar_abs2_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_abs2_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs2_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_abs2_op::result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs2_op	access:public
Eigen::internal::scalar_abs_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_abs_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_abs_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return internal::abs(a); }$/;"	f	struct:Eigen::internal::scalar_abs_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_abs_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_abs_op::result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs_op	access:public
Eigen::internal::scalar_acos_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_acos_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_acos_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::acos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_acos_op::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_acos_op	access:public
Eigen::internal::scalar_acos_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pacos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_add_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_add_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_add_op::m_other	../include/Eigen/src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_add_op	access:public
Eigen::internal::scalar_add_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a + m_other; }$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_add_op::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_add_op	access:public
Eigen::internal::scalar_add_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_add_op::scalar_add_op	../include/Eigen/src/Core/Functors.h	/^  inline scalar_add_op(const scalar_add_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const scalar_add_op& other)
Eigen::internal::scalar_add_op::scalar_add_op	../include/Eigen/src/Core/Functors.h	/^  inline scalar_add_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const Scalar& other)
Eigen::internal::scalar_asin_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_asin_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_asin_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::asin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_asin_op::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_asin_op	access:public
Eigen::internal::scalar_asin_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pasin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_binary_pow_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar, typename OtherScalar> struct scalar_binary_pow_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_binary_pow_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a, const OtherScalar& b) const { return internal::pow(a, b); }$/;"	f	struct:Eigen::internal::scalar_binary_pow_op	access:public	signature:(const Scalar& a, const OtherScalar& b) const
Eigen::internal::scalar_boolean_and_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_boolean_and_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_boolean_and_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a && b; }$/;"	f	struct:Eigen::internal::scalar_boolean_and_op	access:public	signature:(const bool& a, const bool& b) const
Eigen::internal::scalar_boolean_or_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_boolean_or_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_boolean_or_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a || b; }$/;"	f	struct:Eigen::internal::scalar_boolean_or_op	access:public	signature:(const bool& a, const bool& b) const
Eigen::internal::scalar_cast_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_cast_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_cast_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const NewType operator() (const Scalar& a) const { return cast<Scalar, NewType>(a); }$/;"	f	struct:Eigen::internal::scalar_cast_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_cast_op::result_type	../include/Eigen/src/Core/Functors.h	/^  typedef NewType result_type;$/;"	t	struct:Eigen::internal::scalar_cast_op	access:public
Eigen::internal::scalar_conj_product_op::Conj	../include/Eigen/src/Core/Functors.h	/^    Conj = NumTraits<LhsScalar>::IsComplex$/;"	e	enum:Eigen::internal::scalar_conj_product_op::__anon294
Eigen::internal::scalar_conj_product_op	../include/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_conj_product_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_conj_product_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op	access:public	signature:(const LhsScalar& a, const RhsScalar& b) const
Eigen::internal::scalar_conj_product_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_conj_product_op::result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_conj_product_op	access:public
Eigen::internal::scalar_conjugate_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_conjugate_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_conjugate_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return internal::conj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_conjugate_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const { return internal::pconj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_constant_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_constant_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_constant_op::m_other	../include/Eigen/src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_constant_op	access:public
Eigen::internal::scalar_constant_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index, Index = 0) const { return m_other; }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(Index, Index = 0) const
Eigen::internal::scalar_constant_op::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_constant_op	access:public
Eigen::internal::scalar_constant_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index, Index = 0) const { return internal::pset1<Packet>(m_other); }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(Index, Index = 0) const
Eigen::internal::scalar_constant_op::scalar_constant_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(const scalar_constant_op& other)
Eigen::internal::scalar_constant_op::scalar_constant_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_constant_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(const Scalar& other)
Eigen::internal::scalar_cos_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_cos_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_cos_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return internal::cos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_cos_op::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_cos_op	access:public
Eigen::internal::scalar_cos_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pcos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_cube_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_cube_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_cube_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a*a*a; }$/;"	f	struct:Eigen::internal::scalar_cube_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_cube_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_cube_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_difference_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_difference_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_difference_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a - b; }$/;"	f	struct:Eigen::internal::scalar_difference_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_difference_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_difference_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_exp_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_exp_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_exp_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::exp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_exp_op::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_exp_op	access:public
Eigen::internal::scalar_exp_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pexp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_fuzzy_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_fuzzy_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_fuzzy_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_fuzzy_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl {};$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_fuzzy_default_impl::isApprox	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar&)
Eigen::internal::scalar_fuzzy_default_impl::isApprox	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar& prec)
Eigen::internal::scalar_fuzzy_default_impl::isApproxOrLessThan	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar&)
Eigen::internal::scalar_fuzzy_default_impl::isApproxOrLessThan	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar& prec)
Eigen::internal::scalar_fuzzy_default_impl::isMuchSmallerThan	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const OtherScalar& y, const RealScalar& prec)
Eigen::internal::scalar_fuzzy_default_impl::isMuchSmallerThan	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const Scalar&, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar&, const RealScalar&)
Eigen::internal::scalar_fuzzy_default_impl::RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public
Eigen::internal::scalar_fuzzy_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_impl : scalar_fuzzy_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:scalar_fuzzy_default_impl
Eigen::internal::scalar_fuzzy_impl	../include/Eigen/src/Core/MathFunctions.h	/^template<> struct scalar_fuzzy_impl<bool>$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_fuzzy_impl::isApprox	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(bool x, bool y, bool)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl	access:public	signature:(bool x, bool y, bool)
Eigen::internal::scalar_fuzzy_impl::isApproxOrLessThan	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const bool& x, const bool& y, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl	access:public	signature:(const bool& x, const bool& y, const bool&)
Eigen::internal::scalar_fuzzy_impl::isMuchSmallerThan	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const bool& x, const bool&, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl	access:public	signature:(const bool& x, const bool&, const bool&)
Eigen::internal::scalar_fuzzy_impl::RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef bool RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_impl	access:public
Eigen::internal::scalar_hypot_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_hypot_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_hypot_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& _x, const Scalar& _y) const$/;"	f	struct:Eigen::internal::scalar_hypot_op	access:public	signature:(const Scalar& _x, const Scalar& _y) const
Eigen::internal::scalar_identity_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_identity_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_identity_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index row, Index col) const { return row==col ? Scalar(1) : Scalar(0); }$/;"	f	struct:Eigen::internal::scalar_identity_op	access:public	signature:(Index row, Index col) const
Eigen::internal::scalar_imag_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_imag_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_imag_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return internal::imag(a); }$/;"	f	struct:Eigen::internal::scalar_imag_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_imag_op::result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_op	access:public
Eigen::internal::scalar_imag_ref_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_imag_ref_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_imag_ref_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return internal::imag_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_imag_ref_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_imag_ref_op::result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_ref_op	access:public
Eigen::internal::scalar_inverse_mult_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_inverse_mult_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_inverse_mult_op::m_other	../include/Eigen/src/Core/Functors.h	/^  Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_inverse_mult_op	access:public
Eigen::internal::scalar_inverse_mult_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return m_other \/ a; }$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_inverse_mult_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_inverse_mult_op::scalar_inverse_mult_op	../include/Eigen/src/Core/Functors.h	/^  scalar_inverse_mult_op(const Scalar& other) : m_other(other) {}$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op	access:public	signature:(const Scalar& other)
Eigen::internal::scalar_inverse_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_inverse_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_inverse_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return Scalar(1)\/a; }$/;"	f	struct:Eigen::internal::scalar_inverse_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_inverse_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_log_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_log_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_log_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::log(a); }$/;"	f	struct:Eigen::internal::scalar_log_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_log_op::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_log_op	access:public
Eigen::internal::scalar_log_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::plog(a); }$/;"	f	struct:Eigen::internal::scalar_log_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_max_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_max_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_max_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::max; return (max)(a, b); }$/;"	f	struct:Eigen::internal::scalar_max_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_max_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_max_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_max_op::predux	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_max_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_min_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_min_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_min_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::min; return (min)(a, b); }$/;"	f	struct:Eigen::internal::scalar_min_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_min_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_min_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_min_op::predux	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_min_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_multiple2_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_multiple2_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_multiple2_op::m_other	../include/Eigen/src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar2>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_multiple2_op	access:public
Eigen::internal::scalar_multiple2_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar1& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_multiple2_op	access:public	signature:(const Scalar1& a) const
Eigen::internal::scalar_multiple2_op::result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<Scalar1,Scalar2>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_multiple2_op	access:public
Eigen::internal::scalar_multiple2_op::scalar_multiple2_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple2_op(const Scalar2& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_multiple2_op	access:public	signature:(const Scalar2& other)
Eigen::internal::scalar_multiple2_op::scalar_multiple2_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple2_op(const scalar_multiple2_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_multiple2_op	access:public	signature:(const scalar_multiple2_op& other)
Eigen::internal::scalar_multiple_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_multiple_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_multiple_op::m_other	../include/Eigen/src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_multiple_op	access:public
Eigen::internal::scalar_multiple_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_multiple_op::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_multiple_op	access:public
Eigen::internal::scalar_multiple_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_multiple_op::scalar_multiple_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple_op(const scalar_multiple_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const scalar_multiple_op& other)
Eigen::internal::scalar_multiple_op::scalar_multiple_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const Scalar& other)
Eigen::internal::scalar_opposite_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_opposite_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_opposite_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return -a; }$/;"	f	struct:Eigen::internal::scalar_opposite_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_opposite_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_opposite_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_pow_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_pow_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_pow_op::m_exponent	../include/Eigen/src/Core/Functors.h	/^  const Scalar m_exponent;$/;"	m	struct:Eigen::internal::scalar_pow_op	access:public
Eigen::internal::scalar_pow_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return internal::pow(a, m_exponent); }$/;"	f	struct:Eigen::internal::scalar_pow_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_pow_op::scalar_pow_op	../include/Eigen/src/Core/Functors.h	/^  inline scalar_pow_op(const Scalar& exponent) : m_exponent(exponent) {}$/;"	f	struct:Eigen::internal::scalar_pow_op	access:public	signature:(const Scalar& exponent)
Eigen::internal::scalar_pow_op::scalar_pow_op	../include/Eigen/src/Core/Functors.h	/^  inline scalar_pow_op(const scalar_pow_op& other) : m_exponent(other.m_exponent) { }$/;"	f	struct:Eigen::internal::scalar_pow_op	access:public	signature:(const scalar_pow_op& other)
Eigen::internal::scalar_product_op	../include/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_product_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_product_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a * b; }$/;"	f	struct:Eigen::internal::scalar_product_op	access:public	signature:(const LhsScalar& a, const RhsScalar& b) const
Eigen::internal::scalar_product_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_product_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_product_op::predux	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_product_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_product_op::result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_product_op	access:public
Eigen::internal::scalar_product_op::Vectorizable	../include/Eigen/src/Core/Functors.h	/^    Vectorizable = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasMul && packet_traits<RhsScalar>::HasMul$/;"	e	enum:Eigen::internal::scalar_product_op::__anon292
Eigen::internal::scalar_quotient1_impl	../include/Eigen/src/Core/Functors.h	/^struct scalar_quotient1_impl<Scalar,true> {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_quotient1_impl	../include/Eigen/src/Core/Functors.h	/^struct scalar_quotient1_impl {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_quotient1_impl::m_other	../include/Eigen/src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_quotient1_impl	access:public
Eigen::internal::scalar_quotient1_impl::m_other	../include/Eigen/src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_quotient1_impl	access:public
Eigen::internal::scalar_quotient1_impl::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_quotient1_impl	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_quotient1_impl::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a \/ m_other; }$/;"	f	struct:Eigen::internal::scalar_quotient1_impl	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_quotient1_impl::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_quotient1_impl	access:public
Eigen::internal::scalar_quotient1_impl::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_quotient1_impl	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_quotient1_impl::scalar_quotient1_impl	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_impl(const Scalar& other) : m_other(other) {}$/;"	f	struct:Eigen::internal::scalar_quotient1_impl	access:public	signature:(const Scalar& other)
Eigen::internal::scalar_quotient1_impl::scalar_quotient1_impl	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_impl(const Scalar& other) : m_other(static_cast<Scalar>(1) \/ other) {}$/;"	f	struct:Eigen::internal::scalar_quotient1_impl	access:public	signature:(const Scalar& other)
Eigen::internal::scalar_quotient1_impl::scalar_quotient1_impl	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_impl(const scalar_quotient1_impl& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_quotient1_impl	access:public	signature:(const scalar_quotient1_impl& other)
Eigen::internal::scalar_quotient1_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_quotient1_op : scalar_quotient1_impl<Scalar, NumTraits<Scalar>::IsInteger > {$/;"	s	namespace:Eigen::internal	inherits:scalar_quotient1_impl
Eigen::internal::scalar_quotient1_op::scalar_quotient1_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_op(const Scalar& other)$/;"	f	struct:Eigen::internal::scalar_quotient1_op	access:public	signature:(const Scalar& other)
Eigen::internal::scalar_quotient_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_quotient_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_quotient_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a \/ b; }$/;"	f	struct:Eigen::internal::scalar_quotient_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_quotient_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_quotient_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_random_op	../include/Eigen/src/Core/Random.h	/^template<typename Scalar> struct scalar_random_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_random_op::operator ()	../include/Eigen/src/Core/Random.h	/^  inline const Scalar operator() (Index, Index = 0) const { return random<Scalar>(); }$/;"	f	struct:Eigen::internal::scalar_random_op	access:public	signature:(Index, Index = 0) const
Eigen::internal::scalar_real_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_real_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_real_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return internal::real(a); }$/;"	f	struct:Eigen::internal::scalar_real_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_real_op::result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_op	access:public
Eigen::internal::scalar_real_ref_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_real_ref_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_real_ref_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return internal::real_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_real_ref_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_real_ref_op::result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_ref_op	access:public
Eigen::internal::scalar_sin_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_sin_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_sin_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::sin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_sin_op::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_sin_op	access:public
Eigen::internal::scalar_sin_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::psin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_sqrt_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_sqrt_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_sqrt_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::sqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_sqrt_op::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_sqrt_op	access:public
Eigen::internal::scalar_sqrt_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::psqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_square_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_square_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_square_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a*a; }$/;"	f	struct:Eigen::internal::scalar_square_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_square_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_square_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_sum_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_sum_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_sum_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }$/;"	f	struct:Eigen::internal::scalar_sum_op	access:public	signature:(const Scalar& a, const Scalar& b) const
Eigen::internal::scalar_sum_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_sum_op	access:public	signature:(const Packet& a, const Packet& b) const
Eigen::internal::scalar_sum_op::predux	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_sum_op	access:public	signature:(const Packet& a) const
Eigen::internal::scalar_tan_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_tan_op {$/;"	s	namespace:Eigen::internal
Eigen::internal::scalar_tan_op::operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::tan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op	access:public	signature:(const Scalar& a) const
Eigen::internal::scalar_tan_op::Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_tan_op	access:public
Eigen::internal::scalar_tan_op::packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::ptan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op	access:public	signature:(const Packet& a) const
Eigen::internal::SDP_IsDiagonal	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon36
Eigen::internal::SDP_IsSparseColMajor	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon36
Eigen::internal::SDP_IsSparseRowMajor	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon36
Eigen::internal::selfadjoint_matrix_vector_product	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct selfadjoint_matrix_vector_product$/;"	s	namespace:Eigen::internal
Eigen::internal::selfadjoint_matrix_vector_product::run	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::selfadjoint_matrix_vector_product	access:public	signature:( Index size, const Scalar* lhs, Index lhsStride, const Scalar* _rhs, Index rhsIncr, Scalar* res, Scalar alpha)
Eigen::internal::selfadjoint_matrix_vector_product_symv	../include/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^struct selfadjoint_matrix_vector_product_symv :$/;"	s	namespace:Eigen::internal	inherits:selfadjoint_matrix_vector_product
Eigen::internal::selfadjoint_rank2_update_selector	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Lower>$/;"	s	namespace:Eigen::internal
Eigen::internal::selfadjoint_rank2_update_selector	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Upper>$/;"	s	namespace:Eigen::internal
Eigen::internal::selfadjoint_rank2_update_selector::run	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^  static void run(Scalar* mat, Index stride, const UType& u, const VType& v, Scalar alpha)$/;"	f	struct:Eigen::internal::selfadjoint_rank2_update_selector	access:public	signature:(Scalar* mat, Index stride, const UType& u, const VType& v, Scalar alpha)
Eigen::internal::set_from_triplets	../include/Eigen/src/SparseCore/SparseMatrix.h	/^void set_from_triplets(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, int Options = 0)$/;"	f	namespace:Eigen::internal	signature:(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, int Options = 0)
Eigen::internal::setIdentity_impl	../include/Eigen/src/Core/CwiseNullaryOp.h	/^struct setIdentity_impl<Derived, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::setIdentity_impl::Index	../include/Eigen/src/Core/CwiseNullaryOp.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::setIdentity_impl	access:public
Eigen::internal::setIdentity_impl::run	../include/Eigen/src/Core/CwiseNullaryOp.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& m)$/;"	f	struct:Eigen::internal::setIdentity_impl	access:public	signature:(Derived& m)
Eigen::internal::set_is_malloc_allowed	../include/Eigen/src/Core/util/Memory.h	/^inline bool set_is_malloc_allowed(bool new_value) { return is_malloc_allowed_impl(true, new_value); }$/;"	f	namespace:Eigen::internal	signature:(bool new_value)
Eigen::internal::significant_decimals_default_impl	../include/Eigen/src/Core/IO.h	/^struct significant_decimals_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::significant_decimals_default_impl	../include/Eigen/src/Core/IO.h	/^struct significant_decimals_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::significant_decimals_default_impl::RealScalar	../include/Eigen/src/Core/IO.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::significant_decimals_default_impl	access:public
Eigen::internal::significant_decimals_default_impl::run	../include/Eigen/src/Core/IO.h	/^  static inline int run()$/;"	f	struct:Eigen::internal::significant_decimals_default_impl	access:public	signature:()
Eigen::internal::significant_decimals_impl	../include/Eigen/src/Core/IO.h	/^struct significant_decimals_impl$/;"	s	namespace:Eigen::internal	inherits:significant_decimals_default_impl
Eigen::internal::smart_copy_helper	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,false> {$/;"	s	namespace:Eigen::internal
Eigen::internal::smart_copy_helper	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,true> {$/;"	s	namespace:Eigen::internal
Eigen::internal::smart_copy_helper::run	../include/Eigen/src/Core/util/Memory.h	/^  static inline void run(const T* start, const T* end, T* target)$/;"	f	struct:Eigen::internal::smart_copy_helper	access:public	signature:(const T* start, const T* end, T* target)
Eigen::internal::smart_copy	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> void smart_copy(const T* start, const T* end, T* target)$/;"	f	namespace:Eigen::internal	signature:(const T* start, const T* end, T* target)
Eigen::internal::solve_retval_base::Base	../include/Eigen/src/misc/Solve.h	/^  typedef ReturnByValue<solve_retval_base> Base;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
Eigen::internal::solve_retval_base::cols	../include/Eigen/src/misc/Solve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
Eigen::internal::solve_retval_base::dec	../include/Eigen/src/misc/Solve.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
Eigen::internal::solve_retval_base::DecompositionType	../include/Eigen/src/misc/Solve.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
Eigen::internal::solve_retval_base::evalTo	../include/Eigen/src/misc/Solve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval_base	../include/Eigen/src/misc/Solve.h	/^template<typename _DecompositionType, typename Rhs> struct solve_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::solve_retval_base::Index	../include/Eigen/src/misc/Solve.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
Eigen::internal::solve_retval_base::m_dec	../include/Eigen/src/misc/Solve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::solve_retval_base	access:protected
Eigen::internal::solve_retval_base::m_rhs	../include/Eigen/src/misc/Solve.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::solve_retval_base	access:protected
Eigen::internal::solve_retval_base::rhs	../include/Eigen/src/misc/Solve.h	/^  inline const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
Eigen::internal::solve_retval_base::RhsNestedCleaned	../include/Eigen/src/misc/Solve.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
Eigen::internal::solve_retval_base::rows	../include/Eigen/src/misc/Solve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
Eigen::internal::solve_retval_base::solve_retval_base	../include/Eigen/src/misc/Solve.h	/^  solve_retval_base(const DecompositionType& dec, const Rhs& rhs)$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:(const DecompositionType& dec, const Rhs& rhs)
Eigen::internal::solve_retval::Dec	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  typedef CholmodBase<_MatrixType,_UpLo,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^  typedef DiagonalPreconditioner<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef BiCGSTAB<_MatrixType, _Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^  typedef IncompleteLUT<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  typedef PardisoImpl<_Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  typedef PastixBase<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SimplicialCholeskyBase<Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef SuperLUBase<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::Dec	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  typedef UmfPackLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/Cholesky/LDLT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/Cholesky/LLT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/LU/PartialPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/QR/HouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/SVD/JacobiSVD.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval::evalTo	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval	../include/Eigen/src/Cholesky/LDLT.h	/^struct solve_retval<LDLT<_MatrixType,_UpLo>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/Cholesky/LLT.h	/^struct solve_retval<LLT<_MatrixType, UpLo>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^struct solve_retval<CholmodBase<_MatrixType,_UpLo,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^struct solve_retval<DiagonalPreconditioner<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^struct solve_retval<BiCGSTAB<_MatrixType, _Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^struct solve_retval<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^struct solve_retval<IncompleteLUT<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/LU/FullPivLU.h	/^struct solve_retval<FullPivLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/LU/PartialPivLU.h	/^struct solve_retval<PartialPivLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^struct solve_retval<PardisoImpl<_Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^struct solve_retval<PastixBase<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^struct solve_retval<ColPivHouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^struct solve_retval<FullPivHouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/QR/HouseholderQR.h	/^struct solve_retval<HouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^struct solve_retval<SimplicialCholeskyBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct solve_retval<SuperLUBase<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/SVD/JacobiSVD.h	/^struct solve_retval<JacobiSVD<_MatrixType, QRPreconditioner>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^struct solve_retval<UmfPackLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
Eigen::internal::solve_retval::JacobiSVDType	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<_MatrixType, QRPreconditioner> JacobiSVDType;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::LDLTType	../include/Eigen/src/Cholesky/LDLT.h	/^  typedef LDLT<_MatrixType,_UpLo> LDLTType;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval::LLTType	../include/Eigen/src/Cholesky/LLT.h	/^  typedef LLT<_MatrixType,UpLo> LLTType;$/;"	t	struct:Eigen::internal::solve_retval	access:public
Eigen::internal::solve_retval_with_guess::cols	../include/Eigen/src/misc/SparseSolve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:() const
Eigen::internal::solve_retval_with_guess::evalTo	../include/Eigen/src/misc/SparseSolve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:(Dest& dst) const
Eigen::internal::solve_retval_with_guess	../include/Eigen/src/misc/SparseSolve.h	/^template<typename DecompositionType, typename Rhs, typename Guess> struct solve_retval_with_guess$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::solve_retval_with_guess::Index	../include/Eigen/src/misc/SparseSolve.h	/^  typedef typename DecompositionType::Index Index;$/;"	t	struct:Eigen::internal::solve_retval_with_guess	access:public
Eigen::internal::solve_retval_with_guess::m_dec	../include/Eigen/src/misc/SparseSolve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::solve_retval_with_guess	access:protected
Eigen::internal::solve_retval_with_guess::m_guess	../include/Eigen/src/misc/SparseSolve.h	/^    const typename Guess::Nested m_guess;$/;"	m	struct:Eigen::internal::solve_retval_with_guess	access:protected
Eigen::internal::solve_retval_with_guess::m_rhs	../include/Eigen/src/misc/SparseSolve.h	/^    const typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::solve_retval_with_guess	access:protected
Eigen::internal::solve_retval_with_guess::rows	../include/Eigen/src/misc/SparseSolve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:() const
Eigen::internal::solve_retval_with_guess::solve_retval_with_guess	../include/Eigen/src/misc/SparseSolve.h	/^  solve_retval_with_guess(const DecompositionType& dec, const Rhs& rhs, const Guess& guess)$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:(const DecompositionType& dec, const Rhs& rhs, const Guess& guess)
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::BinaryFunc	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef scalar_product_op<T> BinaryFunc;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::col	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return Lhs::IsRowMajor ? index() : m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::col	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::col	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_rhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::CwiseBinaryXpr	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryFunc, Lhs, Rhs> CwiseBinaryXpr;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::CwiseBinaryXpr	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> CwiseBinaryXpr;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<BinaryOp, Lhs, Rhs, Derived, Sparse, Sparse>$/;"	c	namespace:Eigen::internal
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Dense, Sparse>$/;"	c	namespace:Eigen::internal
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Sparse, Dense>$/;"	c	namespace:Eigen::internal
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Sparse, Sparse>$/;"	c	namespace:Eigen::internal
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::index	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_id; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::index	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_lhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::index	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_rhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::Index	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::IsRowMajor	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Lhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::__anon23
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::IsRowMajor	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Rhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::__anon24
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::LhsIterator	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename _LhsNested::InnerIterator LhsIterator;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::_LhsNested	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::_LhsNested _LhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_functor	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryFunc m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_functor	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryFunc& m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_functor	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_id	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Index m_id;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_lhsIter	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    LhsIterator m_lhsIter;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_outer	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const Index m_outer;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_rhs	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_rhsIter	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsIterator m_rhsIter;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_value	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Scalar m_value;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::m_xpr	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const CwiseBinaryXpr& m_xpr;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::operator bool	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_id>=0; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::operator bool	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_lhsIter; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::operator bool	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return (m_lhsIter && m_rhsIter); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::operator bool	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_rhsIter; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::operator ++	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Derived& operator++()$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:()
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::RhsIterator	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename _RhsNested::InnerIterator RhsIterator;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::_RhsNested	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::_RhsNested _RhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::RhsNested	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::RhsNested RhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::row	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return Lhs::IsRowMajor ? m_lhsIter.row() : index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::row	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_lhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::row	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_rhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::Scalar	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename CwiseBinaryXpr::Scalar Scalar;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::Scalar	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::Scalar Scalar;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::sparse_cwise_binary_op_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE sparse_cwise_binary_op_inner_iterator_selector(const CwiseBinaryXpr& xpr, Index outer)$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:(const CwiseBinaryXpr& xpr, Index outer)
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::value	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::value	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_functor(m_lhsIter.value(), m_rhsIter.value()); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::value	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_value; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::Base	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      Transpose<const typename Rhs::DiagonalVectorType> >::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::Base	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename CwiseUnaryOp<scalar_multiple_op<typename Lhs::Scalar>,const Rhs>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::Base	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename CwiseUnaryOp<scalar_multiple_op<typename Rhs::Scalar>,const Lhs>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::Base	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      typename Lhs::DiagonalVectorType>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Eigen::internal::sparse_diagonal_product_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^class sparse_diagonal_product_inner_iterator_selector$/;"	c	namespace:Eigen::internal	inherits:CwiseBinaryOp::InnerIterator
Eigen::internal::sparse_diagonal_product_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^class sparse_diagonal_product_inner_iterator_selector$/;"	c	namespace:Eigen::internal	inherits:CwiseUnaryOp::InnerIterator
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::Index	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Eigen::internal::sparse_diagonal_product_inner_iterator_selector::sparse_diagonal_product_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline sparse_diagonal_product_inner_iterator_selector($/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:public	signature:( const SparseDiagonalProductType& expr, Index outer)
Eigen::internal::sparse_eval::_Flags	../include/Eigen/src/SparseCore/SparseUtil.h	/^    enum { _Flags = traits<T>::Flags };$/;"	e	enum:Eigen::internal::sparse_eval::__anon13
Eigen::internal::sparse_eval::_Flags	../include/Eigen/src/SparseCore/SparseUtil.h	/^    enum { _Flags = traits<T>::Flags| RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_eval::__anon11
Eigen::internal::sparse_eval::_Flags	../include/Eigen/src/SparseCore/SparseUtil.h	/^    enum { _Flags = traits<T>::Flags & (~RowMajorBit) };$/;"	e	enum:Eigen::internal::sparse_eval::__anon12
Eigen::internal::sparse_eval	../include/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Cols> struct sparse_eval<T,1,Cols> {$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_eval	../include/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Rows,int Cols> struct sparse_eval {$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_eval	../include/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Rows> struct sparse_eval<T,Rows,1> {$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_eval	../include/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct sparse_eval<T,1,1> {$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_eval::_Scalar	../include/Eigen/src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
Eigen::internal::sparse_eval::type	../include/Eigen/src/SparseCore/SparseUtil.h	/^    typedef Matrix<_Scalar, 1, 1> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
Eigen::internal::sparse_eval::type	../include/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Flags> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
Eigen::internal::sparse_eval::type	../include/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, _Flags> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
Eigen::internal::sparse_solve_retval_base::Base	../include/Eigen/src/misc/SparseSolve.h	/^  typedef ReturnByValue<sparse_solve_retval_base> Base;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
Eigen::internal::sparse_solve_retval_base::cols	../include/Eigen/src/misc/SparseSolve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
Eigen::internal::sparse_solve_retval_base::dec	../include/Eigen/src/misc/SparseSolve.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
Eigen::internal::sparse_solve_retval_base::DecompositionType	../include/Eigen/src/misc/SparseSolve.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
Eigen::internal::sparse_solve_retval_base::evalTo	../include/Eigen/src/misc/SparseSolve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval_base	../include/Eigen/src/misc/SparseSolve.h	/^template<typename _DecompositionType, typename Rhs> struct sparse_solve_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::sparse_solve_retval_base::Index	../include/Eigen/src/misc/SparseSolve.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
Eigen::internal::sparse_solve_retval_base::m_dec	../include/Eigen/src/misc/SparseSolve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::sparse_solve_retval_base	access:protected
Eigen::internal::sparse_solve_retval_base::m_rhs	../include/Eigen/src/misc/SparseSolve.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::sparse_solve_retval_base	access:protected
Eigen::internal::sparse_solve_retval_base::rhs	../include/Eigen/src/misc/SparseSolve.h	/^  inline const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
Eigen::internal::sparse_solve_retval_base::RhsNestedCleaned	../include/Eigen/src/misc/SparseSolve.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
Eigen::internal::sparse_solve_retval_base::rows	../include/Eigen/src/misc/SparseSolve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
Eigen::internal::sparse_solve_retval_base::sparse_solve_retval_base	../include/Eigen/src/misc/SparseSolve.h	/^  sparse_solve_retval_base(const DecompositionType& dec, const Rhs& rhs)$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:(const DecompositionType& dec, const Rhs& rhs)
Eigen::internal::sparse_solve_retval::Dec	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  typedef CholmodBase<_MatrixType,_UpLo,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef IterativeSolverBase<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  typedef PardisoImpl<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  typedef PastixBase<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SimplicialCholeskyBase<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef SuperLUBase<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::Dec	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  typedef UmfPackLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval	access:public
Eigen::internal::sparse_solve_retval::evalTo	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval::evalTo	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::sparse_solve_retval	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^struct sparse_solve_retval<CholmodBase<_MatrixType,_UpLo,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^struct sparse_solve_retval<IterativeSolverBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^struct sparse_solve_retval<PardisoImpl<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^struct sparse_solve_retval<PastixBase<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^struct sparse_solve_retval<SimplicialCholeskyBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct sparse_solve_retval<SuperLUBase<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_retval	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^struct sparse_solve_retval<UmfPackLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
Eigen::internal::sparse_solve_triangular_selector	../include/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_solve_triangular_selector	../include/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_solve_triangular_selector	../include/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_solve_triangular_selector	../include/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_solve_triangular_selector::run	../include/Eigen/src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_selector	access:public	signature:(const Lhs& lhs, Rhs& other)
Eigen::internal::sparse_solve_triangular_selector::Scalar	../include/Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_selector	access:public
Eigen::internal::sparse_solve_triangular_sparse_selector	../include/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_sparse_selector<Lhs,Rhs,Mode,UpLo,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_solve_triangular_sparse_selector::Index	../include/Eigen/src/SparseCore/TriangularSolver.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector	access:public
Eigen::internal::sparse_solve_triangular_sparse_selector::run	../include/Eigen/src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_sparse_selector	access:public	signature:(const Lhs& lhs, Rhs& other)
Eigen::internal::sparse_solve_triangular_sparse_selector::Scalar	../include/Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector	access:public
Eigen::internal::sparse_sparse_product_with_pruning_impl	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^static void sparse_sparse_product_with_pruning_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res, typename ResultType::RealScalar tolerance)$/;"	f	namespace:Eigen::internal	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res, typename ResultType::RealScalar tolerance)
Eigen::internal::sparse_sparse_product_with_pruning_selector	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_sparse_product_with_pruning_selector	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_sparse_product_with_pruning_selector	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_sparse_product_with_pruning_selector	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_sparse_product_with_pruning_selector::RealScalar	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename ResultType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector	access:public
Eigen::internal::sparse_sparse_product_with_pruning_selector::run	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res, RealScalar tolerance)$/;"	f	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector	access:public	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res, RealScalar tolerance)
Eigen::internal::sparse_sparse_product_with_pruning_selector::Scalar	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector	access:public
Eigen::internal::sparse_time_dense_product_impl	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, ColMajor, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_time_dense_product_impl	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, ColMajor, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_time_dense_product_impl	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, RowMajor, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_time_dense_product_impl	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, RowMajor, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::sparse_time_dense_product_impl::Index	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
Eigen::internal::sparse_time_dense_product_impl::Lhs	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<SparseLhsType>::type Lhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
Eigen::internal::sparse_time_dense_product_impl::LhsInnerIterator	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::InnerIterator LhsInnerIterator;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
Eigen::internal::sparse_time_dense_product_impl::Res	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseResType>::type Res;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
Eigen::internal::sparse_time_dense_product_impl::Rhs	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseRhsType>::type Rhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
Eigen::internal::sparse_time_dense_product_impl::run	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void run(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, typename Res::Scalar alpha)$/;"	f	struct:Eigen::internal::sparse_time_dense_product_impl	access:public	signature:(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, typename Res::Scalar alpha)
Eigen::internal::sparse_time_dense_product	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^inline void sparse_time_dense_product(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)$/;"	f	namespace:Eigen::internal	signature:(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)
Eigen::internal::sqrt_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct sqrt_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::sqrt_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct sqrt_default_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::sqrt_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar&)$/;"	f	struct:Eigen::internal::sqrt_default_impl	access:public	signature:(const Scalar&)
Eigen::internal::sqrt_default_impl::run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::sqrt_default_impl	access:public	signature:(const Scalar& x)
Eigen::internal::sqrt_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct sqrt_impl : sqrt_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:sqrt_default_impl
Eigen::internal::sqrt	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(sqrt, Scalar) sqrt(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
Eigen::internal::sqrt_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct sqrt_retval$/;"	s	namespace:Eigen::internal
Eigen::internal::sqrt_retval::type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::sqrt_retval	access:public
Eigen::internal::stable_norm_kernel	../include/Eigen/src/Core/StableNorm.h	/^inline void stable_norm_kernel(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)$/;"	f	namespace:Eigen::internal	signature:(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)
Eigen::internal::static_assertion::BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER	../include/Eigen/src/Core/util/StaticAssert.h	/^        BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED	../include/Eigen/src/Core/util/StaticAssert.h	/^        COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE	../include/Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT	../include/Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED	../include/Eigen/src/Core/util/StaticAssert.h	/^        FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion	../include/Eigen/src/Core/util/StaticAssert.h	/^    struct static_assertion {};$/;"	s	namespace:Eigen::internal
Eigen::internal::static_assertion	../include/Eigen/src/Core/util/StaticAssert.h	/^    struct static_assertion<true>$/;"	s	namespace:Eigen::internal
Eigen::internal::static_assertion::INVALID_MATRIXBASE_TEMPLATE_PARAMETERS	../include/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIXBASE_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION	../include/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::INVALID_MATRIX_PRODUCT	../include/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::INVALID_MATRIX_TEMPLATE_PARAMETERS	../include/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION	../include/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS	../include/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::NUMERIC_TYPE_MUST_BE_REAL	../include/Eigen/src/Core/util/StaticAssert.h	/^        NUMERIC_TYPE_MUST_BE_REAL,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1	../include/Eigen/src/Core/util/StaticAssert.h	/^        PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD	../include/Eigen/src/Core/util/StaticAssert.h	/^        THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE	../include/Eigen/src/Core/util/StaticAssert.h	/^        THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE	../include/Eigen/src/Core/util/StaticAssert.h	/^        THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH	../include/Eigen/src/Core/util/StaticAssert.h	/^        THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC	../include/Eigen/src/Core/util/StaticAssert.h	/^        UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED	../include/Eigen/src/Core/util/StaticAssert.h	/^        WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_ALREADY_SPECIFIED_THIS_STRIDE	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_ALREADY_SPECIFIED_THIS_STRIDE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_CANNOT_MIX_ARRAYS_AND_MATRICES	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_CANNOT_MIX_ARRAYS_AND_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_MADE_A_PROGRAMMING_MISTAKE	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::static_assertion::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
Eigen::internal::stem_function::ComplexScalar	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^  typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	struct:Eigen::internal::stem_function	access:public
Eigen::internal::stem_function	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^struct stem_function$/;"	s	namespace:Eigen::internal
Eigen::internal::stem_function::type	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^  typedef ComplexScalar type(ComplexScalar, int);$/;"	t	struct:Eigen::internal::stem_function	access:public
Eigen::internal::svd_precondition_2x2_block_to_be_real	../include/Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::svd_precondition_2x2_block_to_be_real	../include/Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>$/;"	s	namespace:Eigen::internal
Eigen::internal::svd_precondition_2x2_block_to_be_real	../include/Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real {};$/;"	s	namespace:Eigen::internal
Eigen::internal::svd_precondition_2x2_block_to_be_real::Index	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename SVD::Index Index;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
Eigen::internal::svd_precondition_2x2_block_to_be_real::RealScalar	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
Eigen::internal::svd_precondition_2x2_block_to_be_real::run	../include/Eigen/src/SVD/JacobiSVD.h	/^  static void run(typename SVD::WorkMatrixType&, SVD&, Index, Index) {}$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public	signature:(typename SVD::WorkMatrixType&, SVD&, Index, Index)
Eigen::internal::svd_precondition_2x2_block_to_be_real::run	../include/Eigen/src/SVD/JacobiSVD.h	/^  static void run(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q)$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public	signature:(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q)
Eigen::internal::svd_precondition_2x2_block_to_be_real::Scalar	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
Eigen::internal::svd_precondition_2x2_block_to_be_real::SVD	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<MatrixType, QRPreconditioner> SVD;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
Eigen::internal::symm_pack_lhs	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_lhs$/;"	s	namespace:Eigen::internal
Eigen::internal::symm_pack_lhs::operator ()	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)$/;"	f	struct:Eigen::internal::symm_pack_lhs	access:public	signature:(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)
Eigen::internal::symm_pack_lhs::pack	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void pack(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)$/;"	f	struct:Eigen::internal::symm_pack_lhs	access:public	signature:(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)
Eigen::internal::symm_pack_rhs	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_rhs$/;"	s	namespace:Eigen::internal
Eigen::internal::symm_pack_rhs::operator ()	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)$/;"	f	struct:Eigen::internal::symm_pack_rhs	access:public	signature:(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)
Eigen::internal::symm_pack_rhs::PacketSize	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::symm_pack_rhs::__anon111
Eigen::internal::take_matrix_for_product	../include/Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product$/;"	s	namespace:Eigen::internal
Eigen::internal::take_matrix_for_product	../include/Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Mode, Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::take_matrix_for_product	../include/Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Projective, Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::take_matrix_for_product::run	../include/Eigen/src/Geometry/Homogeneous.h	/^  static const type& run (const TransformType& x) { return x.matrix(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product	access:public	signature:(const TransformType& x)
Eigen::internal::take_matrix_for_product::run	../include/Eigen/src/Geometry/Homogeneous.h	/^  static const type& run(const type &x) { return x; }$/;"	f	struct:Eigen::internal::take_matrix_for_product	access:public	signature:(const type &x)
Eigen::internal::take_matrix_for_product::run	../include/Eigen/src/Geometry/Homogeneous.h	/^  static type run (const TransformType& x) { return x.affine(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product	access:public	signature:(const TransformType& x)
Eigen::internal::take_matrix_for_product::TransformType	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Mode, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
Eigen::internal::take_matrix_for_product::TransformType	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Projective, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
Eigen::internal::take_matrix_for_product::type	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef MatrixOrTransformType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
Eigen::internal::take_matrix_for_product::type	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename internal::add_const<typename TransformType::ConstAffinePart>::type type;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
Eigen::internal::take_matrix_for_product::type	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename TransformType::MatrixType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
Eigen::internal::throw_std_bad_alloc	../include/Eigen/src/Core/util/Memory.h	/^inline void throw_std_bad_alloc()$/;"	f	namespace:Eigen::internal	signature:()
Eigen::internal::toRotationMatrix	../include/Eigen/src/Geometry/RotationBase.h	/^static inline const MatrixBase<OtherDerived>& toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<OtherDerived>& mat)
Eigen::internal::toRotationMatrix	../include/Eigen/src/Geometry/RotationBase.h	/^static inline Matrix<Scalar,2,2> toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& s)
Eigen::internal::toRotationMatrix	../include/Eigen/src/Geometry/RotationBase.h	/^static inline Matrix<Scalar,Dim,Dim> toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen::internal	signature:(const RotationBase<OtherDerived,Dim>& r)
Eigen::internal::traits::AbsDiagIndex	../include/Eigen/src/Core/Diagonal.h	/^    AbsDiagIndex = DiagIndex<0 ? -DiagIndex : DiagIndex, \/\/ only used if DiagIndex != Dynamic$/;"	e	enum:Eigen::internal::traits::__anon148
Eigen::internal::traits::Ancestor	../include/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_all<Lhs>::type Ancestor;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CanVectorizeInner	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeInner =    SameType$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::CanVectorizeLhs	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeLhs = (!LhsRowMajor) && (LhsFlags & PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::CanVectorizeRhs	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeRhs = RhsRowMajor && (RhsFlags & PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::CholMatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index>                   CholMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CholMatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index>               CholMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Coefficients	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef Map<const Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Coefficients	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef Map<Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Coefficients	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<_Scalar,4,1,_Options> Coefficients;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CoefficientsType	../include/Eigen/src/Core/BandMatrix.h	/^  typedef _CoefficientsType CoefficientsType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CoefficientsType	../include/Eigen/src/Core/BandMatrix.h	/^  typedef Matrix<Scalar,DataRowsAtCompileTime,ColsAtCompileTime,Options&RowMajor?RowMajor:ColMajor> CoefficientsType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/BandMatrix.h	/^    CoeffReadCost = internal::traits<_CoefficientsType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon82
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/BandMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon81
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    CoeffReadCost = LhsCoeffReadCost + RhsCoeffReadCost + functor_traits<BinaryOp>::Cost$/;"	e	enum:Eigen::internal::traits::__anon65
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    CoeffReadCost = functor_traits<NullaryOp>::Cost$/;"	e	enum:Eigen::internal::traits::__anon287
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    CoeffReadCost = _XprTypeNested::CoeffReadCost + functor_traits<UnaryOp>::Cost$/;"	e	enum:Eigen::internal::traits::__anon59
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/CwiseUnaryView.h	/^    CoeffReadCost = traits<_MatrixTypeNested>::CoeffReadCost + functor_traits<ViewOp>::Cost,$/;"	e	enum:Eigen::internal::traits::__anon232
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/DiagonalProduct.h	/^    CoeffReadCost = NumTraits<Scalar>::MulCost + MatrixType::CoeffReadCost + DiagonalType::DiagonalVectorType::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon77
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/Matrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon289
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/PermutationMatrix.h	/^    CoeffReadCost = _IndicesType::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon118
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/ProductBase.h	/^    CoeffReadCost = 0 \/\/ FIXME why is it needed ?$/;"	e	enum:Eigen::internal::traits::__anon288
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CoeffReadCost = InnerSize == Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/Replicate.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon67
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/Reverse.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon115
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/Select.h	/^    CoeffReadCost = traits<typename remove_all<ConditionMatrixNested>::type>::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon60
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/SelfAdjointView.h	/^    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon83
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/Transpose.h	/^    CoeffReadCost = MatrixTypeNestedPlain::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon73
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/TriangularMatrix.h	/^    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon234
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Core/VectorwiseOp.h	/^    CoeffReadCost = TraversalSize * traits<_MatrixTypeNested>::CoeffReadCost + int(CostOpType::value)$/;"	e	enum:Eigen::internal::traits::__anon69
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Eigen2Support/Minor.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost \/\/ minor is used typically on tiny matrices,$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/Geometry/Homogeneous.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon390
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/SparseCore/SparseBlock.h	/^    CoeffReadCost = MatrixType::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon20
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    CoeffReadCost = LhsCoeffReadCost + RhsCoeffReadCost + NumTraits<Scalar>::MulCost$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon35
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost*10$/;"	e	enum:Eigen::internal::traits::__anon32
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon31
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/SparseCore/SparseProduct.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::CoeffReadCost	../include/Eigen/src/SparseCore/SparseVector.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon25
Eigen::internal::traits::colOffset	../include/Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value()>0 ? m_index.value() : 0; }$/;"	f	struct:Eigen::internal::traits	access:public	signature:() const
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon81
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon82
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/Block.h	/^    ColsAtCompileTime = MatrixCols == 0 ? 0 : BlockCols,$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    ColsAtCompileTime = traits<Ancestor>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon64
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^    ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon281
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/DiagonalProduct.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon77
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/Matrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon289
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^    ColsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon118
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/ProductBase.h	/^    ColsAtCompileTime = traits<Rhs>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      ColsAtCompileTime = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/Replicate.h	/^    ColsAtCompileTime = ColFactor==Dynamic || int(MatrixType::ColsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon67
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/Reverse.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon115
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/Select.h	/^    ColsAtCompileTime = ConditionMatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon60
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/Transpose.h	/^    ColsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon73
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/VectorwiseOp.h	/^    ColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon68
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Eigen2Support/Minor.h	/^    ColsAtCompileTime = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Geometry/Homogeneous.h	/^    ColsAtCompileTime = Direction==Horizontal ? ColsPlusOne : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon390
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^    ColsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon7
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseBlock.h	/^    ColsAtCompileTime = IsRowMajor ? MatrixType::ColsAtCompileTime : Size,$/;"	e	enum:Eigen::internal::traits::__anon20
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    ColsAtCompileTime    = Tr ? int(traits<Lhs>::ColsAtCompileTime)     : int(traits<Rhs>::ColsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    ColsAtCompileTime = _Rhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon35
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon32
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon31
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseProduct.h	/^    ColsAtCompileTime    = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseVector.h	/^    ColsAtCompileTime = IsColVector ? 1 : Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon25
Eigen::internal::traits::ColsPlusOne	../include/Eigen/src/Geometry/Homogeneous.h	/^    ColsPlusOne = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon390
Eigen::internal::traits::ConditionMatrixNested	../include/Eigen/src/Core/Select.h	/^  typedef typename ConditionMatrixType::Nested ConditionMatrixNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CostOpType	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::template Cost<InputScalar,int(TraversalSize)> CostOpType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::CostOpType	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::template Cost<InputScalar,TraversalSize> CostOpType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::DataRowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon81
Eigen::internal::traits::DataRowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon82
Eigen::internal::traits::DenseMatrixType	../include/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::DenseMatrixType	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::DiagonalVectorType	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::DiagonalVectorType	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef Matrix<_Scalar,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1> DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ElseMatrixNested	../include/Eigen/src/Core/Select.h	/^  typedef typename ElseMatrixType::Nested ElseMatrixNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::EvalToRowMajor	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      EvalToRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::EvalToRowMajor	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EvalToRowMajor = (RhsFlags & LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::ExpressionType	../include/Eigen/src/Core/SelfAdjointView.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ExpressionType	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Factor	../include/Eigen/src/Core/Replicate.h	/^    Factor = (RowFactor==Dynamic || ColFactor==Dynamic) ? Dynamic : RowFactor*ColFactor$/;"	e	enum:Eigen::internal::traits::__anon66
Eigen::internal::traits::Flags0	../include/Eigen/src/Core/Block.h	/^    Flags0 = traits<XprType>::Flags & ( (HereditaryBits & ~RowMajorBit) |$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::Flags0	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    Flags0 = (int(LhsFlags) | int(RhsFlags)) & ($/;"	e	enum:Eigen::internal::traits::__anon65
Eigen::internal::traits::Flags0	../include/Eigen/src/Core/Map.h	/^    Flags0 = TraitsBase::Flags & (~NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::Flags0	../include/Eigen/src/Core/Transpose.h	/^    Flags0 = MatrixTypeNestedPlain::Flags & ~(LvalueBit | NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon73
Eigen::internal::traits::Flags0	../include/Eigen/src/Core/VectorwiseOp.h	/^    Flags0 = (unsigned int)_MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon68
Eigen::internal::traits::Flags1	../include/Eigen/src/Core/Map.h	/^    Flags1 = IsAligned ? (int(Flags0) | AlignedBit) : (int(Flags0) & ~AlignedBit),$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::Flags1	../include/Eigen/src/Core/Transpose.h	/^    Flags1 = Flags0 | FlagsLvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon73
Eigen::internal::traits::Flags2	../include/Eigen/src/Core/Map.h	/^    Flags2 = (bool(HasNoStride) || bool(PlainObjectType::IsVectorAtCompileTime))$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::Flags3	../include/Eigen/src/Core/Map.h	/^    Flags3 = is_lvalue<PlainObjectType>::value ? int(Flags2) : (int(Flags2) & ~LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::Flags	../include/Eigen/src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon81
Eigen::internal::traits::Flags	../include/Eigen/src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon82
Eigen::internal::traits::Flags	../include/Eigen/src/Core/Block.h	/^    Flags = Flags0 | FlagsLinearAccessBit | FlagsLvalueBit | FlagsRowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::Flags	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon65
Eigen::internal::traits::Flags	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    Flags = (traits<PlainObjectType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon287
Eigen::internal::traits::Flags	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    Flags = _XprTypeNested::Flags & ($/;"	e	enum:Eigen::internal::traits::__anon59
Eigen::internal::traits::Flags	../include/Eigen/src/Core/CwiseUnaryView.h	/^    Flags = (traits<_MatrixTypeNested>::Flags & (HereditaryBits | LvalueBit | LinearAccessBit | DirectAccessBit)),$/;"	e	enum:Eigen::internal::traits::__anon232
Eigen::internal::traits::Flags	../include/Eigen/src/Core/DiagonalMatrix.h	/^    Flags = LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon280
Eigen::internal::traits::Flags	../include/Eigen/src/Core/DiagonalMatrix.h	/^    Flags =  traits<DiagonalVectorType>::Flags & LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon281
Eigen::internal::traits::Flags	../include/Eigen/src/Core/DiagonalProduct.h	/^    Flags = (HereditaryBits & (unsigned int)(MatrixType::Flags)) | (_Vectorizable ? PacketAccessBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon77
Eigen::internal::traits::Flags	../include/Eigen/src/Core/Flagged.h	/^  enum { Flags = (ExpressionType::Flags | Added) & ~Removed };$/;"	e	enum:Eigen::internal::traits::__anon56
Eigen::internal::traits::Flags	../include/Eigen/src/Core/Map.h	/^    Flags = KeepsPacketAccess ? int(Flags3) : (int(Flags3) & ~PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::Flags	../include/Eigen/src/Core/Matrix.h	/^    Flags = compute_matrix_flags<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::ret,$/;"	e	enum:Eigen::internal::traits::__anon289
Eigen::internal::traits::Flags	../include/Eigen/src/Core/PermutationMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon118
Eigen::internal::traits::Flags	../include/Eigen/src/Core/ProductBase.h	/^    Flags = (MaxRowsAtCompileTime==1 ? RowMajorBit : 0)$/;"	e	enum:Eigen::internal::traits::__anon288
Eigen::internal::traits::Flags	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      Flags = ((unsigned int)(LhsFlags | RhsFlags) & HereditaryBits & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::Flags	../include/Eigen/src/Core/Replicate.h	/^    Flags = (_MatrixTypeNested::Flags & HereditaryBits & ~RowMajorBit) | (IsRowMajor ? RowMajorBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon67
Eigen::internal::traits::Flags	../include/Eigen/src/Core/ReturnByValue.h	/^    Flags = (traits<typename traits<Derived>::ReturnType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon58
Eigen::internal::traits::Flags	../include/Eigen/src/Core/Reverse.h	/^    Flags = int(_MatrixTypeNested::Flags) & (HereditaryBits | LvalueBit | PacketAccessBit | LinearAccess),$/;"	e	enum:Eigen::internal::traits::__anon115
Eigen::internal::traits::Flags	../include/Eigen/src/Core/Select.h	/^    Flags = (unsigned int)ThenMatrixType::Flags & ElseMatrixType::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon60
Eigen::internal::traits::Flags	../include/Eigen/src/Core/SelfAdjointView.h	/^    Flags =  MatrixTypeNestedCleaned::Flags & (HereditaryBits)$/;"	e	enum:Eigen::internal::traits::__anon83
Eigen::internal::traits::Flags	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    Flags = traits<CwiseBinaryOp<BinaryOp,Lhs,Rhs> >::Flags | (Lhs::Flags&DirectAccessBit) | (Lhs::Flags&LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon50
Eigen::internal::traits::Flags	../include/Eigen/src/Core/Transpose.h	/^    Flags = Flags1 ^ RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon73
Eigen::internal::traits::Flags	../include/Eigen/src/Core/TriangularMatrix.h	/^    Flags = (MatrixTypeNestedCleaned::Flags & (HereditaryBits) & (~(PacketAccessBit | DirectAccessBit | LinearAccessBit))) | Mode,$/;"	e	enum:Eigen::internal::traits::__anon234
Eigen::internal::traits::Flags	../include/Eigen/src/Core/VectorwiseOp.h	/^    Flags = (Flags0 & ~RowMajorBit) | (RowsAtCompileTime == 1 ? RowMajorBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon68
Eigen::internal::traits::Flags	../include/Eigen/src/Eigen2Support/Minor.h	/^    Flags = _MatrixTypeNested::Flags & (HereditaryBits | LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::Flags	../include/Eigen/src/Geometry/Homogeneous.h	/^    Flags = ColsAtCompileTime==1 ? (TmpFlags & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon390
Eigen::internal::traits::Flags	../include/Eigen/src/Geometry/Quaternion.h	/^    Flags = IsAligned ? (AlignedBit | LvalueBit) : LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon386
Eigen::internal::traits::Flags	../include/Eigen/src/Geometry/Quaternion.h	/^      Flags = TraitsBase::Flags$/;"	e	enum:Eigen::internal::traits::__anon388
Eigen::internal::traits::Flags	../include/Eigen/src/Geometry/Quaternion.h	/^      Flags = TraitsBase::Flags & ~LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon389
Eigen::internal::traits::Flags	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon7
Eigen::internal::traits::Flags	../include/Eigen/src/SparseCore/SparseBlock.h	/^    Flags = MatrixType::Flags,$/;"	e	enum:Eigen::internal::traits::__anon20
Eigen::internal::traits::Flags	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    Flags = Tr ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::Flags	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    Flags = (SparseFlags&RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon35
Eigen::internal::traits::Flags	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon32
Eigen::internal::traits::Flags	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = _Options | NestByRefBit | LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon31
Eigen::internal::traits::Flags	../include/Eigen/src/SparseCore/SparseProduct.h	/^    Flags = (int(LhsFlags | RhsFlags) & HereditaryBits & RemovedBits)$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::Flags	../include/Eigen/src/SparseCore/SparseVector.h	/^    Flags = _Options | NestByRefBit | LvalueBit | (IsColVector ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon25
Eigen::internal::traits::Flags	../include/Eigen/src/SparseCore/SparseView.h	/^    Flags = int(traits<MatrixType>::Flags) & (RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon38
Eigen::internal::traits::FlagsLinearAccessBit	../include/Eigen/src/Core/Block.h	/^    FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1) ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::FlagsLvalueBit	../include/Eigen/src/Core/Block.h	/^    FlagsLvalueBit = is_lvalue<XprType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::FlagsLvalueBit	../include/Eigen/src/Core/Transpose.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon73
Eigen::internal::traits::FlagsRowMajorBit	../include/Eigen/src/Core/Block.h	/^    FlagsRowMajorBit = IsRowMajor ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::getL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::traits	access:public	signature:(const MatrixType& m)
Eigen::internal::traits::getU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::traits	access:public	signature:(const MatrixType& m)
Eigen::internal::traits::HasNoInnerStride	../include/Eigen/src/Core/Map.h	/^    HasNoInnerStride = InnerStrideAtCompileTime == 1,$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::HasNoOuterStride	../include/Eigen/src/Core/Map.h	/^    HasNoOuterStride = StrideType::OuterStrideAtCompileTime == 0,$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::HasNoStride	../include/Eigen/src/Core/Map.h	/^    HasNoStride = HasNoInnerStride && HasNoOuterStride,$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::HasSameStorageOrderAsXprType	../include/Eigen/src/Core/Block.h	/^    HasSameStorageOrderAsXprType = (IsRowMajor == XprTypeIsRowMajor),$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits	../include/Eigen/src/Core/Array.h	/^struct traits<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > : traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/ArrayWrapper.h	/^struct traits<ArrayWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/ArrayWrapper.h	/^struct traits<MatrixWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/BandMatrix.h	/^struct traits<BandMatrix<_Scalar,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/BandMatrix.h	/^struct traits<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/Block.h	/^struct traits<Block<XprType, BlockRows, BlockCols, InnerPanel, HasDirectAccess> > : traits<XprType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/CwiseBinaryOp.h	/^struct traits<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/CwiseNullaryOp.h	/^struct traits<CwiseNullaryOp<NullaryOp, PlainObjectType> > : traits<PlainObjectType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/CwiseUnaryOp.h	/^struct traits<CwiseUnaryOp<UnaryOp, XprType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/CwiseUnaryView.h	/^struct traits<CwiseUnaryView<ViewOp, MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/Diagonal.h	/^struct traits<Diagonal<MatrixType,DiagIndex> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/DiagonalMatrix.h	/^struct traits<DiagonalMatrix<_Scalar,SizeAtCompileTime,MaxSizeAtCompileTime> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/DiagonalMatrix.h	/^struct traits<DiagonalWrapper<_DiagonalVectorType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/DiagonalProduct.h	/^struct traits<DiagonalProduct<MatrixType, DiagonalType, ProductOrder> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/Flagged.h	/^struct traits<Flagged<ExpressionType, Added, Removed> > : traits<ExpressionType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/ForceAlignedAccess.h	/^struct traits<ForceAlignedAccess<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,GemvProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,InnerProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,OuterProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/Map.h	/^struct traits<Map<PlainObjectType, MapOptions, StrideType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/Matrix.h	/^struct traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/NestByValue.h	/^struct traits<NestByValue<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/PermutationMatrix.h	/^struct traits<Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/PermutationMatrix.h	/^struct traits<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/PermutationMatrix.h	/^struct traits<PermutationWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/PermutationMatrix.h	/^struct traits<permut_matrix_product_retval<PermutationType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/PermutationMatrix.h	/^struct traits<Transpose<PermutationBase<Derived> > >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/ProductBase.h	/^struct traits<ProductBase<Derived,_Lhs,_Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/ProductBase.h	/^struct traits<ScaledProduct<NestedProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct traits<CoeffBasedProduct<LhsNested,RhsNested,NestingFlags> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct traits<GeneralProduct<Lhs,Rhs,GemmProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct traits<SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,true> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,true,Rhs,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/Replicate.h	/^struct traits<Replicate<MatrixType,RowFactor,ColFactor> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/ReturnByValue.h	/^struct traits<ReturnByValue<Derived> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/Reverse.h	/^struct traits<Reverse<MatrixType, Direction> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/Select.h	/^struct traits<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/SelfAdjointView.h	/^struct traits<SelfAdjointView<MatrixType, UpLo> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^struct traits<SelfCwiseBinaryOp<BinaryOp,Lhs,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/SolveTriangular.h	/^struct traits<triangular_solve_retval<Side, TriangularType, Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/Swap.h	/^struct traits<SwapWrapper<ExpressionType> > : traits<ExpressionType> {};$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/Transpose.h	/^struct traits<Transpose<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/Transpositions.h	/^struct traits<Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,_PacketAccess> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/Transpositions.h	/^struct traits<transposition_matrix_product_retval<TranspositionType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/Transpositions.h	/^struct traits<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/Transpositions.h	/^struct traits<TranspositionsWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Core/TriangularMatrix.h	/^struct traits<TriangularView<MatrixType, _Mode> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename T> struct traits<const T> : traits<T> {};$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/VectorBlock.h	/^struct traits<VectorBlock<VectorType, Size> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Core/VectorwiseOp.h	/^struct traits<PartialReduxExpr<MatrixType, MemberOp, Direction> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Eigen2Support/Minor.h	/^struct traits<Minor<MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^struct traits<HessenbergDecompositionMatrixHReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct traits<TridiagonalizationMatrixTReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Geometry/AngleAxis.h	/^template<typename _Scalar> struct traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Geometry/Homogeneous.h	/^struct traits<homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Geometry/Homogeneous.h	/^struct traits<Homogeneous<MatrixType,Direction> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Geometry/Homogeneous.h	/^struct traits<homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Geometry/Quaternion.h	/^  struct traits<Map<const Quaternion<_Scalar>, _Options> >:$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Geometry/Quaternion.h	/^  struct traits<Map<Quaternion<_Scalar>, _Options> >:$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/Geometry/Quaternion.h	/^struct traits<Quaternion<_Scalar,_Options> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Geometry/Rotation2D.h	/^template<typename _Scalar> struct traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/Householder/HouseholderSequence.h	/^struct traits<HouseholderSequence<VectorsType,CoeffsType,Side> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^struct traits<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^struct traits<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/LU/Inverse.h	/^struct traits<inverse_impl<MatrixType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/misc/Image.h	/^struct traits<image_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/misc/Kernel.h	/^struct traits<kernel_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/misc/Solve.h	/^struct traits<solve_retval_base<DecompositionType, Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/misc/SparseSolve.h	/^struct traits<solve_retval_with_guess<DecompositionType, Rhs, Guess> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/misc/SparseSolve.h	/^struct traits<sparse_solve_retval_base<DecompositionType, Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^struct traits<FullPivHouseholderQRMatrixQReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo> struct traits<SimplicialCholesky<_MatrixType,_UpLo> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType,int _UpLo> struct traits<SimplicialLDLT<_MatrixType,_UpLo> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo> struct traits<SimplicialLLT<_MatrixType,_UpLo> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^struct traits<MappedSparseMatrix<_Scalar, _Flags, _Index> > : traits<SparseMatrix<_Scalar, _Flags, _Index> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseBlock.h	/^struct traits<SparseInnerVectorSet<MatrixType, Size> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct traits<DenseTimeSparseProduct<Lhs,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct traits<SparseDenseOuterProduct<Lhs,Rhs,Tr> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct traits<SparseTimeDenseProduct<Lhs,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^struct traits<SparseDiagonalProduct<Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<Diagonal<const SparseMatrix<_Scalar, _Options, _Index>, DiagIndex> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<SparseMatrix<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparsePermutation.h	/^struct traits<permut_sparsematrix_product_retval<PermutationType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseProduct.h	/^struct traits<SparseSparseProduct<LhsNested, RhsNested> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<DenseTimeSparseSelfAdjointProduct<Lhs,Rhs,UpLo> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointTimeDenseProduct<Lhs,Rhs,UpLo> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointView<MatrixType,UpLo> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSymmetricPermutationProduct<MatrixType,UpLo> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^struct traits<SparseTriangularView<MatrixType,Mode> >$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseVector.h	/^struct traits<SparseVector<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
Eigen::internal::traits	../include/Eigen/src/SparseCore/SparseView.h	/^struct traits<SparseView<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
Eigen::internal::traits::Index	../include/Eigen/src/Core/BandMatrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Core/CwiseBinaryOp.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Core/Map.h	/^  typedef typename PlainObjectType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Core/Matrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef IndexType Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Core/ProductBase.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^                                         typename traits<_RhsNested>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Core/Transpositions.h	/^  typedef IndexType Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Core/Transpositions.h	/^  typedef typename _IndicesType::Scalar Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Index                              Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Index                          Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/SparseCore/SparseBlock.h	/^  typedef typename traits<MatrixType>::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename MatrixTypeNestedCleaned::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/SparseCore/SparseProduct.h	/^                                         typename traits<_RhsNested>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/SparseCore/SparseVector.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Index	../include/Eigen/src/SparseCore/SparseView.h	/^  typedef int Index;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef Map<const Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IndicesType	../include/Eigen/src/Core/Transpositions.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IndicesType	../include/Eigen/src/Core/Transpositions.h	/^  typedef Map<const Matrix<Index,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IndicesType	../include/Eigen/src/Core/Transpositions.h	/^  typedef Matrix<Index, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::InnerSize	../include/Eigen/src/Core/Block.h	/^    InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::InnerSize	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::InnerSize	../include/Eigen/src/SparseCore/SparseProduct.h	/^    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::InnerStrideAtCompileTime	../include/Eigen/src/Core/Block.h	/^    InnerStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::InnerStrideAtCompileTime	../include/Eigen/src/Core/CwiseUnaryView.h	/^    InnerStrideAtCompileTime = MatrixTypeInnerStride == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon232
Eigen::internal::traits::InnerStrideAtCompileTime	../include/Eigen/src/Core/Map.h	/^    InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::InnerStrideAtCompileTime	../include/Eigen/src/Core/Matrix.h	/^    InnerStrideAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon289
Eigen::internal::traits::InnerStrideAtCompileTime	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    InnerStrideAtCompileTime = Lhs::InnerStrideAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon50
Eigen::internal::traits::InnerStrideAtCompileTime	../include/Eigen/src/Core/Transpose.h	/^    InnerStrideAtCompileTime = inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon73
Eigen::internal::traits::InputScalar	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MatrixType::Scalar InputScalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::IsAligned	../include/Eigen/src/Core/Map.h	/^    IsAligned = bool(EIGEN_ALIGN) && ((int(MapOptions)&Aligned)==Aligned),$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::IsAligned	../include/Eigen/src/Geometry/Quaternion.h	/^    IsAligned = internal::traits<Coefficients>::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::traits::__anon386
Eigen::internal::traits::IsAligned	../include/Eigen/src/Geometry/Quaternion.h	/^      IsAligned = TraitsBase::IsAligned,$/;"	e	enum:Eigen::internal::traits::__anon388
Eigen::internal::traits::IsAligned	../include/Eigen/src/Geometry/Quaternion.h	/^      IsAligned = TraitsBase::IsAligned,$/;"	e	enum:Eigen::internal::traits::__anon389
Eigen::internal::traits::IsColVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    IsColVector = (_Options & RowMajorBit) ? 0 : 1,$/;"	e	enum:Eigen::internal::traits::__anon25
Eigen::internal::traits::IsDynamicSize	../include/Eigen/src/Core/Map.h	/^    IsDynamicSize = PlainObjectType::SizeAtCompileTime==Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::IsRowMajor	../include/Eigen/src/Core/Block.h	/^    IsRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::IsRowMajor	../include/Eigen/src/Core/Replicate.h	/^    IsRowMajor = MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1 ? 1$/;"	e	enum:Eigen::internal::traits::__anon67
Eigen::internal::traits::IsRowMajor	../include/Eigen/src/SparseCore/SparseBlock.h	/^    IsRowMajor = (int(MatrixType::Flags)&RowMajorBit)==RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon20
Eigen::internal::traits::KeepsPacketAccess	../include/Eigen/src/Core/Map.h	/^    KeepsPacketAccess = bool(HasNoInnerStride)$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::LhsCoeffReadCost	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon65
Eigen::internal::traits::LhsCoeffReadCost	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::LhsCoeffReadCost	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    LhsCoeffReadCost = traits<_LhsNested>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::LhsCoeffReadCost	../include/Eigen/src/SparseCore/SparseProduct.h	/^    LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::LhsFlags	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon65
Eigen::internal::traits::LhsFlags	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::LhsFlags	../include/Eigen/src/SparseCore/SparseProduct.h	/^    LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::Lhs	../include/Eigen/src/Core/ProductBase.h	/^  typedef typename remove_all<_Lhs>::type Lhs;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_Lhs	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::LhsMatrixTypeCleaned	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::LhsMatrixType	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename take_matrix_for_product<Lhs>::type LhsMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::LhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_LhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_LhsNested	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::LhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_LhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_LhsNested	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::LhsRowMajor	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      LhsRowMajor = LhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::LinearAccess	../include/Eigen/src/Core/Reverse.h	/^    LinearAccess = ( (Direction==BothDirections) && (int(_MatrixTypeNested::Flags)&PacketAccessBit) )$/;"	e	enum:Eigen::internal::traits::__anon115
Eigen::internal::traits::MaskAlignedBit	../include/Eigen/src/Core/Block.h	/^    MaskAlignedBit = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic) && (((OuterStrideAtCompileTime * int(sizeof(Scalar))) % 16) == 0)) ? AlignedBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::MaskPacketAccessBit	../include/Eigen/src/Core/Block.h	/^    MaskPacketAccessBit = (InnerSize == Dynamic || (InnerSize % packet_traits<Scalar>::size) == 0)$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::MatrixCols	../include/Eigen/src/Core/Block.h	/^    MatrixCols = traits<XprType>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::MatrixL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<CholMatrixType, Eigen::Lower>  MatrixL;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<CholMatrixType, Eigen::UnitLower>  MatrixL;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixRows	../include/Eigen/src/Core/Block.h	/^    MatrixRows = traits<XprType>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::MatrixTypeCleaned	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	../include/Eigen/src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	../include/Eigen/src/misc/Kernel.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	../include/Eigen/src/misc/Solve.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	../include/Eigen/src/misc/SparseSolve.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixType	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef SparseMatrix<_Scalar, _Options, _Index> MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeInnerStride	../include/Eigen/src/Core/CwiseUnaryView.h	/^    MatrixTypeInnerStride =  inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon232
Eigen::internal::traits::MatrixTypeNestedCleaned	../include/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNestedCleaned	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNestedCleaned	../include/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	../include/Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	../include/Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	../include/Eigen/src/Core/Diagonal.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	../include/Eigen/src/Core/Diagonal.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	../include/Eigen/src/Core/Replicate.h	/^  typedef typename nested<MatrixType,Factor>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	../include/Eigen/src/Core/Replicate.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	../include/Eigen/src/Core/Reverse.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	../include/Eigen/src/Core/Reverse.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	../include/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	../include/Eigen/src/Core/Transpose.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	../include/Eigen/src/Eigen2Support/Minor.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	../include/Eigen/src/Eigen2Support/Minor.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNested	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNestedNonRef	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixTypeNestedPlain	../include/Eigen/src/Core/Transpose.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedPlain;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<typename CholMatrixType::AdjointReturnType, Eigen::UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MatrixU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<typename CholMatrixType::AdjointReturnType, Eigen::Upper>   MatrixU;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon81
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon82
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/Block.h	/^    MaxColsAtCompileTime = BlockCols==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    MaxColsAtCompileTime = traits<Ancestor>::MaxColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon64
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^    MaxColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon281
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/DiagonalProduct.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon77
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/Matrix.h	/^    MaxColsAtCompileTime = _MaxCols,$/;"	e	enum:Eigen::internal::traits::__anon289
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^    MaxColsAtCompileTime = IndicesType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon118
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/ProductBase.h	/^    MaxColsAtCompileTime = traits<Rhs>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/Replicate.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon67
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/Reverse.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon115
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/Select.h	/^    MaxColsAtCompileTime = ConditionMatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon60
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/Transpose.h	/^    MaxColsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon73
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/VectorwiseOp.h	/^    MaxColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon68
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Eigen2Support/Minor.h	/^    MaxColsAtCompileTime = (MatrixType::MaxColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Geometry/Homogeneous.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon390
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^    MaxColsAtCompileTime = MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon7
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseBlock.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon20
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    MaxColsAtCompileTime = Tr ? int(traits<Lhs>::MaxColsAtCompileTime)  : int(traits<Rhs>::MaxColsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    MaxColsAtCompileTime = _Rhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon35
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon32
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon31
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseProduct.h	/^    MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseVector.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon25
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon81
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon82
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/Block.h	/^    MaxRowsAtCompileTime = BlockRows==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    MaxRowsAtCompileTime = traits<Ancestor>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon64
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^    MaxRowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon281
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/DiagonalProduct.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon77
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/Matrix.h	/^    MaxRowsAtCompileTime = _MaxRows,$/;"	e	enum:Eigen::internal::traits::__anon289
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^    MaxRowsAtCompileTime = IndicesType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon118
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/ProductBase.h	/^    MaxRowsAtCompileTime = traits<Lhs>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/Replicate.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon67
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/Reverse.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon115
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/Select.h	/^    MaxRowsAtCompileTime = ConditionMatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon60
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/Transpose.h	/^    MaxRowsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon73
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/VectorwiseOp.h	/^    MaxRowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon68
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Eigen2Support/Minor.h	/^    MaxRowsAtCompileTime = (MatrixType::MaxRowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Geometry/Homogeneous.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon390
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^    MaxRowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon7
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseBlock.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon20
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    MaxRowsAtCompileTime = Tr ? int(traits<Rhs>::MaxRowsAtCompileTime)  : int(traits<Lhs>::MaxRowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    MaxRowsAtCompileTime = _Lhs::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon35
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon31
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon32
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseProduct.h	/^    MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseVector.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon25
Eigen::internal::traits::Mode	../include/Eigen/src/Core/SelfAdjointView.h	/^    Mode = UpLo | SelfAdjoint,$/;"	e	enum:Eigen::internal::traits::__anon83
Eigen::internal::traits::Mode	../include/Eigen/src/Core/TriangularMatrix.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::internal::traits::__anon234
Eigen::internal::traits::MoveOuter	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::traits::__anon18
Eigen::internal::traits::Options	../include/Eigen/src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon81
Eigen::internal::traits::Options	../include/Eigen/src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon82
Eigen::internal::traits::Options	../include/Eigen/src/Core/Map.h	/^  enum { Options }; \/\/ Expressions don't have Options$/;"	e	enum:Eigen::internal::traits::__anon286
Eigen::internal::traits::Options	../include/Eigen/src/Core/Matrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon289
Eigen::internal::traits::OuterStrideAtCompileTime	../include/Eigen/src/Core/Block.h	/^    OuterStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::OuterStrideAtCompileTime	../include/Eigen/src/Core/CwiseUnaryView.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret$/;"	e	enum:Eigen::internal::traits::__anon232
Eigen::internal::traits::OuterStrideAtCompileTime	../include/Eigen/src/Core/Map.h	/^    OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon285
Eigen::internal::traits::OuterStrideAtCompileTime	../include/Eigen/src/Core/Matrix.h	/^    OuterStrideAtCompileTime = (Options&RowMajor) ? ColsAtCompileTime : RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon289
Eigen::internal::traits::OuterStrideAtCompileTime	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    OuterStrideAtCompileTime = Lhs::OuterStrideAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon50
Eigen::internal::traits::OuterStrideAtCompileTime	../include/Eigen/src/Core/Transpose.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret$/;"	e	enum:Eigen::internal::traits::__anon73
Eigen::internal::traits::packet	../include/Eigen/src/Core/Diagonal.h	/^    template<int LoadMode> typename MatrixType::PacketReturnType packet(Index) const;$/;"	p	struct:Eigen::internal::traits	access:public	signature:(Index) const
Eigen::internal::traits::packet	../include/Eigen/src/Core/Diagonal.h	/^    template<int LoadMode> typename MatrixType::PacketReturnType packet(Index,Index) const;$/;"	p	struct:Eigen::internal::traits	access:public	signature:(Index,Index) const
Eigen::internal::traits::_PacketOnDiag	../include/Eigen/src/Core/DiagonalProduct.h	/^    _PacketOnDiag = !((int(_StorageOrder) == RowMajor && int(ProductOrder) == OnTheLeft)$/;"	e	enum:Eigen::internal::traits::__anon77
Eigen::internal::traits::PlainObject	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef Quaternion<_Scalar,_Options> PlainObject;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Preconditioner	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Preconditioner	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::RemovedBits	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RemovedBits = ~(EvalToRowMajor ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::ReturnType	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename internal::plain_matrix_type_column_major<Rhs>::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/Core/Transpositions.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^  typedef MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/Geometry/Homogeneous.h	/^                 MatrixTypeCleaned::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/Geometry/Homogeneous.h	/^                 Rhs::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/LU/Inverse.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/misc/Image.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/misc/Kernel.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/misc/Solve.h	/^                 Rhs::MaxColsAtCompileTime> ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/misc/SparseSolve.h	/^                 Rhs::MaxColsAtCompileTime> ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/misc/SparseSolve.h	/^  typedef SparseMatrix<typename Rhs::Scalar, Rhs::Options, typename Rhs::Index> ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::ReturnType	../include/Eigen/src/SparseCore/SparsePermutation.h	/^        SparseMatrix<Scalar,int(SrcStorageOrder)==RowMajor?ColMajor:RowMajor,Index> >::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::RhsCoeffReadCost	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon65
Eigen::internal::traits::RhsCoeffReadCost	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::RhsCoeffReadCost	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    RhsCoeffReadCost = traits<_RhsNested>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::RhsCoeffReadCost	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::RhsFlags	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon65
Eigen::internal::traits::RhsFlags	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::RhsFlags	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::Rhs	../include/Eigen/src/Core/ProductBase.h	/^  typedef typename remove_all<_Rhs>::type Rhs;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_Rhs	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_RhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::RhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_RhsNested	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_RhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::RhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_RhsNested	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::RhsRowMajor	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      RhsRowMajor = RhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon81
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon82
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/Block.h	/^    RowsAtCompileTime = MatrixRows == 0 ? 0 : BlockRows,$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    RowsAtCompileTime = traits<Ancestor>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon64
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^    RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon281
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/DiagonalProduct.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon77
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/Matrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon289
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^    RowsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon118
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/ProductBase.h	/^    RowsAtCompileTime = traits<Lhs>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      RowsAtCompileTime = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/Replicate.h	/^    RowsAtCompileTime = RowFactor==Dynamic || int(MatrixType::RowsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon67
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/Reverse.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon115
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/Select.h	/^    RowsAtCompileTime = ConditionMatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon60
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/Transpose.h	/^    RowsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon73
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/VectorwiseOp.h	/^    RowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon68
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Eigen2Support/Minor.h	/^    RowsAtCompileTime = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon441
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Geometry/Homogeneous.h	/^    RowsAtCompileTime = Direction==Vertical  ?  RowsPlusOne : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon390
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^    RowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon7
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseBlock.h	/^    RowsAtCompileTime = IsRowMajor ? Size : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon20
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    RowsAtCompileTime    = Tr ? int(traits<Rhs>::RowsAtCompileTime)     : int(traits<Lhs>::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon30
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    RowsAtCompileTime = _Lhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon35
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon31
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon32
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RowsAtCompileTime    = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon17
Eigen::internal::traits::RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseVector.h	/^    RowsAtCompileTime = IsColVector ? Dynamic : 1,$/;"	e	enum:Eigen::internal::traits::__anon25
Eigen::internal::traits::RowsPlusOne	../include/Eigen/src/Geometry/Homogeneous.h	/^    RowsPlusOne = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon390
Eigen::internal::traits::SameType	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon65
Eigen::internal::traits::SameType	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon87
Eigen::internal::traits::_SameTypes	../include/Eigen/src/Core/DiagonalProduct.h	/^    _SameTypes = is_same<typename MatrixType::Scalar, typename DiagonalType::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon77
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/BandMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/CwiseBinaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/CwiseUnaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/CwiseUnaryView.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/DiagonalProduct.h	/^  typedef typename scalar_product_traits<typename MatrixType::Scalar, typename DiagonalType::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/Map.h	/^  typedef typename PlainObjectType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/Matrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/ProductBase.h	/^  typedef typename scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename scalar_product_traits<typename _LhsNested::Scalar, typename _RhsNested::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/Replicate.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/Reverse.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/Transpose.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::result_type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                             Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                         Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/SparseCore/SparseBlock.h	/^  typedef typename traits<MatrixType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^                                            typename traits<Rhs>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename _Lhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename MatrixTypeNestedCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename _LhsNested::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::Scalar	../include/Eigen/src/SparseCore/SparseVector.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::SparseFlags	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    SparseFlags = is_diagonal<_Lhs>::ret ? int(_Rhs::Flags) : int(_Lhs::Flags),$/;"	e	enum:Eigen::internal::traits::__anon35
Eigen::internal::traits::SrcStorageOrder	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    SrcStorageOrder = MatrixTypeNestedCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::traits::__anon18
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/BandMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/CwiseBinaryOp.h	/^                                           typename traits<Rhs>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/Diagonal.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/Matrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef PermutationStorage StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/ProductBase.h	/^  typedef typename traits<NestedProduct>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/ProductBase.h	/^                                           typename traits<Rhs>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^                                           typename traits<_RhsNested>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/Select.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/Transpose.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Eigen2Support/Minor.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/SparseCore/SparseBlock.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/SparseCore/SparseVector.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::StorageKind	../include/Eigen/src/SparseCore/SparseView.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_StorageOrder	../include/Eigen/src/Core/DiagonalProduct.h	/^    _StorageOrder = MatrixType::Flags & RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::traits::__anon77
Eigen::internal::traits::StorageOrdersAgree	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    StorageOrdersAgree = (int(Lhs::Flags)&RowMajorBit)==(int(Rhs::Flags)&RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon65
Eigen::internal::traits::Subs	../include/Eigen/src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon81
Eigen::internal::traits::Subs	../include/Eigen/src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon82
Eigen::internal::traits::Supers	../include/Eigen/src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon81
Eigen::internal::traits::Supers	../include/Eigen/src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon82
Eigen::internal::traits::SupportedAccessPatterns	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon31
Eigen::internal::traits::SupportedAccessPatterns	../include/Eigen/src/SparseCore/SparseVector.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon25
Eigen::internal::traits::ThenMatrixNested	../include/Eigen/src/Core/Select.h	/^  typedef typename ThenMatrixType::Nested ThenMatrixNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::TmpFlags	../include/Eigen/src/Geometry/Homogeneous.h	/^    TmpFlags = _MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon390
Eigen::internal::traits::TraitsBase	../include/Eigen/src/Core/Map.h	/^  typedef traits<PlainObjectType> TraitsBase;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::TraitsBase	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef traits<Quaternion<_Scalar, _Options> > TraitsBase;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::TraversalSize	../include/Eigen/src/Core/VectorwiseOp.h	/^    TraversalSize = Direction==Vertical ? RowsAtCompileTime : ColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon68
Eigen::internal::traits::UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon407
Eigen::internal::traits::UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon408
Eigen::internal::traits::UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon409
Eigen::internal::traits::_Vectorizable	../include/Eigen/src/Core/DiagonalProduct.h	/^    _Vectorizable = bool(int(MatrixType::Flags)&PacketAccessBit) && _SameTypes && ((!_PacketOnDiag) || (bool(int(DiagonalType::Flags)&PacketAccessBit))),$/;"	e	enum:Eigen::internal::traits::__anon77
Eigen::internal::traits::XprBase	../include/Eigen/src/Core/Array.h	/^  typedef ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > XprBase;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/Array.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/ArrayWrapper.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/ArrayWrapper.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename traits<Ancestor>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/Matrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/ProductBase.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/Transpose.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/SparseCore/SparseBlock.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprKind	../include/Eigen/src/SparseCore/SparseVector.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprTypeIsRowMajor	../include/Eigen/src/Core/Block.h	/^    XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0,$/;"	e	enum:Eigen::internal::traits::__anon228
Eigen::internal::traits::XprTypeNested	../include/Eigen/src/Core/Block.h	/^  typedef typename nested<XprType>::type XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_XprTypeNested	../include/Eigen/src/Core/Block.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::_XprTypeNested	../include/Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::traits::XprTypeNested	../include/Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename XprType::Nested XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
Eigen::internal::transform_construct_from_matrix	../include/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_construct_from_matrix	../include/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_construct_from_matrix	../include/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_construct_from_matrix	../include/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_construct_from_matrix::run	../include/Eigen/src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,AffineCompact,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix	access:public	signature:(Transform<typename Other::Scalar,Dim,AffineCompact,Options> *transform, const Other& other)
Eigen::internal::transform_construct_from_matrix::run	../include/Eigen/src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,Mode,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix	access:public	signature:(Transform<typename Other::Scalar,Dim,Mode,Options> *transform, const Other& other)
Eigen::internal::transform_left_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_left_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_left_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_left_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_left_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_left_product_impl::MatrixType	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
Eigen::internal::transform_left_product_impl::ResultType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Projective,Options> ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
Eigen::internal::transform_left_product_impl::ResultType	../include/Eigen/src/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
Eigen::internal::transform_left_product_impl::run	../include/Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Other& other, const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl	access:public	signature:(const Other& other, const TransformType& tr)
Eigen::internal::transform_left_product_impl::run	../include/Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Other& other,const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl	access:public	signature:(const Other& other,const TransformType& tr)
Eigen::internal::transform_left_product_impl::TransformType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,AffineCompact,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
Eigen::internal::transform_left_product_impl::TransformType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Mode,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
Eigen::internal::transform_product_result	../include/Eigen/src/Geometry/Transform.h	/^struct transform_product_result$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_product_result::Mode	../include/Eigen/src/Geometry/Transform.h	/^    Mode =$/;"	e	enum:Eigen::internal::transform_product_result::__anon376
Eigen::internal::transform_right_product_impl::Dim	../include/Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon377
Eigen::internal::transform_right_product_impl::Dim	../include/Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon378
Eigen::internal::transform_right_product_impl::HDim	../include/Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon377
Eigen::internal::transform_right_product_impl::HDim	../include/Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon378
Eigen::internal::transform_right_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 0 >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_right_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 1 >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_right_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 2 >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_right_product_impl::OtherCols	../include/Eigen/src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon377
Eigen::internal::transform_right_product_impl::OtherCols	../include/Eigen/src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon378
Eigen::internal::transform_right_product_impl::OtherRows	../include/Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon377
Eigen::internal::transform_right_product_impl::OtherRows	../include/Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon378
Eigen::internal::transform_right_product_impl::ResultType	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename MatrixType::PlainObject ResultType;$/;"	t	struct:Eigen::internal::transform_right_product_impl	access:public
Eigen::internal::transform_right_product_impl::run	../include/Eigen/src/Geometry/Transform.h	/^  static EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)$/;"	f	struct:Eigen::internal::transform_right_product_impl	access:public	signature:(const TransformType& T, const MatrixType& other)
Eigen::internal::transform_take_affine_part::AffinePart	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::AffinePart AffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
Eigen::internal::transform_take_affine_part::ConstAffinePart	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::ConstAffinePart ConstAffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
Eigen::internal::transform_take_affine_part	../include/Eigen/src/Geometry/Transform.h	/^struct transform_take_affine_part<Transform<Scalar,Dim,AffineCompact, Options> > {$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_take_affine_part	../include/Eigen/src/Geometry/Transform.h	/^template<typename TransformType> struct transform_take_affine_part {$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_take_affine_part::MatrixType	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename Transform<Scalar,Dim,AffineCompact,Options>::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
Eigen::internal::transform_take_affine_part::MatrixType	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
Eigen::internal::transform_take_affine_part::run	../include/Eigen/src/Geometry/Transform.h	/^  static inline AffinePart run(MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(MatrixType& m)
Eigen::internal::transform_take_affine_part::run	../include/Eigen/src/Geometry/Transform.h	/^  static inline ConstAffinePart run(const MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(const MatrixType& m)
Eigen::internal::transform_take_affine_part::run	../include/Eigen/src/Geometry/Transform.h	/^  static inline const MatrixType& run(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(const MatrixType& m)
Eigen::internal::transform_take_affine_part::run	../include/Eigen/src/Geometry/Transform.h	/^  static inline MatrixType& run(MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(MatrixType& m)
Eigen::internal::transform_traits::Dim	../include/Eigen/src/Geometry/Transform.h	/^    Dim = Transform::Dim,$/;"	e	enum:Eigen::internal::transform_traits::__anon373
Eigen::internal::transform_traits::HDim	../include/Eigen/src/Geometry/Transform.h	/^    HDim = Transform::HDim,$/;"	e	enum:Eigen::internal::transform_traits::__anon373
Eigen::internal::transform_traits	../include/Eigen/src/Geometry/Transform.h	/^struct transform_traits$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_traits::IsProjective	../include/Eigen/src/Geometry/Transform.h	/^    IsProjective = (int(Mode)==int(Projective))$/;"	e	enum:Eigen::internal::transform_traits::__anon373
Eigen::internal::transform_traits::Mode	../include/Eigen/src/Geometry/Transform.h	/^    Mode = Transform::Mode,$/;"	e	enum:Eigen::internal::transform_traits::__anon373
Eigen::internal::transform_transform_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,AffineCompact,LhsOptions>,Transform<Scalar,Dim,Projective,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_transform_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,false >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_transform_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_transform_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,Projective,LhsOptions>,Transform<Scalar,Dim,AffineCompact,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
Eigen::internal::transform_transform_product_impl::Lhs	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::Lhs	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,LhsMode,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::Lhs	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::ResultMode	../include/Eigen/src/Geometry/Transform.h	/^  enum { ResultMode = transform_product_result<LhsMode,RhsMode>::Mode };$/;"	e	enum:Eigen::internal::transform_transform_product_impl::__anon379
Eigen::internal::transform_transform_product_impl::ResultType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::ResultType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,ResultMode,LhsOptions> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::Rhs	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::Rhs	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::Rhs	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,RhsMode,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Eigen::internal::transform_transform_product_impl::run	../include/Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::transform_transform_product_impl	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::internal::TransposeImpl_base	../include/Eigen/src/Core/Transpose.h	/^struct TransposeImpl_base<MatrixType, false>$/;"	s	namespace:Eigen::internal
Eigen::internal::TransposeImpl_base	../include/Eigen/src/Core/Transpose.h	/^struct TransposeImpl_base$/;"	s	namespace:Eigen::internal
Eigen::internal::TransposeImpl_base::type	../include/Eigen/src/Core/Transpose.h	/^  typedef typename dense_xpr_base<Transpose<MatrixType> >::type type;$/;"	t	struct:Eigen::internal::TransposeImpl_base	access:public
Eigen::internal::transposition_matrix_product_retval::cols	../include/Eigen/src/Core/Transpositions.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:() const
Eigen::internal::transposition_matrix_product_retval::evalTo	../include/Eigen/src/Core/Transpositions.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:(Dest& dst) const
Eigen::internal::transposition_matrix_product_retval	../include/Eigen/src/Core/Transpositions.h	/^struct transposition_matrix_product_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::transposition_matrix_product_retval::Index	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename TranspositionType::Index Index;$/;"	t	struct:Eigen::internal::transposition_matrix_product_retval	access:public
Eigen::internal::transposition_matrix_product_retval::MatrixTypeNestedCleaned	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::transposition_matrix_product_retval	access:public
Eigen::internal::transposition_matrix_product_retval::m_matrix	../include/Eigen/src/Core/Transpositions.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::transposition_matrix_product_retval	access:protected
Eigen::internal::transposition_matrix_product_retval::m_transpositions	../include/Eigen/src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	struct:Eigen::internal::transposition_matrix_product_retval	access:protected
Eigen::internal::transposition_matrix_product_retval::rows	../include/Eigen/src/Core/Transpositions.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:() const
Eigen::internal::transposition_matrix_product_retval::transposition_matrix_product_retval	../include/Eigen/src/Core/Transpositions.h	/^    transposition_matrix_product_retval(const TranspositionType& tr, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:(const TranspositionType& tr, const MatrixType& matrix)
Eigen::internal::triangular_assignment_selector::col	../include/Eigen/src/Core/SelfAdjointView.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon85
Eigen::internal::triangular_assignment_selector::col	../include/Eigen/src/Core/SelfAdjointView.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon86
Eigen::internal::triangular_assignment_selector::col	../include/Eigen/src/Core/TriangularMatrix.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon236
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Lower), UnrollCount, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Upper), UnrollCount, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Lower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Mode, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, StrictlyLower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, StrictlyUpper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, UnitLower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, UnitUpper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Upper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_assignment_selector::Index	../include/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::triangular_assignment_selector	access:public
Eigen::internal::triangular_assignment_selector::Index	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::triangular_assignment_selector	access:public
Eigen::internal::triangular_assignment_selector::row	../include/Eigen/src/Core/SelfAdjointView.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon85
Eigen::internal::triangular_assignment_selector::row	../include/Eigen/src/Core/SelfAdjointView.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon86
Eigen::internal::triangular_assignment_selector::row	../include/Eigen/src/Core/TriangularMatrix.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon236
Eigen::internal::triangular_assignment_selector::run	../include/Eigen/src/Core/SelfAdjointView.h	/^  static inline void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &, const Derived2 &)
Eigen::internal::triangular_assignment_selector::run	../include/Eigen/src/Core/SelfAdjointView.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::triangular_assignment_selector::run	../include/Eigen/src/Core/TriangularMatrix.h	/^  static inline void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &, const Derived2 &)
Eigen::internal::triangular_assignment_selector::run	../include/Eigen/src/Core/TriangularMatrix.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &dst, const Derived2 &src)
Eigen::internal::triangular_assignment_selector::Scalar	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Derived1::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_assignment_selector	access:public
Eigen::internal::triangular_matrix_vector_product::HasUnitDiag	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon93
Eigen::internal::triangular_matrix_vector_product::HasUnitDiag	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon94
Eigen::internal::triangular_matrix_vector_product::HasZeroDiag	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon93
Eigen::internal::triangular_matrix_vector_product::HasZeroDiag	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon94
Eigen::internal::triangular_matrix_vector_product	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,ColMajor,Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_matrix_vector_product	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,RowMajor,Version>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_matrix_vector_product::IsLower	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon93
Eigen::internal::triangular_matrix_vector_product::IsLower	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon94
Eigen::internal::triangular_matrix_vector_product::ResScalar	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::triangular_matrix_vector_product	access:public
Eigen::internal::triangular_matrix_vector_product::run	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^  static EIGEN_DONT_INLINE  void run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::triangular_matrix_vector_product	access:public	signature:(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsIncr, ResScalar* _res, Index resIncr, ResScalar alpha)
Eigen::internal::triangular_matrix_vector_product::run	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^  static void run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::triangular_matrix_vector_product	access:public	signature:(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsIncr, ResScalar* _res, Index resIncr, ResScalar alpha)
Eigen::internal::triangular_matrix_vector_product_trmv	../include/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^struct triangular_matrix_vector_product_trmv :$/;"	s	namespace:Eigen::internal	inherits:triangular_matrix_vector_product
Eigen::internal::triangular_solve_matrix	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solve_matrix	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solve_matrix	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,Side,Mode,Conjugate,TriStorageOrder,RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solve_matrix::run	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::triangular_solve_matrix	access:public	signature:( Index size, Index cols, const Scalar* tri, Index triStride, Scalar* _other, Index otherStride, level3_blocking<Scalar,Scalar>& blocking)
Eigen::internal::triangular_solve_matrix::run	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::triangular_solve_matrix	access:public	signature:( Index size, Index otherSize, const Scalar* _tri, Index triStride, Scalar* _other, Index otherStride, level3_blocking<Scalar,Scalar>& blocking)
Eigen::internal::triangular_solve_retval::Base	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef ReturnByValue<triangular_solve_retval> Base;$/;"	t	struct:Eigen::internal::triangular_solve_retval	access:public
Eigen::internal::triangular_solve_retval::cols	../include/Eigen/src/Core/SolveTriangular.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:() const
Eigen::internal::triangular_solve_retval::evalTo	../include/Eigen/src/Core/SolveTriangular.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:(Dest& dst) const
Eigen::internal::triangular_solve_retval	../include/Eigen/src/Core/SolveTriangular.h	/^template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::triangular_solve_retval::Index	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::triangular_solve_retval	access:public
Eigen::internal::triangular_solve_retval::m_rhs	../include/Eigen/src/Core/SolveTriangular.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::triangular_solve_retval	access:protected
Eigen::internal::triangular_solve_retval::m_triangularMatrix	../include/Eigen/src/Core/SolveTriangular.h	/^    const TriangularType& m_triangularMatrix;$/;"	m	struct:Eigen::internal::triangular_solve_retval	access:protected
Eigen::internal::triangular_solve_retval::RhsNestedCleaned	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::triangular_solve_retval	access:public
Eigen::internal::triangular_solve_retval::rows	../include/Eigen/src/Core/SolveTriangular.h	/^  inline Index rows() const { return m_rhs.rows(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:() const
Eigen::internal::triangular_solve_retval::triangular_solve_retval	../include/Eigen/src/Core/SolveTriangular.h	/^  triangular_solve_retval(const TriangularType& tri, const Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:(const TriangularType& tri, const Rhs& rhs)
Eigen::internal::triangular_solver_selector::ActualLhsType	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::ActualLhsType	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::ExtractType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector	../include/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheLeft,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solver_selector	../include/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheRight,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solver_selector	../include/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,1>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solver_selector	../include/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,Dynamic>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solver_selector::Index	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Index Index;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::LhsProductTraits	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef blas_traits<Lhs> LhsProductTraits;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::LhsScalar	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Lhs::Scalar LhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::MappedRhs	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef Map<Matrix<RhsScalar,Dynamic,1>, Aligned> MappedRhs;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::RhsScalar	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar RhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_selector::run	../include/Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_selector	access:public	signature:(const Lhs& lhs, Rhs& rhs)
Eigen::internal::triangular_solver_selector::Scalar	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Eigen::internal::triangular_solver_unroller::I	../include/Eigen/src/Core/SolveTriangular.h	/^    I = IsLower ? Index : Size - Index - 1,$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon364
Eigen::internal::triangular_solver_unroller	../include/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,false> {$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solver_unroller	../include/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,true> {$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solver_unroller::IsLower	../include/Eigen/src/Core/SolveTriangular.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon364
Eigen::internal::triangular_solver_unroller::run	../include/Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_unroller	access:public	signature:(const Lhs& lhs, Rhs& rhs)
Eigen::internal::triangular_solver_unroller::run	../include/Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs&, Rhs&) {}$/;"	f	struct:Eigen::internal::triangular_solver_unroller	access:public	signature:(const Lhs&, Rhs&)
Eigen::internal::triangular_solver_unroller::S	../include/Eigen/src/Core/SolveTriangular.h	/^    S = IsLower ? 0     : I+1$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon364
Eigen::internal::triangular_solve_vector	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solve_vector	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solve_vector	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheRight, Mode, Conjugate, StorageOrder>$/;"	s	namespace:Eigen::internal
Eigen::internal::triangular_solve_vector::IsLower	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon104
Eigen::internal::triangular_solve_vector::IsLower	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon105
Eigen::internal::triangular_solve_vector::run	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^  static void run(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)$/;"	f	struct:Eigen::internal::triangular_solve_vector	access:public	signature:(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)
Eigen::internal::tribb_kernel::BlockSize	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^    BlockSize  = EIGEN_PLAIN_ENUM_MAX(mr,nr)$/;"	e	enum:Eigen::internal::tribb_kernel::__anon110
Eigen::internal::tribb_kernel	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct tribb_kernel$/;"	s	namespace:Eigen::internal
Eigen::internal::tribb_kernel::operator ()	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, ResScalar alpha, RhsScalar* workspace)$/;"	f	struct:Eigen::internal::tribb_kernel	access:public	signature:(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, ResScalar alpha, RhsScalar* workspace)
Eigen::internal::tribb_kernel::ResScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::tribb_kernel	access:public
Eigen::internal::tribb_kernel::Traits	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjLhs,ConjRhs> Traits;$/;"	t	struct:Eigen::internal::tribb_kernel	access:public
Eigen::internal::tridiagonalization_inplace	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& matA, CoeffVectorType& hCoeffs)
Eigen::internal::tridiagonalization_inplace	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs);$/;"	p	namespace:Eigen::internal	signature:(MatrixType& matA, CoeffVectorType& hCoeffs)
Eigen::internal::tridiagonalization_inplace	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
Eigen::internal::tridiagonalization_inplace_selector::CoeffVectorType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::CoeffVectorType CoeffVectorType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Eigen::internal::tridiagonalization_inplace_selector::HouseholderSequenceType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::HouseholderSequenceType HouseholderSequenceType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Eigen::internal::tridiagonalization_inplace_selector	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,1,IsComplex>$/;"	s	namespace:Eigen::internal
Eigen::internal::tridiagonalization_inplace_selector	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,3,false>$/;"	s	namespace:Eigen::internal
Eigen::internal::tridiagonalization_inplace_selector	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::tridiagonalization_inplace_selector::Index	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Eigen::internal::tridiagonalization_inplace_selector::RealScalar	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Eigen::internal::tridiagonalization_inplace_selector::run	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public	signature:(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)
Eigen::internal::tridiagonalization_inplace_selector::run	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public	signature:(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
Eigen::internal::tridiagonalization_inplace_selector::Scalar	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Eigen::internal::TridiagonalizationMatrixTReturnType::cols	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:() const
Eigen::internal::TridiagonalizationMatrixTReturnType::evalTo	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:(ResultType& result) const
Eigen::internal::TridiagonalizationMatrixTReturnType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^template<typename MatrixType> struct TridiagonalizationMatrixTReturnType$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Eigen::internal::TridiagonalizationMatrixTReturnType::Index	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public
Eigen::internal::TridiagonalizationMatrixTReturnType::m_matrix	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:protected
Eigen::internal::TridiagonalizationMatrixTReturnType::rows	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:() const
Eigen::internal::TridiagonalizationMatrixTReturnType::TridiagonalizationMatrixTReturnType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    TridiagonalizationMatrixTReturnType(const MatrixType& mat) : m_matrix(mat) { }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:(const MatrixType& mat)
Eigen::internal::TridiagonalMatrix::Base	../include/Eigen/src/Core/BandMatrix.h	/^    typedef BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor> Base;$/;"	t	class:Eigen::internal::TridiagonalMatrix	access:private
Eigen::internal::TridiagonalMatrix	../include/Eigen/src/Core/BandMatrix.h	/^class TridiagonalMatrix : public BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor>$/;"	c	namespace:Eigen::internal	inherits:BandMatrix
Eigen::internal::TridiagonalMatrix::Index	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::internal::TridiagonalMatrix	access:private
Eigen::internal::TridiagonalMatrix::sub	../include/Eigen/src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<-1>::Type sub() const$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:() const
Eigen::internal::TridiagonalMatrix::sub	../include/Eigen/src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<-1>::Type sub()$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:()
Eigen::internal::TridiagonalMatrix::super	../include/Eigen/src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<1>::Type super() const$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:() const
Eigen::internal::TridiagonalMatrix::super	../include/Eigen/src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<1>::Type super()$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:()
Eigen::internal::TridiagonalMatrix::TridiagonalMatrix	../include/Eigen/src/Core/BandMatrix.h	/^    TridiagonalMatrix(Index size = Size) : Base(size,size,Options&SelfAdjoint?0:1,1) {}$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:(Index size = Size)
Eigen::internal::tridiagonal_qr_step	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)$/;"	f	namespace:Eigen::internal	signature:(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)
Eigen::internal::tridiagonal_qr_step	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n);$/;"	p	namespace:Eigen::internal	signature:(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)
Eigen::internal::trmv_selector	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^template<> struct trmv_selector<ColMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::trmv_selector	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^template<> struct trmv_selector<RowMajor>$/;"	s	namespace:Eigen::internal
Eigen::internal::trmv_selector::run	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^  static void run(const TriangularProduct<Mode,true,Lhs,false,Rhs,true>& prod, Dest& dest, typename TriangularProduct<Mode,true,Lhs,false,Rhs,true>::Scalar alpha)$/;"	f	struct:Eigen::internal::trmv_selector	access:public	signature:(const TriangularProduct<Mode,true,Lhs,false,Rhs,true>& prod, Dest& dest, typename TriangularProduct<Mode,true,Lhs,false,Rhs,true>::Scalar alpha)
Eigen::internal::trsolve_traits	../include/Eigen/src/Core/SolveTriangular.h	/^class trsolve_traits$/;"	c	namespace:Eigen::internal
Eigen::internal::trsolve_traits::RhsIsVectorAtCompileTime	../include/Eigen/src/Core/SolveTriangular.h	/^      RhsIsVectorAtCompileTime = (Side==OnTheLeft ? Rhs::ColsAtCompileTime : Rhs::RowsAtCompileTime)==1$/;"	e	enum:Eigen::internal::trsolve_traits::__anon362
Eigen::internal::trsolve_traits::RhsVectors	../include/Eigen/src/Core/SolveTriangular.h	/^      RhsVectors  = RhsIsVectorAtCompileTime ? 1 : Dynamic$/;"	e	enum:Eigen::internal::trsolve_traits::__anon363
Eigen::internal::trsolve_traits::Unrolling	../include/Eigen/src/Core/SolveTriangular.h	/^      Unrolling   = (RhsIsVectorAtCompileTime && Rhs::SizeAtCompileTime != Dynamic && Rhs::SizeAtCompileTime <= 8)$/;"	e	enum:Eigen::internal::trsolve_traits::__anon363
Eigen::internal::true_type	../include/Eigen/src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
Eigen::internal::true_type::value	../include/Eigen/src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	e	enum:Eigen::internal::true_type::__anon173
Eigen::internal::umeyama_transform_matrix_type::HomogeneousDimension	../include/Eigen/src/Geometry/Umeyama.h	/^    HomogeneousDimension = int(MinRowsAtCompileTime) == Dynamic ? Dynamic : int(MinRowsAtCompileTime)+1$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon381
Eigen::internal::umeyama_transform_matrix_type	../include/Eigen/src/Geometry/Umeyama.h	/^struct umeyama_transform_matrix_type$/;"	s	namespace:Eigen::internal
Eigen::internal::umeyama_transform_matrix_type::MinRowsAtCompileTime	../include/Eigen/src/Geometry/Umeyama.h	/^    MinRowsAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, OtherMatrixType::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon381
Eigen::internal::umeyama_transform_matrix_type::type	../include/Eigen/src/Geometry/Umeyama.h	/^  > type;$/;"	t	struct:Eigen::internal::umeyama_transform_matrix_type	access:public
Eigen::internal::unaligned_assign_impl	../include/Eigen/src/Core/Assign.h	/^struct unaligned_assign_impl<false>$/;"	s	namespace:Eigen::internal
Eigen::internal::unaligned_assign_impl	../include/Eigen/src/Core/Assign.h	/^struct unaligned_assign_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::unaligned_assign_impl::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_DONT_INLINE void run(const Derived& src, OtherDerived& dst, typename Derived::Index start, typename Derived::Index end)$/;"	f	struct:Eigen::internal::unaligned_assign_impl	access:public	signature:(const Derived& src, OtherDerived& dst, typename Derived::Index start, typename Derived::Index end)
Eigen::internal::unaligned_assign_impl::run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(const Derived&, OtherDerived&, typename Derived::Index, typename Derived::Index) {}$/;"	f	struct:Eigen::internal::unaligned_assign_impl	access:public	signature:(const Derived&, OtherDerived&, typename Derived::Index, typename Derived::Index)
Eigen::internal::unary_result_of_select	../include/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	s	namespace:Eigen::internal
Eigen::internal::unary_result_of_select	../include/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	s	namespace:Eigen::internal
Eigen::internal::unary_result_of_select	../include/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select {typedef ArgType type;};$/;"	s	namespace:Eigen::internal
Eigen::internal::unary_result_of_select::type	../include/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select	access:public
Eigen::internal::unary_result_of_select::type	../include/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select	access:public
Eigen::internal::unary_result_of_select::type	../include/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select {typedef ArgType type;};$/;"	t	struct:Eigen::internal::unary_result_of_select	access:public
Eigen::internal::unitOrthogonal_selector	../include/Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,2>$/;"	s	namespace:Eigen::internal
Eigen::internal::unitOrthogonal_selector	../include/Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,3>$/;"	s	namespace:Eigen::internal
Eigen::internal::unitOrthogonal_selector	../include/Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector$/;"	s	namespace:Eigen::internal
Eigen::internal::unitOrthogonal_selector::Index	../include/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Eigen::internal::unitOrthogonal_selector::RealScalar	../include/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Eigen::internal::unitOrthogonal_selector::run	../include/Eigen/src/Geometry/OrthoMethods.h	/^  static inline VectorType run(const Derived& src)$/;"	f	struct:Eigen::internal::unitOrthogonal_selector	access:public	signature:(const Derived& src)
Eigen::internal::unitOrthogonal_selector::Scalar	../include/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename traits<Derived>::Scalar Scalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Eigen::internal::unitOrthogonal_selector::Vector2	../include/Eigen/src/Geometry/OrthoMethods.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Eigen::internal::unitOrthogonal_selector::VectorType	../include/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename plain_matrix_type<Derived>::type VectorType;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Eigen::internal::unpacket_traits	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
Eigen::internal::unpacket_traits::size	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon251
Eigen::internal::unpacket_traits::size	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon254
Eigen::internal::unpacket_traits::size	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon255
Eigen::internal::unpacket_traits::size	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon257
Eigen::internal::unpacket_traits::size	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon260
Eigen::internal::unpacket_traits::size	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon261
Eigen::internal::unpacket_traits::size	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon240
Eigen::internal::unpacket_traits::size	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon238
Eigen::internal::unpacket_traits::size	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon248
Eigen::internal::unpacket_traits::size	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon247
Eigen::internal::unpacket_traits::size	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon249
Eigen::internal::unpacket_traits::type	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::unpacket_traits::type	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
Eigen::internal::UpperBidiagonalization::bidiagonal	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    const BidiagonalType& bidiagonal() const { return m_bidiagonal; }$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:() const
Eigen::internal::UpperBidiagonalization::BidiagonalType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef BandMatrix<RealScalar, ColsAtCompileTime, ColsAtCompileTime, 1, 0> BidiagonalType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::ColsAtCompileTime	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon420
Eigen::internal::UpperBidiagonalization::ColsAtCompileTimeMinusOne	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTimeMinusOne = internal::decrement_size<ColsAtCompileTime>::ret$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon420
Eigen::internal::UpperBidiagonalization::ColVectorType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::compute	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization& compute(const MatrixType& matrix);$/;"	p	class:Eigen::internal::UpperBidiagonalization	access:public	signature:(const MatrixType& matrix)
Eigen::internal::UpperBidiagonalization::compute	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^UpperBidiagonalization<_MatrixType>& UpperBidiagonalization<_MatrixType>::compute(const _MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization	signature:(const _MatrixType& matrix)
Eigen::internal::UpperBidiagonalization::DiagVectorType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1> DiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::householder	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    const MatrixType& householder() const { return m_householder; }$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:() const
Eigen::internal::UpperBidiagonalization::householderU	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    const HouseholderUSequenceType householderU() const$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:() const
Eigen::internal::UpperBidiagonalization::HouseholderUSequenceType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^            > HouseholderUSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::householderV	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    const HouseholderVSequenceType householderV() \/\/ const here gives nasty errors and i'm lazy$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:()
Eigen::internal::UpperBidiagonalization::HouseholderVSequenceType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^            > HouseholderVSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^template<typename _MatrixType> class UpperBidiagonalization$/;"	c	namespace:Eigen::internal
Eigen::internal::UpperBidiagonalization::Index	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::MatrixType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::m_bidiagonal	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    BidiagonalType m_bidiagonal;$/;"	m	class:Eigen::internal::UpperBidiagonalization	access:protected
Eigen::internal::UpperBidiagonalization::m_householder	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    MatrixType m_householder;$/;"	m	class:Eigen::internal::UpperBidiagonalization	access:protected
Eigen::internal::UpperBidiagonalization::m_isInitialized	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::internal::UpperBidiagonalization	access:protected
Eigen::internal::UpperBidiagonalization::RealScalar	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::RowsAtCompileTime	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon420
Eigen::internal::UpperBidiagonalization::RowVectorType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, 1, ColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::Scalar	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::SuperDiagVectorType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTimeMinusOne, 1> SuperDiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Eigen::internal::UpperBidiagonalization::UpperBidiagonalization	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:(const MatrixType& matrix)
Eigen::internal::UpperBidiagonalization::UpperBidiagonalization	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization() : m_householder(), m_bidiagonal(), m_isInitialized(false) {}$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:()
Eigen::internal::visitor_impl::col	../include/Eigen/src/Core/Visitor.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::visitor_impl::__anon51
Eigen::internal::visitor_impl	../include/Eigen/src/Core/Visitor.h	/^struct visitor_impl$/;"	s	namespace:Eigen::internal
Eigen::internal::visitor_impl	../include/Eigen/src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, 1>$/;"	s	namespace:Eigen::internal
Eigen::internal::visitor_impl	../include/Eigen/src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, Dynamic>$/;"	s	namespace:Eigen::internal
Eigen::internal::visitor_impl::Index	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::visitor_impl	access:public
Eigen::internal::visitor_impl::row	../include/Eigen/src/Core/Visitor.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::visitor_impl::__anon51
Eigen::internal::visitor_impl::run	../include/Eigen/src/Core/Visitor.h	/^  static inline void run(const Derived &mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl	access:public	signature:(const Derived &mat, Visitor& visitor)
Eigen::internal::visitor_impl::run	../include/Eigen/src/Core/Visitor.h	/^  static inline void run(const Derived& mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl	access:public	signature:(const Derived& mat, Visitor& visitor)
Eigen::internal::vld1_f32	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x2_t vld1_f32 (const float* x) { return ::vld1_f32 ((const float32_t*)x); }$/;"	f	namespace:Eigen::internal	signature:(const float* x)
Eigen::internal::vld1q_f32	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x4_t vld1q_f32(const float* x) { return ::vld1q_f32((const float32_t*)x); }$/;"	f	namespace:Eigen::internal	signature:(const float* x)
Eigen::internal::vml_assign_impl	../include/Eigen/src/Core/Assign_MKL.h	/^struct vml_assign_impl<Derived1, Derived2, UnaryOp, Traversal, Unrolling, InnerVectorizedTraversal>$/;"	s	namespace:Eigen::internal
Eigen::internal::vml_assign_impl	../include/Eigen/src/Core/Assign_MKL.h	/^struct vml_assign_impl<Derived1, Derived2, UnaryOp, Traversal, Unrolling, LinearVectorizedTraversal>$/;"	s	namespace:Eigen::internal
Eigen::internal::vml_assign_impl	../include/Eigen/src/Core/Assign_MKL.h	/^struct vml_assign_impl$/;"	s	namespace:Eigen::internal	inherits:assign_impl
Eigen::internal::vml_assign_impl::Index	../include/Eigen/src/Core/Assign_MKL.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::vml_assign_impl	access:public
Eigen::internal::vml_assign_impl::run	../include/Eigen/src/Core/Assign_MKL.h	/^  static inline void run(Derived1& dst, const CwiseUnaryOp<UnaryOp, Derived2>& src)$/;"	f	struct:Eigen::internal::vml_assign_impl	access:public	signature:(Derived1& dst, const CwiseUnaryOp<UnaryOp, Derived2>& src)
Eigen::internal::vml_assign_impl::Scalar	../include/Eigen/src/Core/Assign_MKL.h	/^  typedef typename Derived1::Scalar Scalar;$/;"	t	struct:Eigen::internal::vml_assign_impl	access:public
Eigen::internal::vml_assign_traits::DstHasDirectAccess	../include/Eigen/src/Core/Assign_MKL.h	/^      DstHasDirectAccess = Dst::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Eigen::internal::vml_assign_traits	../include/Eigen/src/Core/Assign_MKL.h	/^class vml_assign_traits$/;"	c	namespace:Eigen::internal
Eigen::internal::vml_assign_traits::InnerMaxSize	../include/Eigen/src/Core/Assign_MKL.h	/^      InnerMaxSize  = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Eigen::internal::vml_assign_traits::InnerSize	../include/Eigen/src/Core/Assign_MKL.h	/^      InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Eigen::internal::vml_assign_traits::LargeEnough	../include/Eigen/src/Core/Assign_MKL.h	/^      LargeEnough = VmlSize==Dynamic || VmlSize>=EIGEN_MKL_VML_THRESHOLD,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Eigen::internal::vml_assign_traits::MaxSizeAtCompileTime	../include/Eigen/src/Core/Assign_MKL.h	/^      MaxSizeAtCompileTime = Dst::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Eigen::internal::vml_assign_traits::MayEnableVml	../include/Eigen/src/Core/Assign_MKL.h	/^      MayEnableVml = MightEnableVml && LargeEnough,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Eigen::internal::vml_assign_traits::MayLinearize	../include/Eigen/src/Core/Assign_MKL.h	/^      MayLinearize = MayEnableVml && MightLinearize$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Eigen::internal::vml_assign_traits::MightEnableVml	../include/Eigen/src/Core/Assign_MKL.h	/^      MightEnableVml =  vml_call<UnaryOp>::IsSupported && StorageOrdersAgree && DstHasDirectAccess && SrcHasDirectAccess$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Eigen::internal::vml_assign_traits::MightLinearize	../include/Eigen/src/Core/Assign_MKL.h	/^      MightLinearize = MightEnableVml && (int(Dst::Flags) & int(Src::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Eigen::internal::vml_assign_traits::SrcHasDirectAccess	../include/Eigen/src/Core/Assign_MKL.h	/^      SrcHasDirectAccess = Src::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Eigen::internal::vml_assign_traits::StorageOrdersAgree	../include/Eigen/src/Core/Assign_MKL.h	/^      StorageOrdersAgree = (int(Dst::IsRowMajor) == int(Src::IsRowMajor)),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Eigen::internal::vml_assign_traits::Traversal	../include/Eigen/src/Core/Assign_MKL.h	/^      Traversal = MayLinearize ? LinearVectorizedTraversal$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon284
Eigen::internal::vml_assign_traits::VmlSize	../include/Eigen/src/Core/Assign_MKL.h	/^      VmlSize = MightLinearize ? MaxSizeAtCompileTime : InnerMaxSize,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Eigen::internal::vml_call	../include/Eigen/src/Core/Assign_MKL.h	/^template<typename Op> struct vml_call$/;"	s	namespace:Eigen::internal
Eigen::internal::vml_call::IsSupported	../include/Eigen/src/Core/Assign_MKL.h	/^{ enum { IsSupported = 0 }; };$/;"	e	enum:Eigen::internal::vml_call::__anon282
Eigen::internal::vst1_f32	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1_f32 (float* to, float32x2_t from) { ::vst1_f32 ((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, float32x2_t from)
Eigen::internal::vst1q_f32	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1q_f32(float* to, float32x4_t from) { ::vst1q_f32((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, float32x4_t from)
Eigen::internal::workaround_msvc_stl_support	../include/Eigen/src/StlSupport/details.h	/^  template<typename T> struct workaround_msvc_stl_support : public T$/;"	s	namespace:Eigen::internal	inherits:T
Eigen::internal::workaround_msvc_stl_support::operator const T&	../include/Eigen/src/StlSupport/details.h	/^    inline operator const T& () const { return *static_cast<const T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:() const
Eigen::internal::workaround_msvc_stl_support::operator =	../include/Eigen/src/StlSupport/details.h	/^    inline T& operator=(const OtherT& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:(const OtherT& other)
Eigen::internal::workaround_msvc_stl_support::operator =	../include/Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support& operator=(const workaround_msvc_stl_support& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:(const workaround_msvc_stl_support& other)
Eigen::internal::workaround_msvc_stl_support::operator T&	../include/Eigen/src/StlSupport/details.h	/^    inline operator T& () { return *static_cast<T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:()
Eigen::internal::workaround_msvc_stl_support::workaround_msvc_stl_support	../include/Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support(const T& other) : T(other) {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:(const T& other)
Eigen::internal::workaround_msvc_stl_support::workaround_msvc_stl_support	../include/Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support() : T() {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:()
Eigen::InvalidInput	../include/Eigen/src/Core/util/Constants.h	/^  InvalidInput = 3$/;"	e	enum:Eigen::ComputationInfo
Eigen::InvalidTraversal	../include/Eigen/src/Core/util/Constants.h	/^  InvalidTraversal$/;"	e	enum:Eigen::__anon209
EIGEN_INVERSE_H	../include/Eigen/src/LU/Inverse.h	26;"	d
EIGEN_INVERSE_SSE_H	../include/Eigen/src/LU/arch/Inverse_SSE.h	43;"	d
Eigen::IOFormat::coeffSeparator	../include/Eigen/src/Core/IO.h	/^  std::string coeffSeparator;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::flags	../include/Eigen/src/Core/IO.h	/^  int flags;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat	../include/Eigen/src/Core/IO.h	/^struct IOFormat$/;"	s	namespace:Eigen
Eigen::IOFormat::IOFormat	../include/Eigen/src/Core/IO.h	/^  IOFormat(int _precision = StreamPrecision, int _flags = 0,$/;"	f	struct:Eigen::IOFormat	access:public	signature:(int _precision = StreamPrecision, int _flags = 0, const std::string& _coeffSeparator = , const std::string& _rowSeparator = , const std::string& _rowPrefix=, const std::string& _rowSuffix=, const std::string& _matPrefix=, const std::string& _matSuffix=)
Eigen::IOFormat::matPrefix	../include/Eigen/src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::matSuffix	../include/Eigen/src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::precision	../include/Eigen/src/Core/IO.h	/^  int precision;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::rowPrefix	../include/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::rowSeparator	../include/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::rowSpacer	../include/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
Eigen::IOFormat::rowSuffix	../include/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
EIGEN_IO_H	../include/Eigen/src/Core/IO.h	27;"	d
Eigen::IsDense	../include/Eigen/src/Core/util/Constants.h	/^  IsDense         = 0,$/;"	e	enum:Eigen::__anon214
Eigen::is_diagonal	../include/Eigen/src/Core/util/Meta.h	/^template<typename T, int S> struct is_diagonal<DiagonalMatrix<T,S> >$/;"	s	namespace:Eigen
Eigen::is_diagonal	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_diagonal<DiagonalBase<T> >$/;"	s	namespace:Eigen
Eigen::is_diagonal	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_diagonal<DiagonalWrapper<T> >$/;"	s	namespace:Eigen
Eigen::is_diagonal	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_diagonal$/;"	s	namespace:Eigen
Eigen::is_diagonal::ret	../include/Eigen/src/Core/util/Meta.h	/^{ enum { ret = false }; };$/;"	e	enum:Eigen::is_diagonal::__anon197
Eigen::is_diagonal::ret	../include/Eigen/src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon198
Eigen::is_diagonal::ret	../include/Eigen/src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon199
Eigen::is_diagonal::ret	../include/Eigen/src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon200
Eigen::Isometry2d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Isometry> Isometry2d;$/;"	t	namespace:Eigen
Eigen::Isometry2f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Isometry> Isometry2f;$/;"	t	namespace:Eigen
Eigen::Isometry3d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Isometry> Isometry3d;$/;"	t	namespace:Eigen
Eigen::Isometry3f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Isometry> Isometry3f;$/;"	t	namespace:Eigen
Eigen::Isometry	../include/Eigen/src/Core/util/Constants.h	/^  Isometry      = 0x1,$/;"	e	enum:Eigen::TransformTraits
Eigen::IsSparse	../include/Eigen/src/Core/util/Constants.h	/^  IsSparse$/;"	e	enum:Eigen::__anon214
Eigen::IterativeSolverBase::analyzePattern	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& analyzePattern(const MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const MatrixType& A)
Eigen::IterativeSolverBase::cols	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index cols() const { return mp_matrix ? mp_matrix->cols() : 0; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::compute	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& compute(const MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const MatrixType& A)
Eigen::IterativeSolverBase::derived	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::derived	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
Eigen::IterativeSolverBase::error	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar error() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::factorize	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& factorize(const MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const MatrixType& A)
EIGEN_ITERATIVE_SOLVER_BASE_H	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	26;"	d
Eigen::IterativeSolverBase	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^class IterativeSolverBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::IterativeSolverBase::Index	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Eigen::IterativeSolverBase::info	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ComputationInfo info() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::init	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void init()$/;"	f	class:Eigen::IterativeSolverBase	access:protected	signature:()
Eigen::IterativeSolverBase::iterations	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int iterations() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::IterativeSolverBase	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase(const MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const MatrixType& A)
Eigen::IterativeSolverBase::~IterativeSolverBase	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ~IterativeSolverBase() {}$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
Eigen::IterativeSolverBase::IterativeSolverBase	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase()$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
Eigen::IterativeSolverBase::m_analysisIsOk	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::MatrixType	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Eigen::IterativeSolverBase::maxIterations	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int maxIterations() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::m_error	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable RealScalar m_error;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_factorizationIsOk	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_info	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable ComputationInfo m_info;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_isInitialized	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_iterations	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable int m_iterations;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_maxIterations	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int m_maxIterations;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::mp_matrix	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const MatrixType* mp_matrix;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_preconditioner	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner m_preconditioner;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::m_tolerance	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar m_tolerance;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
Eigen::IterativeSolverBase::preconditioner	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Preconditioner& preconditioner() const { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::preconditioner	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner& preconditioner() { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
Eigen::IterativeSolverBase::Preconditioner	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::Preconditioner Preconditioner;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Eigen::IterativeSolverBase::RealScalar	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Eigen::IterativeSolverBase::rows	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index rows() const { return mp_matrix ? mp_matrix->rows() : 0; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
Eigen::IterativeSolverBase::Scalar	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Eigen::IterativeSolverBase::setMaxIterations	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setMaxIterations(int maxIters)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(int maxIters)
Eigen::IterativeSolverBase::setTolerance	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setTolerance(RealScalar tolerance)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(RealScalar tolerance)
Eigen::IterativeSolverBase::solve	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::IterativeSolverBase::solve	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
Eigen::IterativeSolverBase::_solve_sparse	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
Eigen::IterativeSolverBase::tolerance	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar tolerance() const { return m_tolerance; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
EIGEN_JACOBI_H	../include/Eigen/src/Jacobi/Jacobi.h	27;"	d
Eigen::JacobiRotation::adjoint	../include/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation adjoint() const { return JacobiRotation(internal::conj(m_c), -m_s); }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
Eigen::JacobiRotation::c	../include/Eigen/src/Jacobi/Jacobi.h	/^    Scalar c() const { return m_c; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
Eigen::JacobiRotation::c	../include/Eigen/src/Jacobi/Jacobi.h	/^    Scalar& c() { return m_c; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:()
Eigen::JacobiRotation	../include/Eigen/src/Jacobi/Jacobi.h	/^template<typename Scalar> class JacobiRotation$/;"	c	namespace:Eigen
Eigen::JacobiRotation::JacobiRotation	../include/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation(const Scalar& c, const Scalar& s) : m_c(c), m_s(s) {}$/;"	f	class:Eigen::JacobiRotation	access:public	signature:(const Scalar& c, const Scalar& s)
Eigen::JacobiRotation::JacobiRotation	../include/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation() {}$/;"	f	class:Eigen::JacobiRotation	access:public	signature:()
Eigen::JacobiRotation::makeGivens	../include/Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)$/;"	f	class:Eigen::JacobiRotation	signature:(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)
Eigen::JacobiRotation::makeGivens	../include/Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)$/;"	f	class:Eigen::JacobiRotation	signature:(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)
Eigen::JacobiRotation::makeGivens	../include/Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* z)$/;"	f	class:Eigen::JacobiRotation	signature:(const Scalar& p, const Scalar& q, Scalar* z)
Eigen::JacobiRotation::makeGivens	../include/Eigen/src/Jacobi/Jacobi.h	/^    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z=0);$/;"	p	class:Eigen::JacobiRotation	access:public	signature:(const Scalar& p, const Scalar& q, Scalar* z=0)
Eigen::JacobiRotation::makeGivens	../include/Eigen/src/Jacobi/Jacobi.h	/^    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z, internal::false_type);$/;"	p	class:Eigen::JacobiRotation	access:protected	signature:(const Scalar& p, const Scalar& q, Scalar* z, internal::false_type)
Eigen::JacobiRotation::makeGivens	../include/Eigen/src/Jacobi/Jacobi.h	/^    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z, internal::true_type);$/;"	p	class:Eigen::JacobiRotation	access:protected	signature:(const Scalar& p, const Scalar& q, Scalar* z, internal::true_type)
Eigen::JacobiRotation::makeJacobi	../include/Eigen/src/Jacobi/Jacobi.h	/^bool JacobiRotation<Scalar>::makeJacobi(RealScalar x, Scalar y, RealScalar z)$/;"	f	class:Eigen::JacobiRotation	signature:(RealScalar x, Scalar y, RealScalar z)
Eigen::JacobiRotation::makeJacobi	../include/Eigen/src/Jacobi/Jacobi.h	/^    bool makeJacobi(const MatrixBase<Derived>&, typename Derived::Index p, typename Derived::Index q);$/;"	p	class:Eigen::JacobiRotation	access:public	signature:(const MatrixBase<Derived>&, typename Derived::Index p, typename Derived::Index q)
Eigen::JacobiRotation::makeJacobi	../include/Eigen/src/Jacobi/Jacobi.h	/^    bool makeJacobi(RealScalar x, Scalar y, RealScalar z);$/;"	p	class:Eigen::JacobiRotation	access:public	signature:(RealScalar x, Scalar y, RealScalar z)
Eigen::JacobiRotation::makeJacobi	../include/Eigen/src/Jacobi/Jacobi.h	/^inline bool JacobiRotation<Scalar>::makeJacobi(const MatrixBase<Derived>& m, typename Derived::Index p, typename Derived::Index q)$/;"	f	class:Eigen::JacobiRotation	signature:(const MatrixBase<Derived>& m, typename Derived::Index p, typename Derived::Index q)
Eigen::JacobiRotation::m_c	../include/Eigen/src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation	access:protected
Eigen::JacobiRotation::m_s	../include/Eigen/src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation	access:protected
Eigen::JacobiRotation::operator *	../include/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation operator*(const JacobiRotation& other)$/;"	f	class:Eigen::JacobiRotation	access:public	signature:(const JacobiRotation& other)
Eigen::JacobiRotation::RealScalar	../include/Eigen/src/Jacobi/Jacobi.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiRotation	access:public
Eigen::JacobiRotation::s	../include/Eigen/src/Jacobi/Jacobi.h	/^    Scalar s() const { return m_s; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
Eigen::JacobiRotation::s	../include/Eigen/src/Jacobi/Jacobi.h	/^    Scalar& s() { return m_s; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:()
Eigen::JacobiRotation::transpose	../include/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation transpose() const { return JacobiRotation(m_c, -internal::conj(m_s)); }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
Eigen::JacobiSVD::allocate	../include/Eigen/src/SVD/JacobiSVD.h	/^    void allocate(Index rows, Index cols, unsigned int computationOptions);$/;"	p	class:Eigen::JacobiSVD	access:private	signature:(Index rows, Index cols, unsigned int computationOptions)
Eigen::JacobiSVD::allocate	../include/Eigen/src/SVD/JacobiSVD.h	/^void JacobiSVD<MatrixType, QRPreconditioner>::allocate(Index rows, Index cols, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD	signature:(Index rows, Index cols, unsigned int computationOptions)
Eigen::JacobiSVD::ColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon419
Eigen::JacobiSVD::cols	../include/Eigen/src/SVD/JacobiSVD.h	/^    inline Index cols() const { return m_cols; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::ColType	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::compute	../include/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD& compute(const MatrixType& matrix)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const MatrixType& matrix)
Eigen::JacobiSVD::compute	../include/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD& compute(const MatrixType& matrix, unsigned int computationOptions);$/;"	p	class:Eigen::JacobiSVD	access:public	signature:(const MatrixType& matrix, unsigned int computationOptions)
Eigen::JacobiSVD::compute	../include/Eigen/src/SVD/JacobiSVD.h	/^JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType& matrix, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD	signature:(const MatrixType& matrix, unsigned int computationOptions)
Eigen::JacobiSVD::computeU	../include/Eigen/src/SVD/JacobiSVD.h	/^    inline bool computeU() const { return m_computeFullU || m_computeThinU; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::computeV	../include/Eigen/src/SVD/JacobiSVD.h	/^    inline bool computeV() const { return m_computeFullV || m_computeThinV; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::DiagSizeAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^      DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon419
EIGEN_JACOBISVD_H	../include/Eigen/src/SVD/JacobiSVD.h	26;"	d
Eigen::JacobiSVD	../include/Eigen/src/SVD/JacobiSVD.h	/^template<typename _MatrixType, int QRPreconditioner> class JacobiSVD$/;"	c	namespace:Eigen
Eigen::JacobiSVD::Index	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::JacobiSVD	../include/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD(const MatrixType& matrix, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const MatrixType& matrix, unsigned int computationOptions = 0)
Eigen::JacobiSVD::JacobiSVD	../include/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD()$/;"	f	class:Eigen::JacobiSVD	access:public	signature:()
Eigen::JacobiSVD::JacobiSVD	../include/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD(Index rows, Index cols, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(Index rows, Index cols, unsigned int computationOptions = 0)
Eigen::JacobiSVD::MatrixOptions	../include/Eigen/src/SVD/JacobiSVD.h	/^      MatrixOptions = MatrixType::Options$/;"	e	enum:Eigen::JacobiSVD::__anon419
Eigen::JacobiSVD::MatrixType	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::matrixU	../include/Eigen/src/SVD/JacobiSVD.h	/^    const MatrixUType& matrixU() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::MatrixUType	../include/Eigen/src/SVD/JacobiSVD.h	/^            MatrixUType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::matrixV	../include/Eigen/src/SVD/JacobiSVD.h	/^    const MatrixVType& matrixV() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::MatrixVType	../include/Eigen/src/SVD/JacobiSVD.h	/^            MatrixVType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::MaxColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon419
Eigen::JacobiSVD::MaxDiagSizeAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^      MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime,MaxColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon419
Eigen::JacobiSVD::MaxRowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon419
Eigen::JacobiSVD::m_cols	../include/Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_computationOptions	../include/Eigen/src/SVD/JacobiSVD.h	/^    unsigned int m_computationOptions;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_computeFullU	../include/Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_computeFullV	../include/Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_computeThinU	../include/Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_computeThinV	../include/Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_diagSize	../include/Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_isAllocated	../include/Eigen/src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_isInitialized	../include/Eigen/src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated;$/;"	m	class:Eigen::JacobiSVD	access:protected
EIGEN_JACOBISVD_MKL_H	../include/Eigen/src/SVD/JacobiSVD_MKL.h	34;"	d
Eigen::JacobiSVD::m_matrixU	../include/Eigen/src/SVD/JacobiSVD.h	/^    MatrixUType m_matrixU;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_matrixV	../include/Eigen/src/SVD/JacobiSVD.h	/^    MatrixVType m_matrixV;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_nonzeroSingularValues	../include/Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_qr_precond_morecols	../include/Eigen/src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows> m_qr_precond_morecols;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_qr_precond_morerows	../include/Eigen/src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols> m_qr_precond_morerows;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_rows	../include/Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_singularValues	../include/Eigen/src/SVD/JacobiSVD.h	/^    SingularValuesType m_singularValues;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::m_workMatrix	../include/Eigen/src/SVD/JacobiSVD.h	/^    WorkMatrixType m_workMatrix;$/;"	m	class:Eigen::JacobiSVD	access:protected
Eigen::JacobiSVD::nonzeroSingularValues	../include/Eigen/src/SVD/JacobiSVD.h	/^    Index nonzeroSingularValues() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::RealScalar	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::RowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon419
Eigen::JacobiSVD::rows	../include/Eigen/src/SVD/JacobiSVD.h	/^    inline Index rows() const { return m_rows; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::RowType	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::Scalar	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::singularValues	../include/Eigen/src/SVD/JacobiSVD.h	/^    const SingularValuesType& singularValues() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
Eigen::JacobiSVD::SingularValuesType	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_diag_type<MatrixType, RealScalar>::type SingularValuesType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::JacobiSVD::solve	../include/Eigen/src/SVD/JacobiSVD.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::JacobiSVD::WorkMatrixType	../include/Eigen/src/SVD/JacobiSVD.h	/^            WorkMatrixType;$/;"	t	class:Eigen::JacobiSVD	access:public
Eigen::l1CacheSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l1CacheSize()$/;"	f	namespace:Eigen	signature:()
Eigen::l2CacheSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l2CacheSize()$/;"	f	namespace:Eigen	signature:()
Eigen::Large	../include/Eigen/src/Core/GeneralProduct.h	/^  Large = 2,$/;"	e	enum:Eigen::__anon120
Eigen::LazyCoeffBasedProductMode	../include/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon215
EIGEN_LAZY_H	../include/Eigen/src/Eigen2Support/Lazy.h	26;"	d
Eigen::LazyProductReturnType	../include/Eigen/src/Core/GeneralProduct.h	/^struct LazyProductReturnType : public ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen	inherits:ProductReturnType
Eigen::LDLT::ColsAtCompileTime	../include/Eigen/src/Cholesky/LDLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon405
Eigen::LDLT::cols	../include/Eigen/src/Cholesky/LDLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::compute	../include/Eigen/src/Cholesky/LDLT.h	/^    LDLT& compute(const MatrixType& matrix);$/;"	p	class:Eigen::LDLT	access:public	signature:(const MatrixType& matrix)
Eigen::LDLT::compute	../include/Eigen/src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::compute(const MatrixType& a)$/;"	f	class:Eigen::LDLT	signature:(const MatrixType& a)
EIGEN_LDLT_H	../include/Eigen/src/Cholesky/LDLT.h	29;"	d
Eigen::LDLT	../include/Eigen/src/Cholesky/LDLT.h	/^template<typename _MatrixType, int _UpLo> class LDLT$/;"	c	namespace:Eigen
Eigen::LDLT::Index	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::info	../include/Eigen/src/Cholesky/LDLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::isNegative	../include/Eigen/src/Cholesky/LDLT.h	/^    inline bool isNegative(void) const$/;"	f	class:Eigen::LDLT	access:public	signature:(void) const
Eigen::LDLT::isPositiveDefinite	../include/Eigen/src/Cholesky/LDLT.h	/^    inline bool isPositiveDefinite() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::isPositive	../include/Eigen/src/Cholesky/LDLT.h	/^    inline bool isPositive() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::LDLT	../include/Eigen/src/Cholesky/LDLT.h	/^    LDLT(const MatrixType& matrix)$/;"	f	class:Eigen::LDLT	access:public	signature:(const MatrixType& matrix)
Eigen::LDLT::LDLT	../include/Eigen/src/Cholesky/LDLT.h	/^    LDLT(Index size)$/;"	f	class:Eigen::LDLT	access:public	signature:(Index size)
Eigen::LDLT::LDLT	../include/Eigen/src/Cholesky/LDLT.h	/^    LDLT() : m_matrix(), m_transpositions(), m_isInitialized(false) {}$/;"	f	class:Eigen::LDLT	access:public	signature:()
Eigen::LDLT::matrixLDLT	../include/Eigen/src/Cholesky/LDLT.h	/^    inline const MatrixType& matrixLDLT() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::matrixL	../include/Eigen/src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::MatrixType	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::matrixU	../include/Eigen/src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::MaxColsAtCompileTime	../include/Eigen/src/Cholesky/LDLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon405
Eigen::LDLT::MaxRowsAtCompileTime	../include/Eigen/src/Cholesky/LDLT.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon405
Eigen::LDLT::m_isInitialized	../include/Eigen/src/Cholesky/LDLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LDLT	access:protected
Eigen::LDLT::m_matrix	../include/Eigen/src/Cholesky/LDLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LDLT	access:protected
Eigen::LDLT::m_sign	../include/Eigen/src/Cholesky/LDLT.h	/^    int m_sign;$/;"	m	class:Eigen::LDLT	access:protected
Eigen::LDLT::m_temporary	../include/Eigen/src/Cholesky/LDLT.h	/^    TmpMatrixType m_temporary;$/;"	m	class:Eigen::LDLT	access:protected
Eigen::LDLT::m_transpositions	../include/Eigen/src/Cholesky/LDLT.h	/^    TranspositionType m_transpositions;$/;"	m	class:Eigen::LDLT	access:protected
Eigen::LDLT::Options	../include/Eigen/src/Cholesky/LDLT.h	/^      Options = MatrixType::Options & ~RowMajorBit, \/\/ these are the options for the TmpMatrixType, we need a ColMajor matrix here!$/;"	e	enum:Eigen::LDLT::__anon405
Eigen::LDLT::PermutationType	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::rankUpdate	../include/Eigen/src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::rankUpdate(const MatrixBase<Derived>& w,typename NumTraits<typename MatrixType::Scalar>::Real sigma)$/;"	f	class:Eigen::LDLT	signature:(const MatrixBase<Derived>& w,typename NumTraits<typename MatrixType::Scalar>::Real sigma)
Eigen::LDLT::rankUpdate	../include/Eigen/src/Cholesky/LDLT.h	/^    LDLT& rankUpdate(const MatrixBase<Derived>& w,RealScalar alpha=1);$/;"	p	class:Eigen::LDLT	access:public	signature:(const MatrixBase<Derived>& w,RealScalar alpha=1)
Eigen::LDLT::RealScalar	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::reconstructedMatrix	../include/Eigen/src/Cholesky/LDLT.h	/^MatrixType LDLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LDLT	signature:() const
Eigen::LDLT::reconstructedMatrix	../include/Eigen/src/Cholesky/LDLT.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::RowsAtCompileTime	../include/Eigen/src/Cholesky/LDLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon405
Eigen::LDLT::rows	../include/Eigen/src/Cholesky/LDLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::Scalar	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::setZero	../include/Eigen/src/Cholesky/LDLT.h	/^    void setZero()$/;"	f	class:Eigen::LDLT	access:public	signature:()
Eigen::LDLT::solve	../include/Eigen/src/Cholesky/LDLT.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LDLT	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
Eigen::LDLT::solve	../include/Eigen/src/Cholesky/LDLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LDLT	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::LDLT::solveInPlace	../include/Eigen/src/Cholesky/LDLT.h	/^bool LDLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LDLT	signature:(MatrixBase<Derived> &bAndX) const
Eigen::LDLT::solveInPlace	../include/Eigen/src/Cholesky/LDLT.h	/^    bool solveInPlace(MatrixBase<Derived> &bAndX) const;$/;"	p	class:Eigen::LDLT	access:public	signature:(MatrixBase<Derived> &bAndX) const
Eigen::LDLT::TmpMatrixType	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1, Options, MaxRowsAtCompileTime, 1> TmpMatrixType;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::Traits	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef internal::LDLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::transpositionsP	../include/Eigen/src/Cholesky/LDLT.h	/^    inline const TranspositionType& transpositionsP() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LDLT::TranspositionType	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::LDLT	access:public
Eigen::LDLT::UpLo	../include/Eigen/src/Cholesky/LDLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LDLT::__anon405
Eigen::LDLT::vectorD	../include/Eigen/src/Cholesky/LDLT.h	/^    inline Diagonal<const MatrixType> vectorD() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
Eigen::LinearAccessBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int LinearAccessBit = 0x10;$/;"	m	namespace:Eigen
Eigen::linearRegression	../include/Eigen/src/Eigen2Support/LeastSquares.h	/^void linearRegression(int numPoints,$/;"	f	namespace:Eigen	signature:(int numPoints, VectorType **points, VectorType *result, int funcOfOthers )
Eigen::LinearTraversal	../include/Eigen/src/Core/util/Constants.h	/^  LinearTraversal,$/;"	e	enum:Eigen::__anon209
Eigen::LinearVectorizedTraversal	../include/Eigen/src/Core/util/Constants.h	/^  LinearVectorizedTraversal,$/;"	e	enum:Eigen::__anon209
Eigen::LLT::AlignmentMask	../include/Eigen/src/Cholesky/LLT.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::LLT::__anon404
Eigen::LLT::ColsAtCompileTime	../include/Eigen/src/Cholesky/LLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon403
Eigen::LLT::cols	../include/Eigen/src/Cholesky/LLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::compute	../include/Eigen/src/Cholesky/LLT.h	/^    LLT& compute(const MatrixType& matrix);$/;"	p	class:Eigen::LLT	access:public	signature:(const MatrixType& matrix)
Eigen::LLT::compute	../include/Eigen/src/Cholesky/LLT.h	/^LLT<MatrixType,_UpLo>& LLT<MatrixType,_UpLo>::compute(const MatrixType& a)$/;"	f	class:Eigen::LLT	signature:(const MatrixType& a)
EIGEN_LLT_H	../include/Eigen/src/Cholesky/LLT.h	26;"	d
Eigen::LLT	../include/Eigen/src/Cholesky/LLT.h	/^template<typename _MatrixType, int _UpLo> class LLT$/;"	c	namespace:Eigen
Eigen::LLT::Index	../include/Eigen/src/Cholesky/LLT.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::LLT	access:public
Eigen::LLT::info	../include/Eigen/src/Cholesky/LLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::isPositiveDefinite	../include/Eigen/src/Cholesky/LLT.h	/^    bool isPositiveDefinite() const { return true; }$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::LLT	../include/Eigen/src/Cholesky/LLT.h	/^    LLT(const MatrixType& matrix)$/;"	f	class:Eigen::LLT	access:public	signature:(const MatrixType& matrix)
Eigen::LLT::LLT	../include/Eigen/src/Cholesky/LLT.h	/^    LLT(Index size) : m_matrix(size, size),$/;"	f	class:Eigen::LLT	access:public	signature:(Index size)
Eigen::LLT::LLT	../include/Eigen/src/Cholesky/LLT.h	/^    LLT() : m_matrix(), m_isInitialized(false) {}$/;"	f	class:Eigen::LLT	access:public	signature:()
Eigen::LLT::matrixL	../include/Eigen/src/Cholesky/LLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::matrixLLT	../include/Eigen/src/Cholesky/LLT.h	/^    inline const MatrixType& matrixLLT() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::MatrixType	../include/Eigen/src/Cholesky/LLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LLT	access:public
Eigen::LLT::matrixU	../include/Eigen/src/Cholesky/LLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::MaxColsAtCompileTime	../include/Eigen/src/Cholesky/LLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::LLT::__anon403
Eigen::LLT::m_info	../include/Eigen/src/Cholesky/LLT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::LLT	access:protected
Eigen::LLT::m_isInitialized	../include/Eigen/src/Cholesky/LLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LLT	access:protected
EIGEN_LLT_MKL_H	../include/Eigen/src/Cholesky/LLT_MKL.h	34;"	d
Eigen::LLT::m_matrix	../include/Eigen/src/Cholesky/LLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LLT	access:protected
Eigen::LLT::Options	../include/Eigen/src/Cholesky/LLT.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::LLT::__anon403
Eigen::LLT::PacketSize	../include/Eigen/src/Cholesky/LLT.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::LLT::__anon404
Eigen::LLT::rankUpdate	../include/Eigen/src/Cholesky/LLT.h	/^LLT<_MatrixType,_UpLo> LLT<_MatrixType,_UpLo>::rankUpdate(const VectorType& v, const RealScalar& sigma)$/;"	f	class:Eigen::LLT	signature:(const VectorType& v, const RealScalar& sigma)
Eigen::LLT::rankUpdate	../include/Eigen/src/Cholesky/LLT.h	/^    LLT rankUpdate(const VectorType& vec, const RealScalar& sigma = 1);$/;"	p	class:Eigen::LLT	access:public	signature:(const VectorType& vec, const RealScalar& sigma = 1)
Eigen::LLT::RealScalar	../include/Eigen/src/Cholesky/LLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LLT	access:public
Eigen::LLT::reconstructedMatrix	../include/Eigen/src/Cholesky/LLT.h	/^MatrixType LLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LLT	signature:() const
Eigen::LLT::reconstructedMatrix	../include/Eigen/src/Cholesky/LLT.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::RowsAtCompileTime	../include/Eigen/src/Cholesky/LLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon403
Eigen::LLT::rows	../include/Eigen/src/Cholesky/LLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LLT	access:public	signature:() const
Eigen::LLT::Scalar	../include/Eigen/src/Cholesky/LLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LLT	access:public
Eigen::LLT::solve	../include/Eigen/src/Cholesky/LLT.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LLT	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
Eigen::LLT::solve	../include/Eigen/src/Cholesky/LLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LLT	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::LLT::solveInPlace	../include/Eigen/src/Cholesky/LLT.h	/^void LLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LLT	signature:(MatrixBase<Derived> &bAndX) const
Eigen::LLT::solveInPlace	../include/Eigen/src/Cholesky/LLT.h	/^    void solveInPlace(MatrixBase<Derived> &bAndX) const;$/;"	p	class:Eigen::LLT	access:public	signature:(MatrixBase<Derived> &bAndX) const
Eigen::LLT::Traits	../include/Eigen/src/Cholesky/LLT.h	/^    typedef internal::LLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LLT	access:public
Eigen::LLT::UpLo	../include/Eigen/src/Cholesky/LLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LLT::__anon404
EIGEN_LOGICAL_XOR	../include/Eigen/src/Core/util/Macros.h	402;"	d
Eigen::Lower	../include/Eigen/src/Core/util/Constants.h	/^  Lower=0x1,                      $/;"	e	enum:Eigen::__anon207
Eigen::LowerTriangularBit	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int LowerTriangularBit = Lower;$/;"	m	namespace:Eigen
Eigen::LowerTriangular	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int LowerTriangular = Lower;$/;"	m	namespace:Eigen
Eigen::LU::Base	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef FullPivLU<MatrixType> Base;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::ColVectorType	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1, MatrixType::Options, MatrixType::MaxRowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::computeImage	../include/Eigen/src/Eigen2Support/LU.h	/^    void computeImage(ImageMatrixType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(ImageMatrixType *result) const
Eigen::LU::computeInverse	../include/Eigen/src/Eigen2Support/LU.h	/^    inline void computeInverse(ResultType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(ResultType *result) const
Eigen::LU::computeKernel	../include/Eigen/src/Eigen2Support/LU.h	/^    void computeKernel(KernelMatrixType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(KernelMatrixType *result) const
EIGEN_LU_H	../include/Eigen/src/LU/FullPivLU.h	26;"	d
Eigen::LU::image	../include/Eigen/src/Eigen2Support/LU.h	/^    const ImageResultType image() const$/;"	f	class:Eigen::LU	access:public	signature:() const
Eigen::LU::ImageResultType	../include/Eigen/src/Eigen2Support/LU.h	/^    > ImageResultType;$/;"	t	class:Eigen::LU	access:public
Eigen::LU	../include/Eigen/src/Eigen2Support/LU.h	/^class LU : public FullPivLU<MatrixType>$/;"	c	namespace:Eigen	inherits:FullPivLU
Eigen::LU::IntColVectorType	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1, MatrixType::Options, MatrixType::MaxRowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::IntRowVectorType	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime, MatrixType::Options, 1, MatrixType::MaxColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::KernelResultType	../include/Eigen/src/Eigen2Support/LU.h	/^    > KernelResultType;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::LU	../include/Eigen/src/Eigen2Support/LU.h	/^    explicit LU(const T& t) : Base(t), m_originalMatrix(t) {}$/;"	f	class:Eigen::LU	access:public	signature:(const T& t)
Eigen::LU::m_originalMatrix	../include/Eigen/src/Eigen2Support/LU.h	/^    const MatrixType& m_originalMatrix;$/;"	m	class:Eigen::LU	access:public
Eigen::LU::RealScalar	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::RowVectorType	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<Scalar, 1, MatrixType::ColsAtCompileTime, MatrixType::Options, 1, MatrixType::MaxColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::Scalar	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LU	access:public
Eigen::LU::solve	../include/Eigen/src/Eigen2Support/LU.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
Eigen::LvalueBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int LvalueBit = 0x20;$/;"	m	namespace:Eigen
Eigen::machine_epsilon	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T machine_epsilon () { return NumTraits<T>::epsilon(); }$/;"	f	namespace:Eigen	signature:()
EIGEN_MACROS_H	../include/Eigen/src/Core/util/Macros.h	27;"	d
EIGEN_MAJOR_VERSION	../include/Eigen/src/Core/util/Macros.h	30;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF	../include/Eigen/src/Core/util/Memory.h	615;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE	../include/Eigen/src/Core/util/Memory.h	640;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW	../include/Eigen/src/Core/util/Memory.h	639;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW	../include/Eigen/src/Core/util/Memory.h	602;"	d
EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS	../include/Eigen/src/Core/Array.h	277;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES	../include/Eigen/src/Core/Array.h	283;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES	../include/Eigen/src/Core/Array.h	298;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS	../include/Eigen/src/Core/Array.h	271;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS	../include/Eigen/src/Core/Array.h	299;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_LARGE	../include/Eigen/src/Core/Array.h	301;"	d
EIGEN_MAKE_CWISE_BINARY_OP	../include/Eigen/src/Core/util/Macros.h	406;"	d
EIGEN_MAKE_FIXED_TYPEDEFS	../include/Eigen/src/Core/Matrix.h	393;"	d
EIGEN_MAKE_FIXED_TYPEDEFS	../include/Eigen/src/Core/Matrix.h	416;"	d
EIGEN_MAKE_IMAGE_HELPERS	../include/Eigen/src/misc/Image.h	83;"	d
EIGEN_MAKE_KERNEL_HELPERS	../include/Eigen/src/misc/Kernel.h	82;"	d
EIGEN_MAKE_SCALAR_CWISE_UNARY_OP	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	189;"	d
EIGEN_MAKE_SOLVE_HELPERS	../include/Eigen/src/misc/Solve.h	76;"	d
EIGEN_MAKE_SPARSE_SOLVE_HELPERS	../include/Eigen/src/misc/SparseSolve.h	69;"	d
EIGEN_MAKESTRING2	../include/Eigen/src/Core/util/Macros.h	130;"	d
EIGEN_MAKESTRING	../include/Eigen/src/Core/util/Macros.h	131;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	../include/Eigen/src/Core/Matrix.h	399;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	../include/Eigen/src/Core/Matrix.h	414;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	../include/Eigen/src/Geometry/AlignedBox.h	374;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	../include/Eigen/src/Geometry/AlignedBox.h	385;"	d
EIGEN_MAKE_TYPEDEFS	../include/Eigen/src/Core/Matrix.h	385;"	d
EIGEN_MAKE_TYPEDEFS	../include/Eigen/src/Core/Matrix.h	415;"	d
EIGEN_MAKE_TYPEDEFS	../include/Eigen/src/Geometry/AlignedBox.h	370;"	d
EIGEN_MAKE_TYPEDEFS	../include/Eigen/src/Geometry/AlignedBox.h	386;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	../include/Eigen/src/Core/DenseStorage.h	58;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	../include/Eigen/src/Core/DenseStorage.h	60;"	d
EIGEN_MALLOC_ALREADY_ALIGNED	../include/Eigen/src/Core/util/Memory.h	65;"	d
EIGEN_MALLOC_ALREADY_ALIGNED	../include/Eigen/src/Core/util/Memory.h	67;"	d
Eigen::MapBase::Base	../include/Eigen/src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::Base	../include/Eigen/src/Core/MapBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::checkSanity	../include/Eigen/src/Core/MapBase.h	/^    void checkSanity() const$/;"	f	class:Eigen::MapBase	access:protected	signature:() const
Eigen::MapBase::coeff	../include/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeff(Index index) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index) const
Eigen::MapBase::coeff	../include/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeff(Index row, Index col) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col) const
Eigen::MapBase::coeffRef	../include/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index) const
Eigen::MapBase::coeffRef	../include/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col) const
Eigen::MapBase::coeffRef	../include/Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index)
Eigen::MapBase::coeffRef	../include/Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col)
Eigen::MapBase::CoeffReturnType	../include/Eigen/src/Core/MapBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::ColsAtCompileTime	../include/Eigen/src/Core/MapBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon76
Eigen::MapBase::cols	../include/Eigen/src/Core/MapBase.h	/^    inline Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
Eigen::MapBase::data	../include/Eigen/src/Core/MapBase.h	/^    inline const Scalar* data() const { return m_data; }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
Eigen::MapBase::data	../include/Eigen/src/Core/MapBase.h	/^    inline const Scalar* data() const { return this->m_data; }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
Eigen::MapBase::data	../include/Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue* data() { return this->m_data; } \/\/ no const-cast here so non-const-correct code will give a compile error$/;"	f	class:Eigen::MapBase	access:public	signature:()
EIGEN_MAPBASE_H	../include/Eigen/src/Core/MapBase.h	27;"	d
Eigen::MapBase	../include/Eigen/src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::MapBase	../include/Eigen/src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, WriteAccessors>$/;"	c	namespace:Eigen	inherits:MapBase
Eigen::Map::Base	../include/Eigen/src/Core/Map.h	/^    typedef MapBase<Map> Base;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::Base	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<Map> Base;$/;"	t	class:Eigen::Map	access:private
Eigen::Map::Base	../include/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<Map> Base;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::Base	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<const Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map	access:private
Eigen::Map::Base	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map	access:private
Eigen::MapBase::Index	../include/Eigen/src/Core/MapBase.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::Index	../include/Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::MapBase	../include/Eigen/src/Core/MapBase.h	/^    explicit inline MapBase(PointerType data) : Base(data) {}$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType data)
Eigen::MapBase::MapBase	../include/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data, Index rows, Index cols) : Base(data, rows, cols) {}$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType data, Index rows, Index cols)
Eigen::MapBase::MapBase	../include/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data, Index rows, Index cols)$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType data, Index rows, Index cols)
Eigen::MapBase::MapBase	../include/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data, Index size) : Base(data, size) {}$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType data, Index size)
Eigen::MapBase::MapBase	../include/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data, Index size)$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType data, Index size)
Eigen::MapBase::MapBase	../include/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data) : m_data(data), m_rows(RowsAtCompileTime), m_cols(ColsAtCompileTime)$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType data)
Eigen::MapBase::m_cols	../include/Eigen/src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::MapBase	access:protected
Eigen::MapBase::m_data	../include/Eigen/src/Core/MapBase.h	/^    PointerType m_data;$/;"	m	class:Eigen::MapBase	access:protected
Eigen::MapBase::m_rows	../include/Eigen/src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::MapBase	access:protected
Eigen::MapBase::operator =	../include/Eigen/src/Core/MapBase.h	/^    Derived& operator=(const MapBase& other)$/;"	f	class:Eigen::MapBase	access:public	signature:(const MapBase& other)
Eigen::MapBase::packet	../include/Eigen/src/Core/MapBase.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index) const
Eigen::MapBase::packet	../include/Eigen/src/Core/MapBase.h	/^    inline PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col) const
Eigen::MapBase::PacketScalar	../include/Eigen/src/Core/MapBase.h	/^    typedef typename Base::PacketScalar PacketScalar;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::PacketScalar	../include/Eigen/src/Core/MapBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::PointerType	../include/Eigen/src/Core/MapBase.h	/^                     PointerType;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::PointerType	../include/Eigen/src/Core/MapBase.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::RealScalar	../include/Eigen/src/Core/MapBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::RowsAtCompileTime	../include/Eigen/src/Core/MapBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon76
Eigen::MapBase::rows	../include/Eigen/src/Core/MapBase.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
Eigen::MapBase::Scalar	../include/Eigen/src/Core/MapBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::Scalar	../include/Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::ScalarWithConstIfNotLvalue	../include/Eigen/src/Core/MapBase.h	/^                  >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::SizeAtCompileTime	../include/Eigen/src/Core/MapBase.h	/^      SizeAtCompileTime = Base::SizeAtCompileTime$/;"	e	enum:Eigen::MapBase::__anon76
Eigen::MapBase::StorageKind	../include/Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MapBase	access:public
Eigen::MapBase::writePacket	../include/Eigen/src/Core/MapBase.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index, const PacketScalar& x)
Eigen::MapBase::writePacket	../include/Eigen/src/Core/MapBase.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col, const PacketScalar& x)
Eigen::Map::cast_to_pointer_type	../include/Eigen/src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return const_cast<PointerType>(ptr); }$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType ptr)
Eigen::Map::cast_to_pointer_type	../include/Eigen/src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return ptr; }$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType ptr)
Eigen::Map::Coefficients	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef typename internal::traits<Map>::Coefficients Coefficients;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^    inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Map	access:public	signature:()
Eigen::Map::coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^    inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Map	access:public	signature:() const
Eigen::Map::coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^    inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Map	access:public	signature:() const
EIGEN_MAP_H	../include/Eigen/src/Core/Map.h	27;"	d
Eigen::Map	../include/Eigen/src/Core/Map.h	/^template<typename PlainObjectType, int MapOptions, typename StrideType> class Map$/;"	c	namespace:Eigen	inherits:MapBase
Eigen::Map	../include/Eigen/src/Core/PermutationMatrix.h	/^class Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess>$/;"	c	namespace:Eigen	inherits:PermutationBase
Eigen::Map	../include/Eigen/src/Core/Transpositions.h	/^class Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,PacketAccess>$/;"	c	namespace:Eigen	inherits:TranspositionsBase
Eigen::Map	../include/Eigen/src/Geometry/Quaternion.h	/^class Map<const Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen	inherits:QuaternionBase
Eigen::Map	../include/Eigen/src/Geometry/Quaternion.h	/^class Map<Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen	inherits:QuaternionBase
Eigen::Map::Index	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::Index	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:() const
Eigen::Map::indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:()
Eigen::Map::indices	../include/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:() const
Eigen::Map::indices	../include/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:()
Eigen::Map::IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::IndicesType	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::innerStride	../include/Eigen/src/Core/Map.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Map	access:public	signature:() const
Eigen::Map::Map	../include/Eigen/src/Core/Map.h	/^    inline Map(PointerArgType data, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType data, const StrideType& stride = StrideType())
Eigen::Map::Map	../include/Eigen/src/Core/Map.h	/^    inline Map(PointerArgType data, Index rows, Index cols, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType data, Index rows, Index cols, const StrideType& stride = StrideType())
Eigen::Map::Map	../include/Eigen/src/Core/Map.h	/^    inline Map(PointerArgType data, Index size, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType data, Index size, const StrideType& stride = StrideType())
Eigen::Map::Map	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Map(const Index* indices)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indices)
Eigen::Map::Map	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Map(const Index* indices, Index size)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indices, Index size)
Eigen::Map::Map	../include/Eigen/src/Core/Transpositions.h	/^    inline Map(const Index* indices)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indices)
Eigen::Map::Map	../include/Eigen/src/Core/Transpositions.h	/^    inline Map(const Index* indices, Index size)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indices, Index size)
Eigen::Map::Map	../include/Eigen/src/Geometry/Quaternion.h	/^    EIGEN_STRONG_INLINE Map(const Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map	access:public	signature:(const Scalar* coeffs)
Eigen::Map::Map	../include/Eigen/src/Geometry/Quaternion.h	/^    EIGEN_STRONG_INLINE Map(Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map	access:public	signature:(Scalar* coeffs)
Eigen::Map::m_coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^    Coefficients m_coeffs;$/;"	m	class:Eigen::Map	access:protected
Eigen::Map::m_coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^    const Coefficients m_coeffs;$/;"	m	class:Eigen::Map	access:protected
Eigen::Map::m_indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map	access:protected
Eigen::Map::m_indices	../include/Eigen/src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map	access:protected
Eigen::Map::m_stride	../include/Eigen/src/Core/Map.h	/^    StrideType m_stride;$/;"	m	class:Eigen::Map	access:protected
Eigen::Map::operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map	access:public	signature:(const Map& other)
Eigen::Map::operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::Map	access:public	signature:(const PermutationBase<Other>& other)
Eigen::Map::operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::Map	access:public	signature:(const TranspositionsBase<Other>& tr)
Eigen::Map::operator =	../include/Eigen/src/Core/Transpositions.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map	access:public	signature:(const Map& other)
Eigen::Map::operator =	../include/Eigen/src/Core/Transpositions.h	/^    Map& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Map	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
Eigen::Map::outerStride	../include/Eigen/src/Core/Map.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Map	access:public	signature:() const
Eigen::MappedSparseMatrix::coeff	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:(Index row, Index col) const
Eigen::MappedSparseMatrix::coeffRef	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:(Index row, Index col)
Eigen::MappedSparseMatrix::cols	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
EIGEN_MAPPED_SPARSEMATRIX_H	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	26;"	d
Eigen::MappedSparseMatrix	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::MappedSparseMatrix::innerIndexPtr	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline const Index* innerIndexPtr() const { return m_innerIndices; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::innerIndexPtr	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index* innerIndexPtr() { return m_innerIndices; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
Eigen::MappedSparseMatrix::InnerIterator::col	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::InnerIterator	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix<Scalar,_Flags,_Index>::InnerIterator$/;"	c	class:Eigen::MappedSparseMatrix
Eigen::MappedSparseMatrix::InnerIterator::index	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index index() const { return m_matrix.innerIndexPtr()[m_id]; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    InnerIterator(const MappedSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:(const MappedSparseMatrix& mat, Index outer)
Eigen::MappedSparseMatrix::InnerIterator::m_end	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
Eigen::MappedSparseMatrix::InnerIterator::m_id	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
Eigen::MappedSparseMatrix::InnerIterator::m_matrix	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const MappedSparseMatrix& m_matrix;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
Eigen::MappedSparseMatrix::InnerIterator::m_outer	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
Eigen::MappedSparseMatrix::InnerIterator::m_start	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
Eigen::MappedSparseMatrix::InnerIterator::operator bool	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end) && (m_id>=m_start); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::InnerIterator::operator ++	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:()
Eigen::MappedSparseMatrix::InnerIterator::row	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::InnerIterator::value	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_id]; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::InnerIterator::valueRef	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_id]); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:()
Eigen::MappedSparseMatrix::innerSize	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::IsRowMajor	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::MappedSparseMatrix::__anon15
Eigen::MappedSparseMatrix::~MappedSparseMatrix	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline ~MappedSparseMatrix() {}$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
Eigen::MappedSparseMatrix::MappedSparseMatrix	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline MappedSparseMatrix(Index rows, Index cols, Index nnz, Index* outerIndexPtr, Index* innerIndexPtr, Scalar* valuePtr)$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:(Index rows, Index cols, Index nnz, Index* outerIndexPtr, Index* innerIndexPtr, Scalar* valuePtr)
Eigen::MappedSparseMatrix::m_innerIndices	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index*  m_innerIndices;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
Eigen::MappedSparseMatrix::m_innerSize	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index   m_innerSize;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
Eigen::MappedSparseMatrix::m_nnz	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index   m_nnz;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
Eigen::MappedSparseMatrix::m_outerIndex	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index*  m_outerIndex;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
Eigen::MappedSparseMatrix::m_outerSize	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index   m_outerSize;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
Eigen::MappedSparseMatrix::m_values	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Scalar* m_values;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
Eigen::MappedSparseMatrix::nonZeros	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index nonZeros() const  { return m_nnz; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::outerIndexPtr	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline const Index* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::outerIndexPtr	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
Eigen::MappedSparseMatrix::outerSize	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::ReverseInnerIterator::col	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::ReverseInnerIterator	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix<Scalar,_Flags,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::MappedSparseMatrix
Eigen::MappedSparseMatrix::ReverseInnerIterator::index	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index index() const { return m_matrix.innerIndexPtr()[m_id-1]; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::ReverseInnerIterator::m_end	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
Eigen::MappedSparseMatrix::ReverseInnerIterator::m_id	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
Eigen::MappedSparseMatrix::ReverseInnerIterator::m_matrix	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const MappedSparseMatrix& m_matrix;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
Eigen::MappedSparseMatrix::ReverseInnerIterator::m_outer	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
Eigen::MappedSparseMatrix::ReverseInnerIterator::m_start	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
Eigen::MappedSparseMatrix::ReverseInnerIterator::operator bool	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline operator bool() const { return (m_id <= m_end) && (m_id>m_start); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::ReverseInnerIterator::operator --	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline ReverseInnerIterator& operator--() { m_id--; return *this; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:()
Eigen::MappedSparseMatrix::ReverseInnerIterator::ReverseInnerIterator	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    ReverseInnerIterator(const MappedSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:(const MappedSparseMatrix& mat, Index outer)
Eigen::MappedSparseMatrix::ReverseInnerIterator::row	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::ReverseInnerIterator::value	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_id-1]; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::MappedSparseMatrix::ReverseInnerIterator::valueRef	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_id-1]); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:()
Eigen::MappedSparseMatrix::rows	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::valuePtr	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline const Scalar* valuePtr() const { return m_values; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
Eigen::MappedSparseMatrix::valuePtr	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar* valuePtr() { return m_values; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
Eigen::Map::PointerArgType	../include/Eigen/src/Core/Map.h	/^    typedef const Scalar* PointerArgType;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::PointerArgType	../include/Eigen/src/Core/Map.h	/^    typedef PointerType PointerArgType;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::PointerType	../include/Eigen/src/Core/Map.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::Scalar	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::Map	access:public
Eigen::Map::Traits	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map	access:private
Eigen::Map::Traits	../include/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map	access:private
EIGEN_MATHFUNC_IMPL	../include/Eigen/src/Core/MathFunctions.h	69;"	d
EIGEN_MATHFUNC_RETVAL	../include/Eigen/src/Core/MathFunctions.h	70;"	d
EIGEN_MATHFUNC_STANDARD_REAL_UNARY	../include/Eigen/src/Core/MathFunctions.h	470;"	d
EIGEN_MATHFUNCTIONS_H	../include/Eigen/src/Core/MathFunctions.h	26;"	d
EIGEN_MATH_FUNCTIONS_SSE_H	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	31;"	d
Eigen::MatrixBase::adjoint	../include/Eigen/src/Core/MatrixBase.h	/^    const AdjointReturnType adjoint() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::adjoint	../include/Eigen/src/Core/Transpose.h	/^MatrixBase<Derived>::adjoint() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::adjointInPlace	../include/Eigen/src/Core/MatrixBase.h	/^    void adjointInPlace();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::adjointInPlace	../include/Eigen/src/Core/Transpose.h	/^inline void MatrixBase<Derived>::adjointInPlace()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::AdjointReturnType	../include/Eigen/src/Core/MatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::applyHouseholderOnTheLeft	../include/Eigen/src/Core/MatrixBase.h	/^    void applyHouseholderOnTheLeft(const EssentialPart& essential,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
Eigen::MatrixBase::applyHouseholderOnTheLeft	../include/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheLeft($/;"	f	class:Eigen::MatrixBase	signature:( const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
Eigen::MatrixBase::applyHouseholderOnTheRight	../include/Eigen/src/Core/MatrixBase.h	/^    void applyHouseholderOnTheRight(const EssentialPart& essential,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
Eigen::MatrixBase::applyHouseholderOnTheRight	../include/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheRight($/;"	f	class:Eigen::MatrixBase	signature:( const EssentialPart& essential, const Scalar& tau, Scalar* workspace)
Eigen::MatrixBase::applyOnTheLeft	../include/Eigen/src/Core/EigenBase.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived> &other)
Eigen::MatrixBase::applyOnTheLeft	../include/Eigen/src/Core/MatrixBase.h	/^    void applyOnTheLeft(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::MatrixBase::applyOnTheLeft	../include/Eigen/src/Core/MatrixBase.h	/^    void applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
Eigen::MatrixBase::applyOnTheLeft	../include/Eigen/src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
Eigen::MatrixBase::applyOnTheRight	../include/Eigen/src/Core/EigenBase.h	/^inline void MatrixBase<Derived>::applyOnTheRight(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived> &other)
Eigen::MatrixBase::applyOnTheRight	../include/Eigen/src/Core/MatrixBase.h	/^    void applyOnTheRight(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::MatrixBase::applyOnTheRight	../include/Eigen/src/Core/MatrixBase.h	/^    void applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
Eigen::MatrixBase::applyOnTheRight	../include/Eigen/src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase	signature:(Index p, Index q, const JacobiRotation<OtherScalar>& j)
Eigen::MatrixBase::array	../include/Eigen/src/Core/MatrixBase.h	/^    ArrayWrapper<Derived> array() { return derived(); }$/;"	f	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::array	../include/Eigen/src/Core/MatrixBase.h	/^    const ArrayWrapper<const Derived> array() const { return derived(); }$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::asDiagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^MatrixBase<Derived>::asDiagonal() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::asDiagonal	../include/Eigen/src/Core/MatrixBase.h	/^    const DiagonalWrapper<const Derived> asDiagonal() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::asPermutation	../include/Eigen/src/Core/MatrixBase.h	/^    const PermutationWrapper<const Derived> asPermutation() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::asPermutation	../include/Eigen/src/Core/PermutationMatrix.h	/^const PermutationWrapper<const Derived> MatrixBase<Derived>::asPermutation() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::Base	../include/Eigen/src/Core/MatrixBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::BasisReturnType	../include/Eigen/src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime> BasisReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::blueNorm	../include/Eigen/src/Core/MatrixBase.h	/^    RealScalar blueNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::blueNorm	../include/Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::CoeffReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::colPivHouseholderQr	../include/Eigen/src/Core/MatrixBase.h	/^    const ColPivHouseholderQR<PlainObject> colPivHouseholderQr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::colPivHouseholderQr	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^MatrixBase<Derived>::colPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::ColXpr	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::ColXpr ColXpr;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::computeInverseAndDetWithCheck	../include/Eigen/src/Core/MatrixBase.h	/^    void computeInverseAndDetWithCheck($/;"	p	class:Eigen::MatrixBase	access:public	signature:( ResultType& inverse, typename ResultType::Scalar& determinant, bool& invertible, const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision() ) const
Eigen::MatrixBase::computeInverseAndDetWithCheck	../include/Eigen/src/LU/Inverse.h	/^inline void MatrixBase<Derived>::computeInverseAndDetWithCheck($/;"	f	class:Eigen::MatrixBase	signature:( ResultType& inverse, typename ResultType::Scalar& determinant, bool& invertible, const RealScalar& absDeterminantThreshold ) const
Eigen::MatrixBase::computeInverse	../include/Eigen/src/Core/MatrixBase.h	/^    void computeInverse(MatrixBase<ResultType> *result) const {$/;"	f	class:Eigen::MatrixBase	access:public	signature:(MatrixBase<ResultType> *result) const
Eigen::MatrixBase::computeInverseWithCheck	../include/Eigen/src/Core/MatrixBase.h	/^    void computeInverseWithCheck($/;"	p	class:Eigen::MatrixBase	access:public	signature:( ResultType& inverse, bool& invertible, const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision() ) const
Eigen::MatrixBase::computeInverseWithCheck	../include/Eigen/src/LU/Inverse.h	/^inline void MatrixBase<Derived>::computeInverseWithCheck($/;"	f	class:Eigen::MatrixBase	signature:( ResultType& inverse, bool& invertible, const RealScalar& absDeterminantThreshold ) const
Eigen::MatrixBase::ConstantReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstDiagonalIndexReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstDiagonalIndexReturnType::Type	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstDiagonalIndexReturnType	access:public
Eigen::MatrixBase::ConstDiagonalReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef const Diagonal<const Derived> ConstDiagonalReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstSelfAdjointViewReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstSelfAdjointViewReturnType::Type	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstSelfAdjointViewReturnType	access:public
Eigen::MatrixBase::ConstStartMinusOne	../include/Eigen/src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime==1 ? 1 : SizeMinusOne> ConstStartMinusOne;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstTransposeReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::ConstTransposeReturnType ConstTransposeReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstTriangularViewReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::ConstTriangularViewReturnType::Type	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstTriangularViewReturnType	access:public
Eigen::MatrixBase::cosh	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> cosh() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::cos	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> cos() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::cross3	../include/Eigen/src/Core/MatrixBase.h	/^    PlainObject cross3(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::cross3	../include/Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross3(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::cross	../include/Eigen/src/Core/MatrixBase.h	/^    cross(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::cross	../include/Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::cross_product_return_type	../include/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> struct cross_product_return_type {$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::cross_product_return_type::Scalar	../include/Eigen/src/Core/MatrixBase.h	/^      typedef typename internal::scalar_product_traits<typename internal::traits<Derived>::Scalar,typename internal::traits<OtherDerived>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type	access:public
Eigen::MatrixBase::cross_product_return_type::type	../include/Eigen/src/Core/MatrixBase.h	/^      typedef Matrix<Scalar,MatrixBase::RowsAtCompileTime,MatrixBase::ColsAtCompileTime> type;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type	access:public
Eigen::MatrixBase::cwise	../include/Eigen/src/Core/MatrixBase.h	/^    inline const Cwise<Derived> cwise() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::cwise	../include/Eigen/src/Core/MatrixBase.h	/^    inline Cwise<Derived> cwise();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::cwise	../include/Eigen/src/Eigen2Support/Cwise.h	/^inline const Cwise<Derived> MatrixBase<Derived>::cwise() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::cwise	../include/Eigen/src/Eigen2Support/Cwise.h	/^inline Cwise<Derived> MatrixBase<Derived>::cwise()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::determinant	../include/Eigen/src/Core/MatrixBase.h	/^    Scalar determinant() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::determinant	../include/Eigen/src/LU/Determinant.h	/^inline typename internal::traits<Derived>::Scalar MatrixBase<Derived>::determinant() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    const ConstDiagonalReturnType diagonal() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    DiagonalReturnType diagonal();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Index> typename ConstDiagonalIndexReturnType<Index>::Type diagonal() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Index> typename DiagonalIndexReturnType<Index>::Type diagonal();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    typename ConstDiagonalIndexReturnType<Dynamic>::Type diagonal(Index index) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index index) const
Eigen::MatrixBase::diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    typename DiagonalIndexReturnType<Dynamic>::Type diagonal(Index index);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index index)
Eigen::MatrixBase::diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    typename MatrixBase::template ConstDiagonalIndexReturnType<Dynamic>::Type diagonal(Index index) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index index) const
Eigen::MatrixBase::diagonal	../include/Eigen/src/Core/MatrixBase.h	/^    typename MatrixBase::template DiagonalIndexReturnType<Dynamic>::Type diagonal(Index index);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index index)
Eigen::MatrixBase::DiagonalIndexReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::DiagonalIndexReturnType::Type	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::DiagonalIndexReturnType	access:public
Eigen::MatrixBase::DiagonalReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef Diagonal<Derived> DiagonalReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::diagonalSize	../include/Eigen/src/Core/MatrixBase.h	/^    inline Index diagonalSize() const { return (std::min)(rows(),cols()); }$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::dot	../include/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::dot	../include/Eigen/src/Core/MatrixBase.h	/^    dot(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::eigen2_dot	../include/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::eigen2_dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::eigen2_dot	../include/Eigen/src/Core/MatrixBase.h	/^      Scalar eigen2_dot(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::eigen2_lu	../include/Eigen/src/Core/MatrixBase.h	/^    const LU<PlainObject> eigen2_lu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::eigen2_lu	../include/Eigen/src/Eigen2Support/LU.h	/^MatrixBase<Derived>::eigen2_lu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
EIGEN_MATRIXBASEEIGENVALUES_H	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	27;"	d
Eigen::MatrixBase::eigenvalues	../include/Eigen/src/Core/MatrixBase.h	/^    EigenvaluesReturnType eigenvalues() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::eigenvalues	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::eigenvalues() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::EigenvaluesReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef Matrix<std::complex<RealScalar>, internal::traits<Derived>::ColsAtCompileTime, 1, ColMajor> EigenvaluesReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::end	../include/Eigen/src/Core/MatrixBase.h	/^    const VectorBlock<const Derived> end(Index size) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size) const
Eigen::MatrixBase::end	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Size> const VectorBlock<const Derived,Size> end() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::end	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Size> VectorBlock<Derived,Size> end();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::end	../include/Eigen/src/Core/MatrixBase.h	/^    VectorBlock<Derived> end(Index size);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size)
Eigen::MatrixBase::end	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::end	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::end	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end(Index size) const$/;"	f	class:Eigen::MatrixBase	signature:(Index size) const
Eigen::MatrixBase::end	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end(Index size)$/;"	f	class:Eigen::MatrixBase	signature:(Index size)
Eigen::MatrixBase::eulerAngles	../include/Eigen/src/Core/MatrixBase.h	/^    Matrix<Scalar,3,1> eulerAngles(Index a0, Index a1, Index a2) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index a0, Index a1, Index a2) const
Eigen::MatrixBase::eulerAngles	../include/Eigen/src/Geometry/EulerAngles.h	/^MatrixBase<Derived>::eulerAngles(Index a0, Index a1, Index a2) const$/;"	f	class:Eigen::MatrixBase	signature:(Index a0, Index a1, Index a2) const
Eigen::MatrixBase::exp	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixExponentialReturnValue<Derived> exp() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::forceAlignedAccessIf	../include/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::forceAlignedAccessIf	../include/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::forceAlignedAccessIf	../include/Eigen/src/Core/MatrixBase.h	/^    template<bool Enable> inline typename internal::add_const_on_value_type<typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type>::type forceAlignedAccessIf() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::forceAlignedAccessIf	../include/Eigen/src/Core/MatrixBase.h	/^    template<bool Enable> inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::forceAlignedAccess	../include/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::forceAlignedAccess	../include/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::forceAlignedAccess	../include/Eigen/src/Core/MatrixBase.h	/^    inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::forceAlignedAccess	../include/Eigen/src/Core/MatrixBase.h	/^    inline ForceAlignedAccess<Derived> forceAlignedAccess();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::fullPivHouseholderQr	../include/Eigen/src/Core/MatrixBase.h	/^    const FullPivHouseholderQR<PlainObject> fullPivHouseholderQr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::fullPivHouseholderQr	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^MatrixBase<Derived>::fullPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::fullPivLu	../include/Eigen/src/Core/MatrixBase.h	/^    const FullPivLU<PlainObject> fullPivLu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::fullPivLu	../include/Eigen/src/LU/FullPivLU.h	/^MatrixBase<Derived>::fullPivLu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
EIGEN_MATRIXBASE_H	../include/Eigen/src/Core/MatrixBase.h	27;"	d
Eigen::MatrixBase::hnormalized	../include/Eigen/src/Core/MatrixBase.h	/^    const HNormalizedReturnType hnormalized() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::hnormalized	../include/Eigen/src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::hnormalized() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::HNormalizedReturnType	../include/Eigen/src/Core/MatrixBase.h	/^                const ConstStartMinusOne > HNormalizedReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::homogeneous	../include/Eigen/src/Core/MatrixBase.h	/^    HomogeneousReturnType homogeneous() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::homogeneous	../include/Eigen/src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::homogeneous() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::HomogeneousReturnTypeDirection	../include/Eigen/src/Core/MatrixBase.h	/^    enum { HomogeneousReturnTypeDirection = ColsAtCompileTime==1?Vertical:Horizontal };$/;"	e	enum:Eigen::MatrixBase::__anon149
Eigen::MatrixBase::HomogeneousReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef Homogeneous<Derived, HomogeneousReturnTypeDirection> HomogeneousReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::householderQr	../include/Eigen/src/Core/MatrixBase.h	/^    const HouseholderQR<PlainObject> householderQr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::householderQr	../include/Eigen/src/QR/HouseholderQR.h	/^MatrixBase<Derived>::householderQr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::hypotNorm	../include/Eigen/src/Core/MatrixBase.h	/^    RealScalar hypotNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::hypotNorm	../include/Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::hypotNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::Identity	../include/Eigen/src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::Identity	../include/Eigen/src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity(Index rows, Index cols)$/;"	f	class:Eigen::MatrixBase	signature:(Index rows, Index cols)
Eigen::MatrixBase::Identity	../include/Eigen/src/Core/MatrixBase.h	/^    static const IdentityReturnType Identity(Index rows, Index cols);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index rows, Index cols)
Eigen::MatrixBase::Identity	../include/Eigen/src/Core/MatrixBase.h	/^    static const IdentityReturnType Identity();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::IdentityReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_identity_op<Scalar>,Derived> IdentityReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase	../include/Eigen/src/Core/MatrixBase.h	/^template<typename Derived> class MatrixBase$/;"	c	namespace:Eigen	inherits:DenseBase
Eigen::Matrix::Base	../include/Eigen/src/Core/Matrix.h	/^    typedef PlainObjectBase<Matrix> Base;$/;"	t	class:Eigen::Matrix	access:public
Eigen::MatrixBase::Index	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::inverse	../include/Eigen/src/Core/MatrixBase.h	/^    const internal::inverse_impl<Derived> inverse() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::inverse	../include/Eigen/src/LU/Inverse.h	/^inline const internal::inverse_impl<Derived> MatrixBase<Derived>::inverse() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::isDiagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^bool MatrixBase<Derived>::isDiagonal(RealScalar prec) const$/;"	f	class:Eigen::MatrixBase	signature:(RealScalar prec) const
Eigen::MatrixBase::isDiagonal	../include/Eigen/src/Core/MatrixBase.h	/^    bool isDiagonal(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::isIdentity	../include/Eigen/src/Core/CwiseNullaryOp.h	/^bool MatrixBase<Derived>::isIdentity$/;"	f	class:Eigen::MatrixBase	signature:(RealScalar prec) const
Eigen::MatrixBase::isIdentity	../include/Eigen/src/Core/MatrixBase.h	/^    bool isIdentity(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::isLowerTriangular	../include/Eigen/src/Core/MatrixBase.h	/^    bool isLowerTriangular(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::isLowerTriangular	../include/Eigen/src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isLowerTriangular(RealScalar prec) const$/;"	f	class:Eigen::MatrixBase	signature:(RealScalar prec) const
Eigen::MatrixBase::isOrthogonal	../include/Eigen/src/Core/Dot.h	/^bool MatrixBase<Derived>::isOrthogonal$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other, RealScalar prec) const
Eigen::MatrixBase::isOrthogonal	../include/Eigen/src/Core/MatrixBase.h	/^    bool isOrthogonal(const MatrixBase<OtherDerived>& other,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::isUnitary	../include/Eigen/src/Core/Dot.h	/^bool MatrixBase<Derived>::isUnitary(RealScalar prec) const$/;"	f	class:Eigen::MatrixBase	signature:(RealScalar prec) const
Eigen::MatrixBase::isUnitary	../include/Eigen/src/Core/MatrixBase.h	/^    bool isUnitary(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::isUpperTriangular	../include/Eigen/src/Core/MatrixBase.h	/^    bool isUpperTriangular(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::isUpperTriangular	../include/Eigen/src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isUpperTriangular(RealScalar prec) const$/;"	f	class:Eigen::MatrixBase	signature:(RealScalar prec) const
Eigen::MatrixBase::jacobiSvd	../include/Eigen/src/Core/MatrixBase.h	/^    JacobiSVD<PlainObject> jacobiSvd(unsigned int computationOptions = 0) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(unsigned int computationOptions = 0) const
Eigen::MatrixBase::jacobiSvd	../include/Eigen/src/SVD/JacobiSVD.h	/^MatrixBase<Derived>::jacobiSvd(unsigned int computationOptions) const$/;"	f	class:Eigen::MatrixBase	signature:(unsigned int computationOptions) const
Eigen::MatrixBase::lazyAssign	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& lazyAssign(const Flagged<OtherDerived, 0, EvalBeforeAssigningBit>& other)$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const Flagged<OtherDerived, 0, EvalBeforeAssigningBit>& other)
Eigen::MatrixBase::lazyAssign	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& lazyAssign(const ProductBase<ProductDerived, Lhs,Rhs>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::MatrixBase::lazyAssign	../include/Eigen/src/Core/ProductBase.h	/^Derived& MatrixBase<Derived>::lazyAssign(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::MatrixBase::lazy	../include/Eigen/src/Core/MatrixBase.h	/^    const Flagged<Derived, 0, EvalBeforeAssigningBit> lazy() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::lazy	../include/Eigen/src/Eigen2Support/Lazy.h	/^MatrixBase<Derived>::lazy() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::lazyProduct	../include/Eigen/src/Core/GeneralProduct.h	/^MatrixBase<Derived>::lazyProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::MatrixBase::lazyProduct	../include/Eigen/src/Core/MatrixBase.h	/^    lazyProduct(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::MatrixBase::ldlt	../include/Eigen/src/Cholesky/LDLT.h	/^MatrixBase<Derived>::ldlt() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::ldlt	../include/Eigen/src/Core/MatrixBase.h	/^    const LDLT<PlainObject> ldlt() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::llt	../include/Eigen/src/Cholesky/LLT.h	/^MatrixBase<Derived>::llt() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::llt	../include/Eigen/src/Core/MatrixBase.h	/^    const LLT<PlainObject>  llt() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::log	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixLogarithmReturnValue<Derived> log() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::lpNorm	../include/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::lpNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::lpNorm	../include/Eigen/src/Core/MatrixBase.h	/^    template<int p> RealScalar lpNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::lu	../include/Eigen/src/Core/MatrixBase.h	/^    const LU<PlainObject> lu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::lu	../include/Eigen/src/Core/MatrixBase.h	/^    const PartialPivLU<PlainObject> lu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::lu	../include/Eigen/src/Eigen2Support/LU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::lu	../include/Eigen/src/LU/PartialPivLU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::makeHouseholder	../include/Eigen/src/Core/MatrixBase.h	/^    void makeHouseholder(EssentialPart& essential,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(EssentialPart& essential, Scalar& tau, RealScalar& beta) const
Eigen::MatrixBase::makeHouseholder	../include/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholder($/;"	f	class:Eigen::MatrixBase	signature:( EssentialPart& essential, Scalar& tau, RealScalar& beta) const
Eigen::MatrixBase::makeHouseholderInPlace	../include/Eigen/src/Core/MatrixBase.h	/^    void makeHouseholderInPlace(Scalar& tau, RealScalar& beta);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Scalar& tau, RealScalar& beta)
Eigen::MatrixBase::makeHouseholderInPlace	../include/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholderInPlace(Scalar& tau, RealScalar& beta)$/;"	f	class:Eigen::MatrixBase	signature:(Scalar& tau, RealScalar& beta)
Eigen::MatrixBase::marked	../include/Eigen/src/Core/MatrixBase.h	/^    const Flagged<Derived, Added, 0> marked() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::marked	../include/Eigen/src/Eigen2Support/Lazy.h	/^MatrixBase<Derived>::marked() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::MatrixBase	../include/Eigen/src/Core/MatrixBase.h	/^    explicit MatrixBase(int);$/;"	p	class:Eigen::MatrixBase	access:private	signature:(int)
Eigen::MatrixBase::MatrixBase	../include/Eigen/src/Core/MatrixBase.h	/^    MatrixBase() : Base() {}$/;"	f	class:Eigen::MatrixBase	access:protected	signature:()
Eigen::MatrixBase::MatrixBase	../include/Eigen/src/Core/MatrixBase.h	/^    MatrixBase(int,int);$/;"	p	class:Eigen::MatrixBase	access:private	signature:(int,int)
Eigen::MatrixBase::MatrixBase	../include/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> explicit MatrixBase(const MatrixBase<OtherDerived>&);$/;"	p	class:Eigen::MatrixBase	access:private	signature:(const MatrixBase<OtherDerived>&)
Eigen::MatrixBase::matrixFunction	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> matrixFunction(StemFunction f) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(StemFunction f) const
Eigen::MatrixBase::matrix	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixBase<Derived>& matrix() const { return *this; }$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::matrix	../include/Eigen/src/Core/MatrixBase.h	/^    MatrixBase<Derived>& matrix() { return *this; }$/;"	f	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::minor	../include/Eigen/src/Core/MatrixBase.h	/^    const Minor<Derived> minor(Index row, Index col) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index row, Index col) const
Eigen::MatrixBase::minor	../include/Eigen/src/Core/MatrixBase.h	/^    Minor<Derived> minor(Index row, Index col);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index row, Index col)
Eigen::MatrixBase::minor	../include/Eigen/src/Eigen2Support/Minor.h	/^MatrixBase<Derived>::minor(Index row, Index col) const$/;"	f	class:Eigen::MatrixBase	signature:(Index row, Index col) const
Eigen::MatrixBase::minor	../include/Eigen/src/Eigen2Support/Minor.h	/^MatrixBase<Derived>::minor(Index row, Index col)$/;"	f	class:Eigen::MatrixBase	signature:(Index row, Index col)
Eigen::MatrixBase::noalias	../include/Eigen/src/Core/MatrixBase.h	/^    NoAlias<Derived,Eigen::MatrixBase > noalias();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::noalias	../include/Eigen/src/Core/NoAlias.h	/^NoAlias<Derived,MatrixBase> MatrixBase<Derived>::noalias()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::normalized	../include/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::normalized() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::normalized	../include/Eigen/src/Core/MatrixBase.h	/^    const PlainObject normalized() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::normalize	../include/Eigen/src/Core/Dot.h	/^inline void MatrixBase<Derived>::normalize()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::normalize	../include/Eigen/src/Core/MatrixBase.h	/^    void normalize();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::norm	../include/Eigen/src/Core/Dot.h	/^inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::norm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::norm	../include/Eigen/src/Core/MatrixBase.h	/^    RealScalar norm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::operator =	../include/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const DenseBase<OtherDerived>& other)
Eigen::MatrixBase::operator =	../include/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived>& other)
Eigen::MatrixBase::operator =	../include/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const MatrixBase& other)$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase& other)
Eigen::MatrixBase::operator =	../include/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::MatrixBase::operator -=	../include/Eigen/src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator-=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived> &other)
Eigen::MatrixBase::operator +=	../include/Eigen/src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator+=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other)
Eigen::MatrixBase::operator *	../include/Eigen/src/Core/DiagonalProduct.h	/^MatrixBase<Derived>::operator*(const DiagonalBase<DiagonalDerived> &diagonal) const$/;"	f	class:Eigen::MatrixBase	signature:(const DiagonalBase<DiagonalDerived> &diagonal) const
Eigen::MatrixBase::operator *=	../include/Eigen/src/Core/EigenBase.h	/^MatrixBase<Derived>::operator*=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived> &other)
Eigen::MatrixBase::operator *	../include/Eigen/src/Core/GeneralProduct.h	/^MatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::MatrixBase::operator =	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator=(const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::MatrixBase::operator =	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator=(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::MatrixBase::operator *=	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator*=(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::MatrixBase::operator -=	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator-=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
Eigen::MatrixBase::operator +=	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator+=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
Eigen::MatrixBase::operator -=	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator-=(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::MatrixBase::operator +=	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator+=(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::MatrixBase::operator =	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator=(const MatrixBase& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase& other)
Eigen::MatrixBase::operator =	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::MatrixBase::operator ==	../include/Eigen/src/Core/MatrixBase.h	/^    inline bool operator==(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::operator !=	../include/Eigen/src/Core/MatrixBase.h	/^    inline bool operator!=(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::MatrixBase::operator *	../include/Eigen/src/Core/MatrixBase.h	/^    operator*(const DiagonalBase<DiagonalDerived> &diagonal) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const DiagonalBase<DiagonalDerived> &diagonal) const
Eigen::MatrixBase::operator *	../include/Eigen/src/Core/MatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::MatrixBase::operator *	../include/Eigen/src/Core/MatrixBase.h	/^    ScalarMultipleReturnType operator*(const UniformScaling<Scalar>& s) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const UniformScaling<Scalar>& s) const
Eigen::MatrixBase::operator -=	../include/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator-=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase	access:protected	signature:(const ArrayBase<OtherDerived>& )
Eigen::MatrixBase::operator +=	../include/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator+=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase	access:protected	signature:(const ArrayBase<OtherDerived>& )
Eigen::MatrixBase::operator -=	../include/Eigen/src/Eigen2Support/Lazy.h	/^Derived& MatrixBase<Derived>::operator-=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	f	class:Eigen::MatrixBase	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
Eigen::MatrixBase::operator +=	../include/Eigen/src/Eigen2Support/Lazy.h	/^Derived& MatrixBase<Derived>::operator+=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	f	class:Eigen::MatrixBase	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
Eigen::MatrixBase::operator *	../include/Eigen/src/Geometry/Scaling.h	/^MatrixBase<Derived>::operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::MatrixBase	signature:(const UniformScaling<Scalar>& s) const
Eigen::MatrixBase::operatorNorm	../include/Eigen/src/Core/MatrixBase.h	/^    RealScalar operatorNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::operatorNorm	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::operatorNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::PacketScalar	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::partialPivLu	../include/Eigen/src/Core/MatrixBase.h	/^    const PartialPivLU<PlainObject> partialPivLu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::partialPivLu	../include/Eigen/src/LU/PartialPivLU.h	/^MatrixBase<Derived>::partialPivLu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::part	../include/Eigen/src/Core/MatrixBase.h	/^    const DiagonalWrapper<ConstDiagonalReturnType> part() const$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::part	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> const typename internal::eigen2_part_return_type<Derived, Mode>::type part() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::part	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> typename internal::eigen2_part_return_type<Derived, Mode>::type part();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::part	../include/Eigen/src/Core/TriangularMatrix.h	/^const typename internal::eigen2_part_return_type<Derived, Mode>::type MatrixBase<Derived>::part() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::part	../include/Eigen/src/Core/TriangularMatrix.h	/^typename internal::eigen2_part_return_type<Derived, Mode>::type MatrixBase<Derived>::part()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::PlainObject	../include/Eigen/src/Core/MatrixBase.h	/^          > PlainObject;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::qr	../include/Eigen/src/Core/MatrixBase.h	/^    const QR<PlainObject> qr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::qr	../include/Eigen/src/Eigen2Support/QR.h	/^MatrixBase<Derived>::qr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::RealScalar	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::RowXpr	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::RowXpr RowXpr;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::Scalar	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::selfadjointView	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> typename ConstSelfAdjointViewReturnType<UpLo>::Type selfadjointView() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::selfadjointView	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> typename SelfAdjointViewReturnType<UpLo>::Type selfadjointView();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::selfadjointView	../include/Eigen/src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::selfadjointView	../include/Eigen/src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::SelfAdjointViewReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::SelfAdjointViewReturnType::Type	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::SelfAdjointViewReturnType	access:public
Eigen::MatrixBase::setIdentity	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::setIdentity	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity(Index rows, Index cols)$/;"	f	class:Eigen::MatrixBase	signature:(Index rows, Index cols)
Eigen::MatrixBase::setIdentity	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& setIdentity(Index rows, Index cols);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index rows, Index cols)
Eigen::MatrixBase::setIdentity	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& setIdentity();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::sinh	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> sinh() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::sin	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> sin() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::SizeMinusOne	../include/Eigen/src/Core/MatrixBase.h	/^      SizeMinusOne = SizeAtCompileTime==Dynamic ? Dynamic : SizeAtCompileTime-1$/;"	e	enum:Eigen::MatrixBase::__anon150
Eigen::MatrixBase::sparseView	../include/Eigen/src/Core/MatrixBase.h	/^    const SparseView<Derived> sparseView(const Scalar& m_reference = Scalar(0),$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const Scalar& m_reference = Scalar(0), typename NumTraits<Scalar>::Real m_epsilon = NumTraits<Scalar>::dummy_precision()) const
Eigen::MatrixBase::sparseView	../include/Eigen/src/SparseCore/SparseView.h	/^const SparseView<Derived> MatrixBase<Derived>::sparseView(const Scalar& m_reference,$/;"	f	class:Eigen::MatrixBase	signature:(const Scalar& m_reference, typename NumTraits<Scalar>::Real m_epsilon) const
Eigen::MatrixBase::sqrt	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixSquareRootReturnValue<Derived> sqrt() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::squaredNorm	../include/Eigen/src/Core/Dot.h	/^EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::squaredNorm	../include/Eigen/src/Core/MatrixBase.h	/^    RealScalar squaredNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::SquareMatrixType	../include/Eigen/src/Core/MatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::stableNorm	../include/Eigen/src/Core/MatrixBase.h	/^    RealScalar stableNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::stableNorm	../include/Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::stableNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::start	../include/Eigen/src/Core/MatrixBase.h	/^    const VectorBlock<const Derived> start(Index size) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size) const
Eigen::MatrixBase::start	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Size> const VectorBlock<const Derived,Size> start() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::start	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Size> VectorBlock<Derived,Size> start();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::start	../include/Eigen/src/Core/MatrixBase.h	/^    VectorBlock<Derived> start(Index size);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size)
Eigen::MatrixBase::start	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::start	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::start	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start(Index size) const$/;"	f	class:Eigen::MatrixBase	signature:(Index size) const
Eigen::MatrixBase::start	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start(Index size)$/;"	f	class:Eigen::MatrixBase	signature:(Index size)
Eigen::MatrixBase::StemFunction	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::stem_function<Scalar>::type StemFunction;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::StorageBaseType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef MatrixBase StorageBaseType;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::StorageKind	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::svd	../include/Eigen/src/Core/MatrixBase.h	/^    SVD<PlainObject> svd() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::svd	../include/Eigen/src/Eigen2Support/SVD.h	/^MatrixBase<Derived>::svd() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::trace	../include/Eigen/src/Core/MatrixBase.h	/^    Scalar trace() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::trace	../include/Eigen/src/Core/Redux.h	/^MatrixBase<Derived>::trace() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::triangularView	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> typename ConstTriangularViewReturnType<Mode>::Type triangularView() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
Eigen::MatrixBase::triangularView	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> typename TriangularViewReturnType<Mode>::Type triangularView();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::triangularView	../include/Eigen/src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::triangularView	../include/Eigen/src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::TriangularViewReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
Eigen::MatrixBase::TriangularViewReturnType::Type	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::TriangularViewReturnType	access:public
Eigen::MatrixBase::Unit	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index i)$/;"	f	class:Eigen::MatrixBase	signature:(Index i)
Eigen::MatrixBase::Unit	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index size, Index i)$/;"	f	class:Eigen::MatrixBase	signature:(Index size, Index i)
Eigen::MatrixBase::Unit	../include/Eigen/src/Core/MatrixBase.h	/^    static const BasisReturnType Unit(Index i);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index i)
Eigen::MatrixBase::Unit	../include/Eigen/src/Core/MatrixBase.h	/^    static const BasisReturnType Unit(Index size, Index i);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size, Index i)
Eigen::MatrixBase::unitOrthogonal	../include/Eigen/src/Core/MatrixBase.h	/^    PlainObject unitOrthogonal(void) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(void) const
Eigen::MatrixBase::unitOrthogonal	../include/Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::unitOrthogonal() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Eigen::MatrixBase::UnitW	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitW()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::UnitW	../include/Eigen/src/Core/MatrixBase.h	/^    static const BasisReturnType UnitW();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::UnitX	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitX()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::UnitX	../include/Eigen/src/Core/MatrixBase.h	/^    static const BasisReturnType UnitX();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::UnitY	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitY()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::UnitY	../include/Eigen/src/Core/MatrixBase.h	/^    static const BasisReturnType UnitY();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Eigen::MatrixBase::UnitZ	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitZ()$/;"	f	class:Eigen::MatrixBase	signature:()
Eigen::MatrixBase::UnitZ	../include/Eigen/src/Core/MatrixBase.h	/^    static const BasisReturnType UnitZ();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
EIGEN_MATRIX_H	../include/Eigen/src/Core/Matrix.h	27;"	d
Eigen::Matrix	../include/Eigen/src/Core/Matrix.h	/^class Matrix$/;"	c	namespace:Eigen	inherits:PlainObjectBase
Eigen::Matrix::innerStride	../include/Eigen/src/Core/Matrix.h	/^    inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Matrix	access:public	signature:() const
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Map.h	/^  ::Matrix(const Scalar *data)$/;"	f	class:Eigen::Matrix	signature:(const Scalar *data)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE explicit Matrix() : Base()$/;"	f	class:Eigen::Matrix	access:public	signature:()
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE explicit Matrix(Index dim)$/;"	f	class:Eigen::Matrix	access:public	signature:(Index dim)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Matrix& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Matrix& other)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const T0& x, const T1& y)$/;"	f	class:Eigen::Matrix	access:public	signature:(const T0& x, const T1& y)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    explicit Matrix(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    explicit Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    explicit Matrix(const Scalar *data);$/;"	p	class:Eigen::Matrix	access:public	signature:(const Scalar *data)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    Matrix(const Scalar& x, const Scalar& y);$/;"	p	class:Eigen::Matrix	access:public	signature:(const Scalar& x, const Scalar& y)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    Matrix(Index rows, Index cols);$/;"	p	class:Eigen::Matrix	access:public	signature:(Index rows, Index cols)
Eigen::Matrix::Matrix	../include/Eigen/src/Core/Matrix.h	/^    Matrix(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Matrix	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::Matrix::Matrix	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::Matrix	../include/Eigen/src/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::operator =	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::Matrix::operator =	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::Matrix::operator =	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const Matrix& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Matrix& other)
Eigen::Matrix::operator =	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::Matrix	access:public	signature:(const ReturnByValue<OtherDerived>& func)
Eigen::Matrix::operator =	../include/Eigen/src/Core/Matrix.h	/^    Matrix& operator=(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::operator =	../include/Eigen/src/Core/Matrix.h	/^    Matrix& operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::operator =	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::operator =	../include/Eigen/src/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Eigen::Matrix::Options	../include/Eigen/src/Core/Matrix.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Matrix::__anon290
Eigen::Matrix::outerStride	../include/Eigen/src/Core/Matrix.h	/^    inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Matrix	access:public	signature:() const
Eigen::Matrix::PlainObject	../include/Eigen/src/Core/Matrix.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Matrix	access:public
EIGEN_MATRIXSTORAGE_H	../include/Eigen/src/Core/DenseStorage.h	28;"	d
Eigen::Matrix::swap	../include/Eigen/src/Core/Matrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::Matrix	access:public	signature:(MatrixBase<OtherDerived> const & other)
Eigen::MatrixWrapper::Base	../include/Eigen/src/Core/ArrayWrapper.h	/^    typedef MatrixBase<MatrixWrapper<ExpressionType> > Base;$/;"	t	class:Eigen::MatrixWrapper	access:public
Eigen::MatrixWrapper::coeff	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index) const
Eigen::MatrixWrapper::coeff	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index row, Index col) const
Eigen::MatrixWrapper::coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index) const
Eigen::MatrixWrapper::coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index row, Index col) const
Eigen::MatrixWrapper::coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index)
Eigen::MatrixWrapper::coeffRef	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index row, Index col)
Eigen::MatrixWrapper::cols	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
Eigen::MatrixWrapper::data	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
Eigen::MatrixWrapper::data	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:()
Eigen::MatrixWrapper	../include/Eigen/src/Core/ArrayWrapper.h	/^class MatrixWrapper : public MatrixBase<MatrixWrapper<ExpressionType> >$/;"	c	namespace:Eigen	inherits:MatrixBase
Eigen::MatrixWrapper::innerStride	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
Eigen::MatrixWrapper::MatrixWrapper	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline MatrixWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(ExpressionType& matrix)
Eigen::MatrixWrapper::m_expression	../include/Eigen/src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::MatrixWrapper	access:protected
Eigen::MatrixWrapper::nestedExpression	../include/Eigen/src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
Eigen::MatrixWrapper::NestedExpressionType	../include/Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;$/;"	t	class:Eigen::MatrixWrapper	access:public
Eigen::MatrixWrapper::outerStride	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
Eigen::MatrixWrapper::packet	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index) const
Eigen::MatrixWrapper::packet	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index row, Index col) const
Eigen::MatrixWrapper::rows	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
Eigen::MatrixWrapper::ScalarWithConstIfNotLvalue	../include/Eigen/src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MatrixWrapper	access:public
Eigen::MatrixWrapper::writePacket	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index, const PacketScalar& x)
Eigen::MatrixWrapper::writePacket	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index row, Index col, const PacketScalar& x)
Eigen::MatrixXpr	../include/Eigen/src/Core/util/Constants.h	/^struct MatrixXpr {};$/;"	s	namespace:Eigen
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	119;"	d
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(all, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(all, (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(any, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(any, (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(blueNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(blueNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(count, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(count, (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(hypotNorm, (Size-1) * functor_traits<scalar_hypot_op<Scalar> >::Cost );$/;"	p	namespace:Eigen::internal	signature:(hypotNorm, (Size-1) * functor_traits<scalar_hypot_op<Scalar> >::Cost )
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(maxCoeff, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(maxCoeff, (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(mean, (Size-1)*NumTraits<Scalar>::AddCost + NumTraits<Scalar>::MulCost);$/;"	p	namespace:Eigen::internal	signature:(mean, (Size-1)*NumTraits<Scalar>::AddCost + NumTraits<Scalar>::MulCost)
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(minCoeff, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(minCoeff, (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(norm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(norm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(prod, (Size-1)*NumTraits<Scalar>::MulCost);$/;"	p	namespace:Eigen::internal	signature:(prod, (Size-1)*NumTraits<Scalar>::MulCost)
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(squaredNorm, Size * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(squaredNorm, Size * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(stableNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(stableNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMBER_FUNCTOR	../include/Eigen/src/Core/VectorwiseOp.h	/^EIGEN_MEMBER_FUNCTOR(sum, (Size-1)*NumTraits<Scalar>::AddCost);$/;"	p	namespace:Eigen::internal	signature:(sum, (Size-1)*NumTraits<Scalar>::AddCost)
EIGEN_MEMORY_H	../include/Eigen/src/Core/util/Memory.h	35;"	d
EIGEN_META_H	../include/Eigen/src/Core/util/Meta.h	27;"	d
Eigen::meta_sqrt	../include/Eigen/src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	c	namespace:Eigen
Eigen::meta_sqrt::ret	../include/Eigen/src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:Eigen::meta_sqrt::__anon196
Eigen::Minor::Base	../include/Eigen/src/Eigen2Support/Minor.h	/^    typedef MatrixBase<Minor> Base;$/;"	t	class:Eigen::Minor	access:public
Eigen::Minor::coeff	../include/Eigen/src/Eigen2Support/Minor.h	/^    inline const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Minor	access:public	signature:(Index row, Index col) const
Eigen::Minor::coeffRef	../include/Eigen/src/Eigen2Support/Minor.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Minor	access:public	signature:(Index row, Index col)
Eigen::Minor::cols	../include/Eigen/src/Eigen2Support/Minor.h	/^    inline Index cols() const { return m_matrix.cols() - 1; }$/;"	f	class:Eigen::Minor	access:public	signature:() const
EIGEN_MINOR_H	../include/Eigen/src/Eigen2Support/Minor.h	26;"	d
Eigen::Minor	../include/Eigen/src/Eigen2Support/Minor.h	/^template<typename MatrixType> class Minor$/;"	c	namespace:Eigen	inherits:MatrixBase
Eigen::Minor::m_col	../include/Eigen/src/Eigen2Support/Minor.h	/^    const Index m_row, m_col;$/;"	m	class:Eigen::Minor	access:protected
Eigen::Minor::Minor	../include/Eigen/src/Eigen2Support/Minor.h	/^    inline Minor(const MatrixType& matrix,$/;"	f	class:Eigen::Minor	access:public	signature:(const MatrixType& matrix, Index row, Index col)
Eigen::Minor::m_matrix	../include/Eigen/src/Eigen2Support/Minor.h	/^    const typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Minor	access:protected
Eigen::Minor::m_row	../include/Eigen/src/Eigen2Support/Minor.h	/^    const Index m_row, m_col;$/;"	m	class:Eigen::Minor	access:protected
Eigen::Minor::rows	../include/Eigen/src/Eigen2Support/Minor.h	/^    inline Index rows() const { return m_matrix.rows() - 1; }$/;"	f	class:Eigen::Minor	access:public	signature:() const
EIGEN_MINOR_VERSION	../include/Eigen/src/Core/util/Macros.h	31;"	d
EIGEN_MISC_IMAGE_H	../include/Eigen/src/misc/Image.h	26;"	d
EIGEN_MISC_KERNEL_H	../include/Eigen/src/misc/Kernel.h	26;"	d
EIGEN_MISC_SOLVE_H	../include/Eigen/src/misc/Solve.h	26;"	d
EIGEN_MKL_EIG_SELFADJ	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_MKL.h	42;"	d
EIGEN_MKL_GEMV_SPECIALIZATION	../include/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	89;"	d
EIGEN_MKL_GEMV_SPECIALIZE	../include/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	53;"	d
EIGEN_MKL_HEMM_L	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	95;"	d
EIGEN_MKL_HEMM_R	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	221;"	d
EIGEN_MKL_LLT	../include/Eigen/src/Cholesky/LLT_MKL.h	45;"	d
EIGEN_MKL_LU_PARTPIV	../include/Eigen/src/LU/PartialPivLU_MKL.h	44;"	d
EIGEN_MKL_QR_COLPIV	../include/Eigen/src/QR/ColPivHouseholderQR_MKL.h	43;"	d
EIGEN_MKL_QR_NOPIV	../include/Eigen/src/QR/HouseholderQR_MKL.h	45;"	d
EIGEN_MKL_RANKUPDATE_C	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	99;"	d
EIGEN_MKL_RANKUPDATE_R	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	74;"	d
EIGEN_MKL_RANKUPDATE_SPECIALIZE	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	47;"	d
EIGEN_MKL_SCHUR_COMPLEX	../include/Eigen/src/Eigenvalues/ComplexSchur_MKL.h	42;"	d
EIGEN_MKL_SCHUR_REAL	../include/Eigen/src/Eigenvalues/RealSchur_MKL.h	42;"	d
EIGEN_MKL_SUPPORT_H	../include/Eigen/src/Core/util/MKL_support.h	34;"	d
EIGEN_MKL_SVD	../include/Eigen/src/SVD/JacobiSVD_MKL.h	42;"	d
EIGEN_MKL_SYMM_L	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	43;"	d
EIGEN_MKL_SYMM_R	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	170;"	d
EIGEN_MKL_SYMV_SPECIALIZATION	../include/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	74;"	d
EIGEN_MKL_SYMV_SPECIALIZE	../include/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	50;"	d
EIGEN_MKL_TRMM_L	../include/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	78;"	d
EIGEN_MKL_TRMM_R	../include/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	192;"	d
EIGEN_MKL_TRMM_SPECIALIZE	../include/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	53;"	d
EIGEN_MKL_TRMV_CM	../include/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	74;"	d
EIGEN_MKL_TRMV_RM	../include/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	159;"	d
EIGEN_MKL_TRMV_SPECIALIZE	../include/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	50;"	d
EIGEN_MKL_TRSM_L	../include/Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	41;"	d
EIGEN_MKL_TRSM_R	../include/Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	96;"	d
EIGEN_MKL_VML_DECLARE_POW_CALL	../include/Eigen/src/Core/Assign_MKL.h	162;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALL	../include/Eigen/src/Core/Assign_MKL.h	143;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALL_LA	../include/Eigen/src/Core/Assign_MKL.h	152;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_COMPLEX	../include/Eigen/src/Core/Assign_MKL.h	178;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_COMPLEX_LA	../include/Eigen/src/Core/Assign_MKL.h	191;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS	../include/Eigen/src/Core/Assign_MKL.h	182;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_LA	../include/Eigen/src/Core/Assign_MKL.h	195;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL	../include/Eigen/src/Core/Assign_MKL.h	174;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL_LA	../include/Eigen/src/Core/Assign_MKL.h	187;"	d
EIGEN_MKL_VML_MODE	../include/Eigen/src/Core/Assign_MKL.h	138;"	d
EIGEN_MKL_VML_SPECIALIZE_ASSIGN	../include/Eigen/src/Core/Assign_MKL.h	116;"	d
EIGEN_MKL_VML_THRESHOLD	../include/Eigen/src/Core/util/MKL_support.h	60;"	d
Eigen::nbThreads	../include/Eigen/src/Core/products/Parallelizer.h	/^inline int nbThreads()$/;"	f	namespace:Eigen	signature:()
Eigen::NestByRefBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int NestByRefBit = 0x100;$/;"	m	namespace:Eigen
Eigen::NestByValue::Base	../include/Eigen/src/Core/NestByValue.h	/^    typedef typename internal::dense_xpr_base<NestByValue>::type Base;$/;"	t	class:Eigen::NestByValue	access:public
Eigen::NestByValue::coeff	../include/Eigen/src/Core/NestByValue.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index) const
Eigen::NestByValue::coeff	../include/Eigen/src/Core/NestByValue.h	/^    inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col) const
Eigen::NestByValue::coeffRef	../include/Eigen/src/Core/NestByValue.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index)
Eigen::NestByValue::coeffRef	../include/Eigen/src/Core/NestByValue.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col)
Eigen::NestByValue::cols	../include/Eigen/src/Core/NestByValue.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
EIGEN_NESTBYVALUE_H	../include/Eigen/src/Core/NestByValue.h	27;"	d
Eigen::NestByValue	../include/Eigen/src/Core/NestByValue.h	/^template<typename ExpressionType> class NestByValue$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::NestByValue::innerStride	../include/Eigen/src/Core/NestByValue.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
Eigen::NestByValue::m_expression	../include/Eigen/src/Core/NestByValue.h	/^    const ExpressionType m_expression;$/;"	m	class:Eigen::NestByValue	access:protected
Eigen::NestByValue::NestByValue	../include/Eigen/src/Core/NestByValue.h	/^    inline NestByValue(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::NestByValue	access:public	signature:(const ExpressionType& matrix)
Eigen::NestByValue::operator const ExpressionType&	../include/Eigen/src/Core/NestByValue.h	/^    operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
Eigen::NestByValue::outerStride	../include/Eigen/src/Core/NestByValue.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
Eigen::NestByValue::packet	../include/Eigen/src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index) const
Eigen::NestByValue::packet	../include/Eigen/src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col) const
Eigen::NestByValue::rows	../include/Eigen/src/Core/NestByValue.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
Eigen::NestByValue::writePacket	../include/Eigen/src/Core/NestByValue.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index, const PacketScalar& x)
Eigen::NestByValue::writePacket	../include/Eigen/src/Core/NestByValue.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col, const PacketScalar& x)
Eigen::NewInf	../include/Eigen/src/Eigen2Support/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen
Eigen::NewSup	../include/Eigen/src/Eigen2Support/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen
EIGEN_NOALIAS_H	../include/Eigen/src/Core/NoAlias.h	26;"	d
Eigen::NoAlias	../include/Eigen/src/Core/NoAlias.h	/^class NoAlias$/;"	c	namespace:Eigen
Eigen::NoAlias::m_expression	../include/Eigen/src/Core/NoAlias.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::NoAlias	access:protected
Eigen::NoAlias::NoAlias	../include/Eigen/src/Core/NoAlias.h	/^    NoAlias(ExpressionType& expression) : m_expression(expression) {}$/;"	f	class:Eigen::NoAlias	access:public	signature:(ExpressionType& expression)
Eigen::NoAlias::operator -=	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)
Eigen::NoAlias::operator +=	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)
Eigen::NoAlias::operator -=	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::NoAlias::operator +=	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::NoAlias::operator =	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const StorageBase<OtherDerived>& other)
Eigen::NoAlias::operator -=	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const StorageBase<OtherDerived>& other)
Eigen::NoAlias::operator +=	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const StorageBase<OtherDerived>& other)
Eigen::NoAlias::Scalar	../include/Eigen/src/Core/NoAlias.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::NoAlias	access:private
Eigen::NoChange	../include/Eigen/src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	e	enum:Eigen::NoChange_t
Eigen::NoChange_t	../include/Eigen/src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	g	namespace:Eigen
Eigen::NoConvergence	../include/Eigen/src/Core/util/Constants.h	/^  NoConvergence = 2,$/;"	e	enum:Eigen::ComputationInfo
EIGEN_NO_DEBUG	../include/Eigen/src/Core/util/Macros.h	178;"	d
Eigen::NoPivoting	../include/Eigen/src/Core/util/Constants.h	/^  NoPivoting          = 0x02, $/;"	e	enum:Eigen::DecompositionOptions
Eigen::NoQRPreconditioner	../include/Eigen/src/Core/util/Constants.h	/^  NoQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
Eigen::NoUnrolling	../include/Eigen/src/Core/util/Constants.h	/^  NoUnrolling,$/;"	e	enum:Eigen::__anon210
Eigen::NumericalIssue	../include/Eigen/src/Core/util/Constants.h	/^  NumericalIssue = 1, $/;"	e	enum:Eigen::ComputationInfo
EIGEN_NUMTRAITS_H	../include/Eigen/src/Core/NumTraits.h	26;"	d
EIGEN_ONLY_USED_FOR_DEBUG	../include/Eigen/src/Core/util/Macros.h	232;"	d
Eigen::OnTheLeft	../include/Eigen/src/Core/util/Constants.h	/^  OnTheLeft = 1,  $/;"	e	enum:Eigen::__anon213
Eigen::OnTheRight	../include/Eigen/src/Core/util/Constants.h	/^  OnTheRight = 2  $/;"	e	enum:Eigen::__anon213
Eigen::operator /	../include/Eigen/src/Core/GlobalFunctions.h	/^    operator\/(typename Derived::Scalar s, const Eigen::ArrayBase<Derived>& a)$/;"	f	namespace:Eigen	signature:(typename Derived::Scalar s, const Eigen::ArrayBase<Derived>& a)
Eigen::operator <<	../include/Eigen/src/Core/IO.h	/^std::ostream & operator <<$/;"	f	namespace:Eigen	signature:(std::ostream & s, const DenseBase<Derived> & m)
Eigen::operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^operator*(const MatrixBase<Derived>& matrix,$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& matrix, const PermutationBase<PermutationDerived> &permutation)
Eigen::operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^operator*(const PermutationBase<PermutationDerived> &permutation,$/;"	f	namespace:Eigen	signature:(const PermutationBase<PermutationDerived> &permutation, const MatrixBase<Derived>& matrix)
Eigen::operator *	../include/Eigen/src/Core/ProductBase.h	/^operator*(const ProductBase<Derived,Lhs,Rhs>& prod, typename Derived::RealScalar x)$/;"	f	namespace:Eigen	signature:(const ProductBase<Derived,Lhs,Rhs>& prod, typename Derived::RealScalar x)
Eigen::operator *	../include/Eigen/src/Core/ProductBase.h	/^operator*(const ProductBase<Derived,Lhs,Rhs>& prod, typename Derived::Scalar x)$/;"	f	namespace:Eigen	signature:(const ProductBase<Derived,Lhs,Rhs>& prod, typename Derived::Scalar x)
Eigen::operator *	../include/Eigen/src/Core/ProductBase.h	/^operator*(typename Derived::RealScalar x,const ProductBase<Derived,Lhs,Rhs>& prod)$/;"	f	namespace:Eigen	signature:(typename Derived::RealScalar x,const ProductBase<Derived,Lhs,Rhs>& prod)
Eigen::operator *	../include/Eigen/src/Core/ProductBase.h	/^operator*(typename Derived::Scalar x,const ProductBase<Derived,Lhs,Rhs>& prod)$/;"	f	namespace:Eigen	signature:(typename Derived::Scalar x,const ProductBase<Derived,Lhs,Rhs>& prod)
Eigen::operator *	../include/Eigen/src/Core/Transpositions.h	/^operator*(const MatrixBase<Derived>& matrix,$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& matrix, const TranspositionsBase<TranspositionsDerived> &transpositions)
Eigen::operator *	../include/Eigen/src/Core/Transpositions.h	/^operator*(const TranspositionsBase<TranspositionDerived> &transpositions,$/;"	f	namespace:Eigen	signature:(const TranspositionsBase<TranspositionDerived> &transpositions, const MatrixBase<Derived>& matrix)
Eigen::operator *	../include/Eigen/src/Householder/HouseholderSequence.h	/^typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)$/;"	f	namespace:Eigen	signature:(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)
Eigen::operator *	../include/Eigen/src/SparseCore/SparsePermutation.h	/^operator*( const PermutationBase<PermDerived>& perm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen	signature:( const PermutationBase<PermDerived>& perm, const SparseMatrixBase<SparseDerived>& matrix)
Eigen::operator *	../include/Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)$/;"	f	namespace:Eigen	signature:(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)
Eigen::operator *	../include/Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const Transpose<PermutationBase<PermDerived> >& tperm)$/;"	f	namespace:Eigen	signature:(const SparseMatrixBase<SparseDerived>& matrix, const Transpose<PermutationBase<PermDerived> >& tperm)
Eigen::operator *	../include/Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const Transpose<PermutationBase<PermDerived> >& tperm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen	signature:(const Transpose<PermutationBase<PermDerived> >& tperm, const SparseMatrixBase<SparseDerived>& matrix)
EIGEN_ORTHOMETHODS_H	../include/Eigen/src/Geometry/OrthoMethods.h	27;"	d
Eigen::OuterProduct	../include/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon215
Eigen::OuterRandomAccessPattern	../include/Eigen/src/SparseCore/SparseUtil.h	/^const int OuterRandomAccessPattern  = 0x4 | CoherentAccessPattern;$/;"	m	namespace:Eigen
Eigen::OuterStride::Base	../include/Eigen/src/Core/Stride.h	/^    typedef Stride<Value, 0> Base;$/;"	t	class:Eigen::OuterStride	access:private
Eigen::OuterStride	../include/Eigen/src/Core/Stride.h	/^class OuterStride : public Stride<Value, 0>$/;"	c	namespace:Eigen	inherits:Stride
Eigen::OuterStride::Index	../include/Eigen/src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::OuterStride	access:public
Eigen::OuterStride::OuterStride	../include/Eigen/src/Core/Stride.h	/^    OuterStride() : Base() {}$/;"	f	class:Eigen::OuterStride	access:public	signature:()
Eigen::OuterStride::OuterStride	../include/Eigen/src/Core/Stride.h	/^    OuterStride(Index v) : Base(v,0) {}$/;"	f	class:Eigen::OuterStride	access:public	signature:(Index v)
Eigen::PacketAccessBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int PacketAccessBit = 0x8;$/;"	m	namespace:Eigen
EIGEN_PACKET_MATH_ALTIVEC_H	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	26;"	d
EIGEN_PACKET_MATH_NEON_H	../include/Eigen/src/Core/arch/NEON/PacketMath.h	28;"	d
EIGEN_PACKET_MATH_SSE_H	../include/Eigen/src/Core/arch/SSE/PacketMath.h	26;"	d
EIGEN_PARALLELIZER_H	../include/Eigen/src/Core/products/Parallelizer.h	26;"	d
Eigen::ParametrizedLine::AmbientDimAtCompileTime	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::ParametrizedLine::__anon433
Eigen::ParametrizedLine::AmbientDimAtCompileTime	../include/Eigen/src/Geometry/ParametrizedLine.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::ParametrizedLine::__anon372
Eigen::ParametrizedLine::cast	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::cast	../include/Eigen/src/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::dim	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline int dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::dim	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  inline Index dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::direction	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::direction	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::direction	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::direction	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::distance	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  RealScalar distance(const VectorType& p) const { return ei_sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
Eigen::ParametrizedLine::distance	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  RealScalar distance(const VectorType& p) const { return internal::sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
EIGEN_PARAMETRIZEDLINE_H	../include/Eigen/src/Geometry/ParametrizedLine.h	27;"	d
Eigen::ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
Eigen::ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
Eigen::ParametrizedLine::Index	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::intersection	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim>::intersection(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
Eigen::ParametrizedLine::intersection	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  Scalar intersection(const Hyperplane<_Scalar, _AmbientDim>& hyperplane);$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
Eigen::ParametrizedLine::intersection	../include/Eigen/src/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
Eigen::ParametrizedLine::intersection	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  Scalar intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
Eigen::ParametrizedLine::intersectionParameter	../include/Eigen/src/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionParameter(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
Eigen::ParametrizedLine::intersectionParameter	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  Scalar intersectionParameter(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
Eigen::ParametrizedLine::intersectionPoint	../include/Eigen/src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
Eigen::ParametrizedLine::intersectionPoint	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
Eigen::ParametrizedLine::isApprox	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  bool isApprox(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::ParametrizedLine::isApprox	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  bool isApprox(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::ParametrizedLine::m_direction	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
Eigen::ParametrizedLine::m_direction	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
Eigen::ParametrizedLine::m_origin	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
Eigen::ParametrizedLine::m_origin	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
Eigen::ParametrizedLine::Options	../include/Eigen/src/Geometry/ParametrizedLine.h	/^    Options = _Options$/;"	e	enum:Eigen::ParametrizedLine::__anon372
Eigen::ParametrizedLine::origin	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::origin	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::origin	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
Eigen::ParametrizedLine::origin	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  explicit ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim>& hyperplane);$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime>& other)
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(int _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(int _dim)
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^inline ParametrizedLine<_Scalar, _AmbientDim>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& origin, const VectorType& direction)
Eigen::ParametrizedLine::~ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  explicit ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane);$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane)
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(Index _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(Index _dim)
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^inline ParametrizedLine<_Scalar, _AmbientDim,_Options>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim,OtherOptions>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim,OtherOptions>& hyperplane)
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const ParametrizedLine<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)
Eigen::ParametrizedLine::ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& origin, const VectorType& direction)
Eigen::ParametrizedLine::~ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
Eigen::ParametrizedLine::pointAt	../include/Eigen/src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::pointAt( _Scalar t ) const$/;"	f	class:Eigen::ParametrizedLine	signature:( _Scalar t ) const
Eigen::ParametrizedLine::pointAt	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType pointAt( Scalar t ) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:( Scalar t ) const
Eigen::ParametrizedLine::projection	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
Eigen::ParametrizedLine::projection	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
Eigen::ParametrizedLine::RealScalar	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::RealScalar	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::Scalar	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::Scalar	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::squaredDistance	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
Eigen::ParametrizedLine::squaredDistance	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
Eigen::ParametrizedLine::Through	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p0, const VectorType& p1)
Eigen::ParametrizedLine::Through	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p0, const VectorType& p1)
Eigen::ParametrizedLine::VectorType	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::ParametrizedLine::VectorType	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1,Options> VectorType;$/;"	t	class:Eigen::ParametrizedLine	access:public
Eigen::PardisoImpl::analyzePattern	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Derived& analyzePattern(const MatrixType& matrix);$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoImpl::analyzePattern	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixType& a)
Eigen::PardisoImpl::cols	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
Eigen::PardisoImpl::compute	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Derived& compute(const MatrixType& matrix);$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoImpl::compute	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::compute(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixType& a)
Eigen::PardisoImpl::derived	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    const Derived& derived() const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
Eigen::PardisoImpl::derived	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Derived& derived()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
Eigen::PardisoImpl::factorize	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Derived& factorize(const MatrixType& matrix);$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoImpl::factorize	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::factorize(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixType& a)
Eigen::PardisoImpl	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoImpl$/;"	c	namespace:Eigen
Eigen::PardisoImpl::Index	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Index Index;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::info	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
Eigen::PardisoImpl::IntColVectorType	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Index, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::IntRowVectorType	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Index, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::manageErrorCode	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void manageErrorCode(Index error)$/;"	f	class:Eigen::PardisoImpl	access:protected	signature:(Index error)
Eigen::PardisoImpl::m_analysisIsOk	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::MatrixType	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::MatrixType MatrixType;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::m_factorizationIsOk	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_info	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_initialized	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_iparm	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable Array<Index,64,1> m_iparm;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_matrix	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable SparseMatrixType m_matrix;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_msglvl	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_perm	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable IntColVectorType m_perm;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_pt	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable void *m_pt[64];$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_size	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_size;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::m_type	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl	access:protected
Eigen::PardisoImpl::~PardisoImpl	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ~PardisoImpl()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
Eigen::PardisoImpl::PardisoImpl	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
Eigen::PardisoImpl::PardisoImpl	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl(PardisoImpl &) {}$/;"	f	class:Eigen::PardisoImpl	access:private	signature:(PardisoImpl &)
Eigen::PardisoImpl::pardisoInit	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void pardisoInit(int type)$/;"	f	class:Eigen::PardisoImpl	access:protected	signature:(int type)
Eigen::PardisoImpl::pardisoParameterArray	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Array<Index,64,1>& pardisoParameterArray()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
Eigen::PardisoImpl::pardisoRelease	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void pardisoRelease()$/;"	f	class:Eigen::PardisoImpl	access:protected	signature:()
Eigen::PardisoImpl::RealScalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::rows	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
Eigen::PardisoImpl::Scalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::ScalarIsComplex	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^      ScalarIsComplex = NumTraits<Scalar>::IsComplex$/;"	e	enum:Eigen::PardisoImpl::__anon400
Eigen::PardisoImpl::_solve	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^bool PardisoImpl<Base>::_solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const
Eigen::PardisoImpl::_solve	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool _solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const;$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const
Eigen::PardisoImpl::solve	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::PardisoImpl::solve	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
Eigen::PardisoImpl::_solve_sparse	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
Eigen::PardisoImpl::SparseMatrixType	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef SparseMatrix<Scalar,RowMajor,Index> SparseMatrixType;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoImpl::Traits	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef internal::pardiso_traits<Derived> Traits;$/;"	t	class:Eigen::PardisoImpl	access:private
Eigen::PardisoImpl::VectorType	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::PardisoImpl	access:public
Eigen::PardisoLDLT::Base	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLDLT<MatrixType,Options> > Base;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Eigen::PardisoLDLT::getMatrix	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoLDLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLDLT : public PardisoImpl< PardisoLDLT<MatrixType,Options> >$/;"	c	namespace:Eigen	inherits:PardisoImpl
Eigen::PardisoLDLT::Index	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Eigen::PardisoLDLT::PardisoLDLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoLDLT::PardisoLDLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT()$/;"	f	class:Eigen::PardisoLDLT	access:public	signature:()
Eigen::PardisoLDLT::PardisoLDLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT(PardisoLDLT& ) {}$/;"	f	class:Eigen::PardisoLDLT	access:private	signature:(PardisoLDLT& )
Eigen::PardisoLDLT::RealScalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Eigen::PardisoLDLT::Scalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Eigen::PardisoLDLT::UpLo	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = Options&(Upper|Lower) };$/;"	e	enum:Eigen::PardisoLDLT::__anon402
Eigen::PardisoLLT::Base	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLLT<MatrixType,_UpLo> > Base;$/;"	t	class:Eigen::PardisoLLT	access:protected
Eigen::PardisoLLT::getMatrix	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT	access:protected	signature:(const MatrixType& matrix)
Eigen::PardisoLLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLLT : public PardisoImpl< PardisoLLT<MatrixType,_UpLo> >$/;"	c	namespace:Eigen	inherits:PardisoImpl
Eigen::PardisoLLT::Index	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::PardisoLLT	access:protected
Eigen::PardisoLLT::PardisoLLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoLLT::PardisoLLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT()$/;"	f	class:Eigen::PardisoLLT	access:public	signature:()
Eigen::PardisoLLT::PardisoLLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT(PardisoLLT& ) {}$/;"	f	class:Eigen::PardisoLLT	access:private	signature:(PardisoLLT& )
Eigen::PardisoLLT::RealScalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLLT	access:protected
Eigen::PardisoLLT::Scalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLLT	access:protected
Eigen::PardisoLLT::UpLo	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PardisoLLT::__anon401
Eigen::PardisoLU::Base	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLU<MatrixType> > Base;$/;"	t	class:Eigen::PardisoLU	access:protected
Eigen::PardisoLU::getMatrix	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU	access:protected	signature:(const MatrixType& matrix)
Eigen::PardisoLU	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLU : public PardisoImpl< PardisoLU<MatrixType> >$/;"	c	namespace:Eigen	inherits:PardisoImpl
Eigen::PardisoLU::PardisoLU	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU	access:public	signature:(const MatrixType& matrix)
Eigen::PardisoLU::PardisoLU	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU()$/;"	f	class:Eigen::PardisoLU	access:public	signature:()
Eigen::PardisoLU::PardisoLU	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU(PardisoLU& ) {}$/;"	f	class:Eigen::PardisoLU	access:private	signature:(PardisoLU& )
Eigen::PardisoLU::RealScalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLU	access:protected
Eigen::PardisoLU::Scalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLU	access:protected
EIGEN_PARDISOSUPPORT_H	../include/Eigen/src/PardisoSupport/PardisoSupport.h	33;"	d
EIGEN_PARTIALLU_H	../include/Eigen/src/LU/PartialPivLU.h	27;"	d
EIGEN_PARTIALLU_LAPACK_H	../include/Eigen/src/LU/PartialPivLU_MKL.h	34;"	d
Eigen::PartialPivLU::ColsAtCompileTime	../include/Eigen/src/LU/PartialPivLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon394
Eigen::PartialPivLU::cols	../include/Eigen/src/LU/PartialPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::compute	../include/Eigen/src/LU/PartialPivLU.h	/^    PartialPivLU& compute(const MatrixType& matrix);$/;"	p	class:Eigen::PartialPivLU	access:public	signature:(const MatrixType& matrix)
Eigen::PartialPivLU::compute	../include/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>& PartialPivLU<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::PartialPivLU	signature:(const MatrixType& matrix)
Eigen::PartialPivLU::determinant	../include/Eigen/src/LU/PartialPivLU.h	/^    typename internal::traits<MatrixType>::Scalar determinant() const;$/;"	p	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::determinant	../include/Eigen/src/LU/PartialPivLU.h	/^typename internal::traits<MatrixType>::Scalar PartialPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::PartialPivLU	signature:() const
Eigen::PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^template<typename _MatrixType> class PartialPivLU$/;"	c	namespace:Eigen
Eigen::PartialPivLU::Index	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::inverse	../include/Eigen/src/LU/PartialPivLU.h	/^    inline const internal::solve_retval<PartialPivLU,typename MatrixType::IdentityReturnType> inverse() const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::matrixLU	../include/Eigen/src/LU/PartialPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::MatrixType	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::MaxColsAtCompileTime	../include/Eigen/src/LU/PartialPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::PartialPivLU::__anon394
Eigen::PartialPivLU::MaxRowsAtCompileTime	../include/Eigen/src/LU/PartialPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon394
Eigen::PartialPivLU::m_det_p	../include/Eigen/src/LU/PartialPivLU.h	/^    Index m_det_p;$/;"	m	class:Eigen::PartialPivLU	access:protected
Eigen::PartialPivLU::m_isInitialized	../include/Eigen/src/LU/PartialPivLU.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PartialPivLU	access:protected
Eigen::PartialPivLU::m_lu	../include/Eigen/src/LU/PartialPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::PartialPivLU	access:protected
Eigen::PartialPivLU::m_p	../include/Eigen/src/LU/PartialPivLU.h	/^    PermutationType m_p;$/;"	m	class:Eigen::PartialPivLU	access:protected
Eigen::PartialPivLU::m_rowsTranspositions	../include/Eigen/src/LU/PartialPivLU.h	/^    TranspositionType m_rowsTranspositions;$/;"	m	class:Eigen::PartialPivLU	access:protected
Eigen::PartialPivLU::Options	../include/Eigen/src/LU/PartialPivLU.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::PartialPivLU::__anon394
Eigen::PartialPivLU::PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^    PartialPivLU(const MatrixType& matrix);$/;"	p	class:Eigen::PartialPivLU	access:public	signature:(const MatrixType& matrix)
Eigen::PartialPivLU::PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^    PartialPivLU(Index size);$/;"	p	class:Eigen::PartialPivLU	access:public	signature:(Index size)
Eigen::PartialPivLU::PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(const MatrixType& matrix)$/;"	f	class:Eigen::PartialPivLU	signature:(const MatrixType& matrix)
Eigen::PartialPivLU::PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU()$/;"	f	class:Eigen::PartialPivLU	signature:()
Eigen::PartialPivLU::PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(Index size)$/;"	f	class:Eigen::PartialPivLU	signature:(Index size)
Eigen::PartialPivLU::PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^    PartialPivLU();$/;"	p	class:Eigen::PartialPivLU	access:public	signature:()
Eigen::PartialPivLU::permutationP	../include/Eigen/src/LU/PartialPivLU.h	/^    inline const PermutationType& permutationP() const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::PermutationType	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::RealScalar	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::reconstructedMatrix	../include/Eigen/src/LU/PartialPivLU.h	/^MatrixType PartialPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::PartialPivLU	signature:() const
Eigen::PartialPivLU::reconstructedMatrix	../include/Eigen/src/LU/PartialPivLU.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::RowsAtCompileTime	../include/Eigen/src/LU/PartialPivLU.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon394
Eigen::PartialPivLU::rows	../include/Eigen/src/LU/PartialPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
Eigen::PartialPivLU::Scalar	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::solve	../include/Eigen/src/LU/PartialPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::PartialPivLU::StorageKind	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialPivLU::TranspositionType	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::PartialPivLU	access:public
Eigen::PartialReduxExpr::Base	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::dense_xpr_base<PartialReduxExpr>::type Base;$/;"	t	class:Eigen::PartialReduxExpr	access:public
Eigen::PartialReduxExpr::coeff	../include/Eigen/src/Core/VectorwiseOp.h	/^    const Scalar coeff(Index index) const$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:(Index index) const
Eigen::PartialReduxExpr::coeff	../include/Eigen/src/Core/VectorwiseOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:(Index i, Index j) const
Eigen::PartialReduxExpr::cols	../include/Eigen/src/Core/VectorwiseOp.h	/^    Index cols() const { return (Direction==Horizontal ? 1 : m_matrix.cols()); }$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:() const
Eigen::PartialReduxExpr	../include/Eigen/src/Core/VectorwiseOp.h	/^class PartialReduxExpr : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
Eigen::PartialReduxExpr::_MatrixTypeNested	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::traits<PartialReduxExpr>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::PartialReduxExpr	access:public
Eigen::PartialReduxExpr::MatrixTypeNested	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::traits<PartialReduxExpr>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::PartialReduxExpr	access:public
Eigen::PartialReduxExpr::m_functor	../include/Eigen/src/Core/VectorwiseOp.h	/^    const MemberOp m_functor;$/;"	m	class:Eigen::PartialReduxExpr	access:protected
Eigen::PartialReduxExpr::m_matrix	../include/Eigen/src/Core/VectorwiseOp.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::PartialReduxExpr	access:protected
Eigen::PartialReduxExpr::PartialReduxExpr	../include/Eigen/src/Core/VectorwiseOp.h	/^    PartialReduxExpr(const MatrixType& mat, const MemberOp& func = MemberOp())$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:(const MatrixType& mat, const MemberOp& func = MemberOp())
Eigen::PartialReduxExpr::rows	../include/Eigen/src/Core/VectorwiseOp.h	/^    Index rows() const { return (Direction==Vertical   ? 1 : m_matrix.rows()); }$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:() const
EIGEN_PARTIAL_REDUX_H	../include/Eigen/src/Core/VectorwiseOp.h	27;"	d
Eigen::PastixBase::analyzePattern	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(ColSpMatrix& mat);$/;"	p	class:Eigen::PastixBase	access:protected	signature:(ColSpMatrix& mat)
Eigen::PastixBase::analyzePattern	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::analyzePattern(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase	signature:(ColSpMatrix& mat)
Eigen::PastixBase::clean	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void clean()$/;"	f	class:Eigen::PastixBase	access:protected	signature:()
Eigen::PastixBase::cols	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
Eigen::PastixBase::ColSpMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor> ColSpMatrix;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::compute	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute(ColSpMatrix& mat);$/;"	p	class:Eigen::PastixBase	access:protected	signature:(ColSpMatrix& mat)
Eigen::PastixBase::compute	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::compute(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase	signature:(ColSpMatrix& mat)
Eigen::PastixBase::derived	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    const Derived& derived() const$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
Eigen::PastixBase::derived	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Derived& derived()$/;"	f	class:Eigen::PastixBase	access:public	signature:()
Eigen::PastixBase::dparm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Array<RealScalar,IPARM_SIZE,1>& dparm()$/;"	f	class:Eigen::PastixBase	access:public	signature:()
Eigen::PastixBase::dparm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    double& dparm(int idxparam)$/;"	f	class:Eigen::PastixBase	access:public	signature:(int idxparam)
Eigen::PastixBase::factorize	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(ColSpMatrix& mat);$/;"	p	class:Eigen::PastixBase	access:protected	signature:(ColSpMatrix& mat)
Eigen::PastixBase::factorize	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::factorize(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase	signature:(ColSpMatrix& mat)
Eigen::PastixBase	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::PastixBase::Index	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::info	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
Eigen::PastixBase::init	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init(); $/;"	p	class:Eigen::PastixBase	access:protected	signature:()
Eigen::PastixBase::init	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::init()$/;"	f	class:Eigen::PastixBase	signature:()
Eigen::PastixBase::iparm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Array<Index,IPARM_SIZE,1>& iparm()$/;"	f	class:Eigen::PastixBase	access:public	signature:()
Eigen::PastixBase::iparm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int& iparm(int idxparam)$/;"	f	class:Eigen::PastixBase	access:public	signature:(int idxparam)
Eigen::PastixBase::m_analysisIsOk	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::MatrixType	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::_MatrixType	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename internal::pastix_traits<Derived>::MatrixType _MatrixType;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::m_comm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_comm; \/\/ The MPI communicator identifier$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_dparm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<double,DPARM_SIZE,1> m_dparm; \/\/ Scalar vector for the input parameters$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_factorizationIsOk	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_info	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable ComputationInfo m_info; $/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_initisOk	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_initisOk; $/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_invp	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<Index,Dynamic,1> m_invp;  \/\/ Inverse permutation vector$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_iparm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<int,IPARM_SIZE,1> m_iparm; \/\/ integer vector for the input parameters$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_isInitialized	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_pastixdata	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable pastix_data_t *m_pastixdata; \/\/ Data structure for pastix$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_perm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<Index,Dynamic,1> m_perm;  \/\/ Permutation vector$/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::m_size	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_size; \/\/ Size of the matrix $/;"	m	class:Eigen::PastixBase	access:protected
Eigen::PastixBase::~PastixBase	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    ~PastixBase() $/;"	f	class:Eigen::PastixBase	access:public	signature:()
Eigen::PastixBase::PastixBase	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixBase() : m_initisOk(false), m_analysisIsOk(false), m_factorizationIsOk(false), m_isInitialized(false), m_pastixdata(0), m_size(0)$/;"	f	class:Eigen::PastixBase	access:public	signature:()
Eigen::PastixBase::RealScalar	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::rows	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
Eigen::PastixBase::Scalar	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PastixBase	access:public
Eigen::PastixBase::_solve	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^bool PastixBase<Base>::_solve (const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const$/;"	f	class:Eigen::PastixBase	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const
Eigen::PastixBase::_solve	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    bool _solve (const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const;$/;"	p	class:Eigen::PastixBase	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const
Eigen::PastixBase::solve	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PastixBase	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::PastixBase::solve	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PastixBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
Eigen::PastixBase::_solve_sparse	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::PastixBase	access:public	signature:(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
Eigen::PastixBase::Vector	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::PastixBase	access:public
eigen_pastix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, double *vals, int *perm, int * invp, double *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, double *vals, int *perm, int * invp, double *x, int nbrhs, int *iparm, double *dparm)
eigen_pastix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, float *vals, int *perm, int * invp, float *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, float *vals, int *perm, int * invp, float *x, int nbrhs, int *iparm, double *dparm)
eigen_pastix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<double> *vals, int *perm, int * invp, std::complex<double> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<double> *vals, int *perm, int * invp, std::complex<double> *x, int nbrhs, int *iparm, double *dparm)
eigen_pastix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<float> *vals, int *perm, int * invp, std::complex<float> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal	signature:(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<float> *vals, int *perm, int * invp, std::complex<float> *x, int nbrhs, int *iparm, double *dparm)
Eigen::PastixLDLT::analyzePattern	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLDLT::Base	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLDLT<MatrixType, _UpLo> > Base; $/;"	t	class:Eigen::PastixLDLT	access:public
Eigen::PastixLDLT::ColSpMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLDLT	access:public
Eigen::PastixLDLT::compute	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLDLT::factorize	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLDLT::grabMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLDLT	access:protected	signature:(const MatrixType& matrix, ColSpMatrix& out)
Eigen::PastixLDLT	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLDLT : public PastixBase< PastixLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:PastixBase
Eigen::PastixLDLT::init	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLDLT	access:protected	signature:()
Eigen::PastixLDLT::MatrixType	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLDLT	access:public
Eigen::PastixLDLT::PastixLDLT	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT():Base()$/;"	f	class:Eigen::PastixLDLT	access:public	signature:()
Eigen::PastixLDLT::PastixLDLT	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLDLT::UpLo	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLDLT::__anon47
Eigen::PastixLLT::analyzePattern	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLLT::Base	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLLT<MatrixType, _UpLo> > Base;$/;"	t	class:Eigen::PastixLLT	access:public
Eigen::PastixLLT::ColSpMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLLT	access:public
Eigen::PastixLLT::compute	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLLT::factorize	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLLT::grabMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLLT	access:protected	signature:(const MatrixType& matrix, ColSpMatrix& out)
Eigen::PastixLLT	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLLT : public PastixBase< PastixLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:PastixBase
Eigen::PastixLLT::init	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLLT	access:protected	signature:()
Eigen::PastixLLT::MatrixType	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLLT	access:public
Eigen::PastixLLT::PastixLLT	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT() : Base()$/;"	f	class:Eigen::PastixLLT	access:public	signature:()
Eigen::PastixLLT::PastixLLT	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLLT::UpLo	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLLT::__anon46
Eigen::PastixLU::analyzePattern	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLU::Base	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLU<MatrixType> > Base;$/;"	t	class:Eigen::PastixLU	access:public
Eigen::PastixLU::ColSpMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLU	access:public
Eigen::PastixLU::compute	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLU::factorize	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
Eigen::PastixLU::grabMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLU	access:protected	signature:(const MatrixType& matrix, ColSpMatrix& out)
Eigen::PastixLU	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLU : public PastixBase< PastixLU<_MatrixType> >$/;"	c	namespace:Eigen	inherits:PastixBase
Eigen::PastixLU::Index	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PastixLU	access:public
Eigen::PastixLU::init	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLU	access:protected	signature:()
Eigen::PastixLU::MatrixType	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLU	access:public
Eigen::PastixLU::m_structureIsUptodate	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    bool m_structureIsUptodate;$/;"	m	class:Eigen::PastixLU	access:protected
Eigen::PastixLU::PastixLU	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU() : Base()$/;"	f	class:Eigen::PastixLU	access:public	signature:()
Eigen::PastixLU::PastixLU	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
EIGEN_PASTIXSUPPORT_H	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	26;"	d
Eigen::PermutationBase::applyTranspositionOnTheLeft	../include/Eigen/src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheLeft(Index i, Index j)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index i, Index j)
Eigen::PermutationBase::applyTranspositionOnTheRight	../include/Eigen/src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheRight(Index i, Index j)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index i, Index j)
Eigen::PermutationBase::assignProduct	../include/Eigen/src/Core/PermutationMatrix.h	/^    void assignProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationBase	access:protected	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::PermutationBase::assignTranspose	../include/Eigen/src/Core/PermutationMatrix.h	/^    void assignTranspose(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase	access:protected	signature:(const PermutationBase<OtherDerived>& other)
Eigen::PermutationBase::Base	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::PermutationBase	access:private
Eigen::PermutationBase::CoeffReadCost	../include/Eigen/src/Core/PermutationMatrix.h	/^      CoeffReadCost = Traits::CoeffReadCost,$/;"	e	enum:Eigen::PermutationBase::__anon117
Eigen::PermutationBase::ColsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon117
Eigen::PermutationBase::cols	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Index cols() const { return indices().size(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::DenseMatrixType	../include/Eigen/src/Core/PermutationMatrix.h	/^            DenseMatrixType;$/;"	t	class:Eigen::PermutationBase	access:public
Eigen::PermutationBase::evalTo	../include/Eigen/src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::PermutationBase	access:public	signature:(MatrixBase<DenseDerived>& other) const
Eigen::PermutationBase::Flags	../include/Eigen/src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::PermutationBase::__anon117
Eigen::PermutationBase	../include/Eigen/src/Core/PermutationMatrix.h	/^class PermutationBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::PermutationBase::Index	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::Index Index;$/;"	t	class:Eigen::PermutationBase	access:public
Eigen::PermutationBase::indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:()
Eigen::PermutationBase::IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationBase	access:public
Eigen::PermutationBase::inverse	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Transpose<PermutationBase> inverse() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::MaxColsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::PermutationBase::__anon117
Eigen::PermutationBase::MaxRowsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon117
Eigen::PermutationBase::operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const PermutationBase<OtherDerived>& other)
Eigen::PermutationBase::operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase& other)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const PermutationBase& other)
Eigen::PermutationBase::operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& tr)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const TranspositionsBase<OtherDerived>& tr)
Eigen::PermutationBase::operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const PermutationBase<Other>& other) const$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const PermutationBase<Other>& other) const
Eigen::PermutationBase::operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other) const$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const Transpose<PermutationBase<Other> >& other) const
Eigen::PermutationBase::operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other, const PermutationBase& perm)$/;"	f	class:Eigen::PermutationBase	access:friend	signature:(const Transpose<PermutationBase<Other> >& other, const PermutationBase& perm)
Eigen::PermutationBase::PlainPermutationType	../include/Eigen/src/Core/PermutationMatrix.h	/^            PlainPermutationType;$/;"	t	class:Eigen::PermutationBase	access:public
Eigen::PermutationBase::resize	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline void resize(Index size)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index size)
Eigen::PermutationBase::RowsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon117
Eigen::PermutationBase::rows	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Index rows() const { return indices().size(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::Scalar	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PermutationBase	access:public
Eigen::PermutationBase::setIdentity	../include/Eigen/src/Core/PermutationMatrix.h	/^    void setIdentity()$/;"	f	class:Eigen::PermutationBase	access:public	signature:()
Eigen::PermutationBase::setIdentity	../include/Eigen/src/Core/PermutationMatrix.h	/^    void setIdentity(Index size)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index size)
Eigen::PermutationBase::size	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Index size() const { return indices().size(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::toDenseMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationBase::Traits	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::PermutationBase	access:private
Eigen::PermutationBase::transpose	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Transpose<PermutationBase> transpose() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Eigen::PermutationMatrix::Base	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationMatrix> Base;$/;"	t	class:Eigen::PermutationMatrix	access:private
EIGEN_PERMUTATIONMATRIX_H	../include/Eigen/src/Core/PermutationMatrix.h	27;"	d
Eigen::PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^class PermutationMatrix : public PermutationBase<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >$/;"	c	namespace:Eigen	inherits:PermutationBase
Eigen::PermutationMatrix::indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:() const
Eigen::PermutationMatrix::indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:()
Eigen::PermutationMatrix::IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationMatrix	access:public
Eigen::PermutationMatrix::m_indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::PermutationMatrix	access:protected
Eigen::PermutationMatrix::operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationBase<Other>& other)
Eigen::PermutationMatrix::operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationMatrix& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationMatrix& other)
Eigen::PermutationMatrix::operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const TranspositionsBase<Other>& tr)
Eigen::PermutationMatrix::PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    explicit inline PermutationMatrix(const MatrixBase<Other>& indices) : m_indices(indices)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const MatrixBase<Other>& indices)
Eigen::PermutationMatrix::PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    explicit PermutationMatrix(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const TranspositionsBase<Other>& tr)
Eigen::PermutationMatrix::PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationBase<OtherDerived>& other)
Eigen::PermutationMatrix::PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationMatrix& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationMatrix& other)
Eigen::PermutationMatrix::PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix()$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:()
Eigen::PermutationMatrix::PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(int size) : m_indices(size)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(int size)
Eigen::PermutationMatrix::PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix(const Transpose<PermutationBase<Other> >& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const Transpose<PermutationBase<Other> >& other)
Eigen::PermutationMatrix::PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)
Eigen::PermutationMatrix::Traits	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationMatrix> Traits;$/;"	t	class:Eigen::PermutationMatrix	access:private
Eigen::PermutationStorage	../include/Eigen/src/Core/PermutationMatrix.h	/^struct PermutationStorage {};$/;"	s	namespace:Eigen
Eigen::PermutationWrapper::Base	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationWrapper> Base;$/;"	t	class:Eigen::PermutationWrapper	access:private
Eigen::PermutationWrapper	../include/Eigen/src/Core/PermutationMatrix.h	/^class PermutationWrapper : public PermutationBase<PermutationWrapper<_IndicesType> >$/;"	c	namespace:Eigen	inherits:PermutationBase
Eigen::PermutationWrapper::indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationWrapper	access:public	signature:() const
Eigen::PermutationWrapper::IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationWrapper	access:public
Eigen::PermutationWrapper::m_indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::PermutationWrapper	access:protected
Eigen::PermutationWrapper::PermutationWrapper	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationWrapper(const IndicesType& indices)$/;"	f	class:Eigen::PermutationWrapper	access:public	signature:(const IndicesType& indices)
Eigen::PermutationWrapper::Traits	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationWrapper> Traits;$/;"	t	class:Eigen::PermutationWrapper	access:private
Eigen::Pivoting	../include/Eigen/src/Core/util/Constants.h	/^  Pivoting            = 0x01, $/;"	e	enum:Eigen::DecompositionOptions
eigen_plain_assert	../include/Eigen/src/Core/util/Macros.h	184;"	d
eigen_plain_assert	../include/Eigen/src/Core/util/Macros.h	192;"	d
EIGEN_PLAIN_ENUM_MAX	../include/Eigen/src/Core/util/Macros.h	378;"	d
EIGEN_PLAIN_ENUM_MIN	../include/Eigen/src/Core/util/Macros.h	377;"	d
Eigen::PlainObjectBase::AlignedMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Aligned> AlignedMapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::base	../include/Eigen/src/Core/PlainObjectBase.h	/^    Base& base() { return *static_cast<Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
Eigen::PlainObjectBase::base	../include/Eigen/src/Core/PlainObjectBase.h	/^    const Base& base() const { return *static_cast<const Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
Eigen::PlainObjectBase::Base	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::_check_template_params	../include/Eigen/src/Core/PlainObjectBase.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
Eigen::PlainObjectBase::coeff	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index) const
Eigen::PlainObjectBase::coeff	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index row, Index col) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index row, Index col) const
Eigen::PlainObjectBase::coeffRef	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index) const
Eigen::PlainObjectBase::coeffRef	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index row, Index col) const
Eigen::PlainObjectBase::coeffRef	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index)
Eigen::PlainObjectBase::coeffRef	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index row, Index col)
Eigen::PlainObjectBase::cols	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
Eigen::PlainObjectBase::conservativeResize	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
Eigen::PlainObjectBase::conservativeResize	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index rows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, NoChange_t)
Eigen::PlainObjectBase::conservativeResize	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index size)
Eigen::PlainObjectBase::conservativeResize	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(NoChange_t, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(NoChange_t, Index cols)
Eigen::PlainObjectBase::conservativeResizeLike	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResizeLike(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::PlainObjectBase::ConstAlignedMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::ConstMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::data	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar *data() const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
Eigen::PlainObjectBase::data	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar *data()$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
Eigen::PlainObjectBase::DenseType	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef Derived DenseType;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase	../include/Eigen/src/Core/PlainObjectBase.h	/^class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base_dispatcher_for_doxygen
Eigen::PlainObjectBase::Index	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::_init2	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(const Scalar& x, const Scalar& y, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const Scalar& x, const Scalar& y, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)
Eigen::PlainObjectBase::_init2	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)
Eigen::PlainObjectBase::lazyAssign	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::PlainObjectBase::MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data)
Eigen::PlainObjectBase::MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols)
Eigen::PlainObjectBase::MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size)
Eigen::PlainObjectBase::MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data)
Eigen::PlainObjectBase::MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols)
Eigen::PlainObjectBase::MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size)
Eigen::PlainObjectBase::MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data)
Eigen::PlainObjectBase::Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols)
Eigen::PlainObjectBase::Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size)
Eigen::PlainObjectBase::Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data)
Eigen::PlainObjectBase::Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols)
Eigen::PlainObjectBase::Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size)
Eigen::PlainObjectBase::Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size, const Stride<Outer, Inner>& stride)
Eigen::PlainObjectBase::MapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Unaligned>  MapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::m_storage	../include/Eigen/src/Core/PlainObjectBase.h	/^    DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;$/;"	m	class:Eigen::PlainObjectBase	access:protected
Eigen::PlainObjectBase::NeedsToAlign	../include/Eigen/src/Core/PlainObjectBase.h	/^    enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };$/;"	e	enum:Eigen::PlainObjectBase::__anon62
Eigen::PlainObjectBase::operator =	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::PlainObjectBase::operator =	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const PlainObjectBase& other)
Eigen::PlainObjectBase::operator =	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const ReturnByValue<OtherDerived>& func)
Eigen::PlainObjectBase::Options	../include/Eigen/src/Core/PlainObjectBase.h	/^    enum { Options = internal::traits<Derived>::Options };$/;"	e	enum:Eigen::PlainObjectBase::__anon61
Eigen::PlainObjectBase::packet	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index) const
Eigen::PlainObjectBase::packet	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index row, Index col) const
Eigen::PlainObjectBase::PacketScalar	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::PlainObjectBase	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE explicit PlainObjectBase() : m_storage()$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
Eigen::PlainObjectBase::PlainObjectBase	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::PlainObjectBase::PlainObjectBase	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(Index size, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index size, Index rows, Index cols)
Eigen::PlainObjectBase::PlainObjectBase	../include/Eigen/src/Core/PlainObjectBase.h	/^    PlainObjectBase(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Eigen::PlainObjectBase::RealScalar	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::resize	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resize(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
Eigen::PlainObjectBase::resize	../include/Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(Index rows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, NoChange_t)
Eigen::PlainObjectBase::resize	../include/Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index size)
Eigen::PlainObjectBase::resize	../include/Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(NoChange_t, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(NoChange_t, Index cols)
Eigen::PlainObjectBase::resizeLike	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const EigenBase<OtherDerived>& _other)
Eigen::PlainObjectBase::_resize_to_match	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const EigenBase<OtherDerived>& other)
Eigen::PlainObjectBase::rows	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
Eigen::PlainObjectBase::Scalar	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::setConstant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index rows, Index cols, const Scalar& value)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index rows, Index cols, const Scalar& value)
Eigen::PlainObjectBase::setConstant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index size, const Scalar& value)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index size, const Scalar& value)
Eigen::PlainObjectBase::setConstant	../include/Eigen/src/Core/PlainObjectBase.h	/^    Derived& setConstant(Index rows, Index cols, const Scalar& value);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols, const Scalar& value)
Eigen::PlainObjectBase::_set	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const DenseBase<OtherDerived>& other)
Eigen::PlainObjectBase::_set_noalias	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const DenseBase<OtherDerived>& other)
Eigen::PlainObjectBase::setOnes	../include/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index rows, Index cols)
Eigen::PlainObjectBase::setOnes	../include/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index size)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index size)
Eigen::PlainObjectBase::setOnes	../include/Eigen/src/Core/PlainObjectBase.h	/^    Derived& setOnes(Index rows, Index cols);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
Eigen::PlainObjectBase::setRandom	../include/Eigen/src/Core/PlainObjectBase.h	/^    Derived& setRandom(Index rows, Index cols);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
Eigen::PlainObjectBase::setRandom	../include/Eigen/src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index rows, Index cols)
Eigen::PlainObjectBase::setRandom	../include/Eigen/src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index size)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index size)
Eigen::PlainObjectBase::_set_selector	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::false_type&) { _set_noalias(other); }$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const OtherDerived& other, const internal::false_type&)
Eigen::PlainObjectBase::_set_selector	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::true_type&) { _set_noalias(other.eval()); }$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const OtherDerived& other, const internal::true_type&)
Eigen::PlainObjectBase::setZero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index rows, Index cols)
Eigen::PlainObjectBase::setZero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index size)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index size)
Eigen::PlainObjectBase::setZero	../include/Eigen/src/Core/PlainObjectBase.h	/^    Derived& setZero(Index rows, Index cols);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
Eigen::PlainObjectBase::StorageKind	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::StridedAlignedMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::StridedAlignedMapType::type	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedAlignedMapType	access:public
Eigen::PlainObjectBase::StridedConstAlignedMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::StridedConstAlignedMapType::type	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstAlignedMapType	access:public
Eigen::PlainObjectBase::StridedConstMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::StridedConstMapType::type	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstMapType	access:public
Eigen::PlainObjectBase::StridedMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
Eigen::PlainObjectBase::StridedMapType::type	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedMapType	access:public
Eigen::PlainObjectBase::_swap	../include/Eigen/src/Core/PlainObjectBase.h	/^    void _swap(DenseBase<OtherDerived> const & other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(DenseBase<OtherDerived> const & other)
Eigen::PlainObjectBase::ThisConstantIsPrivateInPlainObjectBase	../include/Eigen/src/Core/PlainObjectBase.h	/^    enum { ThisConstantIsPrivateInPlainObjectBase };$/;"	e	enum:Eigen::PlainObjectBase::__anon63
Eigen::PlainObjectBase::writePacket	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index, const PacketScalar& x)
Eigen::PlainObjectBase::writePacket	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index row, Index col, const PacketScalar& x)
Eigen::precision	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T precision () { return NumTraits<T>::dummy_precision(); }$/;"	f	namespace:Eigen	signature:()
EIGEN_PREDICATE_SAME_MATRIX_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	172;"	d
Eigen::ProductBase::_ActualLhsType	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<ActualLhsType>::type _ActualLhsType;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::ActualLhsType	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::_ActualRhsType	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<ActualRhsType>::type _ActualRhsType;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::ActualRhsType	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::addTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void addTo(Dest& dst) const { scaleAndAddTo(dst,Scalar(1)); }$/;"	f	class:Eigen::ProductBase	access:public	signature:(Dest& dst) const
Eigen::ProductBase::Base	../include/Eigen/src/Core/ProductBase.h	/^    typedef MatrixBase<Derived> Base;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::coeff	../include/Eigen/src/Core/ProductBase.h	/^    typename Base::CoeffReturnType coeff(Index i) const$/;"	f	class:Eigen::ProductBase	access:public	signature:(Index i) const
Eigen::ProductBase::coeff	../include/Eigen/src/Core/ProductBase.h	/^    typename Base::CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ProductBase	access:public	signature:(Index row, Index col) const
Eigen::ProductBase::coeffRef	../include/Eigen/src/Core/ProductBase.h	/^    const Scalar& coeffRef(Index i) const$/;"	f	class:Eigen::ProductBase	access:public	signature:(Index i) const
Eigen::ProductBase::coeffRef	../include/Eigen/src/Core/ProductBase.h	/^    const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::ProductBase	access:public	signature:(Index row, Index col) const
Eigen::ProductBase::cols	../include/Eigen/src/Core/ProductBase.h	/^    inline Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
Eigen::ProductBase::diagonal	../include/Eigen/src/Core/ProductBase.h	/^    const Diagonal<const FullyLazyCoeffBaseProductType,0> diagonal() const$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
Eigen::ProductBase::diagonal	../include/Eigen/src/Core/ProductBase.h	/^    const Diagonal<FullyLazyCoeffBaseProductType,Dynamic> diagonal(Index index) const$/;"	f	class:Eigen::ProductBase	access:public	signature:(Index index) const
Eigen::ProductBase::diagonal	../include/Eigen/src/Core/ProductBase.h	/^    const Diagonal<FullyLazyCoeffBaseProductType,Index> diagonal() const$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
Eigen::ProductBase::evalTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst,Scalar(1)); }$/;"	f	class:Eigen::ProductBase	access:public	signature:(Dest& dst) const
Eigen::ProductBase::FullyLazyCoeffBaseProductType	../include/Eigen/src/Core/ProductBase.h	/^    typedef CoeffBasedProduct<LhsNested, RhsNested, 0> FullyLazyCoeffBaseProductType;$/;"	t	class:Eigen::ProductBase	access:public
EIGEN_PRODUCTBASE_H	../include/Eigen/src/Core/ProductBase.h	26;"	d
Eigen::ProductBase	../include/Eigen/src/Core/ProductBase.h	/^class ProductBase : public MatrixBase<Derived>$/;"	c	namespace:Eigen	inherits:MatrixBase
Eigen::ProductBase::LhsBlasTraits	../include/Eigen/src/Core/ProductBase.h	/^    typedef internal::blas_traits<_LhsNested> LhsBlasTraits;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::lhs	../include/Eigen/src/Core/ProductBase.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
Eigen::ProductBase::_LhsNested	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::LhsNested	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::LhsScalar	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::traits<Lhs>::Scalar LhsScalar;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::m_lhs	../include/Eigen/src/Core/ProductBase.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::ProductBase	access:protected
Eigen::ProductBase::m_result	../include/Eigen/src/Core/ProductBase.h	/^    mutable PlainObject m_result;$/;"	m	class:Eigen::ProductBase	access:protected
Eigen::ProductBase::m_rhs	../include/Eigen/src/Core/ProductBase.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::ProductBase	access:protected
Eigen::ProductBase::operator const PlainObject&	../include/Eigen/src/Core/ProductBase.h	/^    operator const PlainObject& () const$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
Eigen::ProductBase::PlainObject	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::ProductBase	../include/Eigen/src/Core/ProductBase.h	/^    ProductBase(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::ProductBase	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::ProductBase::RhsBlasTraits	../include/Eigen/src/Core/ProductBase.h	/^    typedef internal::blas_traits<_RhsNested> RhsBlasTraits;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::rhs	../include/Eigen/src/Core/ProductBase.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
Eigen::ProductBase::_RhsNested	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::RhsNested	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::RhsScalar	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::traits<Rhs>::Scalar RhsScalar;$/;"	t	class:Eigen::ProductBase	access:public
Eigen::ProductBase::rows	../include/Eigen/src/Core/ProductBase.h	/^    inline Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
Eigen::ProductBase::scaleAndAddTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void scaleAndAddTo(Dest& dst,Scalar alpha) const { derived().scaleAndAddTo(dst,alpha); }$/;"	f	class:Eigen::ProductBase	access:public	signature:(Dest& dst,Scalar alpha) const
Eigen::ProductBase::subTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void subTo(Dest& dst) const { scaleAndAddTo(dst,Scalar(-1)); }$/;"	f	class:Eigen::ProductBase	access:public	signature:(Dest& dst) const
EIGEN_PRODUCT_H	../include/Eigen/src/Core/Product.h	26;"	d
EIGEN_PRODUCT_PUBLIC_INTERFACE	../include/Eigen/src/Core/ProductBase.h	61;"	d
Eigen::ProductReturnType	../include/Eigen/src/Core/GeneralProduct.h	/^struct ProductReturnType<Lhs,Rhs,CoeffBasedProductMode>$/;"	s	namespace:Eigen
Eigen::ProductReturnType	../include/Eigen/src/Core/GeneralProduct.h	/^struct ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen
Eigen::ProductReturnType	../include/Eigen/src/Core/GeneralProduct.h	/^struct ProductReturnType$/;"	s	namespace:Eigen
Eigen::ProductReturnType::LhsNested	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef typename internal::nested<Lhs, Rhs::ColsAtCompileTime, typename internal::plain_matrix_type<Lhs>::type >::type LhsNested;$/;"	t	struct:Eigen::ProductReturnType	access:public
Eigen::ProductReturnType::RhsNested	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef typename internal::nested<Rhs, Lhs::RowsAtCompileTime, typename internal::plain_matrix_type<Rhs>::type >::type RhsNested;$/;"	t	struct:Eigen::ProductReturnType	access:public
Eigen::ProductReturnType::Type	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef CoeffBasedProduct<LhsNested, RhsNested, EvalBeforeAssigningBit | EvalBeforeNestingBit> Type;$/;"	t	struct:Eigen::ProductReturnType	access:public
Eigen::ProductReturnType::Type	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef CoeffBasedProduct<LhsNested, RhsNested, NestByRefBit> Type;$/;"	t	struct:Eigen::ProductReturnType	access:public
Eigen::ProductReturnType::Type	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef GeneralProduct<Lhs\/*Nested*\/, Rhs\/*Nested*\/, ProductType> Type;$/;"	t	struct:Eigen::ProductReturnType	access:public
Eigen::Projective2d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Projective> Projective2d;$/;"	t	namespace:Eigen
Eigen::Projective2f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Projective> Projective2f;$/;"	t	namespace:Eigen
Eigen::Projective3d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Projective> Projective3d;$/;"	t	namespace:Eigen
Eigen::Projective3f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Projective> Projective3f;$/;"	t	namespace:Eigen
Eigen::Projective	../include/Eigen/src/Core/util/Constants.h	/^  Projective    = 0x20$/;"	e	enum:Eigen::TransformTraits
Eigen::QR::Base	../include/Eigen/src/Eigen2Support/QR.h	/^    typedef HouseholderQR<MatrixType> Base;$/;"	t	class:Eigen::QR	access:public
EIGEN_QR_H	../include/Eigen/src/QR/HouseholderQR.h	28;"	d
Eigen::QR	../include/Eigen/src/Eigen2Support/QR.h	/^class QR : public HouseholderQR<MatrixType>$/;"	c	namespace:Eigen	inherits:HouseholderQR
Eigen::QR::isFullRank	../include/Eigen/src/Eigen2Support/QR.h	/^    bool isFullRank() const {$/;"	f	class:Eigen::QR	access:public	signature:() const
Eigen::QR::matrixQ	../include/Eigen/src/Eigen2Support/QR.h	/^    MatrixType matrixQ(void) const {$/;"	f	class:Eigen::QR	access:public	signature:(void) const
Eigen::QR::MatrixRBlockType	../include/Eigen/src/Eigen2Support/QR.h	/^    typedef Block<const MatrixType, MatrixType::ColsAtCompileTime, MatrixType::ColsAtCompileTime> MatrixRBlockType;$/;"	t	class:Eigen::QR	access:public
Eigen::QR::matrixR	../include/Eigen/src/Eigen2Support/QR.h	/^    matrixR(void) const$/;"	f	class:Eigen::QR	access:public	signature:(void) const
EIGEN_QR_MKL_H	../include/Eigen/src/QR/HouseholderQR_MKL.h	35;"	d
Eigen::QRPreconditioners	../include/Eigen/src/Core/util/Constants.h	/^enum QRPreconditioners {$/;"	g	namespace:Eigen
Eigen::QR::QR	../include/Eigen/src/Eigen2Support/QR.h	/^    explicit QR(const T& t) : Base(t) {}$/;"	f	class:Eigen::QR	access:public	signature:(const T& t)
Eigen::QR::QR	../include/Eigen/src/Eigen2Support/QR.h	/^    QR() : Base() {}$/;"	f	class:Eigen::QR	access:public	signature:()
Eigen::QR::solve	../include/Eigen/src/Eigen2Support/QR.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::QR	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
Eigen::Quaternion::AngleAxisType	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::AngleAxisType	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef typename Base::AngleAxisType AngleAxisType;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::angularDistance	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar angularDistance(const Quaternion& other) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other) const
Eigen::Quaternion::angularDistance	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Scalar Quaternion<Scalar>::angularDistance(const Quaternion& other) const$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other) const
Eigen::QuaternionBase::AngleAxisType	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::QuaternionBase	access:public
Eigen::QuaternionBase::angularDistance	../include/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::angularDistance(const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other) const
Eigen::QuaternionBase::angularDistance	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> Scalar angularDistance(const QuaternionBase<OtherDerived>& other) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other) const
Eigen::QuaternionBase::Base	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef RotationBase<Derived, 3> Base;$/;"	t	class:Eigen::QuaternionBase	access:private
Eigen::QuaternionBase::cast	../include/Eigen/src/Geometry/Quaternion.h	/^  inline typename internal::cast_return_type<Derived,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::Coefficients	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Coefficients Coefficients;$/;"	t	class:Eigen::QuaternionBase	access:public
Eigen::QuaternionBase::coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^  inline const typename internal::traits<Derived>::Coefficients& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^  inline typename internal::traits<Derived>::Coefficients& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::conjugate	../include/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::conjugate() const$/;"	f	class:Eigen::QuaternionBase	signature:() const
Eigen::QuaternionBase::conjugate	../include/Eigen/src/Geometry/Quaternion.h	/^  Quaternion<Scalar> conjugate() const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::dot	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> inline Scalar dot(const QuaternionBase<OtherDerived>& other) const { return coeffs().dot(other.coeffs()); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other) const
Eigen::QuaternionBase::Flags	../include/Eigen/src/Geometry/Quaternion.h	/^    Flags = Eigen::internal::traits<Derived>::Flags$/;"	e	enum:Eigen::QuaternionBase::__anon385
Eigen::QuaternionBase::Identity	../include/Eigen/src/Geometry/Quaternion.h	/^  static inline Quaternion<Scalar> Identity() { return Quaternion<Scalar>(1, 0, 0, 0); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::Quaternion::Base	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef RotationBase<Quaternion<_Scalar>,3> Base;$/;"	t	class:Eigen::Quaternion	access:private
Eigen::QuaternionBase	../include/Eigen/src/Geometry/Quaternion.h	/^class QuaternionBase : public RotationBase<Derived, 3>$/;"	c	namespace:Eigen	inherits:RotationBase
Eigen::Quaternion::Base	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef QuaternionBase<Quaternion<_Scalar,_Options> > Base;$/;"	t	class:Eigen::Quaternion	access:private
Eigen::QuaternionBase::inverse	../include/Eigen/src/Geometry/Quaternion.h	/^inline Quaternion<typename internal::traits<Derived>::Scalar> QuaternionBase<Derived>::inverse() const$/;"	f	class:Eigen::QuaternionBase	signature:() const
Eigen::QuaternionBase::inverse	../include/Eigen/src/Geometry/Quaternion.h	/^  Quaternion<Scalar> inverse() const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::isApprox	../include/Eigen/src/Geometry/Quaternion.h	/^  bool isApprox(const QuaternionBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::QuaternionBase::Matrix3	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::QuaternionBase	access:public
Eigen::QuaternionBase::normalized	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion<Scalar> normalized() const { return Quaternion<Scalar>(coeffs().normalized()); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::normalize	../include/Eigen/src/Geometry/Quaternion.h	/^  inline void normalize() { coeffs().normalize(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::norm	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar norm() const { return coeffs().norm(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::operator =	../include/Eigen/src/Geometry/Quaternion.h	/^  Derived& operator=(const AngleAxisType& aa);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const AngleAxisType& aa)
Eigen::QuaternionBase::operator =	../include/Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::QuaternionBase	signature:(const AngleAxisType& aa)
Eigen::QuaternionBase::operator =	../include/Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other)
Eigen::QuaternionBase::operator *=	../include/Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator*= (const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other)
Eigen::QuaternionBase::operator =	../include/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_STRONG_INLINE QuaternionBase<Derived>& operator=(const QuaternionBase<Derived>& other);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<Derived>& other)
Eigen::QuaternionBase::operator =	../include/Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE QuaternionBase<Derived>& QuaternionBase<Derived>::operator=(const QuaternionBase<Derived>& other)$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<Derived>& other)
Eigen::QuaternionBase::operator =	../include/Eigen/src/Geometry/Quaternion.h	/^inline Derived& QuaternionBase<Derived>::operator=(const MatrixBase<MatrixDerived>& xpr)$/;"	f	class:Eigen::QuaternionBase	signature:(const MatrixBase<MatrixDerived>& xpr)
Eigen::QuaternionBase::operator *	../include/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::operator* (const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other) const
Eigen::QuaternionBase::operator =	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> Derived& operator=(const MatrixBase<OtherDerived>& m);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const MatrixBase<OtherDerived>& m)
Eigen::QuaternionBase::operator =	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_STRONG_INLINE Derived& operator=(const QuaternionBase<OtherDerived>& other);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other)
Eigen::QuaternionBase::operator *=	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_STRONG_INLINE Derived& operator*= (const QuaternionBase<OtherDerived>& q);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& q)
Eigen::QuaternionBase::operator *	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_STRONG_INLINE Quaternion<Scalar> operator* (const QuaternionBase<OtherDerived>& q) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& q) const
Eigen::QuaternionBase::RealScalar	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::QuaternionBase	access:public
Eigen::QuaternionBase::Scalar	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::QuaternionBase	access:public
Eigen::QuaternionBase::setFromTwoVectors	../include/Eigen/src/Geometry/Quaternion.h	/^  Derived& setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
Eigen::QuaternionBase::setFromTwoVectors	../include/Eigen/src/Geometry/Quaternion.h	/^inline Derived& QuaternionBase<Derived>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::QuaternionBase	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
Eigen::QuaternionBase::setIdentity	../include/Eigen/src/Geometry/Quaternion.h	/^  inline QuaternionBase& setIdentity() { coeffs() << 0, 0, 0, 1; return *this; }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::slerp	../include/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::slerp(Scalar t, const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase	signature:(Scalar t, const QuaternionBase<OtherDerived>& other) const
Eigen::QuaternionBase::slerp	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> Quaternion<Scalar> slerp(Scalar t, const QuaternionBase<OtherDerived>& other) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(Scalar t, const QuaternionBase<OtherDerived>& other) const
Eigen::QuaternionBase::squaredNorm	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar squaredNorm() const { return coeffs().squaredNorm(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::toRotationMatrix	../include/Eigen/src/Geometry/Quaternion.h	/^  Matrix3 toRotationMatrix() const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::toRotationMatrix	../include/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::toRotationMatrix(void) const$/;"	f	class:Eigen::QuaternionBase	signature:(void) const
Eigen::QuaternionBase::_transformVector	../include/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_STRONG_INLINE Vector3 _transformVector(Vector3 v) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(Vector3 v) const
Eigen::QuaternionBase::_transformVector	../include/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::_transformVector(Vector3 v) const$/;"	f	class:Eigen::QuaternionBase	signature:(Vector3 v) const
Eigen::QuaternionBase::vec	../include/Eigen/src/Geometry/Quaternion.h	/^  inline const VectorBlock<const Coefficients,3> vec() const { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::vec	../include/Eigen/src/Geometry/Quaternion.h	/^  inline VectorBlock<Coefficients,3> vec() { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::Vector3	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::QuaternionBase	access:public
Eigen::QuaternionBase::w	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar w() const { return this->derived().coeffs().coeff(3); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::w	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& w() { return this->derived().coeffs().coeffRef(3); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::x	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar x() const { return this->derived().coeffs().coeff(0); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::x	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& x() { return this->derived().coeffs().coeffRef(0); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::y	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar y() const { return this->derived().coeffs().coeff(1); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::y	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& y() { return this->derived().coeffs().coeffRef(1); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::QuaternionBase::z	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar z() const { return this->derived().coeffs().coeff(2); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
Eigen::QuaternionBase::z	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& z() { return this->derived().coeffs().coeffRef(2); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Eigen::Quaternion::cast	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline typename internal::cast_return_type<Quaternion,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::_check_template_params	../include/Eigen/src/Geometry/Quaternion.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::Quaternion	access:protected	signature:()
Eigen::Quaternion::Coefficients	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar, 4, 1> Coefficients;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::Coefficients	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Quaternion>::Coefficients Coefficients;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::coeffs	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::coeffs	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Coefficients& coeffs() { return m_coeffs;}$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^  inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::conjugate	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::conjugate() const$/;"	f	class:Eigen::Quaternion	signature:() const
Eigen::Quaternion::conjugate	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion conjugate(void) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(void) const
Eigen::Quaterniond	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Eigen::Quaterniond	../include/Eigen/src/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Eigen::Quaternion::eigen2_dot	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar eigen2_dot(const Quaternion& other) const { return m_coeffs.eigen2_dot(other.m_coeffs); }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other) const
Eigen::Quaternionf	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
Eigen::Quaternionf	../include/Eigen/src/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
Eigen::Quaternion::FromTwoVectors	../include/Eigen/src/Geometry/Quaternion.h	/^Quaternion<Scalar,Options> Quaternion<Scalar,Options>::FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
Eigen::Quaternion::FromTwoVectors	../include/Eigen/src/Geometry/Quaternion.h	/^  static Quaternion FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
EIGEN_QUATERNION_H	../include/Eigen/src/Geometry/Quaternion.h	27;"	d
Eigen::Quaternion::Identity	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  static inline Quaternion Identity() { return Quaternion(1, 0, 0, 0); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^class Quaternion : public RotationBase<Quaternion<_Scalar>,3>$/;"	c	namespace:Eigen	inherits:RotationBase
Eigen::Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^class Quaternion : public QuaternionBase<Quaternion<_Scalar,_Options> >$/;"	c	namespace:Eigen	inherits:QuaternionBase
Eigen::Quaternion::inverse	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::inverse() const$/;"	f	class:Eigen::Quaternion	signature:() const
Eigen::Quaternion::inverse	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion inverse(void) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(void) const
Eigen::Quaternion::IsAligned	../include/Eigen/src/Geometry/Quaternion.h	/^  enum { IsAligned = internal::traits<Quaternion>::IsAligned };$/;"	e	enum:Eigen::Quaternion::__anon387
Eigen::Quaternion::isApprox	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  bool isApprox(const Quaternion& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::QuaternionMapAlignedd	../include/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, Aligned>  QuaternionMapAlignedd;$/;"	t	namespace:Eigen
Eigen::QuaternionMapAlignedf	../include/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, Aligned>   QuaternionMapAlignedf;$/;"	t	namespace:Eigen
Eigen::QuaternionMapd	../include/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, 0>        QuaternionMapd;$/;"	t	namespace:Eigen
Eigen::QuaternionMapf	../include/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, 0>         QuaternionMapf;$/;"	t	namespace:Eigen
Eigen::Quaternion::Matrix3	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::m_coeffs	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion	access:protected
Eigen::Quaternion::m_coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion	access:protected
Eigen::Quaternion::normalized	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion normalized() const { return Quaternion(m_coeffs.normalized()); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::normalize	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline void normalize() { m_coeffs.normalize(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::norm	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar norm() const { return m_coeffs.norm(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::operator *	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion operator* (const Quaternion& q) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& q) const
Eigen::Quaternion::operator *=	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion& operator*= (const Quaternion& q);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& q)
Eigen::Quaternion::operator =	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::Quaternion	signature:(const AngleAxisType& aa)
Eigen::Quaternion::operator =	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const MatrixBase<Derived>& xpr)$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived>& xpr)
Eigen::Quaternion::operator *	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::operator* (const Quaternion& other) const$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other) const
Eigen::Quaternion::operator =	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const Quaternion& other)$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other)
Eigen::Quaternion::operator *=	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator*= (const Quaternion& other)$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other)
Eigen::Quaternion::operator =	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& operator=(const AngleAxisType& aa);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const AngleAxisType& aa)
Eigen::Quaternion::operator =	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& operator=(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::Quaternion::operator =	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& operator=(const Quaternion& other);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other)
Eigen::Quaternion::operator *	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar>::operator* (const MatrixBase<Derived>& v) const$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived>& v) const
Eigen::Quaternion::operator *	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Vector3 operator* (const MatrixBase<Derived>& vec) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& vec) const
Eigen::Quaternion::Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const AngleAxisType& aa)
Eigen::Quaternion::Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& other)
Eigen::Quaternion::Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline explicit Quaternion(const Quaternion<OtherScalarType>& other)$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion<OtherScalarType>& other)
Eigen::Quaternion::Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion(const Quaternion& other) { m_coeffs = other.m_coeffs; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other)
Eigen::Quaternion::Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion() {}$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion(Scalar w, Scalar x, Scalar y, Scalar z)$/;"	f	class:Eigen::Quaternion	access:public	signature:(Scalar w, Scalar x, Scalar y, Scalar z)
Eigen::Quaternion::Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const AngleAxisType& aa)
Eigen::Quaternion::Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& other)
Eigen::Quaternion::Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const Quaternion<OtherScalar, OtherOptions>& other)$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion<OtherScalar, OtherOptions>& other)
Eigen::Quaternion::Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion(const Scalar* data) : m_coeffs(data) {}$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Scalar* data)
Eigen::Quaternion::Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion() {}$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion(Scalar w, Scalar x, Scalar y, Scalar z) : m_coeffs(x, y, z, w){}$/;"	f	class:Eigen::Quaternion	access:public	signature:(Scalar w, Scalar x, Scalar y, Scalar z)
Eigen::Quaternion::Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> EIGEN_STRONG_INLINE Quaternion(const QuaternionBase<Derived>& other) { this->Base::operator=(other); }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const QuaternionBase<Derived>& other)
Eigen::Quaternion::Scalar	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::Scalar	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::setFromTwoVectors	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
Eigen::Quaternion::setFromTwoVectors	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
Eigen::Quaternion::setIdentity	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion& setIdentity() { m_coeffs << 0, 0, 0, 1; return *this; }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::slerp	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar> Quaternion<Scalar>::slerp(Scalar t, const Quaternion& other) const$/;"	f	class:Eigen::Quaternion	signature:(Scalar t, const Quaternion& other) const
Eigen::Quaternion::slerp	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion slerp(Scalar t, const Quaternion& other) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(Scalar t, const Quaternion& other) const
Eigen::Quaternion::squaredNorm	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar squaredNorm() const { return m_coeffs.squaredNorm(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Matrix3 toRotationMatrix(void) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(void) const
Eigen::Quaternion::toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Quaternion	signature:(void) const
Eigen::Quaternion::vec	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Block<Coefficients,3,1> vec() { return m_coeffs.template start<3>(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::vec	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline const Block<const Coefficients,3,1> vec() const { return m_coeffs.template start<3>(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::Vector3	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::Quaternion	access:public
Eigen::Quaternion::w	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar w() const { return m_coeffs.coeff(3); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::w	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& w() { return m_coeffs.coeffRef(3); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::x	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar x() const { return m_coeffs.coeff(0); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::x	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& x() { return m_coeffs.coeffRef(0); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::y	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar y() const { return m_coeffs.coeff(1); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::y	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& y() { return m_coeffs.coeffRef(1); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::Quaternion::z	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar z() const { return m_coeffs.coeff(2); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
Eigen::Quaternion::z	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& z() { return m_coeffs.coeffRef(2); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Eigen::RandomAccessPattern	../include/Eigen/src/SparseCore/SparseUtil.h	/^const int RandomAccessPattern       = 0x8 | OuterRandomAccessPattern | InnerRandomAccessPattern;$/;"	m	namespace:Eigen
EIGEN_RANDOM_H	../include/Eigen/src/Core/Random.h	26;"	d
Eigen::ReadOnlyAccessors	../include/Eigen/src/Core/util/Constants.h	/^  ReadOnlyAccessors, $/;"	e	enum:Eigen::AccessorLevels
Eigen::RealSchur::ColsAtCompileTime	../include/Eigen/src/Eigenvalues/RealSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon39
Eigen::RealSchur::ColumnVectorType	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::RealSchur::ComplexScalar	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::RealSchur::compute	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur& compute(const MatrixType& matrix, bool computeU = true);$/;"	p	class:Eigen::RealSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
Eigen::RealSchur::compute	../include/Eigen/src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)$/;"	f	class:Eigen::RealSchur	signature:(const MatrixType& matrix, bool computeU)
Eigen::RealSchur::computeNormOfT	../include/Eigen/src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Scalar RealSchur<MatrixType>::computeNormOfT()$/;"	f	class:Eigen::RealSchur	signature:()
Eigen::RealSchur::computeNormOfT	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    Scalar computeNormOfT();$/;"	p	class:Eigen::RealSchur	access:private	signature:()
Eigen::RealSchur::computeShift	../include/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)$/;"	f	class:Eigen::RealSchur	signature:(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)
Eigen::RealSchur::computeShift	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    void computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)
Eigen::RealSchur::EigenvalueType	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::RealSchur::findSmallSubdiagEntry	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    Index findSmallSubdiagEntry(Index iu, Scalar norm);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index iu, Scalar norm)
Eigen::RealSchur::findSmallSubdiagEntry	../include/Eigen/src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Index RealSchur<MatrixType>::findSmallSubdiagEntry(Index iu, Scalar norm)$/;"	f	class:Eigen::RealSchur	signature:(Index iu, Scalar norm)
EIGEN_REAL_SCHUR_H	../include/Eigen/src/Eigenvalues/RealSchur.h	27;"	d
Eigen::RealSchur	../include/Eigen/src/Eigenvalues/RealSchur.h	/^template<typename _MatrixType> class RealSchur$/;"	c	namespace:Eigen
Eigen::RealSchur::Index	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::RealSchur::info	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::RealSchur	access:public	signature:() const
Eigen::RealSchur::initFrancisQRStep	../include/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)$/;"	f	class:Eigen::RealSchur	signature:(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)
Eigen::RealSchur::initFrancisQRStep	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    void initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)
Eigen::RealSchur::matrixT	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixT() const$/;"	f	class:Eigen::RealSchur	access:public	signature:() const
Eigen::RealSchur::MatrixType	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::RealSchur::matrixU	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixU() const$/;"	f	class:Eigen::RealSchur	access:public	signature:() const
Eigen::RealSchur::MaxColsAtCompileTime	../include/Eigen/src/Eigenvalues/RealSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealSchur::__anon39
Eigen::RealSchur::MaxRowsAtCompileTime	../include/Eigen/src/Eigenvalues/RealSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon39
Eigen::RealSchur::m_hess	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::m_info	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::m_isInitialized	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::RealSchur	access:private
EIGEN_REAL_SCHUR_MKL_H	../include/Eigen/src/Eigenvalues/RealSchur_MKL.h	34;"	d
Eigen::RealSchur::m_matT	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::m_matU	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    MatrixType m_matU;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::m_matUisUptodate	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::m_maxIterations	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    static const int m_maxIterations = 40;$/;"	m	class:Eigen::RealSchur	access:public
Eigen::RealSchur::m_workspaceVector	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    ColumnVectorType m_workspaceVector;$/;"	m	class:Eigen::RealSchur	access:private
Eigen::RealSchur::Options	../include/Eigen/src/Eigenvalues/RealSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::RealSchur::__anon39
Eigen::RealSchur::performFrancisQRStep	../include/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)$/;"	f	class:Eigen::RealSchur	signature:(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)
Eigen::RealSchur::performFrancisQRStep	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    void performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)
Eigen::RealSchur::RealSchur	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur(const MatrixType& matrix, bool computeU = true)$/;"	f	class:Eigen::RealSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
Eigen::RealSchur::RealSchur	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::RealSchur	access:public	signature:(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)
Eigen::RealSchur::RowsAtCompileTime	../include/Eigen/src/Eigenvalues/RealSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon39
Eigen::RealSchur::Scalar	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::RealSchur::splitOffTwoRows	../include/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::splitOffTwoRows(Index iu, bool computeU, Scalar exshift)$/;"	f	class:Eigen::RealSchur	signature:(Index iu, bool computeU, Scalar exshift)
Eigen::RealSchur::splitOffTwoRows	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    void splitOffTwoRows(Index iu, bool computeU, Scalar exshift);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index iu, bool computeU, Scalar exshift)
Eigen::RealSchur::Vector3s	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealSchur	access:private
EIGEN_REDUX_H	../include/Eigen/src/Core/Redux.h	27;"	d
Eigen::Replicate::Base	../include/Eigen/src/Core/Replicate.h	/^    typedef typename internal::dense_xpr_base<Replicate>::type Base;$/;"	t	class:Eigen::Replicate	access:public
Eigen::Replicate::coeff	../include/Eigen/src/Core/Replicate.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Replicate	access:public	signature:(Index row, Index col) const
Eigen::Replicate::cols	../include/Eigen/src/Core/Replicate.h	/^    inline Index cols() const { return m_matrix.cols() * m_colFactor.value(); }$/;"	f	class:Eigen::Replicate	access:public	signature:() const
EIGEN_REPLICATE_H	../include/Eigen/src/Core/Replicate.h	26;"	d
Eigen::Replicate	../include/Eigen/src/Core/Replicate.h	/^template<typename MatrixType,int RowFactor,int ColFactor> class Replicate$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::Replicate::_MatrixTypeNested	../include/Eigen/src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::Replicate	access:private
Eigen::Replicate::MatrixTypeNested	../include/Eigen/src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::Replicate	access:private
Eigen::Replicate::m_colFactor	../include/Eigen/src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, ColFactor> m_colFactor;$/;"	m	class:Eigen::Replicate	access:protected
Eigen::Replicate::m_matrix	../include/Eigen/src/Core/Replicate.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::Replicate	access:protected
Eigen::Replicate::m_rowFactor	../include/Eigen/src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, RowFactor> m_rowFactor;$/;"	m	class:Eigen::Replicate	access:protected
Eigen::Replicate::nestedExpression	../include/Eigen/src/Core/Replicate.h	/^    const _MatrixTypeNested& nestedExpression() const$/;"	f	class:Eigen::Replicate	access:public	signature:() const
Eigen::Replicate::packet	../include/Eigen/src/Core/Replicate.h	/^    inline PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Replicate	access:public	signature:(Index row, Index col) const
Eigen::Replicate::Replicate	../include/Eigen/src/Core/Replicate.h	/^    inline explicit Replicate(const OriginalMatrixType& matrix)$/;"	f	class:Eigen::Replicate	access:public	signature:(const OriginalMatrixType& matrix)
Eigen::Replicate::Replicate	../include/Eigen/src/Core/Replicate.h	/^    inline Replicate(const OriginalMatrixType& matrix, Index rowFactor, Index colFactor)$/;"	f	class:Eigen::Replicate	access:public	signature:(const OriginalMatrixType& matrix, Index rowFactor, Index colFactor)
Eigen::Replicate::rows	../include/Eigen/src/Core/Replicate.h	/^    inline Index rows() const { return m_matrix.rows() * m_rowFactor.value(); }$/;"	f	class:Eigen::Replicate	access:public	signature:() const
EIGEN_RESTRICT	../include/Eigen/src/Core/util/Macros.h	293;"	d
EIGEN_RESTRICT	../include/Eigen/src/Core/util/Macros.h	296;"	d
Eigen::ret	../include/Eigen/src/Eigen2Support/Meta.h	/^    enum { ret = ei_meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::__anon429
Eigen::ReturnByValue::Base	../include/Eigen/src/Core/ReturnByValue.h	/^    typedef typename internal::dense_xpr_base<ReturnByValue>::type Base;$/;"	t	class:Eigen::ReturnByValue	access:public
Eigen::ReturnByValue::coeff	../include/Eigen/src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index) const
Eigen::ReturnByValue::coeff	../include/Eigen/src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index,Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index,Index) const
Eigen::ReturnByValue::coeffRef	../include/Eigen/src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index,Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index,Index)
Eigen::ReturnByValue::coeffRef	../include/Eigen/src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Index)
Eigen::ReturnByValue::cols	../include/Eigen/src/Core/ReturnByValue.h	/^    inline Index cols() const { return static_cast<const Derived*>(this)->cols(); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:() const
Eigen::ReturnByValue::evalTo	../include/Eigen/src/Core/ReturnByValue.h	/^    inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Dest& dst) const
EIGEN_RETURNBYVALUE_H	../include/Eigen/src/Core/ReturnByValue.h	27;"	d
Eigen::ReturnByValue	../include/Eigen/src/Core/ReturnByValue.h	/^template<typename Derived> class ReturnByValue$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::ReturnByValue::ReturnType	../include/Eigen/src/Core/ReturnByValue.h	/^    typedef typename internal::traits<Derived>::ReturnType ReturnType;$/;"	t	class:Eigen::ReturnByValue	access:public
Eigen::ReturnByValue::rows	../include/Eigen/src/Core/ReturnByValue.h	/^    inline Index rows() const { return static_cast<const Derived*>(this)->rows(); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:() const
Eigen::ReturnByValue::Unusable	../include/Eigen/src/Core/ReturnByValue.h	/^    class Unusable{$/;"	c	class:Eigen::ReturnByValue	access:public
Eigen::ReturnByValue::Unusable::operator =	../include/Eigen/src/Core/ReturnByValue.h	/^      Unusable& operator=(const Unusable&) {return *this;}$/;"	f	class:Eigen::ReturnByValue::Unusable	access:private	signature:(const Unusable&)
Eigen::ReturnByValue::Unusable::Unusable	../include/Eigen/src/Core/ReturnByValue.h	/^      Unusable(const Unusable&) {}$/;"	f	class:Eigen::ReturnByValue::Unusable	access:private	signature:(const Unusable&)
Eigen::Reverse::Base	../include/Eigen/src/Core/Reverse.h	/^    typedef typename internal::dense_xpr_base<Reverse>::type Base;$/;"	t	class:Eigen::Reverse	access:public
Eigen::Reverse::coeff	../include/Eigen/src/Core/Reverse.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index) const
Eigen::Reverse::coeff	../include/Eigen/src/Core/Reverse.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col) const
Eigen::Reverse::coeffRef	../include/Eigen/src/Core/Reverse.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index)
Eigen::Reverse::coeffRef	../include/Eigen/src/Core/Reverse.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col)
Eigen::Reverse::cols	../include/Eigen/src/Core/Reverse.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Reverse	access:public	signature:() const
EIGEN_REVERSE_H	../include/Eigen/src/Core/Reverse.h	28;"	d
Eigen::Reverse	../include/Eigen/src/Core/Reverse.h	/^template<typename MatrixType, int Direction> class Reverse$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::Reverse::innerStride	../include/Eigen/src/Core/Reverse.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Reverse	access:public	signature:() const
Eigen::Reverse::IsColMajor	../include/Eigen/src/Core/Reverse.h	/^      IsColMajor = !IsRowMajor,$/;"	e	enum:Eigen::Reverse::__anon116
Eigen::Reverse::m_matrix	../include/Eigen/src/Core/Reverse.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Reverse	access:protected
Eigen::Reverse::nestedExpression	../include/Eigen/src/Core/Reverse.h	/^    nestedExpression() const $/;"	f	class:Eigen::Reverse	access:public	signature:() const
Eigen::Reverse::OffsetCol	../include/Eigen/src/Core/Reverse.h	/^      OffsetCol  = ReverseCol && IsRowMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon116
Eigen::Reverse::OffsetRow	../include/Eigen/src/Core/Reverse.h	/^      OffsetRow  = ReverseRow && IsColMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon116
Eigen::Reverse::operator ()	../include/Eigen/src/Core/Reverse.h	/^    inline Scalar& operator()(Index index)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index)
Eigen::Reverse::operator ()	../include/Eigen/src/Core/Reverse.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col)
Eigen::Reverse::packet	../include/Eigen/src/Core/Reverse.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index) const
Eigen::Reverse::packet	../include/Eigen/src/Core/Reverse.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col) const
Eigen::Reverse::PacketSize	../include/Eigen/src/Core/Reverse.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::Reverse::__anon116
Eigen::Reverse::ReverseCol	../include/Eigen/src/Core/Reverse.h	/^      ReverseCol = (Direction == Horizontal) || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon116
Eigen::Reverse::Reverse	../include/Eigen/src/Core/Reverse.h	/^    inline Reverse(const MatrixType& matrix) : m_matrix(matrix) { }$/;"	f	class:Eigen::Reverse	access:public	signature:(const MatrixType& matrix)
Eigen::Reverse::ReversePacket	../include/Eigen/src/Core/Reverse.h	/^      ReversePacket = (Direction == BothDirections)$/;"	e	enum:Eigen::Reverse::__anon116
Eigen::Reverse::reverse_packet	../include/Eigen/src/Core/Reverse.h	/^    typedef internal::reverse_packet_cond<PacketScalar,ReversePacket> reverse_packet;$/;"	t	class:Eigen::Reverse	access:protected
Eigen::Reverse::ReverseRow	../include/Eigen/src/Core/Reverse.h	/^      ReverseRow = (Direction == Vertical)   || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon116
Eigen::Reverse::rows	../include/Eigen/src/Core/Reverse.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Reverse	access:public	signature:() const
Eigen::Reverse::writePacket	../include/Eigen/src/Core/Reverse.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index, const PacketScalar& x)
Eigen::Reverse::writePacket	../include/Eigen/src/Core/Reverse.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col, const PacketScalar& x)
Eigen::rightHouseholderSequence	../include/Eigen/src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType,OnTheRight> rightHouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen	signature:(const VectorsType& v, const CoeffsType& h)
Eigen::Rotation2D::angle	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::angle	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
Eigen::Rotation2D::angle	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::angle	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
Eigen::Rotation2D::Base	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D	access:private
Eigen::Rotation2D::Base	../include/Eigen/src/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D	access:private
Eigen::Rotation2D::cast	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::cast	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::Dim	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon436
Eigen::Rotation2D::Dim	../include/Eigen/src/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon380
Eigen::Rotation2Dd	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Eigen::Rotation2Dd	../include/Eigen/src/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Eigen::Rotation2Df	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
Eigen::Rotation2Df	../include/Eigen/src/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
Eigen::Rotation2D::fromRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  Rotation2D& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::Rotation2D	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::Rotation2D::fromRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D	signature:(const MatrixBase<Derived>& mat)
Eigen::Rotation2D::fromRotationMatrix	../include/Eigen/src/Geometry/Rotation2D.h	/^  Rotation2D& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::Rotation2D	access:public	signature:(const MatrixBase<Derived>& m)
Eigen::Rotation2D::fromRotationMatrix	../include/Eigen/src/Geometry/Rotation2D.h	/^Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D	signature:(const MatrixBase<Derived>& mat)
EIGEN_ROTATION2D_H	../include/Eigen/src/Geometry/Rotation2D.h	26;"	d
Eigen::Rotation2D::Identity	../include/Eigen/src/Geometry/Rotation2D.h	/^  static inline Rotation2D Identity() { return Rotation2D(0); }$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
Eigen::Rotation2D	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen	inherits:RotationBase
Eigen::Rotation2D	../include/Eigen/src/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen	inherits:RotationBase
Eigen::Rotation2D::inverse	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D inverse() const { return -m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::inverse	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D inverse() const { return -m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
Eigen::Rotation2D::isApprox	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  bool isApprox(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::Rotation2D::isApprox	../include/Eigen/src/Geometry/Rotation2D.h	/^  bool isApprox(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::Rotation2D::m_angle	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D	access:protected
Eigen::Rotation2D::m_angle	../include/Eigen/src/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D	access:protected
Eigen::Rotation2D::Matrix2	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D	access:public
Eigen::Rotation2D::Matrix2	../include/Eigen/src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D	access:public
Eigen::Rotation2D::operator *	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other) const
Eigen::Rotation2D::operator *=	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other)
Eigen::Rotation2D::operator *	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Vector2& vec) const
Eigen::Rotation2D::operator *	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other) const
Eigen::Rotation2D::operator *=	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other)
Eigen::Rotation2D::operator *	../include/Eigen/src/Geometry/Rotation2D.h	/^  Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Vector2& vec) const
Eigen::Rotation2D::Rotation2D	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D<OtherScalarType>& other)
Eigen::Rotation2D::Rotation2D	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D(Scalar a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D	access:public	signature:(Scalar a)
Eigen::Rotation2D::Rotation2D	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D<OtherScalarType>& other)
Eigen::Rotation2D::Rotation2D	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D(Scalar a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D	access:public	signature:(Scalar a)
Eigen::Rotation2D::Scalar	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D	access:public
Eigen::Rotation2D::Scalar	../include/Eigen/src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D	access:public
Eigen::Rotation2D::slerp	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D slerp(Scalar t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(Scalar t, const Rotation2D& other) const
Eigen::Rotation2D::slerp	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D slerp(Scalar t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(Scalar t, const Rotation2D& other) const
Eigen::Rotation2D::toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  Matrix2 toRotationMatrix(void) const;$/;"	p	class:Eigen::Rotation2D	access:public	signature:(void) const
Eigen::Rotation2D::toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D	signature:(void) const
Eigen::Rotation2D::toRotationMatrix	../include/Eigen/src/Geometry/Rotation2D.h	/^  Matrix2 toRotationMatrix(void) const;$/;"	p	class:Eigen::Rotation2D	access:public	signature:(void) const
Eigen::Rotation2D::toRotationMatrix	../include/Eigen/src/Geometry/Rotation2D.h	/^Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D	signature:(void) const
Eigen::Rotation2D::Vector2	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D	access:public
Eigen::Rotation2D::Vector2	../include/Eigen/src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D	access:public
Eigen::RotationBase::derived	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::derived	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:()
Eigen::RotationBase::derived	../include/Eigen/src/Geometry/RotationBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::derived	../include/Eigen/src/Geometry/RotationBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase	access:public	signature:()
Eigen::RotationBase::Dim	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon437
Eigen::RotationBase::Dim	../include/Eigen/src/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon382
EIGEN_ROTATIONBASE_H	../include/Eigen/src/Geometry/RotationBase.h	26;"	d
Eigen::RotationBase	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
Eigen::RotationBase	../include/Eigen/src/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
Eigen::RotationBase::inverse	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::inverse	../include/Eigen/src/Geometry/RotationBase.h	/^    inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::matrix	../include/Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType matrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::operator *	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const Scaling<Scalar,Dim>& s) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Scaling<Scalar,Dim>& s) const
Eigen::RotationBase::operator *	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim> operator*(const Transform<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Transform<Scalar,Dim>& t) const
Eigen::RotationBase::operator *	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Translation<Scalar,Dim>& t) const
Eigen::RotationBase::operator *	../include/Eigen/src/Geometry/RotationBase.h	/^    friend inline Transform<Scalar,Dim,Affine> operator*(const DiagonalMatrix<Scalar,Dim>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase	access:friend	signature:(const DiagonalMatrix<Scalar,Dim>& l, const Derived& r)
Eigen::RotationBase::operator *	../include/Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const EigenBase<OtherDerived>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase	access:friend	signature:(const EigenBase<OtherDerived>& l, const Derived& r)
Eigen::RotationBase::operator *	../include/Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const UniformScaling<Scalar>& s) const
Eigen::RotationBase::operator *	../include/Eigen/src/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim,Isometry> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Translation<Scalar,Dim>& t) const
Eigen::RotationBase::operator *	../include/Eigen/src/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim,Mode> operator*(const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Transform<Scalar,Dim,Mode,Options>& t) const
Eigen::RotationBase::operator *	../include/Eigen/src/Geometry/RotationBase.h	/^    operator*(const EigenBase<OtherDerived>& e) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const EigenBase<OtherDerived>& e) const
Eigen::RotationBase::RotationMatrixType	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase	access:public
Eigen::RotationBase::RotationMatrixType	../include/Eigen/src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase	access:public
Eigen::RotationBase::Scalar	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    typedef typename ei_traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase	access:public
Eigen::RotationBase::Scalar	../include/Eigen/src/Geometry/RotationBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase	access:public
Eigen::RotationBase::toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::toRotationMatrix	../include/Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Eigen::RotationBase::_transformVector	../include/Eigen/src/Geometry/RotationBase.h	/^    inline VectorType _transformVector(const OtherVectorType& v) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const OtherVectorType& v) const
Eigen::RotationBase::VectorType	../include/Eigen/src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::RotationBase	access:public
Eigen::RowMajorBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int RowMajorBit = 0x1;$/;"	m	namespace:Eigen
Eigen::RowMajor	../include/Eigen/src/Core/util/Constants.h	/^  RowMajor = 0x1,  \/\/ it is only a coincidence that this is equal to RowMajorBit -- don't rely on that$/;"	e	enum:Eigen::__anon212
EIGEN_SAEIGENSOLVER_MKL_H	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_MKL.h	34;"	d
EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO	../include/Eigen/src/Core/util/Macros.h	50;"	d
EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO	../include/Eigen/src/Core/util/Macros.h	52;"	d
Eigen::scalar_product_traits	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<std::complex<T>, T>$/;"	s	namespace:Eigen
Eigen::scalar_product_traits	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<T,std::complex<T> >$/;"	s	namespace:Eigen
Eigen::scalar_product_traits	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<T,T>$/;"	s	namespace:Eigen
Eigen::scalar_product_traits::ReturnType	../include/Eigen/src/Core/util/Meta.h	/^  typedef std::complex<T> ReturnType;$/;"	t	struct:Eigen::scalar_product_traits	access:public
Eigen::scalar_product_traits::ReturnType	../include/Eigen/src/Core/util/Meta.h	/^  typedef T ReturnType;$/;"	t	struct:Eigen::scalar_product_traits	access:public
Eigen::ScaledProduct::addTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void addTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(1)); }$/;"	f	class:Eigen::ScaledProduct	access:public	signature:(Dest& dst) const
Eigen::ScaledProduct::alpha	../include/Eigen/src/Core/ProductBase.h	/^    const Scalar& alpha() const { return m_alpha; }$/;"	f	class:Eigen::ScaledProduct	access:public	signature:() const
Eigen::ScaledProduct::Base	../include/Eigen/src/Core/ProductBase.h	/^                       typename NestedProduct::_RhsNested> Base;$/;"	t	class:Eigen::ScaledProduct	access:public
Eigen::ScaledProduct::evalTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst, Scalar(1)); }$/;"	f	class:Eigen::ScaledProduct	access:public	signature:(Dest& dst) const
Eigen::ScaledProduct	../include/Eigen/src/Core/ProductBase.h	/^class ScaledProduct$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::ScaledProduct::m_alpha	../include/Eigen/src/Core/ProductBase.h	/^    Scalar m_alpha;$/;"	m	class:Eigen::ScaledProduct	access:protected
Eigen::ScaledProduct::m_prod	../include/Eigen/src/Core/ProductBase.h	/^    const NestedProduct& m_prod;$/;"	m	class:Eigen::ScaledProduct	access:protected
Eigen::ScaledProduct::PlainObject	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::ScaledProduct	access:public
Eigen::ScaledProduct::Scalar	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::ScaledProduct	access:public
Eigen::ScaledProduct::scaleAndAddTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void scaleAndAddTo(Dest& dst,Scalar alpha) const { m_prod.derived().scaleAndAddTo(dst,alpha * m_alpha); }$/;"	f	class:Eigen::ScaledProduct	access:public	signature:(Dest& dst,Scalar alpha) const
Eigen::ScaledProduct::ScaledProduct	../include/Eigen/src/Core/ProductBase.h	/^    ScaledProduct(const NestedProduct& prod, Scalar x)$/;"	f	class:Eigen::ScaledProduct	access:public	signature:(const NestedProduct& prod, Scalar x)
Eigen::ScaledProduct::subTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void subTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(-1)); }$/;"	f	class:Eigen::ScaledProduct	access:public	signature:(Dest& dst) const
Eigen::Scaling2d	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<double,2> Scaling2d;$/;"	t	namespace:Eigen
Eigen::Scaling2f	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<float, 2> Scaling2f;$/;"	t	namespace:Eigen
Eigen::Scaling3d	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<double,3> Scaling3d;$/;"	t	namespace:Eigen
Eigen::Scaling3f	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<float, 3> Scaling3f;$/;"	t	namespace:Eigen
Eigen::Scaling::cast	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline typename internal::cast_return_type<Scaling,Scaling<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Scaling	access:public	signature:() const
Eigen::Scaling::coeffs	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  const VectorType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Scaling	access:public	signature:() const
Eigen::Scaling::coeffs	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  VectorType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Scaling	access:public	signature:()
Eigen::Scaling::Dim	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Scaling::__anon435
EIGEN_SCALING_H	../include/Eigen/src/Geometry/Scaling.h	26;"	d
Eigen::Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^class Scaling$/;"	c	namespace:Eigen
Eigen::Scaling	../include/Eigen/src/Geometry/Scaling.h	/^static inline const DiagonalWrapper<const Derived> Scaling(const MatrixBase<Derived>& coeffs)$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& coeffs)
Eigen::Scaling	../include/Eigen/src/Geometry/Scaling.h	/^static inline DiagonalMatrix<Scalar,2> Scaling(Scalar sx, Scalar sy)$/;"	f	namespace:Eigen	signature:(Scalar sx, Scalar sy)
Eigen::Scaling	../include/Eigen/src/Geometry/Scaling.h	/^static inline DiagonalMatrix<Scalar,3> Scaling(Scalar sx, Scalar sy, Scalar sz)$/;"	f	namespace:Eigen	signature:(Scalar sx, Scalar sy, Scalar sz)
Eigen::Scaling	../include/Eigen/src/Geometry/Scaling.h	/^static inline UniformScaling<double> Scaling(double s) { return UniformScaling<double>(s); }$/;"	f	namespace:Eigen	signature:(double s)
Eigen::Scaling	../include/Eigen/src/Geometry/Scaling.h	/^static inline UniformScaling<float> Scaling(float s) { return UniformScaling<float>(s); }$/;"	f	namespace:Eigen	signature:(float s)
Eigen::Scaling	../include/Eigen/src/Geometry/Scaling.h	/^static inline UniformScaling<std::complex<RealScalar> > Scaling(const std::complex<RealScalar>& s)$/;"	f	namespace:Eigen	signature:(const std::complex<RealScalar>& s)
Eigen::Scaling::inverse	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling inverse() const$/;"	f	class:Eigen::Scaling	access:public	signature:() const
Eigen::Scaling::isApprox	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  bool isApprox(const Scaling& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::Scaling::LinearMatrixType	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Scaling	access:public
Eigen::Scaling::m_coeffs	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Scaling	access:protected
Eigen::Scaling::operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  friend inline LinearMatrixType operator* (const LinearMatrixType& other, const Scaling& s)$/;"	f	class:Eigen::Scaling	access:friend	signature:(const LinearMatrixType& other, const Scaling& s)
Eigen::Scaling::operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline LinearMatrixType operator* (const LinearMatrixType& other) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const LinearMatrixType& other) const
Eigen::Scaling::operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline LinearMatrixType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Scaling::operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling operator* (const Scaling& other) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling& other) const
Eigen::Scaling::operator =	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling& operator=(const Scaling& other)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling& other)
Eigen::Scaling::operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline TransformType operator* (const TransformType& t) const;$/;"	p	class:Eigen::Scaling	access:public	signature:(const TransformType& t) const
Eigen::Scaling::operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline TransformType operator* (const TranslationType& t) const;$/;"	p	class:Eigen::Scaling	access:public	signature:(const TranslationType& t) const
Eigen::Scaling::operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const VectorType& other) const
Eigen::Scaling::operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^Scaling<Scalar,Dim>::operator* (const TransformType& t) const$/;"	f	class:Eigen::Scaling	signature:(const TransformType& t) const
Eigen::Scaling::operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^Scaling<Scalar,Dim>::operator* (const TranslationType& t) const$/;"	f	class:Eigen::Scaling	signature:(const TranslationType& t) const
Eigen::Scaling::Scalar	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Scaling	access:public
Eigen::Scaling::Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  explicit inline Scaling(const Scalar& s) { m_coeffs.setConstant(s); }$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scalar& s)
Eigen::Scaling::Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  explicit inline Scaling(const VectorType& coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Scaling	access:public	signature:(const VectorType& coeffs)
Eigen::Scaling::Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline explicit Scaling(const Scaling<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling<OtherScalarType,Dim>& other)
Eigen::Scaling::Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Eigen::Scaling::Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scalar& sx, const Scalar& sy)
Eigen::Scaling::Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  Scaling() {}$/;"	f	class:Eigen::Scaling	access:public	signature:()
Eigen::Scaling::TransformType	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	class:Eigen::Scaling	access:public
Eigen::Scaling::TranslationType	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Scaling	access:public
Eigen::Scaling::VectorType	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Scaling	access:public
Eigen::scomplex	../include/Eigen/src/Core/util/MKL_support.h	/^typedef std::complex<float>  scomplex;$/;"	t	namespace:Eigen
Eigen::Select::Base	../include/Eigen/src/Core/Select.h	/^    typedef typename internal::dense_xpr_base<Select>::type Base;$/;"	t	class:Eigen::Select	access:public
Eigen::Select::coeff	../include/Eigen/src/Core/Select.h	/^    const Scalar coeff(Index i) const$/;"	f	class:Eigen::Select	access:public	signature:(Index i) const
Eigen::Select::coeff	../include/Eigen/src/Core/Select.h	/^    const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::Select	access:public	signature:(Index i, Index j) const
Eigen::Select::cols	../include/Eigen/src/Core/Select.h	/^    Index cols() const { return m_condition.cols(); }$/;"	f	class:Eigen::Select	access:public	signature:() const
Eigen::Select::conditionMatrix	../include/Eigen/src/Core/Select.h	/^    const ConditionMatrixType& conditionMatrix() const$/;"	f	class:Eigen::Select	access:public	signature:() const
Eigen::Select::elseMatrix	../include/Eigen/src/Core/Select.h	/^    const ElseMatrixType& elseMatrix() const$/;"	f	class:Eigen::Select	access:public	signature:() const
EIGEN_SELECT_H	../include/Eigen/src/Core/Select.h	26;"	d
Eigen::Select	../include/Eigen/src/Core/Select.h	/^class Select : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
Eigen::Select::m_condition	../include/Eigen/src/Core/Select.h	/^    typename ConditionMatrixType::Nested m_condition;$/;"	m	class:Eigen::Select	access:protected
Eigen::Select::m_else	../include/Eigen/src/Core/Select.h	/^    typename ElseMatrixType::Nested m_else;$/;"	m	class:Eigen::Select	access:protected
Eigen::Select::m_then	../include/Eigen/src/Core/Select.h	/^    typename ThenMatrixType::Nested m_then;$/;"	m	class:Eigen::Select	access:protected
Eigen::Select::rows	../include/Eigen/src/Core/Select.h	/^    Index rows() const { return m_condition.rows(); }$/;"	f	class:Eigen::Select	access:public	signature:() const
Eigen::Select::Select	../include/Eigen/src/Core/Select.h	/^    Select(const ConditionMatrixType& conditionMatrix,$/;"	f	class:Eigen::Select	access:public	signature:(const ConditionMatrixType& conditionMatrix, const ThenMatrixType& thenMatrix, const ElseMatrixType& elseMatrix)
Eigen::Select::thenMatrix	../include/Eigen/src/Core/Select.h	/^    const ThenMatrixType& thenMatrix() const$/;"	f	class:Eigen::Select	access:public	signature:() const
Eigen::SelfAdjointBit	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int SelfAdjointBit = SelfAdjoint;$/;"	m	namespace:Eigen
Eigen::SelfAdjointEigenSolver::ColsAtCompileTime	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon40
Eigen::SelfAdjointEigenSolver::computeDirect	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::computeDirect(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver	signature:(const MatrixType& matrix, int options)
Eigen::SelfAdjointEigenSolver::computeDirect	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver& computeDirect(const MatrixType& matrix, int options = ComputeEigenvectors);$/;"	p	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, int options = ComputeEigenvectors)
Eigen::SelfAdjointEigenSolver::compute	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::compute(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver	signature:(const MatrixType& matrix, int options)
Eigen::SelfAdjointEigenSolver::compute	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver& compute(const MatrixType& matrix, int options = ComputeEigenvectors);$/;"	p	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, int options = ComputeEigenvectors)
Eigen::SelfAdjointEigenSolver::compute	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    void compute(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)
Eigen::SelfAdjointEigenSolver::compute	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    void compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors)
Eigen::SelfAdjointEigenSolver::eigenvalues	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const RealVectorType& eigenvalues() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
Eigen::SelfAdjointEigenSolver::eigenvectors	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const MatrixType& eigenvectors() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
EIGEN_SELFADJOINTEIGENSOLVER_H	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	27;"	d
Eigen::SelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename _MatrixType> class SelfAdjointEigenSolver$/;"	c	namespace:Eigen
Eigen::SelfAdjointEigenSolver::Index	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::info	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
Eigen::SelfAdjointEigenSolver::MatrixType	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::MaxColsAtCompileTime	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon40
Eigen::SelfAdjointEigenSolver::m_eigenvectorsOk	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
Eigen::SelfAdjointEigenSolver::m_eivalues	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    RealVectorType m_eivalues;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
Eigen::SelfAdjointEigenSolver::m_eivec	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
Eigen::SelfAdjointEigenSolver::m_info	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
Eigen::SelfAdjointEigenSolver::m_isInitialized	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
Eigen::SelfAdjointEigenSolver::m_maxIterations	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static const int m_maxIterations = 30;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::m_subdiag	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typename TridiagonalizationType::SubDiagonalType m_subdiag;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
Eigen::SelfAdjointEigenSolver::operatorInverseSqrt	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorInverseSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
Eigen::SelfAdjointEigenSolver::operatorSqrt	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
Eigen::SelfAdjointEigenSolver::Options	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon40
Eigen::SelfAdjointEigenSolver::RealScalar	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::RealVectorType	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type RealVectorType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::Scalar	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjointEigenSolver::SelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)
Eigen::SelfAdjointEigenSolver::SelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors)
Eigen::SelfAdjointEigenSolver::SelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matrix, int options = ComputeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, int options = ComputeEigenvectors)
Eigen::SelfAdjointEigenSolver::SelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver()$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:()
Eigen::SelfAdjointEigenSolver::SelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(Index size)
Eigen::SelfAdjointEigenSolver::Size	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon40
Eigen::SelfAdjointEigenSolver::TridiagonalizationType	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Tridiagonalization<MatrixType> TridiagonalizationType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Eigen::SelfAdjoint	../include/Eigen/src/Core/util/Constants.h	/^  SelfAdjoint=0x10,$/;"	e	enum:Eigen::__anon207
EIGEN_SELFADJOINTMATRIX_H	../include/Eigen/src/Core/SelfAdjointView.h	26;"	d
EIGEN_SELFADJOINT_MATRIX_MATRIX_H	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	26;"	d
EIGEN_SELFADJOINT_MATRIX_MATRIX_MKL_H	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	34;"	d
EIGEN_SELFADJOINT_MATRIX_VECTOR_H	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	26;"	d
EIGEN_SELFADJOINT_MATRIX_VECTOR_MKL_H	../include/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	34;"	d
EIGEN_SELFADJOINT_PRODUCT_H	../include/Eigen/src/Core/products/SelfadjointProduct.h	26;"	d
Eigen::SelfadjointProductMatrix	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false>$/;"	s	namespace:Eigen	inherits:ProductBase
Eigen::SelfadjointProductMatrix	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false>$/;"	s	namespace:Eigen	inherits:ProductBase
Eigen::SelfadjointProductMatrix	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true>$/;"	s	namespace:Eigen	inherits:ProductBase
Eigen::SelfadjointProductMatrix::LhsIsSelfAdjoint	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsSelfAdjoint = (LhsMode&SelfAdjoint)==SelfAdjoint,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon112
Eigen::SelfadjointProductMatrix::LhsIsUpper	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsUpper = (LhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon112
Eigen::SelfadjointProductMatrix::LhsUpLo	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^    LhsUpLo = LhsMode&(Upper|Lower)$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon113
Eigen::SelfadjointProductMatrix::RhsIsSelfAdjoint	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsSelfAdjoint = (RhsMode&SelfAdjoint)==SelfAdjoint$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon112
Eigen::SelfadjointProductMatrix::RhsIsUpper	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsUpper = (RhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon112
Eigen::SelfadjointProductMatrix::RhsUpLo	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^    RhsUpLo = RhsMode&(Upper|Lower)$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon114
Eigen::SelfadjointProductMatrix::scaleAndAddTo	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(Dest& dst, Scalar alpha) const
Eigen::SelfadjointProductMatrix::scaleAndAddTo	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(Dest& dest, Scalar alpha) const
Eigen::SelfadjointProductMatrix::SelfadjointProductMatrix	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::SelfadjointProductMatrix::SelfadjointProductMatrix	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::selfadjoint_product_selector	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,false>$/;"	s	namespace:Eigen
Eigen::selfadjoint_product_selector	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,true>$/;"	s	namespace:Eigen
Eigen::selfadjoint_product_selector::run	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^  static void run(MatrixType& mat, const OtherType& other, typename MatrixType::Scalar alpha)$/;"	f	struct:Eigen::selfadjoint_product_selector	access:public	signature:(MatrixType& mat, const OtherType& other, typename MatrixType::Scalar alpha)
Eigen::selfadjoint_rank1_update	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,ColMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
Eigen::selfadjoint_rank1_update	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,RowMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
Eigen::selfadjoint_rank1_update::run	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^  static void run(Index size, Scalar* mat, Index stride, const Scalar* vec, Scalar alpha)$/;"	f	struct:Eigen::selfadjoint_rank1_update	access:public	signature:(Index size, Scalar* mat, Index stride, const Scalar* vec, Scalar alpha)
EIGEN_SELFADJOINTRANK2UPTADE_H	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	26;"	d
Eigen::SelfAdjointView::Base	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef TriangularBase<SelfAdjointView> Base;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::coeff	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(Index row, Index col) const
Eigen::SelfAdjointView::coeffRef	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(Index row, Index col)
Eigen::SelfAdjointView::cols	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::eigenvalues	../include/Eigen/src/Core/SelfAdjointView.h	/^    EigenvaluesReturnType eigenvalues() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::eigenvalues	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::eigenvalues() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
Eigen::SelfAdjointView::EigenvaluesReturnType	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef Matrix<RealScalar, internal::traits<MatrixType>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::_expression	../include/Eigen/src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& _expression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView	../include/Eigen/src/Core/SelfAdjointView.h	/^template<typename MatrixType, unsigned int UpLo> class SelfAdjointView$/;"	c	namespace:Eigen	inherits:TriangularBase
Eigen::SelfAdjointView::Index	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::innerStride	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::ldlt	../include/Eigen/src/Cholesky/LDLT.h	/^SelfAdjointView<MatrixType, UpLo>::ldlt() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
Eigen::SelfAdjointView::ldlt	../include/Eigen/src/Core/SelfAdjointView.h	/^    const LDLT<PlainObject, UpLo> ldlt() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::llt	../include/Eigen/src/Cholesky/LLT.h	/^SelfAdjointView<MatrixType, UpLo>::llt() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
Eigen::SelfAdjointView::llt	../include/Eigen/src/Core/SelfAdjointView.h	/^    const LLT<PlainObject, UpLo> llt() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::MatrixTypeNestedCleaned	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::MatrixTypeNested	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::m_matrix	../include/Eigen/src/Core/SelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SelfAdjointView	access:protected
Eigen::SelfAdjointView::Mode	../include/Eigen/src/Core/SelfAdjointView.h	/^      Mode = internal::traits<SelfAdjointView>::Mode$/;"	e	enum:Eigen::SelfAdjointView::__anon84
Eigen::SelfAdjointView::nestedExpression	../include/Eigen/src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::nestedExpression	../include/Eigen/src/Core/SelfAdjointView.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:()
Eigen::SelfAdjointView::operator *	../include/Eigen/src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)$/;"	f	class:Eigen::SelfAdjointView	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)
Eigen::SelfAdjointView::operator *	../include/Eigen/src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<OtherDerived>& rhs) const
Eigen::SelfAdjointView::operator =	../include/Eigen/src/Core/SelfAdjointView.h	/^    SelfAdjointView& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::SelfAdjointView::operator =	../include/Eigen/src/Core/SelfAdjointView.h	/^    SelfAdjointView& operator=(const TriangularView<OtherMatrixType, OtherMode>& other)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(const TriangularView<OtherMatrixType, OtherMode>& other)
Eigen::SelfAdjointView::operatorNorm	../include/Eigen/src/Core/SelfAdjointView.h	/^    RealScalar operatorNorm() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::operatorNorm	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::operatorNorm() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
Eigen::SelfAdjointView::outerStride	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::PlainObject	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::rankUpdate	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, Scalar alpha)$/;"	f	class:Eigen::SelfAdjointView	signature:(const MatrixBase<DerivedU>& u, Scalar alpha)
Eigen::SelfAdjointView::rankUpdate	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, Scalar alpha)$/;"	f	class:Eigen::SelfAdjointView	signature:(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, Scalar alpha)
Eigen::SelfAdjointView::rankUpdate	../include/Eigen/src/Core/SelfAdjointView.h	/^    SelfAdjointView& rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, Scalar alpha = Scalar(1));$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, Scalar alpha = Scalar(1))
Eigen::SelfAdjointView::rankUpdate	../include/Eigen/src/Core/SelfAdjointView.h	/^    SelfAdjointView& rankUpdate(const MatrixBase<DerivedU>& u, Scalar alpha = Scalar(1));$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<DerivedU>& u, Scalar alpha = Scalar(1))
Eigen::SelfAdjointView::RealScalar	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::rows	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
Eigen::SelfAdjointView::Scalar	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::Scalar Scalar; $/;"	t	class:Eigen::SelfAdjointView	access:public
Eigen::SelfAdjointView::SelfAdjointView	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline SelfAdjointView(MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(MatrixType& matrix)
Eigen::SelfCwiseBinaryOp::Base	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    typedef typename internal::dense_xpr_base<SelfCwiseBinaryOp>::type Base;$/;"	t	class:Eigen::SelfCwiseBinaryOp	access:public
Eigen::SelfCwiseBinaryOp::coeffRef	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index) const
Eigen::SelfCwiseBinaryOp::coeffRef	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col) const
Eigen::SelfCwiseBinaryOp::coeffRef	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index)
Eigen::SelfCwiseBinaryOp::coeffRef	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col)
Eigen::SelfCwiseBinaryOp::cols	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfCwiseBinaryOp::copyCoeff	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
Eigen::SelfCwiseBinaryOp::copyCoeff	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
Eigen::SelfCwiseBinaryOp::copyPacket	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
Eigen::SelfCwiseBinaryOp::copyPacket	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
Eigen::SelfCwiseBinaryOp::data	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfCwiseBinaryOp::expression	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    Lhs& expression() const $/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfCwiseBinaryOp::functor	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    const BinaryOp& functor() const $/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
EIGEN_SELFCWISEBINARYOP_H	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	26;"	d
Eigen::SelfCwiseBinaryOp	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^template<typename BinaryOp, typename Lhs, typename Rhs> class SelfCwiseBinaryOp$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::SelfCwiseBinaryOp::innerStride	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfCwiseBinaryOp::lazyAssign	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE SelfCwiseBinaryOp& lazyAssign(const DenseBase<RhsDerived>& rhs)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(const DenseBase<RhsDerived>& rhs)
Eigen::SelfCwiseBinaryOp::m_functor	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::SelfCwiseBinaryOp	access:protected
Eigen::SelfCwiseBinaryOp::m_matrix	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    Lhs& m_matrix;$/;"	m	class:Eigen::SelfCwiseBinaryOp	access:protected
Eigen::SelfCwiseBinaryOp::operator =	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    SelfCwiseBinaryOp& operator=(const Rhs& _rhs)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(const Rhs& _rhs)
Eigen::SelfCwiseBinaryOp::operator =	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    SelfCwiseBinaryOp& operator=(const SelfCwiseBinaryOp&);$/;"	p	class:Eigen::SelfCwiseBinaryOp	access:private	signature:(const SelfCwiseBinaryOp&)
Eigen::SelfCwiseBinaryOp::outerStride	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfCwiseBinaryOp::Packet	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    typedef typename internal::packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::SelfCwiseBinaryOp	access:public
Eigen::SelfCwiseBinaryOp::rows	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
Eigen::SelfCwiseBinaryOp::SelfCwiseBinaryOp	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Lhs& xpr, const BinaryOp& func = BinaryOp())
Eigen::Sequential	../include/Eigen/src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	e	enum:Eigen::Sequential_t
Eigen::Sequential_t	../include/Eigen/src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	g	namespace:Eigen
Eigen::SetAction	../include/Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
Eigen::setCpuCacheSizes	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void setCpuCacheSizes(std::ptrdiff_t l1, std::ptrdiff_t l2)$/;"	f	namespace:Eigen	signature:(std::ptrdiff_t l1, std::ptrdiff_t l2)
Eigen::setNbThreads	../include/Eigen/src/Core/products/Parallelizer.h	/^inline void setNbThreads(int v)$/;"	f	namespace:Eigen	signature:(int v)
Eigen::SimplicialCholesky::analyzePattern	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& a)
Eigen::SimplicialCholeskyBase::analyzePattern	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& a, bool doLDLT)
Eigen::SimplicialCholeskyBase::analyzePattern_preordered	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern_preordered(const CholMatrixType& a, bool doLDLT);$/;"	p	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const CholMatrixType& a, bool doLDLT)
Eigen::SimplicialCholeskyBase::analyzePattern_preordered	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::analyzePattern_preordered(const CholMatrixType& ap, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase	signature:(const CholMatrixType& ap, bool doLDLT)
Eigen::SimplicialCholeskyBase::CholMatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholeskyBase::cols	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
Eigen::SimplicialCholeskyBase::compute	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& matrix)
Eigen::SimplicialCholeskyBase::derived	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
Eigen::SimplicialCholeskyBase::derived	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:()
Eigen::SimplicialCholeskyBase::dumpMemory	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(Stream& s)
Eigen::SimplicialCholeskyBase::factorize	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& a)
Eigen::SimplicialCholeskyBase::factorize_preordered	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize_preordered(const CholMatrixType& a);$/;"	p	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const CholMatrixType& a)
Eigen::SimplicialCholeskyBase::factorize_preordered	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::factorize_preordered(const CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase	signature:(const CholMatrixType& ap)
Eigen::SimplicialCholeskyBase	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^class SimplicialCholeskyBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::SimplicialCholesky::Base	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialCholesky> Base;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholeskyBase::Index	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholeskyBase::info	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
Eigen::SimplicialCholeskyBase::keep_diag	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    struct keep_diag {$/;"	s	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::keep_diag::operator ()	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::SimplicialCholeskyBase::keep_diag	access:public	signature:(const Index& row, const Index& col, const Scalar&) const
Eigen::SimplicialCholeskyBase::m_analysisIsOk	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::MatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholeskyBase::m_diag	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorType m_diag;                                \/\/ the diagonal coefficients (LDLT mode)$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_factorizationIsOk	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_info	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_isInitialized	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_matrix	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    CholMatrixType m_matrix;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_nonZerosPerCol	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorXi m_nonZerosPerCol;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_parent	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorXi m_parent;                                \/\/ elimination tree$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_P	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_P;     \/\/ the permutation$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_Pinv	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_Pinv;  \/\/ the inverse permutation$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_shiftOffset	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftOffset;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::m_shiftScale	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftScale;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
Eigen::SimplicialCholeskyBase::ordering	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void ordering(const MatrixType& a, CholMatrixType& ap);$/;"	p	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& a, CholMatrixType& ap)
Eigen::SimplicialCholeskyBase::ordering	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::ordering(const MatrixType& a, CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase	signature:(const MatrixType& a, CholMatrixType& ap)
Eigen::SimplicialCholeskyBase::permutationP	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,Index>& permutationP() const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
Eigen::SimplicialCholeskyBase::permutationPinv	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,Index>& permutationPinv() const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
Eigen::SimplicialCholeskyBase::RealScalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholeskyBase::rows	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
Eigen::SimplicialCholeskyBase::Scalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholeskyBase::setShift	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Derived& setShift(const RealScalar& offset, const RealScalar& scale = 1)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const RealScalar& offset, const RealScalar& scale = 1)
Eigen::SimplicialCholeskyBase::SimplicialCholeskyBase	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialCholeskyBase::~SimplicialCholeskyBase	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    ~SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:()
Eigen::SimplicialCholeskyBase::SimplicialCholeskyBase	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:()
Eigen::SimplicialCholeskyBase::solve	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::SimplicialCholeskyBase::solve	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
Eigen::SimplicialCholeskyBase::_solve	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
Eigen::SimplicialCholeskyBase::_solve_sparse	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
Eigen::SimplicialCholeskyBase::UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = internal::traits<Derived>::UpLo };$/;"	e	enum:Eigen::SimplicialCholeskyBase::__anon406
Eigen::SimplicialCholeskyBase::VectorType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Eigen::SimplicialCholesky::CholMatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::compute	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialCholesky::determinant	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:() const
Eigen::SimplicialCholesky::factorize	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& a)
EIGEN_SIMPLICIAL_CHOLESKY_H	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	64;"	d
Eigen::SimplicialCholesky	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialCholesky : public SimplicialCholeskyBase<SimplicialCholesky<_MatrixType,_UpLo> >$/;"	c	namespace:Eigen	inherits:SimplicialCholeskyBase
Eigen::SimplicialCholesky::Index	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholeskyLDLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLDLT$/;"	e	enum:Eigen::SimplicialCholeskyMode
Eigen::SimplicialCholesky::LDLTTraits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT<MatrixType,UpLo> > LDLTTraits;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholeskyLLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLLT,$/;"	e	enum:Eigen::SimplicialCholeskyMode
Eigen::SimplicialCholesky::LLTTraits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT<MatrixType,UpLo>  > LLTTraits;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::MatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::m_LDLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_LDLT;$/;"	m	class:Eigen::SimplicialCholesky	access:protected
Eigen::SimplicialCholeskyMode	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^enum SimplicialCholeskyMode {$/;"	g	namespace:Eigen
Eigen::SimplicialCholesky::rawMatrix	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const CholMatrixType rawMatrix() const {$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:() const
Eigen::SimplicialCholesky::RealScalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::Scalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::setMode	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& setMode(SimplicialCholeskyMode mode)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(SimplicialCholeskyMode mode)
Eigen::SimplicialCholesky::SimplicialCholesky	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky() : Base(), m_LDLT(true) {}$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:()
Eigen::SimplicialCholesky::SimplicialCholesky	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialCholesky::_solve	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
Eigen::SimplicialCholesky::Traits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialCholesky> Traits;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialCholesky::UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialCholesky::__anon412
Eigen::SimplicialCholesky::vectorD	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:() const
Eigen::SimplicialCholesky::VectorType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Eigen::SimplicialLDLT::analyzePattern	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& a)
Eigen::SimplicialLDLT::Base	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLDLT> Base;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::CholMatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::compute	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialLDLT::determinant	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
Eigen::SimplicialLDLT::factorize	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& a)
Eigen::SimplicialLDLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLDLT : public SimplicialCholeskyBase<SimplicialLDLT<_MatrixType,_UpLo> >$/;"	c	namespace:Eigen	inherits:SimplicialCholeskyBase
Eigen::SimplicialLDLT::Index	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::matrixL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
Eigen::SimplicialLDLT::MatrixL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::MatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::matrixU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
Eigen::SimplicialLDLT::MatrixU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::RealScalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::Scalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::SimplicialLDLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT() : Base() {}$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:()
Eigen::SimplicialLDLT::SimplicialLDLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialLDLT::Traits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT> Traits;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLDLT::UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLDLT::__anon411
Eigen::SimplicialLDLT::vectorD	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
Eigen::SimplicialLDLT::VectorType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Eigen::SimplicialLLT::analyzePattern	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& a)
Eigen::SimplicialLLT::Base	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLLT> Base;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::CholMatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::compute	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialLLT::determinant	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:() const
Eigen::SimplicialLLT::factorize	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& a)
Eigen::SimplicialLLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLLT : public SimplicialCholeskyBase<SimplicialLLT<_MatrixType,_UpLo> >$/;"	c	namespace:Eigen	inherits:SimplicialCholeskyBase
Eigen::SimplicialLLT::Index	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::matrixL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:() const
Eigen::SimplicialLLT::MatrixL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::MatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::matrixU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:() const
Eigen::SimplicialLLT::MatrixU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::RealScalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::Scalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::SimplicialLLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT() : Base() {}$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:()
Eigen::SimplicialLLT::SimplicialLLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& matrix)
Eigen::SimplicialLLT::Traits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT> Traits;$/;"	t	class:Eigen::SimplicialLLT	access:public
Eigen::SimplicialLLT::UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLLT::__anon410
Eigen::SimplicialLLT::VectorType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLLT	access:public
EIGEN_SIZE_MAX	../include/Eigen/src/Core/util/Macros.h	399;"	d
EIGEN_SIZE_MIN_PREFER_DYNAMIC	../include/Eigen/src/Core/util/Macros.h	383;"	d
EIGEN_SIZE_MIN_PREFER_FIXED	../include/Eigen/src/Core/util/Macros.h	391;"	d
Eigen::SliceVectorizedTraversal	../include/Eigen/src/Core/util/Constants.h	/^  SliceVectorizedTraversal,$/;"	e	enum:Eigen::__anon209
Eigen::SluMatrix::__anon1::__anon2::lda	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon1::__anon2	access:public
Eigen::SluMatrix::__anon1::__anon2::nnz	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon1::__anon2	access:public
Eigen::SluMatrix::__anon1::innerInd	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int *innerInd;$/;"	m	struct:Eigen::SluMatrix::__anon1	access:public
Eigen::SluMatrix::__anon1::outerInd	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int *outerInd;$/;"	m	struct:Eigen::SluMatrix::__anon1	access:public
Eigen::SluMatrix::__anon1::values	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void *values;$/;"	m	struct:Eigen::SluMatrix::__anon1	access:public
Eigen::SluMatrix	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrix : SuperMatrix$/;"	s	namespace:Eigen	inherits:SuperMatrix
Eigen::SluMatrixMapHelper	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<Matrix<Scalar,Rows,Cols,Options,MRows,MCols> >$/;"	s	namespace:Eigen
Eigen::SluMatrixMapHelper	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<SparseMatrixBase<Derived> >$/;"	s	namespace:Eigen
Eigen::SluMatrixMapHelper::MatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef Derived MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper	access:public
Eigen::SluMatrixMapHelper::MatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef Matrix<Scalar,Rows,Cols,Options,MRows,MCols> MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper	access:public
Eigen::SluMatrixMapHelper::run	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static void run(MatrixType& mat, SluMatrix& res)$/;"	f	struct:Eigen::SluMatrixMapHelper	access:public	signature:(MatrixType& mat, SluMatrix& res)
Eigen::SluMatrix::Map	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(MatrixBase<MatrixType>& _mat)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(MatrixBase<MatrixType>& _mat)
Eigen::SluMatrix::Map	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(SparseMatrixBase<MatrixType>& mat)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(SparseMatrixBase<MatrixType>& mat)
Eigen::SluMatrix::operator =	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix& operator=(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(const SluMatrix& other)
Eigen::SluMatrix::setScalarType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  void setScalarType()$/;"	f	struct:Eigen::SluMatrix	access:public	signature:()
Eigen::SluMatrix::setStorageType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  void setStorageType(Stype_t t)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(Stype_t t)
Eigen::SluMatrix::SluMatrix	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(const SluMatrix& other)
Eigen::SluMatrix::SluMatrix	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix()$/;"	f	struct:Eigen::SluMatrix	access:public	signature:()
Eigen::SluMatrix::storage	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  } storage;$/;"	m	struct:Eigen::SluMatrix	typeref:struct:Eigen::SluMatrix::__anon1	access:public
Eigen::Small	../include/Eigen/src/Core/GeneralProduct.h	/^  Small = 3$/;"	e	enum:Eigen::__anon120
EigenSolver	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::EigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors = true)
EigenSolver	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver(Index size)$/;"	f	class:Eigen::EigenSolver	access:public	signature:(Index size)
EigenSolver	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^ EigenSolver() : m_eivec(), m_eivalues(), m_isInitialized(false), m_realSchur(), m_matT(), m_tmp() {}$/;"	f	class:Eigen::EigenSolver	access:public	signature:()
EigenSolver	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^template<typename _MatrixType> class EigenSolver$/;"	c	namespace:Eigen
EIGEN_SOLVETRIANGULAR_H	../include/Eigen/src/Core/SolveTriangular.h	26;"	d
EIGEN_SPARSE_AMD_H	../include/Eigen/src/OrderingMethods/Amd.h	49;"	d
EIGEN_SPARSE_BLOCK_H	../include/Eigen/src/SparseCore/SparseBlock.h	26;"	d
EIGEN_SPARSE_CWISE_BINARY_OP_H	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	26;"	d
EIGEN_SPARSE_CWISE_PRODUCT_RETURN_TYPE	../include/Eigen/src/SparseCore/SparseMatrixBase.h	332;"	d
EIGEN_SPARSE_CWISE_UNARY_OP_H	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	26;"	d
Eigen::SparseDenseOuterProduct::Base	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef SparseMatrixBase<SparseDenseOuterProduct> Base;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:public
Eigen::SparseDenseOuterProduct::cols	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return Tr ? m_lhs.cols() : m_rhs.cols(); }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
Eigen::SparseDenseOuterProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^class SparseDenseOuterProduct$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::SparseDenseOuterProduct::InnerIterator::Base	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename _LhsNested::InnerIterator Base;$/;"	t	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:private
Eigen::SparseDenseOuterProduct::InnerIterator::col	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Index col() const { return Transpose ? m_outer : Base::row(); }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
Eigen::SparseDenseOuterProduct::InnerIterator	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^class SparseDenseOuterProduct<Lhs,Rhs,Transpose>::InnerIterator : public _LhsNested::InnerIterator$/;"	c	class:Eigen::SparseDenseOuterProduct	inherits:_LhsNested::InnerIterator
Eigen::SparseDenseOuterProduct::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE InnerIterator(const SparseDenseOuterProduct& prod, Index outer)$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:(const SparseDenseOuterProduct& prod, Index outer)
Eigen::SparseDenseOuterProduct::InnerIterator::m_factor	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    Scalar m_factor;$/;"	m	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:protected
Eigen::SparseDenseOuterProduct::InnerIterator::m_outer	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    int m_outer;$/;"	m	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:protected
Eigen::SparseDenseOuterProduct::InnerIterator::outer	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
Eigen::SparseDenseOuterProduct::InnerIterator::row	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Index row() const { return Transpose ? Base::row() : m_outer; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
Eigen::SparseDenseOuterProduct::InnerIterator::value	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Scalar value() const { return Base::value() * m_factor; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
Eigen::SparseDenseOuterProduct::lhs	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
Eigen::SparseDenseOuterProduct::_LhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::_LhsNested _LhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
Eigen::SparseDenseOuterProduct::LhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::LhsNested LhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
Eigen::SparseDenseOuterProduct::m_lhs	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseDenseOuterProduct	access:protected
Eigen::SparseDenseOuterProduct::m_rhs	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseDenseOuterProduct	access:protected
Eigen::SparseDenseOuterProduct::rhs	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
Eigen::SparseDenseOuterProduct::_RhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::_RhsNested _RhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
Eigen::SparseDenseOuterProduct::RhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::RhsNested RhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
Eigen::SparseDenseOuterProduct::rows	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return Tr ? m_rhs.rows() : m_lhs.rows(); }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
Eigen::SparseDenseOuterProduct::SparseDenseOuterProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE SparseDenseOuterProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::SparseDenseOuterProduct::SparseDenseOuterProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE SparseDenseOuterProduct(const Rhs& rhs, const Lhs& lhs)$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:(const Rhs& rhs, const Lhs& lhs)
Eigen::SparseDenseOuterProduct::Traits	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef internal::traits<SparseDenseOuterProduct> Traits;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:public
EIGEN_SPARSEDENSEPRODUCT_H	../include/Eigen/src/SparseCore/SparseDenseProduct.h	26;"	d
Eigen::SparseDenseProductReturnType	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs, int InnerSize> struct SparseDenseProductReturnType$/;"	s	namespace:Eigen
Eigen::SparseDenseProductReturnType	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs> struct SparseDenseProductReturnType<Lhs,Rhs,1>$/;"	s	namespace:Eigen
Eigen::SparseDenseProductReturnType::Type	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef SparseDenseOuterProduct<Lhs,Rhs,false> Type;$/;"	t	struct:Eigen::SparseDenseProductReturnType	access:public
Eigen::SparseDenseProductReturnType::Type	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef SparseTimeDenseProduct<Lhs,Rhs> Type;$/;"	t	struct:Eigen::SparseDenseProductReturnType	access:public
Eigen::SparseDiagonalProduct::cols	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
EIGEN_SPARSE_DIAGONAL_PRODUCT_H	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	26;"	d
Eigen::SparseDiagonalProduct	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^class SparseDiagonalProduct$/;"	c	namespace:Eigen	inherits:SparseMatrixBase,internal::no_assignment_operator
Eigen::SparseDiagonalProduct::InnerIterator	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^                <_LhsNested,_RhsNested,SparseDiagonalProduct,LhsMode,RhsMode> InnerIterator;$/;"	t	class:Eigen::SparseDiagonalProduct	access:public
Eigen::SparseDiagonalProduct::lhs	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
Eigen::SparseDiagonalProduct::LhsMode	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      LhsMode = internal::is_diagonal<_LhsNested>::ret ? internal::SDP_IsDiagonal$/;"	e	enum:Eigen::SparseDiagonalProduct::__anon37
Eigen::SparseDiagonalProduct::_LhsNested	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
Eigen::SparseDiagonalProduct::LhsNested	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
Eigen::SparseDiagonalProduct::m_lhs	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseDiagonalProduct	access:protected
Eigen::SparseDiagonalProduct::m_rhs	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseDiagonalProduct	access:protected
Eigen::SparseDiagonalProduct::rhs	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
Eigen::SparseDiagonalProduct::RhsMode	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      RhsMode = internal::is_diagonal<_RhsNested>::ret ? internal::SDP_IsDiagonal$/;"	e	enum:Eigen::SparseDiagonalProduct::__anon37
Eigen::SparseDiagonalProduct::_RhsNested	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
Eigen::SparseDiagonalProduct::RhsNested	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
Eigen::SparseDiagonalProduct::rows	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
Eigen::SparseDiagonalProduct::SparseDiagonalProduct	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE SparseDiagonalProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
EIGEN_SPARSE_DOT_H	../include/Eigen/src/SparseCore/SparseDot.h	26;"	d
EIGEN_SPARSE_FUZZY_H	../include/Eigen/src/SparseCore/SparseFuzzy.h	26;"	d
EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATOR	../include/Eigen/src/SparseCore/SparseUtil.h	36;"	d
EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATORS	../include/Eigen/src/SparseCore/SparseUtil.h	54;"	d
EIGEN_SPARSE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR	../include/Eigen/src/SparseCore/SparseUtil.h	47;"	d
Eigen::SparseInnerVectorSet::cols	../include/Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
Eigen::SparseInnerVectorSet	../include/Eigen/src/SparseCore/SparseBlock.h	/^class SparseInnerVectorSet : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,SparseMatrixBase
Eigen::SparseInnerVectorSet	../include/Eigen/src/SparseCore/SparseBlock.h	/^class SparseInnerVectorSet<SparseMatrix<_Scalar, _Options, _Index>, Size>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::SparseInnerVectorSet::innerIndexPtr	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Index* innerIndexPtr() const$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
Eigen::SparseInnerVectorSet::innerIndexPtr	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline Index* innerIndexPtr()$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:()
Eigen::SparseInnerVectorSet::InnerIterator::col	../include/Eigen/src/SparseCore/SparseBlock.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::SparseInnerVectorSet::InnerIterator	access:public	signature:() const
Eigen::SparseInnerVectorSet::InnerIterator	../include/Eigen/src/SparseCore/SparseBlock.h	/^    class InnerIterator: public MatrixType::InnerIterator$/;"	c	class:Eigen::SparseInnerVectorSet	inherits:MatrixType::InnerIterator	access:public
Eigen::SparseInnerVectorSet::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/SparseBlock.h	/^        inline InnerIterator(const SparseInnerVectorSet& xpr, Index outer)$/;"	f	class:Eigen::SparseInnerVectorSet::InnerIterator	access:public	signature:(const SparseInnerVectorSet& xpr, Index outer)
Eigen::SparseInnerVectorSet::InnerIterator::m_outer	../include/Eigen/src/SparseCore/SparseBlock.h	/^        Index m_outer;$/;"	m	class:Eigen::SparseInnerVectorSet::InnerIterator	access:protected
Eigen::SparseInnerVectorSet::InnerIterator::row	../include/Eigen/src/SparseCore/SparseBlock.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::SparseInnerVectorSet::InnerIterator	access:public	signature:() const
Eigen::SparseInnerVectorSet::IsRowMajor	../include/Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<SparseInnerVectorSet>::IsRowMajor };$/;"	e	enum:Eigen::SparseInnerVectorSet::__anon21
Eigen::SparseInnerVectorSet::IsRowMajor	../include/Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<SparseInnerVectorSet>::IsRowMajor };$/;"	e	enum:Eigen::SparseInnerVectorSet::__anon22
Eigen::SparseInnerVectorSet::lastCoeff	../include/Eigen/src/SparseCore/SparseBlock.h	/^    const Scalar& lastCoeff() const$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
Eigen::SparseInnerVectorSet::MatrixType	../include/Eigen/src/SparseCore/SparseBlock.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> MatrixType;$/;"	t	class:Eigen::SparseInnerVectorSet	access:private
Eigen::SparseInnerVectorSet::m_matrix	../include/Eigen/src/SparseCore/SparseBlock.h	/^    const typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseInnerVectorSet	access:protected
Eigen::SparseInnerVectorSet::m_matrix	../include/Eigen/src/SparseCore/SparseBlock.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseInnerVectorSet	access:protected
Eigen::SparseInnerVectorSet::m_outerSize	../include/Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, Size> m_outerSize;$/;"	m	class:Eigen::SparseInnerVectorSet	access:protected
Eigen::SparseInnerVectorSet::m_outerStart	../include/Eigen/src/SparseCore/SparseBlock.h	/^    Index m_outerStart;$/;"	m	class:Eigen::SparseInnerVectorSet	access:protected
Eigen::SparseInnerVectorSet::nonZeros	../include/Eigen/src/SparseCore/SparseBlock.h	/^    Index nonZeros() const$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
Eigen::SparseInnerVectorSet::operator =	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseInnerVectorSet& operator=(const SparseInnerVectorSet& other)$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:(const SparseInnerVectorSet& other)
Eigen::SparseInnerVectorSet::operator =	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseInnerVectorSet& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseInnerVectorSet::outerIndexPtr	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Index* outerIndexPtr() const$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
Eigen::SparseInnerVectorSet::outerIndexPtr	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline Index* outerIndexPtr()$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:()
Eigen::SparseInnerVectorSet::ReverseInnerIterator::col	../include/Eigen/src/SparseCore/SparseBlock.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::SparseInnerVectorSet::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseInnerVectorSet::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseBlock.h	/^    class ReverseInnerIterator: public MatrixType::ReverseInnerIterator$/;"	c	class:Eigen::SparseInnerVectorSet	inherits:MatrixType::ReverseInnerIterator	access:public
Eigen::SparseInnerVectorSet::ReverseInnerIterator::m_outer	../include/Eigen/src/SparseCore/SparseBlock.h	/^        Index m_outer;$/;"	m	class:Eigen::SparseInnerVectorSet::ReverseInnerIterator	access:protected
Eigen::SparseInnerVectorSet::ReverseInnerIterator::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseBlock.h	/^        inline ReverseInnerIterator(const SparseInnerVectorSet& xpr, Index outer)$/;"	f	class:Eigen::SparseInnerVectorSet::ReverseInnerIterator	access:public	signature:(const SparseInnerVectorSet& xpr, Index outer)
Eigen::SparseInnerVectorSet::ReverseInnerIterator::row	../include/Eigen/src/SparseCore/SparseBlock.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::SparseInnerVectorSet::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseInnerVectorSet::rows	../include/Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
Eigen::SparseInnerVectorSet::SparseInnerVectorSet	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseInnerVectorSet(const MatrixType& matrix, Index outer)$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:(const MatrixType& matrix, Index outer)
Eigen::SparseInnerVectorSet::SparseInnerVectorSet	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseInnerVectorSet(const MatrixType& matrix, Index outerStart, Index outerSize)$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:(const MatrixType& matrix, Index outerStart, Index outerSize)
Eigen::SparseInnerVectorSet::valuePtr	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar* valuePtr() const$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
Eigen::SparseInnerVectorSet::valuePtr	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar* valuePtr()$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:()
Eigen::SparseMatrixBase::adjoint	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const AdjointReturnType adjoint() const { return transpose(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::AdjointReturnType	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::assignGeneric	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline void assignGeneric(const OtherDerived& other)$/;"	f	class:Eigen::SparseMatrixBase	access:protected	signature:(const OtherDerived& other)
Eigen::SparseMatrixBase::assign	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& assign(const OtherDerived& other)$/;"	f	class:Eigen::SparseMatrixBase	access:protected	signature:(const OtherDerived& other)
Eigen::SparseMatrixBase::Base	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::CoeffReadCost	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
Eigen::SparseMatrixBase::CoeffReturnType	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::conditional<_HasDirectAccess, const Scalar&, Scalar>::type CoeffReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::col	../include/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::col(Index i) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index i) const
Eigen::SparseMatrixBase::col	../include/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::col(Index i)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index i)
Eigen::SparseMatrixBase::col	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,1> col(Index j) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index j) const
Eigen::SparseMatrixBase::col	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,1> col(Index j);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index j)
Eigen::SparseMatrixBase::ColsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
Eigen::SparseMatrixBase::cols	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::ConstantReturnType	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Matrix<Scalar,Dynamic,Dynamic> > ConstantReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::const_cast_derived	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& const_cast_derived() const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::cwiseProduct	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::cwiseProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::cwiseProduct	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    cwiseProduct(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::derived	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::derived	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
Eigen::SparseMatrixBase::dot	../include/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::dot	../include/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::dot	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> Scalar dot(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::dot	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> Scalar dot(const SparseMatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::eval	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const typename internal::eval<Derived>::type eval() const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::evalTo	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      void evalTo(MatrixBase<DenseDerived>& dst) const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(MatrixBase<DenseDerived>& dst) const
Eigen::SparseMatrixBase::Flags	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
Eigen::SparseMatrixBase::_HasDirectAccess	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      _HasDirectAccess = (int(Flags)&DirectAccessBit) ? 1 : 0 \/\/ workaround sunCC$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
EIGEN_SPARSEMATRIXBASE_H	../include/Eigen/src/SparseCore/SparseMatrixBase.h	26;"	d
Eigen::SparseMatrixBase	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^template<typename Derived> class SparseMatrixBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::SparseMatrixBase::Index	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::innerSize	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Index innerSize() const { return (int(Flags)&RowMajorBit) ? this->cols() : this->rows(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::innerVector	../include/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::innerVector(Index outer) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outer) const
Eigen::SparseMatrixBase::innerVector	../include/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::innerVector(Index outer)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outer)
Eigen::SparseMatrixBase::innerVector	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,1> innerVector(Index outer) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outer) const
Eigen::SparseMatrixBase::innerVector	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,1> innerVector(Index outer);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outer)
Eigen::SparseMatrixBase::innerVectors	../include/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outerStart, Index outerSize) const
Eigen::SparseMatrixBase::innerVectors	../include/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outerStart, Index outerSize)
Eigen::SparseMatrixBase::innerVectors	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,Dynamic> innerVectors(Index outerStart, Index outerSize) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outerStart, Index outerSize) const
Eigen::SparseMatrixBase::innerVectors	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,Dynamic> innerVectors(Index outerStart, Index outerSize);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outerStart, Index outerSize)
Eigen::SparseMatrixBase::isApprox	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::SparseMatrixBase::isApprox	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const SparseMatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::SparseMatrixBase::IsRowMajor	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      IsRowMajor = Flags&RowMajorBit ? 1 : 0,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
Eigen::SparseMatrixBase::isRValue	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isRValue() const { return m_isRValue; }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::IsVectorAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      IsVectorAtCompileTime = RowsAtCompileTime == 1 || ColsAtCompileTime == 1,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
Eigen::SparseMatrixBase::isVector	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline bool isVector() const { return rows()==1 || cols()==1; }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::markAsRValue	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& markAsRValue() { m_isRValue = true; return derived(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
Eigen::SparseMatrixBase::MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
Eigen::SparseMatrixBase::MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
Eigen::SparseMatrixBase::MaxSizeAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
Eigen::SparseMatrixBase::middleCols	../include/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::middleCols(Index start, Index size) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index start, Index size) const
Eigen::SparseMatrixBase::middleCols	../include/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::middleCols(Index start, Index size)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index start, Index size)
Eigen::SparseMatrixBase::middleCols	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,Dynamic> middleCols(Index start, Index size) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size) const
Eigen::SparseMatrixBase::middleCols	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,Dynamic> middleCols(Index start, Index size);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size)
Eigen::SparseMatrixBase::middleRows	../include/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::middleRows(Index start, Index size) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index start, Index size) const
Eigen::SparseMatrixBase::middleRows	../include/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::middleRows(Index start, Index size)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index start, Index size)
Eigen::SparseMatrixBase::middleRows	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,Dynamic> middleRows(Index start, Index size) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size) const
Eigen::SparseMatrixBase::middleRows	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,Dynamic> middleRows(Index start, Index size);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size)
Eigen::SparseMatrixBase::m_isRValue	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool m_isRValue;$/;"	m	class:Eigen::SparseMatrixBase	access:protected
Eigen::SparseMatrixBase::nonZeros	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index nonZeros() const { return derived().nonZeros(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::norm	../include/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::norm() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
Eigen::SparseMatrixBase::norm	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    RealScalar norm()  const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::operator -=	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator-=(const SparseMatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived> &other)
Eigen::SparseMatrixBase::operator +=	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator+=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrixBase::operator /=	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const Scalar& other)
Eigen::SparseMatrixBase::operator *=	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const Scalar& other)
Eigen::SparseMatrixBase::operator *	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^SparseMatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::operator *	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^SparseMatrixBase<Derived>::operator*(const DiagonalBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const DiagonalBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::operator =	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const EigenBase<OtherDerived> &other)
Eigen::SparseMatrixBase::operator =	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::SparseMatrixBase::operator /=	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator\/=(const Scalar& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const Scalar& other)
Eigen::SparseMatrixBase::operator *=	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator*=(const Scalar& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const Scalar& other)
Eigen::SparseMatrixBase::operator -=	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator-=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrixBase::operator *=	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator*=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrixBase::operator +=	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator+=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrixBase::operator <<	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrixBase& m)$/;"	f	class:Eigen::SparseMatrixBase	access:friend	signature:(std::ostream & s, const SparseMatrixBase& m)
Eigen::SparseMatrixBase::operator =	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const Derived& other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const Derived& other)
Eigen::SparseMatrixBase::operator =	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrixBase::operator =	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const SparseSparseProduct<Lhs,Rhs>& product);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
Eigen::SparseMatrixBase::operator *	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)$/;"	f	class:Eigen::SparseMatrixBase	access:friend	signature:(const DiagonalBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)
Eigen::SparseMatrixBase::operator *	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const DiagonalBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::operator *	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const Derived& rhs)$/;"	f	class:Eigen::SparseMatrixBase	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const Derived& rhs)
Eigen::SparseMatrixBase::operator *	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::operator *	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const SparseMatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::operator =	../include/Eigen/src/SparseCore/SparseProduct.h	/^inline Derived& SparseMatrixBase<Derived>::operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
Eigen::SparseMatrixBase::operator *	../include/Eigen/src/SparseCore/SparseProduct.h	/^SparseMatrixBase<Derived>::operator*(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived> &other) const
Eigen::SparseMatrixBase::outerSize	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Index outerSize() const { return (int(Flags)&RowMajorBit) ? this->rows() : this->cols(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::PacketReturnType	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::PacketScalar	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::PlainObject	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrix<Scalar, Flags&RowMajorBit ? RowMajor : ColMajor> PlainObject;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::RealScalar	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::row	../include/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::row(Index i) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index i) const
Eigen::SparseMatrixBase::row	../include/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::row(Index i)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index i)
Eigen::SparseMatrixBase::row	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,1> row(Index i) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index i) const
Eigen::SparseMatrixBase::row	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,1> row(Index i);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index i)
Eigen::SparseMatrixBase::RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
Eigen::SparseMatrixBase::rows	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::Scalar	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::selfadjointView	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> inline const SparseSelfAdjointView<Derived, UpLo> selfadjointView() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::selfadjointView	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> inline SparseSelfAdjointView<Derived, UpLo> selfadjointView();$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:()
Eigen::SparseMatrixBase::selfadjointView	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^const SparseSelfAdjointView<Derived, UpLo> SparseMatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
Eigen::SparseMatrixBase::selfadjointView	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<Derived, UpLo> SparseMatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::SparseMatrixBase	signature:()
Eigen::SparseMatrixBase::SizeAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
Eigen::SparseMatrixBase::size	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index size() const { return rows() * cols(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::solveTriangular	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    solveTriangular(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::solveTriangular	../include/Eigen/src/SparseCore/TriangularSolver.h	/^SparseMatrixBase<Derived>::solveTriangular(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::solveTriangularInPlace	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    void solveTriangularInPlace(MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(MatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::solveTriangularInPlace	../include/Eigen/src/SparseCore/TriangularSolver.h	/^void SparseMatrixBase<Derived>::solveTriangularInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(MatrixBase<OtherDerived>& other) const
Eigen::SparseMatrixBase::SparseMatrixBase	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseMatrixBase() : m_isRValue(false) { \/* TODO check flags *\/ }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
Eigen::SparseMatrixBase::squaredNorm	../include/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
Eigen::SparseMatrixBase::squaredNorm	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    RealScalar squaredNorm() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::SquareMatrixType	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::StorageBaseType	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrixBase StorageBaseType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::StorageKind	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Eigen::SparseMatrixBase::subcols	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,Dynamic> subcols(Index start, Index size) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size) const
Eigen::SparseMatrixBase::subcols	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,Dynamic> subcols(Index start, Index size);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size)
Eigen::SparseMatrixBase::subrows	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,Dynamic> subrows(Index start, Index size) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size) const
Eigen::SparseMatrixBase::subrows	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,Dynamic> subrows(Index start, Index size);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size)
Eigen::SparseMatrixBase::sum	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Scalar sum() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::sum	../include/Eigen/src/SparseCore/SparseRedux.h	/^SparseMatrixBase<Derived>::sum() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
Eigen::SparseMatrixBase::toDense	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> toDense() const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::transpose	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const Transpose<const Derived> transpose() const { return derived(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::transpose	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Transpose<Derived> transpose() { return derived(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
Eigen::SparseMatrixBase::triangularView	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const SparseTriangularView<Derived, Mode> triangularView() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
Eigen::SparseMatrixBase::triangularView	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^SparseMatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
Eigen::SparseMatrixBase::twistedBy	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseSymmetricPermutationProduct<Derived,Upper|Lower> twistedBy(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const
Eigen::SparseMatrix::check_template_parameters	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  static void check_template_parameters()$/;"	f	class:Eigen::SparseMatrix	access:private	signature:()
Eigen::SparseMatrix::coeff	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col) const
Eigen::SparseMatrix::coeffRef	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
Eigen::SparseMatrix::cols	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::data	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::data	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::default_prunning_func::default_prunning_func	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    default_prunning_func(Scalar ref, RealScalar eps) : reference(ref), epsilon(eps) {}$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func	access:public	signature:(Scalar ref, RealScalar eps)
Eigen::SparseMatrix::default_prunning_func::epsilon	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    RealScalar epsilon;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func	access:public
Eigen::SparseMatrix::default_prunning_func	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  struct default_prunning_func {$/;"	s	class:Eigen::SparseMatrix	access:private
Eigen::SparseMatrix::default_prunning_func::operator ()	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline bool operator() (const Index&, const Index&, const Scalar& value) const$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func	access:public	signature:(const Index&, const Index&, const Scalar& value) const
Eigen::SparseMatrix::default_prunning_func::reference	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Scalar reference;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func	access:public
Eigen::SparseMatrix::diagonal	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Diagonal<const SparseMatrix> diagonal() const { return *this; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::finalize	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void finalize()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
EIGEN_SPARSEMATRIX_H	../include/Eigen/src/SparseCore/SparseMatrix.h	26;"	d
Eigen::SparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::SparseMatrix::initAssignment	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void initAssignment(const Other& other)$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:(const Other& other)
Eigen::SparseMatrix::innerIndexPtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Index* innerIndexPtr() const { return &m_data.index(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::innerIndexPtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index* innerIndexPtr() { return &m_data.index(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::InnerIterator::col	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Eigen::SparseMatrix::InnerIterator	../include/Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::SparseMatrix
Eigen::SparseMatrix::InnerIterator::index	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index index() const { return m_indices[m_id]; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Eigen::SparseMatrix::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    InnerIterator(const SparseMatrix& mat, Index outer)$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:(const SparseMatrix& mat, Index outer)
Eigen::SparseMatrix::InnerIterator::m_end	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_end;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
Eigen::SparseMatrix::InnerIterator::m_id	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
Eigen::SparseMatrix::InnerIterator::m_indices	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index* m_indices;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
Eigen::SparseMatrix::InnerIterator::m_outer	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
Eigen::SparseMatrix::InnerIterator::m_values	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
Eigen::SparseMatrix::InnerIterator::operator bool	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Eigen::SparseMatrix::InnerIterator::operator ++	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:()
Eigen::SparseMatrix::InnerIterator::outer	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Eigen::SparseMatrix::InnerIterator::row	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Eigen::SparseMatrix::InnerIterator::value	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar& value() const { return m_values[m_id]; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Eigen::SparseMatrix::InnerIterator::valueRef	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id]); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:()
Eigen::SparseMatrix::innerNonZeroPtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Index* innerNonZeroPtr() const { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::innerNonZeroPtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index* innerNonZeroPtr() { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::innerNonZeros	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const  Eigen::Map<const Matrix<Index,Dynamic,1> > innerNonZeros() const { return Eigen::Map<const Matrix<Index,Dynamic,1> >(m_innerNonZeros, m_innerNonZeros?m_outerSize:0); }$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:() const
Eigen::SparseMatrix::innerNonZeros	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Eigen::Map<Matrix<Index,Dynamic,1> > innerNonZeros() { return Eigen::Map<Matrix<Index,Dynamic,1> >(m_innerNonZeros, m_innerNonZeros?m_outerSize:0); }$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:()
Eigen::SparseMatrix::innerSize	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::insertBackByOuterInner	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index outer, Index inner)
Eigen::SparseMatrix::insertBackByOuterInnerUnordered	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInnerUnordered(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index outer, Index inner)
Eigen::SparseMatrix::insertBack	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBack(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
Eigen::SparseMatrix::insertBackUncompressed	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
Eigen::SparseMatrix::insertByOuterInner	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertByOuterInner(Index j, Index i)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index j, Index i)
Eigen::SparseMatrix::insertCompressed	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertCompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:(Index row, Index col)
Eigen::SparseMatrix::insert	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
Eigen::SparseMatrix::insertUncompressed	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:(Index row, Index col)
Eigen::SparseMatrix::isCompressed	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline bool isCompressed() const { return m_innerNonZeros==0; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::makeCompressed	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void makeCompressed()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::Map	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef MappedSparseMatrix<Scalar,Flags> Map;$/;"	t	class:Eigen::SparseMatrix	access:public
Eigen::SparseMatrix::m_data	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::m_innerNonZeros	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index* m_innerNonZeros;     \/\/ optional, if null then the data is compressed$/;"	m	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::m_innerSize	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_innerSize;$/;"	m	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::m_outerIndex	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index* m_outerIndex;$/;"	m	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::m_outerSize	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_outerSize;$/;"	m	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::nonZeros	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index nonZeros() const$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::operator =	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE SparseMatrix& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrix::operator <<	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrix& m)$/;"	f	class:Eigen::SparseMatrix	access:friend	signature:(std::ostream & s, const SparseMatrix& m)
Eigen::SparseMatrix::operator =	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::SparseMatrix::operator =	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::SparseMatrix::operator =	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrix& other)
Eigen::SparseMatrix::operator =	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
Eigen::SparseMatrix::Options	../include/Eigen/src/SparseCore/SparseMatrix.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseMatrix::__anon33
Eigen::SparseMatrix::outerIndexPtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Index* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::outerIndexPtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::outerSize	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::prune	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void prune(const KeepFunc& keep = KeepFunc())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const KeepFunc& keep = KeepFunc())
Eigen::SparseMatrix::prune	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void prune(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())
Eigen::SparseMatrix::reserve	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::Scalar& enableif = typename SizesType::Scalar())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SizesType& reserveSizes, const typename SizesType::Scalar& enableif = typename SizesType::Scalar())
Eigen::SparseMatrix::reserve	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::value_type& enableif = typename SizesType::value_type())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SizesType& reserveSizes, const typename SizesType::value_type& enableif = typename SizesType::value_type())
Eigen::SparseMatrix::reserve	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes);$/;"	p	class:Eigen::SparseMatrix	access:public	signature:(const SizesType& reserveSizes)
Eigen::SparseMatrix::reserve	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(Index reserveSize)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index reserveSize)
Eigen::SparseMatrix::reserveInnerVectors	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserveInnerVectors(const SizesType& reserveSizes)$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:(const SizesType& reserveSizes)
Eigen::SparseMatrix::resize	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index rows, Index cols)
Eigen::SparseMatrix::resizeNonZeros	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void resizeNonZeros(Index size)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index size)
Eigen::SparseMatrix::ReverseInnerIterator::col	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseMatrix::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::SparseMatrix
Eigen::SparseMatrix::ReverseInnerIterator::index	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index index() const { return m_indices[m_id-1]; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseMatrix::ReverseInnerIterator::m_id	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
Eigen::SparseMatrix::ReverseInnerIterator::m_indices	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index* m_indices;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
Eigen::SparseMatrix::ReverseInnerIterator::m_outer	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
Eigen::SparseMatrix::ReverseInnerIterator::m_start	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
Eigen::SparseMatrix::ReverseInnerIterator::m_values	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
Eigen::SparseMatrix::ReverseInnerIterator::operator bool	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseMatrix::ReverseInnerIterator::operator --	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline ReverseInnerIterator& operator--() { --m_id; return *this; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:()
Eigen::SparseMatrix::ReverseInnerIterator::outer	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseMatrix::ReverseInnerIterator::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    ReverseInnerIterator(const SparseMatrix& mat, Index outer)$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:(const SparseMatrix& mat, Index outer)
Eigen::SparseMatrix::ReverseInnerIterator::row	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseMatrix::ReverseInnerIterator::value	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar& value() const { return m_values[m_id-1]; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseMatrix::ReverseInnerIterator::valueRef	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id-1]); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:()
Eigen::SparseMatrix::rows	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::setFromTriplets	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void setFromTriplets(const InputIterators& begin, const InputIterators& end);$/;"	p	class:Eigen::SparseMatrix	access:public	signature:(const InputIterators& begin, const InputIterators& end)
Eigen::SparseMatrix::setFromTriplets	../include/Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_Index>::setFromTriplets(const InputIterators& begin, const InputIterators& end)$/;"	f	class:Eigen::SparseMatrix	signature:(const InputIterators& begin, const InputIterators& end)
Eigen::SparseMatrix::setZero	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void setZero()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::SingletonVector	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    class SingletonVector$/;"	c	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::SingletonVector::m_index	../include/Eigen/src/SparseCore/SparseMatrix.h	/^        Index m_index;$/;"	m	class:Eigen::SparseMatrix::SingletonVector	access:private
Eigen::SparseMatrix::SingletonVector::m_value	../include/Eigen/src/SparseCore/SparseMatrix.h	/^        Index m_value;$/;"	m	class:Eigen::SparseMatrix::SingletonVector	access:private
Eigen::SparseMatrix::SingletonVector::operator []	../include/Eigen/src/SparseCore/SparseMatrix.h	/^        Index operator[](Index i) const { return i==m_index ? m_value : 0; }$/;"	f	class:Eigen::SparseMatrix::SingletonVector	access:public	signature:(Index i) const
Eigen::SparseMatrix::SingletonVector::SingletonVector	../include/Eigen/src/SparseCore/SparseMatrix.h	/^        SingletonVector(Index i, Index v)$/;"	f	class:Eigen::SparseMatrix::SingletonVector	access:public	signature:(Index i, Index v)
Eigen::SparseMatrix::SingletonVector::value_type	../include/Eigen/src/SparseCore/SparseMatrix.h	/^        typedef Index value_type;$/;"	t	class:Eigen::SparseMatrix::SingletonVector	access:public
Eigen::SparseMatrix::SparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseMatrix::SparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrix& other)
Eigen::SparseMatrix::~SparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline ~SparseMatrix()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::SparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::SparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index rows, Index cols)
Eigen::SparseMatrix::startVec	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index outer)
Eigen::SparseMatrix::Storage	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef internal::CompressedStorage<Scalar,Index> Storage;$/;"	t	class:Eigen::SparseMatrix	access:public
Eigen::SparseMatrix::sum	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Scalar sum() const;$/;"	p	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::sum	../include/Eigen/src/SparseCore/SparseRedux.h	/^SparseMatrix<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseMatrix	signature:() const
Eigen::SparseMatrix::sumupDuplicates	../include/Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_Index>::sumupDuplicates()$/;"	f	class:Eigen::SparseMatrix	signature:()
Eigen::SparseMatrix::sumupDuplicates	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void sumupDuplicates();$/;"	p	class:Eigen::SparseMatrix	access:public	signature:()
Eigen::SparseMatrix::swap	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void swap(SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(SparseMatrix& other)
Eigen::SparseMatrix::TransposedSparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef SparseMatrix<Scalar,(Flags&~RowMajorBit)|(IsRowMajor?RowMajorBit:0)> TransposedSparseMatrix;$/;"	t	class:Eigen::SparseMatrix	access:protected
Eigen::SparseMatrix::valuePtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar* valuePtr() const { return &m_data.value(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
Eigen::SparseMatrix::valuePtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar* valuePtr() { return &m_data.value(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
EIGEN_SPARSE_PERMUTATION_H	../include/Eigen/src/SparseCore/SparsePermutation.h	26;"	d
EIGEN_SPARSEPRODUCT_H	../include/Eigen/src/SparseCore/SparseProduct.h	26;"	d
_EIGEN_SPARSE_PUBLIC_INTERFACE	../include/Eigen/src/SparseCore/SparseUtil.h	61;"	d
EIGEN_SPARSE_PUBLIC_INTERFACE	../include/Eigen/src/SparseCore/SparseUtil.h	77;"	d
EIGEN_SPARSEREDUX_H	../include/Eigen/src/SparseCore/SparseRedux.h	26;"	d
Eigen::SparseSelfAdjointTimeDenseProduct	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class SparseSelfAdjointTimeDenseProduct$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::SparseSelfAdjointTimeDenseProduct::operator =	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointTimeDenseProduct& operator=(const SparseSelfAdjointTimeDenseProduct&);$/;"	p	class:Eigen::SparseSelfAdjointTimeDenseProduct	access:private	signature:(const SparseSelfAdjointTimeDenseProduct&)
Eigen::SparseSelfAdjointTimeDenseProduct::scaleAndAddTo	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	class:Eigen::SparseSelfAdjointTimeDenseProduct	access:public	signature:(Dest& dest, Scalar alpha) const
Eigen::SparseSelfAdjointTimeDenseProduct::SparseSelfAdjointTimeDenseProduct	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::SparseSelfAdjointTimeDenseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::SparseSelfAdjointView::cols	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:() const
Eigen::SparseSelfAdjointView::evalTo	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestScalar,int StorageOrder> void evalTo(SparseMatrix<DestScalar,StorageOrder,Index>& _dest) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(SparseMatrix<DestScalar,StorageOrder,Index>& _dest) const
Eigen::SparseSelfAdjointView::evalTo	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestScalar> void evalTo(DynamicSparseMatrix<DestScalar,ColMajor,Index>& _dest) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(DynamicSparseMatrix<DestScalar,ColMajor,Index>& _dest) const
EIGEN_SPARSE_SELFADJOINTVIEW_H	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	26;"	d
Eigen::SparseSelfAdjointView	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<typename MatrixType, unsigned int UpLo> class SparseSelfAdjointView$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::SparseSelfAdjointView::Index	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Eigen::SparseSelfAdjointView::matrix	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const _MatrixTypeNested& matrix() const { return m_matrix; }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:() const
Eigen::SparseSelfAdjointView::matrix	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    _MatrixTypeNested& matrix() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:()
Eigen::SparseSelfAdjointView::_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Eigen::SparseSelfAdjointView::MatrixTypeNested	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Eigen::SparseSelfAdjointView::m_countPerCol	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    mutable VectorI m_countPerCol;$/;"	m	class:Eigen::SparseSelfAdjointView	access:protected
Eigen::SparseSelfAdjointView::m_countPerRow	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    mutable VectorI m_countPerRow;$/;"	m	class:Eigen::SparseSelfAdjointView	access:protected
Eigen::SparseSelfAdjointView::m_matrix	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseSelfAdjointView	access:protected
Eigen::SparseSelfAdjointView::operator *	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)
Eigen::SparseSelfAdjointView::operator *	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const MatrixBase<OtherDerived>& rhs) const
Eigen::SparseSelfAdjointView::operator =	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView& src)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseSelfAdjointView& src)
Eigen::SparseSelfAdjointView::operator =	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView<SrcMatrixType,SrcUpLo>& src)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseSelfAdjointView<SrcMatrixType,SrcUpLo>& src)
Eigen::SparseSelfAdjointView::operator =	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSymmetricPermutationProduct<SrcMatrixType,SrcUpLo>& permutedMatrix)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseSymmetricPermutationProduct<SrcMatrixType,SrcUpLo>& permutedMatrix)
Eigen::SparseSelfAdjointView::rankUpdate	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<MatrixType,UpLo>::rankUpdate(const SparseMatrixBase<DerivedU>& u, Scalar alpha)$/;"	f	class:Eigen::SparseSelfAdjointView	signature:(const SparseMatrixBase<DerivedU>& u, Scalar alpha)
Eigen::SparseSelfAdjointView::rankUpdate	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& rankUpdate(const SparseMatrixBase<DerivedU>& u, Scalar alpha = Scalar(1));$/;"	p	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseMatrixBase<DerivedU>& u, Scalar alpha = Scalar(1))
Eigen::SparseSelfAdjointView::rows	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:() const
Eigen::SparseSelfAdjointView::Scalar	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Eigen::SparseSelfAdjointView::SparseSelfAdjointView	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline SparseSelfAdjointView(const MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const MatrixType& matrix)
Eigen::SparseSelfAdjointView::twistedBy	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct<_MatrixTypeNested,UpLo> twistedBy(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const
Eigen::SparseSelfAdjointView::VectorI	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<Index,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
EIGEN_SPARSE_SOLVE_H	../include/Eigen/src/misc/SparseSolve.h	26;"	d
Eigen::SparseSparseProduct::Base	../include/Eigen/src/SparseCore/SparseProduct.h	/^    typedef SparseMatrixBase<SparseSparseProduct> Base;$/;"	t	class:Eigen::SparseSparseProduct	access:public
Eigen::SparseSparseProduct::cols	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
Eigen::SparseSparseProduct::evalTo	../include/Eigen/src/SparseCore/SparseProduct.h	/^    void evalTo(Dest& result) const$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(Dest& result) const
Eigen::SparseSparseProduct	../include/Eigen/src/SparseCore/SparseProduct.h	/^class SparseSparseProduct : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,SparseMatrixBase
Eigen::SparseSparseProduct::init	../include/Eigen/src/SparseCore/SparseProduct.h	/^    void init()$/;"	f	class:Eigen::SparseSparseProduct	access:protected	signature:()
Eigen::SparseSparseProduct::lhs	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
Eigen::SparseSparseProduct::_LhsNested	../include/Eigen/src/SparseCore/SparseProduct.h	/^    typedef typename internal::traits<SparseSparseProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::SparseSparseProduct	access:private
Eigen::SparseSparseProduct::m_conservative	../include/Eigen/src/SparseCore/SparseProduct.h	/^    bool m_conservative;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
Eigen::SparseSparseProduct::m_lhs	../include/Eigen/src/SparseCore/SparseProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
Eigen::SparseSparseProduct::m_rhs	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
Eigen::SparseSparseProduct::m_tolerance	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RealScalar m_tolerance;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
Eigen::SparseSparseProduct::pruned	../include/Eigen/src/SparseCore/SparseProduct.h	/^    SparseSparseProduct pruned(Scalar reference = 0, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision()) const$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(Scalar reference = 0, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision()) const
Eigen::SparseSparseProductReturnType	../include/Eigen/src/SparseCore/SparseProduct.h	/^struct SparseSparseProductReturnType$/;"	s	namespace:Eigen
Eigen::SparseSparseProductReturnType::LhsNested	../include/Eigen/src/SparseCore/SparseProduct.h	/^    typename internal::nested<Lhs,Rhs::RowsAtCompileTime>::type>::type LhsNested;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Eigen::SparseSparseProductReturnType::LhsRowMajor	../include/Eigen/src/SparseCore/SparseProduct.h	/^    LhsRowMajor = internal::traits<Lhs>::Flags & RowMajorBit,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon16
Eigen::SparseSparseProductReturnType::RhsNested	../include/Eigen/src/SparseCore/SparseProduct.h	/^    typename internal::nested<Rhs,Lhs::RowsAtCompileTime>::type>::type RhsNested;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Eigen::SparseSparseProductReturnType::RhsRowMajor	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RhsRowMajor = internal::traits<Rhs>::Flags & RowMajorBit,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon16
Eigen::SparseSparseProductReturnType::Scalar	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename internal::traits<Lhs>::Scalar Scalar;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Eigen::SparseSparseProductReturnType::TransposeLhs	../include/Eigen/src/SparseCore/SparseProduct.h	/^    TransposeLhs = LhsRowMajor && (!RhsRowMajor)$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon16
Eigen::SparseSparseProductReturnType::TransposeRhs	../include/Eigen/src/SparseCore/SparseProduct.h	/^    TransposeRhs = (!LhsRowMajor) && RhsRowMajor,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon16
Eigen::SparseSparseProductReturnType::Type	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef SparseSparseProduct<LhsNested, RhsNested> Type;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Eigen::SparseSparseProduct::rhs	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
Eigen::SparseSparseProduct::_RhsNested	../include/Eigen/src/SparseCore/SparseProduct.h	/^    typedef typename internal::traits<SparseSparseProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::SparseSparseProduct	access:private
Eigen::SparseSparseProduct::rows	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
Eigen::SparseSparseProduct::SparseSparseProduct	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE SparseSparseProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::SparseSparseProduct::SparseSparseProduct	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE SparseSparseProduct(const Lhs& lhs, const Rhs& rhs, RealScalar tolerance)$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs, RealScalar tolerance)
EIGEN_SPARSESPARSEPRODUCTWITHPRUNING_H	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	26;"	d
Eigen::SparseSymmetricPermutationProduct::cols	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:() const
Eigen::SparseSymmetricPermutationProduct::evalTo	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestType,unsigned int DestUpLo> void evalTo(SparseSelfAdjointView<DestType,DestUpLo>& dest) const$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:(SparseSelfAdjointView<DestType,DestUpLo>& dest) const
Eigen::SparseSymmetricPermutationProduct::evalTo	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    void evalTo(SparseMatrix<DestScalar,Options,DstIndex>& _dest) const$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:(SparseMatrix<DestScalar,Options,DstIndex>& _dest) const
Eigen::SparseSymmetricPermutationProduct	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class SparseSymmetricPermutationProduct$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::SparseSymmetricPermutationProduct::Index	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Eigen::SparseSymmetricPermutationProduct::_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Eigen::SparseSymmetricPermutationProduct::MatrixTypeNested	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Eigen::SparseSymmetricPermutationProduct::m_matrix	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct	access:protected
Eigen::SparseSymmetricPermutationProduct::m_perm	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const Perm& m_perm;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct	access:protected
Eigen::SparseSymmetricPermutationProduct::Perm	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef PermutationMatrix<Dynamic,Dynamic,Index> Perm;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:protected
Eigen::SparseSymmetricPermutationProduct::rows	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:() const
Eigen::SparseSymmetricPermutationProduct::Scalar	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Eigen::SparseSymmetricPermutationProduct::SparseSymmetricPermutationProduct	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct(const MatrixType& mat, const Perm& perm)$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:(const MatrixType& mat, const Perm& perm)
Eigen::SparseSymmetricPermutationProduct::VectorI	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<Index,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Eigen::SparseTimeDenseProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^class SparseTimeDenseProduct$/;"	c	namespace:Eigen	inherits:ProductBase
Eigen::SparseTimeDenseProduct::operator =	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    SparseTimeDenseProduct& operator=(const SparseTimeDenseProduct&);$/;"	p	class:Eigen::SparseTimeDenseProduct	access:private	signature:(const SparseTimeDenseProduct&)
Eigen::SparseTimeDenseProduct::scaleAndAddTo	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	class:Eigen::SparseTimeDenseProduct	access:public	signature:(Dest& dest, Scalar alpha) const
Eigen::SparseTimeDenseProduct::SparseTimeDenseProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    SparseTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::SparseTimeDenseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
EIGEN_SPARSETRANSPOSE_H	../include/Eigen/src/SparseCore/SparseTranspose.h	26;"	d
EIGEN_SPARSETRIANGULARSOLVER_H	../include/Eigen/src/SparseCore/TriangularSolver.h	26;"	d
Eigen::SparseTriangularView::cols	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:() const
Eigen::SparseTriangularView::HasUnitDiag	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^           HasUnitDiag = (Mode&UnitDiag) ? 1 : 0$/;"	e	enum:Eigen::SparseTriangularView::__anon29
EIGEN_SPARSE_TRIANGULARVIEW_H	../include/Eigen/src/SparseCore/SparseTriangularView.h	26;"	d
Eigen::SparseTriangularView	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^template<typename MatrixType, int Mode> class SparseTriangularView$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::SparseTriangularView::InnerIterator::Base	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixTypeNestedCleaned::InnerIterator Base;$/;"	t	class:Eigen::SparseTriangularView::InnerIterator	access:private
Eigen::SparseTriangularView::InnerIterator::col	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index col() const { return Base::col(); }$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::InnerIterator	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^class SparseTriangularView<MatrixType,Mode>::InnerIterator : public MatrixTypeNestedCleaned::InnerIterator$/;"	c	class:Eigen::SparseTriangularView	inherits:MatrixTypeNestedCleaned::InnerIterator
Eigen::SparseTriangularView::InnerIterator::index	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index index() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator(const SparseTriangularView& view, Index outer)$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:(const SparseTriangularView& view, Index outer)
Eigen::SparseTriangularView::InnerIterator::m_returnOne	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    bool m_returnOne;$/;"	m	class:Eigen::SparseTriangularView::InnerIterator	access:protected
Eigen::SparseTriangularView::InnerIterator::operator bool	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::InnerIterator::operator ++	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:()
Eigen::SparseTriangularView::InnerIterator::row	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index row() const { return Base::row(); }$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::InnerIterator::value	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Scalar value() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::MatrixTypeNestedCleaned	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SparseTriangularView	access:public
Eigen::SparseTriangularView::MatrixTypeNested	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseTriangularView	access:public
Eigen::SparseTriangularView::MatrixTypeNestedNonRef	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	class:Eigen::SparseTriangularView	access:public
Eigen::SparseTriangularView::m_matrix	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseTriangularView	access:protected
Eigen::SparseTriangularView::nestedExpression	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:() const
Eigen::SparseTriangularView::ReverseInnerIterator::Base	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixTypeNestedCleaned::ReverseInnerIterator Base;$/;"	t	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:private
Eigen::SparseTriangularView::ReverseInnerIterator::col	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index col() const { return Base::col(); }$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^class SparseTriangularView<MatrixType,Mode>::ReverseInnerIterator : public MatrixTypeNestedCleaned::ReverseInnerIterator$/;"	c	class:Eigen::SparseTriangularView	inherits:MatrixTypeNestedCleaned::ReverseInnerIterator
Eigen::SparseTriangularView::ReverseInnerIterator::operator bool	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::ReverseInnerIterator::operator --	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator--()$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:()
Eigen::SparseTriangularView::ReverseInnerIterator::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const SparseTriangularView& view, Index outer)$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:(const SparseTriangularView& view, Index outer)
Eigen::SparseTriangularView::ReverseInnerIterator::row	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index row() const { return Base::row(); }$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseTriangularView::rows	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:() const
Eigen::SparseTriangularView::SkipFirst	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    enum { SkipFirst = ((Mode&Lower) && !(MatrixType::Flags&RowMajorBit))$/;"	e	enum:Eigen::SparseTriangularView::__anon29
Eigen::SparseTriangularView::SkipLast	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^           SkipLast = !SkipFirst,$/;"	e	enum:Eigen::SparseTriangularView::__anon29
Eigen::SparseTriangularView::solve	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    solve(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseTriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::SparseTriangularView::solve	../include/Eigen/src/SparseCore/TriangularSolver.h	/^SparseTriangularView<ExpressionType,Mode>::solve(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::SparseTriangularView::solveInPlace	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    template<typename OtherDerived> void solveInPlace(MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseTriangularView	access:public	signature:(MatrixBase<OtherDerived>& other) const
Eigen::SparseTriangularView::solveInPlace	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    template<typename OtherDerived> void solveInPlace(SparseMatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseTriangularView	access:public	signature:(SparseMatrixBase<OtherDerived>& other) const
Eigen::SparseTriangularView::solveInPlace	../include/Eigen/src/SparseCore/TriangularSolver.h	/^void SparseTriangularView<ExpressionType,Mode>::solveInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView	signature:(MatrixBase<OtherDerived>& other) const
Eigen::SparseTriangularView::solveInPlace	../include/Eigen/src/SparseCore/TriangularSolver.h	/^void SparseTriangularView<ExpressionType,Mode>::solveInPlace(SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView	signature:(SparseMatrixBase<OtherDerived>& other) const
Eigen::SparseTriangularView::SparseTriangularView	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline SparseTriangularView(const MatrixType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:(const MatrixType& matrix)
EIGEN_SPARSEUTIL_H	../include/Eigen/src/SparseCore/SparseUtil.h	26;"	d
Eigen::SparseVector::assign	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DONT_INLINE SparseVector& assign(const SparseMatrixBase<OtherDerived>& _other)$/;"	f	class:Eigen::SparseVector	access:protected	signature:(const SparseMatrixBase<OtherDerived>& _other)
Eigen::SparseVector::coeff	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index i) const { return m_data.at(i); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i) const
Eigen::SparseVector::coeff	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index row, Index col) const
Eigen::SparseVector::coeffRef	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
Eigen::SparseVector::coeffRef	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index row, Index col)
Eigen::SparseVector::cols	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsColVector ? 1 : m_size; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::_data	../include/Eigen/src/SparseCore/SparseVector.h	/^    internal::CompressedStorage<Scalar,Index>& _data() const { return m_data; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::_data	../include/Eigen/src/SparseCore/SparseVector.h	/^    internal::CompressedStorage<Scalar,Index>& _data() { return m_data; }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::endFill	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void endFill() {}$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::fill	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
Eigen::SparseVector::fill	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index r, Index c)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index r, Index c)
Eigen::SparseVector::fillrand	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
Eigen::SparseVector::fillrand	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index r, Index c)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index r, Index c)
Eigen::SparseVector::finalize	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline void finalize() {}$/;"	f	class:Eigen::SparseVector	access:public	signature:()
EIGEN_SPARSEVECTOR_H	../include/Eigen/src/SparseCore/SparseVector.h	26;"	d
Eigen::SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^class SparseVector$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::SparseVector::innerIndexPtr	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Index* innerIndexPtr() const { return &m_data.index(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::innerIndexPtr	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index* innerIndexPtr() { return &m_data.index(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::InnerIterator::col	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index col() const { return IsColVector ? 0 : index(); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
Eigen::SparseVector::InnerIterator	../include/Eigen/src/SparseCore/SparseVector.h	/^class SparseVector<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::SparseVector
Eigen::SparseVector::InnerIterator::index	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index index() const { return m_data.index(m_id); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
Eigen::SparseVector::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/SparseVector.h	/^    InnerIterator(const internal::CompressedStorage<Scalar,Index>& data)$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:(const internal::CompressedStorage<Scalar,Index>& data)
Eigen::SparseVector::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/SparseVector.h	/^    InnerIterator(const SparseVector& vec, Index outer=0)$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:(const SparseVector& vec, Index outer=0)
Eigen::SparseVector::InnerIterator::m_data	../include/Eigen/src/SparseCore/SparseVector.h	/^    const internal::CompressedStorage<Scalar,Index>& m_data;$/;"	m	class:Eigen::SparseVector::InnerIterator	access:protected
Eigen::SparseVector::InnerIterator::m_end	../include/Eigen/src/SparseCore/SparseVector.h	/^    const Index m_end;$/;"	m	class:Eigen::SparseVector::InnerIterator	access:protected
Eigen::SparseVector::InnerIterator::m_id	../include/Eigen/src/SparseCore/SparseVector.h	/^    Index m_id;$/;"	m	class:Eigen::SparseVector::InnerIterator	access:protected
Eigen::SparseVector::InnerIterator::operator bool	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
Eigen::SparseVector::InnerIterator::operator ++	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:()
Eigen::SparseVector::InnerIterator::row	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index row() const { return IsColVector ? index() : 0; }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
Eigen::SparseVector::InnerIterator::value	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar value() const { return m_data.value(m_id); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
Eigen::SparseVector::InnerIterator::valueRef	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_data.value(m_id)); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:()
Eigen::SparseVector::innerSize	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index innerSize() const { return m_size; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::insertBackByOuterInner	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index outer, Index inner)
Eigen::SparseVector::insertBack	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBack(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
Eigen::SparseVector::insert	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index row, Index col)
Eigen::SparseVector::insert	../include/Eigen/src/SparseCore/SparseVector.h	/^    Scalar& insert(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
Eigen::SparseVector::IsColVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    enum { IsColVector = internal::traits<SparseVector>::IsColVector };$/;"	e	enum:Eigen::SparseVector::__anon26
Eigen::SparseVector::m_data	../include/Eigen/src/SparseCore/SparseVector.h	/^    internal::CompressedStorage<Scalar,Index> m_data;$/;"	m	class:Eigen::SparseVector	access:public
Eigen::SparseVector::m_size	../include/Eigen/src/SparseCore/SparseVector.h	/^    Index m_size;$/;"	m	class:Eigen::SparseVector	access:public
Eigen::SparseVector::nonZeros	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index nonZeros() const  { return static_cast<Index>(m_data.size()); }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::operator <<	../include/Eigen/src/SparseCore/SparseVector.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseVector& m)$/;"	f	class:Eigen::SparseVector	access:friend	signature:(std::ostream & s, const SparseVector& m)
Eigen::SparseVector::operator =	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseVector::operator =	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
Eigen::SparseVector::operator =	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseVector& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseVector& other)
Eigen::SparseVector::Options	../include/Eigen/src/SparseCore/SparseVector.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseVector::__anon27
Eigen::SparseVector::outerSize	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index outerSize() const { return 1; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::prune	../include/Eigen/src/SparseCore/SparseVector.h	/^    void prune(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseVector	access:public	signature:(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())
Eigen::SparseVector::reserve	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline void reserve(Index reserveSize) { m_data.reserve(reserveSize); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index reserveSize)
Eigen::SparseVector::resize	../include/Eigen/src/SparseCore/SparseVector.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index newSize)
Eigen::SparseVector::resize	../include/Eigen/src/SparseCore/SparseVector.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index rows, Index cols)
Eigen::SparseVector::resizeNonZeros	../include/Eigen/src/SparseCore/SparseVector.h	/^    void resizeNonZeros(Index size) { m_data.resize(size); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index size)
Eigen::SparseVector::ReverseInnerIterator::col	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index col() const { return IsColVector ? 0 : index(); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseVector::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseVector.h	/^class SparseVector<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::SparseVector
Eigen::SparseVector::ReverseInnerIterator::index	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index index() const { return m_data.index(m_id-1); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseVector::ReverseInnerIterator::m_data	../include/Eigen/src/SparseCore/SparseVector.h	/^    const internal::CompressedStorage<Scalar,Index>& m_data;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator	access:protected
Eigen::SparseVector::ReverseInnerIterator::m_id	../include/Eigen/src/SparseCore/SparseVector.h	/^    Index m_id;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator	access:protected
Eigen::SparseVector::ReverseInnerIterator::m_start	../include/Eigen/src/SparseCore/SparseVector.h	/^    const Index m_start;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator	access:protected
Eigen::SparseVector::ReverseInnerIterator::operator bool	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseVector::ReverseInnerIterator::operator --	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline ReverseInnerIterator& operator--() { m_id--; return *this; }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:()
Eigen::SparseVector::ReverseInnerIterator::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseVector.h	/^    ReverseInnerIterator(const internal::CompressedStorage<Scalar,Index>& data)$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:(const internal::CompressedStorage<Scalar,Index>& data)
Eigen::SparseVector::ReverseInnerIterator::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseVector.h	/^    ReverseInnerIterator(const SparseVector& vec, Index outer=0)$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:(const SparseVector& vec, Index outer=0)
Eigen::SparseVector::ReverseInnerIterator::row	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index row() const { return IsColVector ? index() : 0; }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseVector::ReverseInnerIterator::value	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar value() const { return m_data.value(m_id-1); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
Eigen::SparseVector::ReverseInnerIterator::valueRef	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_data.value(m_id-1)); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:()
Eigen::SparseVector::rows	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsColVector ? m_size : 1; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::setZero	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline void setZero() { m_data.clear(); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::SparseBase	../include/Eigen/src/SparseCore/SparseVector.h	/^    typedef SparseMatrixBase<SparseVector> SparseBase;$/;"	t	class:Eigen::SparseVector	access:public
Eigen::SparseVector::SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
Eigen::SparseVector::SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseVector& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseVector& other)
Eigen::SparseVector::~SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline ~SparseVector() {}$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(Index rows, Index cols) : m_size(0) { resize(rows,cols); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index rows, Index cols)
Eigen::SparseVector::SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(Index size) : m_size(0) { resize(size); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index size)
Eigen::SparseVector::SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector() : m_size(0) { resize(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseVector::startFill	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void startFill(Index reserve)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index reserve)
Eigen::SparseVector::startVec	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index outer)
Eigen::SparseVector::sum	../include/Eigen/src/SparseCore/SparseRedux.h	/^SparseVector<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseVector	signature:() const
Eigen::SparseVector::sum	../include/Eigen/src/SparseCore/SparseVector.h	/^    Scalar sum() const;$/;"	p	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::swap	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline void swap(SparseVector& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(SparseVector& other)
Eigen::SparseVector::valuePtr	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Scalar* valuePtr() const { return &m_data.value(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
Eigen::SparseVector::valuePtr	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Scalar* valuePtr() { return &m_data.value(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
Eigen::SparseView::cols	../include/Eigen/src/SparseCore/SparseView.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
EIGEN_SPARSEVIEW_H	../include/Eigen/src/SparseCore/SparseView.h	27;"	d
Eigen::SparseView	../include/Eigen/src/SparseCore/SparseView.h	/^class SparseView : public SparseMatrixBase<SparseView<MatrixType> >$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::SparseView::InnerIterator	../include/Eigen/src/SparseCore/SparseView.h	/^class SparseView<MatrixType>::InnerIterator : public _MatrixTypeNested::InnerIterator$/;"	c	class:Eigen::SparseView	inherits:_MatrixTypeNested::InnerIterator
Eigen::SparseView::InnerIterator::incrementToNonZero	../include/Eigen/src/SparseCore/SparseView.h	/^  void incrementToNonZero()$/;"	f	class:Eigen::SparseView::InnerIterator	access:private	signature:()
Eigen::SparseView::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/SparseView.h	/^  InnerIterator(const SparseView& view, Index outer) :$/;"	f	class:Eigen::SparseView::InnerIterator	access:public	signature:(const SparseView& view, Index outer)
Eigen::SparseView::InnerIterator::IterBase	../include/Eigen/src/SparseCore/SparseView.h	/^  typedef typename _MatrixTypeNested::InnerIterator IterBase;$/;"	t	class:Eigen::SparseView::InnerIterator	access:public
Eigen::SparseView::InnerIterator::m_view	../include/Eigen/src/SparseCore/SparseView.h	/^  const SparseView& m_view;$/;"	m	class:Eigen::SparseView::InnerIterator	access:protected
Eigen::SparseView::InnerIterator::operator ++	../include/Eigen/src/SparseCore/SparseView.h	/^  EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::SparseView::InnerIterator	access:public	signature:()
Eigen::SparseView::innerSize	../include/Eigen/src/SparseCore/SparseView.h	/^  inline Index innerSize() const { return m_matrix.innerSize(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
Eigen::SparseView::_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseView.h	/^  typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseView	access:private
Eigen::SparseView::MatrixTypeNested	../include/Eigen/src/SparseCore/SparseView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseView	access:private
Eigen::SparseView::m_epsilon	../include/Eigen/src/SparseCore/SparseView.h	/^  typename NumTraits<Scalar>::Real m_epsilon;$/;"	m	class:Eigen::SparseView	access:protected
Eigen::SparseView::m_matrix	../include/Eigen/src/SparseCore/SparseView.h	/^  MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseView	access:protected
Eigen::SparseView::m_reference	../include/Eigen/src/SparseCore/SparseView.h	/^  Scalar m_reference;$/;"	m	class:Eigen::SparseView	access:protected
Eigen::SparseView::outerSize	../include/Eigen/src/SparseCore/SparseView.h	/^  inline Index outerSize() const { return m_matrix.outerSize(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
Eigen::SparseView::rows	../include/Eigen/src/SparseCore/SparseView.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
Eigen::SparseView::SparseView	../include/Eigen/src/SparseCore/SparseView.h	/^  SparseView(const MatrixType& mat, const Scalar& m_reference = Scalar(0),$/;"	f	class:Eigen::SparseView	access:public	signature:(const MatrixType& mat, const Scalar& m_reference = Scalar(0), typename NumTraits<Scalar>::Real m_epsilon = NumTraits<Scalar>::dummy_precision())
Eigen::Specialized	../include/Eigen/src/Core/util/Constants.h	/^  Specialized,$/;"	e	enum:Eigen::__anon211
EIGEN_STABLENORM_H	../include/Eigen/src/Core/StableNorm.h	26;"	d
EIGEN_STACK_ALLOCATION_LIMIT	../include/Eigen/src/Core/util/Macros.h	300;"	d
EIGEN_STATIC_ASSERT_ARRAYXPR	../include/Eigen/src/Core/util/StaticAssert.h	209;"	d
EIGEN_STATIC_ASSERT_DYNAMIC_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	150;"	d
EIGEN_STATIC_ASSERT_FIXED_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	145;"	d
EIGEN_STATIC_ASSERT_H	../include/Eigen/src/Core/util/StaticAssert.h	27;"	d
EIGEN_STATIC_ASSERT	../include/Eigen/src/Core/util/StaticAssert.h	120;"	d
EIGEN_STATIC_ASSERT	../include/Eigen/src/Core/util/StaticAssert.h	47;"	d
EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS	../include/Eigen/src/Core/MapBase.h	29;"	d
EIGEN_STATIC_ASSERT_LVALUE	../include/Eigen/src/Core/util/StaticAssert.h	205;"	d
EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	160;"	d
EIGEN_STATIC_ASSERT_NON_INTEGER	../include/Eigen/src/Core/util/StaticAssert.h	186;"	d
EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	195;"	d
EIGEN_STATIC_ASSERT_SAME_VECTOR_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	165;"	d
EIGEN_STATIC_ASSERT_SAME_XPR_KIND	../include/Eigen/src/Core/util/StaticAssert.h	213;"	d
EIGEN_STATIC_ASSERT_SIZE_1x1	../include/Eigen/src/Core/util/StaticAssert.h	200;"	d
EIGEN_STATIC_ASSERT_VECTOR_ONLY	../include/Eigen/src/Core/util/StaticAssert.h	140;"	d
EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	155;"	d
EIGEN_STDDEQUE_H	../include/Eigen/src/StlSupport/StdDeque.h	27;"	d
EIGEN_STD_DEQUE_SPECIALIZATION_BODY	../include/Eigen/src/StlSupport/StdDeque.h	75;"	d
EIGEN_STDLIST_H	../include/Eigen/src/StlSupport/StdList.h	26;"	d
EIGEN_STD_LIST_SPECIALIZATION_BODY	../include/Eigen/src/StlSupport/StdList.h	75;"	d
EIGEN_STDVECTOR_H	../include/Eigen/src/StlSupport/StdVector.h	27;"	d
EIGEN_STD_VECTOR_SPECIALIZATION_BODY	../include/Eigen/src/StlSupport/StdVector.h	64;"	d
EIGEN_STL_DETAILS_H	../include/Eigen/src/StlSupport/details.h	27;"	d
Eigen::StreamPrecision	../include/Eigen/src/Core/IO.h	/^enum { StreamPrecision = -1,$/;"	e	enum:Eigen::__anon55
Eigen::StrictlyLower	../include/Eigen/src/Core/util/Constants.h	/^  StrictlyLower=ZeroDiag|Lower, $/;"	e	enum:Eigen::__anon207
Eigen::StrictlyUpper	../include/Eigen/src/Core/util/Constants.h	/^  StrictlyUpper=ZeroDiag|Upper,$/;"	e	enum:Eigen::__anon207
EIGEN_STRIDE_H	../include/Eigen/src/Core/Stride.h	26;"	d
Eigen::Stride	../include/Eigen/src/Core/Stride.h	/^class Stride$/;"	c	namespace:Eigen
Eigen::Stride::Index	../include/Eigen/src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::Stride	access:public
Eigen::Stride::inner	../include/Eigen/src/Core/Stride.h	/^    inline Index inner() const { return m_inner.value(); }$/;"	f	class:Eigen::Stride	access:public	signature:() const
Eigen::Stride::InnerStrideAtCompileTime	../include/Eigen/src/Core/Stride.h	/^      InnerStrideAtCompileTime = _InnerStrideAtCompileTime,$/;"	e	enum:Eigen::Stride::__anon57
Eigen::Stride::m_inner	../include/Eigen/src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, InnerStrideAtCompileTime> m_inner;$/;"	m	class:Eigen::Stride	access:protected
Eigen::Stride::m_outer	../include/Eigen/src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, OuterStrideAtCompileTime> m_outer;$/;"	m	class:Eigen::Stride	access:protected
Eigen::Stride::outer	../include/Eigen/src/Core/Stride.h	/^    inline Index outer() const { return m_outer.value(); }$/;"	f	class:Eigen::Stride	access:public	signature:() const
Eigen::Stride::OuterStrideAtCompileTime	../include/Eigen/src/Core/Stride.h	/^      OuterStrideAtCompileTime = _OuterStrideAtCompileTime$/;"	e	enum:Eigen::Stride::__anon57
Eigen::Stride::Stride	../include/Eigen/src/Core/Stride.h	/^    Stride(const Stride& other)$/;"	f	class:Eigen::Stride	access:public	signature:(const Stride& other)
Eigen::Stride::Stride	../include/Eigen/src/Core/Stride.h	/^    Stride()$/;"	f	class:Eigen::Stride	access:public	signature:()
Eigen::Stride::Stride	../include/Eigen/src/Core/Stride.h	/^    Stride(Index outerStride, Index innerStride)$/;"	f	class:Eigen::Stride	access:public	signature:(Index outerStride, Index innerStride)
EIGEN_STRONG_INLINE	../include/Eigen/src/Core/util/Macros.h	143;"	d
EIGEN_STRONG_INLINE	../include/Eigen/src/Core/util/Macros.h	145;"	d
Eigen::Success	../include/Eigen/src/Core/util/Constants.h	/^  Success = 0,        $/;"	e	enum:Eigen::ComputationInfo
Eigen::SuperILU::analyzePattern	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperILU	access:public	signature:(const MatrixType& matrix)
Eigen::SuperILU::Base	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperILU> Base;$/;"	t	class:Eigen::SuperILU	access:public
Eigen::SuperILU::factorize	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void factorize(const MatrixType& matrix);$/;"	p	class:Eigen::SuperILU	access:public	signature:(const MatrixType& matrix)
Eigen::SuperILU::factorize	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperILU	signature:(const MatrixType& a)
Eigen::SuperILU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperILU : public SuperLUBase<_MatrixType,SuperILU<_MatrixType> >$/;"	c	namespace:Eigen	inherits:SuperLUBase
Eigen::SuperILU::Index	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::SuperILU	access:public
Eigen::SuperILU::init	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperILU	access:protected	signature:()
Eigen::SuperILU::MatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperILU	access:public
Eigen::SuperILU::RealScalar	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperILU	access:public
Eigen::SuperILU::Scalar	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperILU	access:public
Eigen::SuperILU::_solve	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const;$/;"	p	class:Eigen::SuperILU	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
Eigen::SuperILU::_solve	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::_solve(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperILU	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const
Eigen::SuperILU::SuperILU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU() : Base() { init(); }$/;"	f	class:Eigen::SuperILU	access:public	signature:()
Eigen::SuperILU::SuperILU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperILU	access:public	signature:(const MatrixType& matrix)
Eigen::SuperILU::~SuperILU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperILU()$/;"	f	class:Eigen::SuperILU	access:public	signature:()
Eigen::SuperILU::SuperILU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(SuperILU& ) { }$/;"	f	class:Eigen::SuperILU	access:private	signature:(SuperILU& )
Eigen::SuperLU::analyzePattern	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLU	access:public	signature:(const MatrixType& matrix)
Eigen::SuperLUBase::analyzePattern	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& \/*matrix*\/)$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const MatrixType& )
Eigen::SuperLUBase::clearFactors	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void clearFactors()$/;"	f	class:Eigen::SuperLUBase	access:protected	signature:()
Eigen::SuperLUBase::cols	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
Eigen::SuperLUBase::compute	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const MatrixType& matrix)
Eigen::SuperLUBase::derived	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
Eigen::SuperLUBase::derived	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
Eigen::SuperLUBase::dumpMemory	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(Stream& s)
Eigen::SuperLUBase::extractData	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void extractData() const;$/;"	p	class:Eigen::SuperLUBase	access:protected	signature:() const
Eigen::SuperLUBase::extractData	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLUBase<MatrixType,Derived>::extractData() const$/;"	f	class:Eigen::SuperLUBase	signature:() const
Eigen::SuperLUBase	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperLUBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::SuperLU::Base	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperLU> Base;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLUBase::Index	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::info	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
Eigen::SuperLUBase::initFactorization	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void initFactorization(const MatrixType& a)$/;"	f	class:Eigen::SuperLUBase	access:protected	signature:(const MatrixType& a)
Eigen::SuperLUBase::init	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLUBase	access:protected	signature:()
Eigen::SuperLUBase::IntColVectorType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;    $/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::IntRowVectorType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::LUMatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::m_analysisIsOk	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::MatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::m_extractedDataAreDirty	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_factorizationIsOk	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_info	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_isInitialized	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_l	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_matrix	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_matrix;  \/\/ copy of the factorized matrix$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_p	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_q	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluA	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluA;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluBerr	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluB	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluCscale	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluEqued	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable char m_sluEqued;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluEtree	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable std::vector<int> m_sluEtree;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluFerr	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluL	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluOptions	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable superlu_options_t m_sluOptions;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluRscale	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluStat	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperLUStat_t m_sluStat;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_sluX	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::m_u	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::SuperLUBase	access:protected
Eigen::SuperLUBase::options	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline superlu_options_t& options() { return m_sluOptions; }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
Eigen::SuperLUBase::RealScalar	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::rows	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
Eigen::SuperLUBase::Scalar	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLUBase::solve	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const internal::solve_retval<SuperLUBase, Rhs> solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::SuperLUBase::~SuperLUBase	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLUBase()$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
Eigen::SuperLUBase::SuperLUBase	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase() {}$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
Eigen::SuperLUBase::SuperLUBase	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase(SuperLUBase& ) { }$/;"	f	class:Eigen::SuperLUBase	access:private	signature:(SuperLUBase& )
Eigen::SuperLUBase::Vector	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::SuperLUBase	access:public
Eigen::SuperLU::determinant	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    Scalar determinant() const;$/;"	p	class:Eigen::SuperLU	access:public	signature:() const
Eigen::SuperLU::determinant	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^typename SuperLU<MatrixType>::Scalar SuperLU<MatrixType>::determinant() const$/;"	f	class:Eigen::SuperLU	signature:() const
Eigen::SuperLU::factorize	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void factorize(const MatrixType& matrix);$/;"	p	class:Eigen::SuperLU	access:public	signature:(const MatrixType& matrix)
Eigen::SuperLU::factorize	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperLU	signature:(const MatrixType& a)
EIGEN_SUPERLU_HAS_ILU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	60;"	d
EIGEN_SUPERLU_HAS_ILU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	815;"	d
Eigen::SuperLU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperLU : public SuperLUBase<_MatrixType,SuperLU<_MatrixType> >$/;"	c	namespace:Eigen	inherits:SuperLUBase
Eigen::SuperLU::Index	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::init	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLU	access:protected	signature:()
Eigen::SuperLU::IntColVectorType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntColVectorType IntColVectorType;    $/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::IntRowVectorType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntRowVectorType IntRowVectorType;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::LMatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType, Lower|UnitDiag>  LMatrixType;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::LUMatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::LUMatrixType LUMatrixType;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::matrixL	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const LMatrixType& matrixL() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
Eigen::SuperLU::MatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::matrixU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const UMatrixType& matrixU() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
Eigen::SuperLU::permutationP	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
Eigen::SuperLU::permutationQ	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
Eigen::SuperLU::RealScalar	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::Scalar	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SuperLU::_solve	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const;$/;"	p	class:Eigen::SuperLU	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
Eigen::SuperLU::_solve	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::_solve(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperLU	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const
Eigen::SuperLU::SuperLU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU() : Base() { init(); }$/;"	f	class:Eigen::SuperLU	access:public	signature:()
Eigen::SuperLU::SuperLU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperLU	access:public	signature:(const MatrixType& matrix)
Eigen::SuperLU::~SuperLU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLU()$/;"	f	class:Eigen::SuperLU	access:public	signature:()
Eigen::SuperLU::SuperLU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(SuperLU& ) { }$/;"	f	class:Eigen::SuperLU	access:private	signature:(SuperLU& )
EIGEN_SUPERLUSUPPORT_H	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	26;"	d
Eigen::SuperLU::UMatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType,  Upper>           UMatrixType;$/;"	t	class:Eigen::SuperLU	access:public
Eigen::SVD::AlignmentMask	../include/Eigen/src/Eigen2Support/SVD.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::SVD::__anon440
Eigen::SVD::ColVector	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1> ColVector;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::compute	../include/Eigen/src/Eigen2Support/SVD.h	/^    void compute(const MatrixType& matrix);$/;"	p	class:Eigen::SVD	access:public	signature:(const MatrixType& matrix)
Eigen::SVD::compute	../include/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::SVD	signature:(const MatrixType& matrix)
Eigen::SVD::computePositiveUnitary	../include/Eigen/src/Eigen2Support/SVD.h	/^    void computePositiveUnitary(PositiveType *positive, UnitaryType *unitary) const;$/;"	p	class:Eigen::SVD	access:public	signature:(PositiveType *positive, UnitaryType *unitary) const
Eigen::SVD::computePositiveUnitary	../include/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computePositiveUnitary(UnitaryType *positive,$/;"	f	class:Eigen::SVD	signature:(UnitaryType *positive, PositiveType *unitary) const
Eigen::SVD::computeRotationScaling	../include/Eigen/src/Eigen2Support/SVD.h	/^    void computeRotationScaling(RotationType *unitary, ScalingType *positive) const;$/;"	p	class:Eigen::SVD	access:public	signature:(RotationType *unitary, ScalingType *positive) const
Eigen::SVD::computeRotationScaling	../include/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeRotationScaling(RotationType *rotation, ScalingType *scaling) const$/;"	f	class:Eigen::SVD	signature:(RotationType *rotation, ScalingType *scaling) const
Eigen::SVD::computeScalingRotation	../include/Eigen/src/Eigen2Support/SVD.h	/^    void computeScalingRotation(ScalingType *positive, RotationType *unitary) const;$/;"	p	class:Eigen::SVD	access:public	signature:(ScalingType *positive, RotationType *unitary) const
Eigen::SVD::computeScalingRotation	../include/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeScalingRotation(ScalingType *scaling, RotationType *rotation) const$/;"	f	class:Eigen::SVD	signature:(ScalingType *scaling, RotationType *rotation) const
Eigen::SVD::computeUnitaryPositive	../include/Eigen/src/Eigen2Support/SVD.h	/^    void computeUnitaryPositive(UnitaryType *unitary, PositiveType *positive) const;$/;"	p	class:Eigen::SVD	access:public	signature:(UnitaryType *unitary, PositiveType *positive) const
Eigen::SVD::computeUnitaryPositive	../include/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeUnitaryPositive(UnitaryType *unitary,$/;"	f	class:Eigen::SVD	signature:(UnitaryType *unitary, PositiveType *positive) const
Eigen::SVD	../include/Eigen/src/Eigen2Support/SVD.h	/^template<typename MatrixType> class SVD$/;"	c	namespace:Eigen
Eigen::SVD::matrixU	../include/Eigen/src/Eigen2Support/SVD.h	/^    const MatrixUType& matrixU() const { return m_matU; }$/;"	f	class:Eigen::SVD	access:public	signature:() const
Eigen::SVD::MatrixUType	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, MinSize> MatrixUType;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::matrixV	../include/Eigen/src/Eigen2Support/SVD.h	/^    const MatrixVType& matrixV() const { return m_matV; }$/;"	f	class:Eigen::SVD	access:public	signature:() const
Eigen::SVD::MatrixVType	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::ColsAtCompileTime, MatrixType::ColsAtCompileTime> MatrixVType;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::MinSize	../include/Eigen/src/Eigen2Support/SVD.h	/^      MinSize = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, MatrixType::ColsAtCompileTime)$/;"	e	enum:Eigen::SVD::__anon440
Eigen::SVD::m_matU	../include/Eigen/src/Eigen2Support/SVD.h	/^    MatrixUType m_matU;$/;"	m	class:Eigen::SVD	access:protected
Eigen::SVD::m_matV	../include/Eigen/src/Eigen2Support/SVD.h	/^    MatrixVType m_matV;$/;"	m	class:Eigen::SVD	access:protected
Eigen::SVD::m_sigma	../include/Eigen/src/Eigen2Support/SVD.h	/^    SingularValuesType m_sigma;$/;"	m	class:Eigen::SVD	access:protected
Eigen::SVD::PacketSize	../include/Eigen/src/Eigen2Support/SVD.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::SVD::__anon440
Eigen::SVD::RealScalar	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::RowVector	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::ColsAtCompileTime, 1> RowVector;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::Scalar	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::singularValues	../include/Eigen/src/Eigen2Support/SVD.h	/^    const SingularValuesType& singularValues() const { return m_sigma; }$/;"	f	class:Eigen::SVD	access:public	signature:() const
Eigen::SVD::SingularValuesType	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MinSize, 1> SingularValuesType;$/;"	t	class:Eigen::SVD	access:private
Eigen::SVD::solve	../include/Eigen/src/Eigen2Support/SVD.h	/^    bool solve(const MatrixBase<OtherDerived> &b, ResultType* result) const;$/;"	p	class:Eigen::SVD	access:public	signature:(const MatrixBase<OtherDerived> &b, ResultType* result) const
Eigen::SVD::solve	../include/Eigen/src/Eigen2Support/SVD.h	/^bool SVD<MatrixType>::solve(const MatrixBase<OtherDerived> &b, ResultType* result) const$/;"	f	class:Eigen::SVD	signature:(const MatrixBase<OtherDerived> &b, ResultType* result) const
Eigen::SVD::sort	../include/Eigen/src/Eigen2Support/SVD.h	/^SVD<MatrixType>& SVD<MatrixType>::sort()$/;"	f	class:Eigen::SVD	signature:()
Eigen::SVD::sort	../include/Eigen/src/Eigen2Support/SVD.h	/^    SVD& sort();$/;"	p	class:Eigen::SVD	access:public	signature:()
Eigen::SVD::SVD	../include/Eigen/src/Eigen2Support/SVD.h	/^    SVD() {} \/\/ a user who relied on compiler-generated default compiler reported problems with MSVC in 2.0.7$/;"	f	class:Eigen::SVD	access:public	signature:()
Eigen::SVD::SVD	../include/Eigen/src/Eigen2Support/SVD.h	/^    SVD(const MatrixType& matrix)$/;"	f	class:Eigen::SVD	access:public	signature:(const MatrixType& matrix)
EIGEN_SWAP_H	../include/Eigen/src/Core/Swap.h	26;"	d
Eigen::SwapWrapper::Base	../include/Eigen/src/Core/Swap.h	/^    typedef typename internal::dense_xpr_base<SwapWrapper>::type Base;$/;"	t	class:Eigen::SwapWrapper	access:public
Eigen::SwapWrapper::coeffRef	../include/Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index) const
Eigen::SwapWrapper::coeffRef	../include/Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index)
Eigen::SwapWrapper::coeffRef	../include/Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index row, Index col) const
Eigen::SwapWrapper::coeffRef	../include/Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index row, Index col)
Eigen::SwapWrapper::cols	../include/Eigen/src/Core/Swap.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
Eigen::SwapWrapper::copyCoeff	../include/Eigen/src/Core/Swap.h	/^    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
Eigen::SwapWrapper::copyCoeff	../include/Eigen/src/Core/Swap.h	/^    void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
Eigen::SwapWrapper::copyPacket	../include/Eigen/src/Core/Swap.h	/^    void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index index, const DenseBase<OtherDerived>& other)
Eigen::SwapWrapper::copyPacket	../include/Eigen/src/Core/Swap.h	/^    void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(Index row, Index col, const DenseBase<OtherDerived>& other)
Eigen::SwapWrapper::data	../include/Eigen/src/Core/Swap.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
Eigen::SwapWrapper::data	../include/Eigen/src/Core/Swap.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:()
Eigen::SwapWrapper::expression	../include/Eigen/src/Core/Swap.h	/^    ExpressionType& expression() const { return m_expression; }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
Eigen::SwapWrapper	../include/Eigen/src/Core/Swap.h	/^template<typename ExpressionType> class SwapWrapper$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Eigen::SwapWrapper::innerStride	../include/Eigen/src/Core/Swap.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
Eigen::SwapWrapper::m_expression	../include/Eigen/src/Core/Swap.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::SwapWrapper	access:protected
Eigen::SwapWrapper::outerStride	../include/Eigen/src/Core/Swap.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
Eigen::SwapWrapper::Packet	../include/Eigen/src/Core/Swap.h	/^    typedef typename internal::packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::SwapWrapper	access:public
Eigen::SwapWrapper::rows	../include/Eigen/src/Core/Swap.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
Eigen::SwapWrapper::ScalarWithConstIfNotLvalue	../include/Eigen/src/Core/Swap.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::SwapWrapper	access:public
Eigen::SwapWrapper::SwapWrapper	../include/Eigen/src/Core/Swap.h	/^    inline SwapWrapper(ExpressionType& xpr) : m_expression(xpr) {}$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(ExpressionType& xpr)
Eigen::Symmetric	../include/Eigen/src/Core/util/Constants.h	/^  Symmetric=0x20$/;"	e	enum:Eigen::__anon207
Eigen::TopLeft	../include/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
Eigen::TopRight	../include/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
Eigen::Transform2d	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<double,2> Transform2d;$/;"	t	namespace:Eigen
Eigen::Transform2f	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<float,2> Transform2f;$/;"	t	namespace:Eigen
Eigen::Transform3d	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<double,3> Transform3d;$/;"	t	namespace:Eigen
Eigen::Transform3f	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<float,3> Transform3f;$/;"	t	namespace:Eigen
Eigen::Transform::affine	../include/Eigen/src/Geometry/Transform.h	/^  inline AffinePart affine() { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::affine	../include/Eigen/src/Geometry/Transform.h	/^  inline ConstAffinePart affine() const { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::AffinePart	../include/Eigen/src/Geometry/Transform.h	/^                              Block<MatrixType,Dim,HDim> >::type AffinePart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::cast	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::cast	../include/Eigen/src/Geometry/Transform.h	/^  inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim,Mode,Options> >::type cast() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::check_template_params	../include/Eigen/src/Geometry/Transform.h	/^    static EIGEN_STRONG_INLINE void check_template_params()$/;"	f	class:Eigen::Transform	access:protected	signature:()
Eigen::Transform::computeRotationScaling	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  void computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const;$/;"	p	class:Eigen::Transform	access:public	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
Eigen::Transform::computeRotationScaling	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^void Transform<Scalar,Dim>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
Eigen::Transform::computeRotationScaling	../include/Eigen/src/Geometry/Transform.h	/^  void computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const;$/;"	p	class:Eigen::Transform	access:public	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
Eigen::Transform::computeRotationScaling	../include/Eigen/src/Geometry/Transform.h	/^void Transform<Scalar,Dim,Mode,Options>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform	signature:(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
Eigen::Transform::computeScalingRotation	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  void computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const;$/;"	p	class:Eigen::Transform	access:public	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
Eigen::Transform::computeScalingRotation	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^void Transform<Scalar,Dim>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
Eigen::Transform::computeScalingRotation	../include/Eigen/src/Geometry/Transform.h	/^  void computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const;$/;"	p	class:Eigen::Transform	access:public	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
Eigen::Transform::computeScalingRotation	../include/Eigen/src/Geometry/Transform.h	/^void Transform<Scalar,Dim,Mode,Options>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform	signature:(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
Eigen::Transform::ConstAffinePart	../include/Eigen/src/Geometry/Transform.h	/^                              const Block<const MatrixType,Dim,HDim> >::type ConstAffinePart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::ConstLinearPart	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef const Block<const MatrixType,Dim,Dim> ConstLinearPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::ConstLinearPart	../include/Eigen/src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,Dim,int(Mode)==(AffineCompact)> ConstLinearPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::ConstMatrixType	../include/Eigen/src/Geometry/Transform.h	/^  typedef const MatrixType ConstMatrixType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::construct_from_matrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  struct construct_from_matrix$/;"	s	class:Eigen::Transform	access:public
Eigen::Transform::construct_from_matrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  template<typename OtherDerived> struct construct_from_matrix<OtherDerived, true>$/;"	s	class:Eigen::Transform	access:public
Eigen::Transform::construct_from_matrix::run	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^    static inline void run(Transform *transform, const MatrixBase<OtherDerived>& other)$/;"	f	struct:Eigen::Transform::construct_from_matrix	access:public	signature:(Transform *transform, const MatrixBase<OtherDerived>& other)
Eigen::Transform::ConstTranslationPart	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef const Block<const MatrixType,Dim,1> ConstTranslationPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::ConstTranslationPart	../include/Eigen/src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,1,int(Mode)==(AffineCompact)> ConstTranslationPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::data	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::data	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::data	../include/Eigen/src/Geometry/Transform.h	/^  const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::data	../include/Eigen/src/Geometry/Transform.h	/^  Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::Dim	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon434
Eigen::Transform::Dim	../include/Eigen/src/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon374
Eigen::Transform::fromPositionOrientationScale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  Transform& fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
Eigen::Transform::fromPositionOrientationScale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
Eigen::Transform::fromPositionOrientationScale	../include/Eigen/src/Geometry/Transform.h	/^  Transform& fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
Eigen::Transform::fromPositionOrientationScale	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
Eigen::Transform::HDim	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^    HDim = _Dim+1   \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon434
Eigen::Transform::HDim	../include/Eigen/src/Geometry/Transform.h	/^    HDim = _Dim+1,  \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon374
EIGEN_TRANSFORM_H	../include/Eigen/src/Geometry/Transform.h	28;"	d
Eigen::Transform::icc_11_workaround	../include/Eigen/src/Geometry/Transform.h	/^  template<int OtherMode,int OtherOptions> struct icc_11_workaround$/;"	s	class:Eigen::Transform	access:private
Eigen::Transform::icc_11_workaround::ProductType	../include/Eigen/src/Geometry/Transform.h	/^    typedef internal::transform_transform_product_impl<Transform,Transform<Scalar,Dim,OtherMode,OtherOptions> > ProductType;$/;"	t	struct:Eigen::Transform::icc_11_workaround	access:public
Eigen::Transform::icc_11_workaround::ResultType	../include/Eigen/src/Geometry/Transform.h	/^    typedef typename ProductType::ResultType ResultType;$/;"	t	struct:Eigen::Transform::icc_11_workaround	access:public
Eigen::Transform::Identity	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  static const typename MatrixType::IdentityReturnType Identity()$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::Identity	../include/Eigen/src/Geometry/Transform.h	/^  static const Transform Identity()$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
Eigen::Transform	../include/Eigen/src/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
Eigen::Transform::Index	../include/Eigen/src/Geometry/Transform.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::inverse	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline const MatrixType inverse(TransformTraits traits = Affine) const;$/;"	p	class:Eigen::Transform	access:public	signature:(TransformTraits traits = Affine) const
Eigen::Transform::inverse	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::inverse(TransformTraits traits) const$/;"	f	class:Eigen::Transform	signature:(TransformTraits traits) const
Eigen::Transform::inverse	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform inverse(TransformTraits traits = (TransformTraits)Mode) const;$/;"	p	class:Eigen::Transform	access:public	signature:(TransformTraits traits = (TransformTraits)Mode) const
Eigen::Transform::inverse	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::inverse(TransformTraits hint) const$/;"	f	class:Eigen::Transform	signature:(TransformTraits hint) const
Eigen::Transform::isApprox	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  bool isApprox(const Transform& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::Transform::isApprox	../include/Eigen/src/Geometry/Transform.h	/^  bool isApprox(const Transform& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::Transform::linearExt	../include/Eigen/src/Geometry/Transform.h	/^  inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt()$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::linearExt	../include/Eigen/src/Geometry/Transform.h	/^  inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::linear	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline ConstLinearPart linear() const { return m_matrix.template block<Dim,Dim>(0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::linear	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline LinearPart linear() { return m_matrix.template block<Dim,Dim>(0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::linear	../include/Eigen/src/Geometry/Transform.h	/^  inline ConstLinearPart linear() const { return ConstLinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::linear	../include/Eigen/src/Geometry/Transform.h	/^  inline LinearPart linear() { return LinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::LinearMatrixType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::LinearMatrixType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim,Options> LinearMatrixType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::LinearPart	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim> LinearPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::LinearPart	../include/Eigen/src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim,int(Mode)==(AffineCompact)> LinearPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::makeAffine	../include/Eigen/src/Geometry/Transform.h	/^  void makeAffine()$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::matrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::matrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::matrix	../include/Eigen/src/Geometry/Transform.h	/^  inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::matrix	../include/Eigen/src/Geometry/Transform.h	/^  inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::MatrixType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,HDim,HDim> MatrixType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::MatrixType	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename internal::make_proper_matrix_type<Scalar,Rows,HDim,Options>::type MatrixType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::m_matrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform	access:protected
Eigen::Transform::m_matrix	../include/Eigen/src/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform	access:protected
Eigen::Transform::Mode	../include/Eigen/src/Geometry/Transform.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::Transform::__anon374
Eigen::Transform::operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  friend inline Transform operator*(const LinearMatrixType& mat, const Transform& t)$/;"	f	class:Eigen::Transform	access:friend	signature:(const LinearMatrixType& mat, const Transform& t)
Eigen::Transform::operator ()	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Scalar operator() (int row, int col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(int row, int col) const
Eigen::Transform::operator ()	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Scalar& operator() (int row, int col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(int row, int col)
Eigen::Transform::operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::Transform::operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
Eigen::Transform::operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
Eigen::Transform::operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform operator*(const RotationBase<Derived,Dim>& r) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Transform::operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const RotationBase<Derived,Dim>& r);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
Eigen::Transform::operator *=	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
Eigen::Transform::operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform operator*(const ScalingType& s) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const ScalingType& s) const
Eigen::Transform::operator *=	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const ScalingType& s) { return scale(s.coeffs()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const ScalingType& s)
Eigen::Transform::operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const ScalingType& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const ScalingType& t)
Eigen::Transform::operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
Eigen::Transform::operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform operator*(const TranslationType& t) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t) const
Eigen::Transform::operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const TranslationType& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Eigen::Transform::operator *=	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Eigen::Transform::operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Transform::operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r)
Eigen::Transform::operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const ScalingType& s) const$/;"	f	class:Eigen::Transform	signature:(const ScalingType& s) const
Eigen::Transform::operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const ScalingType& s)$/;"	f	class:Eigen::Transform	signature:(const ScalingType& s)
Eigen::Transform::operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t) const
Eigen::Transform::operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t)
Eigen::Transform::operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  operator * (const MatrixBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform	access:friend	signature:(const MatrixBase<OtherDerived> &a, const Transform &b)
Eigen::Transform::operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  operator * (const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other) const
Eigen::Transform::operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  operator * (const Transform& other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other) const
Eigen::Transform::operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
Eigen::Transform::operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
Eigen::Transform::operator *	../include/Eigen/src/Geometry/Transform.h	/^  inline const Transform operator * (const Transform& other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other) const
Eigen::Transform::operator ()	../include/Eigen/src/Geometry/Transform.h	/^  inline Scalar operator() (Index row, Index col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(Index row, Index col) const
Eigen::Transform::operator ()	../include/Eigen/src/Geometry/Transform.h	/^  inline Scalar& operator() (Index row, Index col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(Index row, Index col)
Eigen::Transform::operator *=	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const DiagonalMatrix<Scalar,Dim>& s) { linear() *= s; return *this; }$/;"	f	class:Eigen::Transform	access:public	signature:(const DiagonalMatrix<Scalar,Dim>& s)
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::Transform::operator *=	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const EigenBase<OtherDerived>& other) { return *this = *this * other; }$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
Eigen::Transform::operator *	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform operator*(const RotationBase<Derived,Dim>& r) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const RotationBase<Derived,Dim>& r);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
Eigen::Transform::operator *=	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
Eigen::Transform::operator *	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform operator*(const TranslationType& t) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t) const
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const TranslationType& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Eigen::Transform::operator *=	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Eigen::Transform::operator *	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform operator*(const UniformScaling<Scalar>& s) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& s) const
Eigen::Transform::operator *=	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const UniformScaling<Scalar>& s) { return scale(s.factor()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& s)
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const UniformScaling<Scalar>& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& t)
Eigen::Transform::operator *	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r)
Eigen::Transform::operator *	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t) const
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t)
Eigen::Transform::operator *	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::Transform	signature:(const UniformScaling<Scalar>& s) const
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform	signature:(const UniformScaling<Scalar>& s)
Eigen::Transform::operator *	../include/Eigen/src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform	access:friend	signature:(const DiagonalBase<DiagonalDerived> &a, const Transform &b)
Eigen::Transform::operator *	../include/Eigen/src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &b) const$/;"	f	class:Eigen::Transform	access:public	signature:(const DiagonalBase<DiagonalDerived> &b) const
Eigen::Transform::operator *	../include/Eigen/src/Geometry/Transform.h	/^    operator * (const EigenBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform	access:friend	signature:(const EigenBase<OtherDerived> &a, const Transform &b)
Eigen::Transform::operator *	../include/Eigen/src/Geometry/Transform.h	/^  operator * (const EigenBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived> &other) const
Eigen::Transform::operator *	../include/Eigen/src/Geometry/Transform.h	/^    operator * (const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^  Transform& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
Eigen::Transform::operator =	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
Eigen::Transform::Options	../include/Eigen/src/Geometry/Transform.h	/^    Options = _Options,$/;"	e	enum:Eigen::Transform::__anon374
Eigen::Transform::prerotate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& prerotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
Eigen::Transform::prerotate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
Eigen::Transform::prerotate	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& prerotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
Eigen::Transform::prerotate	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
Eigen::Transform::prescale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& prescale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::prescale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& prescale(Scalar s);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar s)
Eigen::Transform::prescale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::prescale(Scalar s)$/;"	f	class:Eigen::Transform	signature:(Scalar s)
Eigen::Transform::prescale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::prescale	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& prescale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::prescale	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& prescale(Scalar s);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar s)
Eigen::Transform::prescale	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::prescale(Scalar s)$/;"	f	class:Eigen::Transform	signature:(Scalar s)
Eigen::Transform::prescale	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::preshear	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  Transform& preshear(Scalar sx, Scalar sy);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar sx, Scalar sy)
Eigen::Transform::preshear	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::preshear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform	signature:(Scalar sx, Scalar sy)
Eigen::Transform::preshear	../include/Eigen/src/Geometry/Transform.h	/^  Transform& preshear(Scalar sx, Scalar sy);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar sx, Scalar sy)
Eigen::Transform::preshear	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::preshear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform	signature:(Scalar sx, Scalar sy)
Eigen::Transform::pretranslate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& pretranslate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::pretranslate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::pretranslate	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& pretranslate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::pretranslate	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::rotate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& rotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
Eigen::Transform::rotate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
Eigen::Transform::rotate	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& rotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
Eigen::Transform::rotate	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
Eigen::Transform::rotation	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  LinearMatrixType rotation() const;$/;"	p	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::rotation	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::rotation() const$/;"	f	class:Eigen::Transform	signature:() const
Eigen::Transform::rotation	../include/Eigen/src/Geometry/Transform.h	/^  const LinearMatrixType rotation() const;$/;"	p	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::rotation	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotation() const$/;"	f	class:Eigen::Transform	signature:() const
Eigen::Transform::Rows	../include/Eigen/src/Geometry/Transform.h	/^    Rows = int(Mode)==(AffineCompact) ? Dim : HDim$/;"	e	enum:Eigen::Transform::__anon374
Eigen::Transform::Scalar	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::Scalar	../include/Eigen/src/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::scale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::scale(Scalar s)$/;"	f	class:Eigen::Transform	signature:(Scalar s)
Eigen::Transform::scale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& scale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::scale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& scale(Scalar s);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar s)
Eigen::Transform::scale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::scale	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::scale(Scalar s)$/;"	f	class:Eigen::Transform	signature:(Scalar s)
Eigen::Transform::scale	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& scale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::scale	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& scale(Scalar s);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar s)
Eigen::Transform::scale	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::ScalingType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Scaling<Scalar,Dim> ScalingType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::setIdentity	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::setIdentity	../include/Eigen/src/Geometry/Transform.h	/^  void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::shear	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::shear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform	signature:(Scalar sx, Scalar sy)
Eigen::Transform::shear	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  Transform& shear(Scalar sx, Scalar sy);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar sx, Scalar sy)
Eigen::Transform::shear	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::shear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform	signature:(Scalar sx, Scalar sy)
Eigen::Transform::shear	../include/Eigen/src/Geometry/Transform.h	/^  Transform& shear(Scalar sx, Scalar sy);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar sx, Scalar sy)
Eigen::Transform::take_affine_part	../include/Eigen/src/Geometry/Transform.h	/^  typedef internal::transform_take_affine_part<Transform> take_affine_part;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::toQMatrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline QMatrix toQMatrix(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
Eigen::Transform::toQMatrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim>::toQMatrix(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
Eigen::Transform::toQMatrix	../include/Eigen/src/Geometry/Transform.h	/^  inline QMatrix toQMatrix(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
Eigen::Transform::toQMatrix	../include/Eigen/src/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim,Mode,Options>::toQMatrix(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
Eigen::Transform::toQTransform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline QTransform toQTransform(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
Eigen::Transform::toQTransform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim>::toQTransform(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
Eigen::Transform::toQTransform	../include/Eigen/src/Geometry/Transform.h	/^  inline QTransform toQTransform(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
Eigen::Transform::toQTransform	../include/Eigen/src/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim,Mode,Options>::toQTransform(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
Eigen::TransformTraits	../include/Eigen/src/Core/util/Constants.h	/^enum TransformTraits {$/;"	g	namespace:Eigen
Eigen::Transform::Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::Transform::Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const RotationBase<Derived, Dim>& r) { *this = r; }$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived, Dim>& r)
Eigen::Transform::Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const ScalingType& s) { *this = s; }$/;"	f	class:Eigen::Transform	access:public	signature:(const ScalingType& s)
Eigen::Transform::Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const Transform<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<OtherScalarType,Dim>& other)
Eigen::Transform::Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const TranslationType& t) { *this = t; }$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Eigen::Transform::Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
Eigen::Transform::Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
Eigen::Transform::Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
Eigen::Transform::Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform() { }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
Eigen::Transform::Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived>& other)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const RotationBase<Derived, Dim>& r)$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived, Dim>& r)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const Transform<OtherScalarType,Dim,Mode,Options>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<OtherScalarType,Dim,Mode,Options>& other)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const TranslationType& t)$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& s)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform(const Transform<Scalar,Dim,Mode,OtherOptions>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<Scalar,Dim,Mode,OtherOptions>& other)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform()$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^  Transform(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
Eigen::Transform::Transform	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
Eigen::Transform::TransformTimeDiagonalMode	../include/Eigen/src/Geometry/Transform.h	/^  enum { TransformTimeDiagonalMode = ((Mode==int(Isometry))?Affine:int(Mode)) };$/;"	e	enum:Eigen::Transform::__anon375
Eigen::Transform::TransformTimeDiagonalReturnType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,TransformTimeDiagonalMode> TransformTimeDiagonalReturnType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::translate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& translate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::translate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::translate	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& translate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::translate	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Eigen::Transform::translationExt	../include/Eigen/src/Geometry/Transform.h	/^  inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt()$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::translationExt	../include/Eigen/src/Geometry/Transform.h	/^  inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::translation	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline ConstTranslationPart translation() const { return m_matrix.template block<Dim,1>(0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::translation	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline TranslationPart translation() { return m_matrix.template block<Dim,1>(0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::translation	../include/Eigen/src/Geometry/Transform.h	/^  inline ConstTranslationPart translation() const { return ConstTranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
Eigen::Transform::translation	../include/Eigen/src/Geometry/Transform.h	/^  inline TranslationPart translation() { return TranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Eigen::Transform::TranslationPart	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1> TranslationPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::TranslationPart	../include/Eigen/src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1,int(Mode)==(AffineCompact)> TranslationPart;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::TranslationType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::TranslationType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::VectorType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Transform::VectorType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform	access:public
Eigen::Translation2d	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Eigen::Translation2d	../include/Eigen/src/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Eigen::Translation2f	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Eigen::Translation2f	../include/Eigen/src/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Eigen::Translation3d	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Eigen::Translation3d	../include/Eigen/src/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Eigen::Translation3f	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
Eigen::Translation3f	../include/Eigen/src/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
Eigen::Translation::AffineTransformType	../include/Eigen/src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Affine> AffineTransformType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::cast	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::cast	../include/Eigen/src/Geometry/Translation.h	/^  inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::Dim	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon431
Eigen::Translation::Dim	../include/Eigen/src/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon370
EIGEN_TRANSLATION_H	../include/Eigen/src/Geometry/Translation.h	26;"	d
Eigen::Translation::Identity	../include/Eigen/src/Geometry/Translation.h	/^  static const Translation Identity() { return Translation(VectorType::Zero()); }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Eigen::Translation	../include/Eigen/src/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Eigen::Translation::inverse	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::inverse	../include/Eigen/src/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::isApprox	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  bool isApprox(const Translation& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
Eigen::Translation::isApprox	../include/Eigen/src/Geometry/Translation.h	/^  bool isApprox(const Translation& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::Translation::IsometryTransformType	../include/Eigen/src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Isometry> IsometryTransformType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::LinearMatrixType	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::LinearMatrixType	../include/Eigen/src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::m_coeffs	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation	access:protected
Eigen::Translation::m_coeffs	../include/Eigen/src/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation	access:protected
Eigen::Translation::operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  friend inline TransformType operator* (const LinearMatrixType& linear, const Translation& t)$/;"	f	class:Eigen::Translation	access:friend	signature:(const LinearMatrixType& linear, const Translation& t)
Eigen::Translation::operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator* (const LinearMatrixType& linear) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const LinearMatrixType& linear) const
Eigen::Translation::operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation	access:public	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Translation::operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator* (const ScalingType& other) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const ScalingType& other) const
Eigen::Translation::operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator* (const TransformType& t) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const TransformType& t) const
Eigen::Translation::operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other) const
Eigen::Translation::operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& other) const
Eigen::Translation::operator =	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other)
Eigen::Translation::operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const LinearMatrixType& linear) const$/;"	f	class:Eigen::Translation	signature:(const LinearMatrixType& linear) const
Eigen::Translation::operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const ScalingType& other) const$/;"	f	class:Eigen::Translation	signature:(const ScalingType& other) const
Eigen::Translation::operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const TransformType& t) const$/;"	f	class:Eigen::Translation	signature:(const TransformType& t) const
Eigen::Translation::operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline AffineTransformType operator* (const EigenBase<OtherDerived>& linear) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const EigenBase<OtherDerived>& linear) const
Eigen::Translation::operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline AffineTransformType operator*(const EigenBase<OtherDerived>& linear, const Translation& t)$/;"	f	class:Eigen::Translation	access:friend	signature:(const EigenBase<OtherDerived>& linear, const Translation& t)
Eigen::Translation::operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline AffineTransformType operator* (const UniformScaling<Scalar>& other) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const UniformScaling<Scalar>& other) const
Eigen::Translation::operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline IsometryTransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation	access:public	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::Translation::operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline Transform<Scalar,Dim,Mode> operator* (const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Transform<Scalar,Dim,Mode,Options>& t) const
Eigen::Translation::operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other) const
Eigen::Translation::operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& other) const
Eigen::Translation::operator =	../include/Eigen/src/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other)
Eigen::Translation::operator *	../include/Eigen/src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const EigenBase<OtherDerived>& linear) const$/;"	f	class:Eigen::Translation	signature:(const EigenBase<OtherDerived>& linear) const
Eigen::Translation::operator *	../include/Eigen/src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const UniformScaling<Scalar>& other) const$/;"	f	class:Eigen::Translation	signature:(const UniformScaling<Scalar>& other) const
Eigen::Translation::Scalar	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::Scalar	../include/Eigen/src/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::ScalingType	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Scaling<Scalar,Dim> ScalingType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::TransformType	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::Translation	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& vector)
Eigen::Translation::Translation	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation<OtherScalarType,Dim>& other)
Eigen::Translation::Translation	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Eigen::Translation::Translation	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy)
Eigen::Translation::Translation	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  Translation() {}$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::translation	../include/Eigen/src/Geometry/Translation.h	/^  const VectorType& translation() const { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::Translation	../include/Eigen/src/Geometry/Translation.h	/^  explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& vector)
Eigen::Translation::Translation	../include/Eigen/src/Geometry/Translation.h	/^  inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation<OtherScalarType,Dim>& other)
Eigen::Translation::Translation	../include/Eigen/src/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Eigen::Translation::Translation	../include/Eigen/src/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy)
Eigen::Translation::Translation	../include/Eigen/src/Geometry/Translation.h	/^  Translation() {}$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::translation	../include/Eigen/src/Geometry/Translation.h	/^  VectorType& translation() { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::vector	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::vector	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::vector	../include/Eigen/src/Geometry/Translation.h	/^  const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::vector	../include/Eigen/src/Geometry/Translation.h	/^  VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::VectorType	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::VectorType	../include/Eigen/src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation	access:public
Eigen::Translation::x	../include/Eigen/src/Geometry/Translation.h	/^  inline Scalar x() const { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::x	../include/Eigen/src/Geometry/Translation.h	/^  inline Scalar& x() { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::y	../include/Eigen/src/Geometry/Translation.h	/^  inline Scalar y() const { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::y	../include/Eigen/src/Geometry/Translation.h	/^  inline Scalar& y() { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Translation::z	../include/Eigen/src/Geometry/Translation.h	/^  inline Scalar z() const { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Eigen::Translation::z	../include/Eigen/src/Geometry/Translation.h	/^  inline Scalar& z() { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation	access:public	signature:()
Eigen::Transpose::Base	../include/Eigen/src/Core/Transpose.h	/^    typedef typename TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::Transpose	access:public
Eigen::Transpose::CoeffReadCost	../include/Eigen/src/Core/PermutationMatrix.h	/^      CoeffReadCost = Traits::CoeffReadCost,$/;"	e	enum:Eigen::Transpose::__anon119
Eigen::Transpose::ColsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon119
Eigen::Transpose::cols	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline int cols() const { return m_permutation.cols(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::cols	../include/Eigen/src/Core/Transpose.h	/^    inline Index cols() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::DenseMatrixType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Derived::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::Transpose	access:public
Eigen::Transpose::eval	../include/Eigen/src/Core/PermutationMatrix.h	/^    PlainPermutationType eval() const { return *this; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::evalTo	../include/Eigen/src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::Transpose	access:public	signature:(MatrixBase<DenseDerived>& other) const
Eigen::Transpose::Flags	../include/Eigen/src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::Transpose::__anon119
EIGEN_TRANSPOSE_H	../include/Eigen/src/Core/Transpose.h	27;"	d
Eigen::TransposeImpl::Base	../include/Eigen/src/Core/Transpose.h	/^    typedef typename internal::TransposeImpl_base<MatrixType>::type Base;$/;"	t	class:Eigen::TransposeImpl	access:public
Eigen::TransposeImpl::coeff	../include/Eigen/src/Core/Transpose.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index) const
Eigen::TransposeImpl::coeff	../include/Eigen/src/Core/Transpose.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index row, Index col) const
Eigen::TransposeImpl::coeffRef	../include/Eigen/src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index) const
Eigen::TransposeImpl::coeffRef	../include/Eigen/src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index row, Index col) const
Eigen::TransposeImpl::coeffRef	../include/Eigen/src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index)
Eigen::TransposeImpl::coeffRef	../include/Eigen/src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index row, Index col)
Eigen::TransposeImpl::data	../include/Eigen/src/Core/Transpose.h	/^    inline const Scalar* data() const { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
Eigen::TransposeImpl::data	../include/Eigen/src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:()
Eigen::TransposeImpl	../include/Eigen/src/Core/Transpose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Dense>$/;"	c	namespace:Eigen	inherits:internal::TransposeImpl_base::type
Eigen::TransposeImpl	../include/Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
Eigen::TransposeImpl::InnerIterator::Base	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename _MatrixTypeNested::InnerIterator Base;$/;"	t	class:Eigen::TransposeImpl::InnerIterator	access:private
Eigen::TransposeImpl::InnerIterator::col	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    inline typename TransposeImpl<MatrixType,Sparse>::Index col() const { return Base::row(); }$/;"	f	class:Eigen::TransposeImpl::InnerIterator	access:public	signature:() const
Eigen::TransposeImpl::InnerIterator	../include/Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::TransposeImpl	inherits:_MatrixTypeNested::InnerIterator
Eigen::TransposeImpl::InnerIterator::InnerIterator	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    EIGEN_STRONG_INLINE InnerIterator(const TransposeImpl& trans, typename TransposeImpl<MatrixType,Sparse>::Index outer)$/;"	f	class:Eigen::TransposeImpl::InnerIterator	access:public	signature:(const TransposeImpl& trans, typename TransposeImpl<MatrixType,Sparse>::Index outer)
Eigen::TransposeImpl::InnerIterator::row	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    inline typename TransposeImpl<MatrixType,Sparse>::Index row() const { return Base::col(); }$/;"	f	class:Eigen::TransposeImpl::InnerIterator	access:public	signature:() const
Eigen::TransposeImpl::innerStride	../include/Eigen/src/Core/Transpose.h	/^    inline Index innerStride() const { return derived().nestedExpression().innerStride(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
Eigen::TransposeImpl::_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename internal::remove_all<typename MatrixType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::TransposeImpl	access:private
Eigen::TransposeImpl::nonZeros	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    inline Index nonZeros() const { return derived().nestedExpression().nonZeros(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
Eigen::TransposeImpl::outerStride	../include/Eigen/src/Core/Transpose.h	/^    inline Index outerStride() const { return derived().nestedExpression().outerStride(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
Eigen::TransposeImpl::packet	../include/Eigen/src/Core/Transpose.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index) const
Eigen::TransposeImpl::packet	../include/Eigen/src/Core/Transpose.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index row, Index col) const
Eigen::TransposeImpl::ReverseInnerIterator::Base	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator Base;$/;"	t	class:Eigen::TransposeImpl::ReverseInnerIterator	access:private
Eigen::TransposeImpl::ReverseInnerIterator::col	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    inline typename TransposeImpl<MatrixType,Sparse>::Index col() const { return Base::row(); }$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::TransposeImpl::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::TransposeImpl	inherits:_MatrixTypeNested::ReverseInnerIterator
Eigen::TransposeImpl::ReverseInnerIterator::ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const TransposeImpl& xpr, typename TransposeImpl<MatrixType,Sparse>::Index outer)$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator	access:public	signature:(const TransposeImpl& xpr, typename TransposeImpl<MatrixType,Sparse>::Index outer)
Eigen::TransposeImpl::ReverseInnerIterator::row	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    inline typename TransposeImpl<MatrixType,Sparse>::Index row() const { return Base::col(); }$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator	access:public	signature:() const
Eigen::TransposeImpl::ScalarWithConstIfNotLvalue	../include/Eigen/src/Core/Transpose.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::TransposeImpl	access:public
Eigen::TransposeImpl::writePacket	../include/Eigen/src/Core/Transpose.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index, const PacketScalar& x)
Eigen::TransposeImpl::writePacket	../include/Eigen/src/Core/Transpose.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index row, Index col, const PacketScalar& x)
Eigen::Transpose	../include/Eigen/src/Core/PermutationMatrix.h	/^class Transpose<PermutationBase<Derived> >$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::Transpose	../include/Eigen/src/Core/Transpose.h	/^template<typename MatrixType> class Transpose$/;"	c	namespace:Eigen	inherits:TransposeImpl
Eigen::Transpose	../include/Eigen/src/Core/Transpositions.h	/^class Transpose<TranspositionsBase<TranspositionsDerived> >$/;"	c	namespace:Eigen
Eigen::Transpose::IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose	access:private
Eigen::Transpose::IndicesType	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename TranspositionType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose	access:private
Eigen::Transpose::MaxColsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::Transpose::__anon119
Eigen::Transpose::MaxRowsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon119
Eigen::Transpose::m_matrix	../include/Eigen/src/Core/Transpose.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Transpose	access:protected
Eigen::Transpose::m_permutation	../include/Eigen/src/Core/PermutationMatrix.h	/^    const PermutationType& m_permutation;$/;"	m	class:Eigen::Transpose	access:protected
Eigen::Transpose::m_transpositions	../include/Eigen/src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	class:Eigen::Transpose	access:protected
Eigen::Transpose::nestedExpression	../include/Eigen/src/Core/Transpose.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::nestedExpression	../include/Eigen/src/Core/Transpose.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::Transpose	access:public	signature:()
Eigen::Transpose::nestedPermutation	../include/Eigen/src/Core/PermutationMatrix.h	/^    const PermutationType& nestedPermutation() const { return m_permutation; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix) const$/;"	f	class:Eigen::Transpose	access:public	signature:(const MatrixBase<OtherDerived>& matrix) const
Eigen::Transpose::operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix, const Transpose& trPerm)$/;"	f	class:Eigen::Transpose	access:friend	signature:(const MatrixBase<OtherDerived>& matrix, const Transpose& trPerm)
Eigen::Transpose::operator *	../include/Eigen/src/Core/Transpositions.h	/^    operator*(const MatrixBase<Derived>& matrix) const$/;"	f	class:Eigen::Transpose	access:public	signature:(const MatrixBase<Derived>& matrix) const
Eigen::Transpose::operator *	../include/Eigen/src/Core/Transpositions.h	/^    operator*(const MatrixBase<Derived>& matrix, const Transpose& trt)$/;"	f	class:Eigen::Transpose	access:friend	signature:(const MatrixBase<Derived>& matrix, const Transpose& trt)
Eigen::Transpose::PermutationType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef Derived PermutationType;$/;"	t	class:Eigen::Transpose	access:private
Eigen::Transpose::PlainPermutationType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::PlainPermutationType PlainPermutationType;$/;"	t	class:Eigen::Transpose	access:private
Eigen::Transpose::RowsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon119
Eigen::Transpose::rows	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline int rows() const { return m_permutation.rows(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::rows	../include/Eigen/src/Core/Transpose.h	/^    inline Index rows() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::Scalar	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::Transpose	access:public
Eigen::Transpose::size	../include/Eigen/src/Core/Transpositions.h	/^    inline int size() const { return m_transpositions.size(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::toDenseMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return *this; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Eigen::Transpose::Traits	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationType> Traits;$/;"	t	class:Eigen::Transpose	access:public
Eigen::Transpose::Transpose	../include/Eigen/src/Core/PermutationMatrix.h	/^    Transpose(const PermutationType& p) : m_permutation(p) {}$/;"	f	class:Eigen::Transpose	access:public	signature:(const PermutationType& p)
Eigen::Transpose::Transpose	../include/Eigen/src/Core/Transpose.h	/^    inline Transpose(MatrixType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Transpose	access:public	signature:(MatrixType& matrix)
Eigen::Transpose::Transpose	../include/Eigen/src/Core/Transpositions.h	/^    Transpose(const TranspositionType& t) : m_transpositions(t) {}$/;"	f	class:Eigen::Transpose	access:public	signature:(const TranspositionType& t)
Eigen::Transpose::TranspositionType	../include/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsDerived TranspositionType;$/;"	t	class:Eigen::Transpose	access:private
Eigen::TranspositionsBase::coeff	../include/Eigen/src/Core/Transpositions.h	/^    inline const Index& coeff(Index i) const { return indices().coeff(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i) const
Eigen::TranspositionsBase::coeffRef	../include/Eigen/src/Core/Transpositions.h	/^    inline Index& coeffRef(Index i) { return indices().coeffRef(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i)
Eigen::TranspositionsBase::derived	../include/Eigen/src/Core/Transpositions.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
Eigen::TranspositionsBase::derived	../include/Eigen/src/Core/Transpositions.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:()
Eigen::TranspositionsBase	../include/Eigen/src/Core/Transpositions.h	/^class TranspositionsBase$/;"	c	namespace:Eigen
Eigen::Transpositions::Base	../include/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<Transpositions> Base;$/;"	t	class:Eigen::Transpositions	access:public
Eigen::TranspositionsBase::Index	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::TranspositionsBase	access:public
Eigen::TranspositionsBase::indices	../include/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
Eigen::TranspositionsBase::indices	../include/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:()
Eigen::TranspositionsBase::IndicesType	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsBase	access:public
Eigen::TranspositionsBase::inverse	../include/Eigen/src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> inverse() const$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
Eigen::TranspositionsBase::operator =	../include/Eigen/src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
Eigen::TranspositionsBase::operator =	../include/Eigen/src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase& other)$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(const TranspositionsBase& other)
Eigen::TranspositionsBase::operator ()	../include/Eigen/src/Core/Transpositions.h	/^    inline const Index& operator()(Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i) const
Eigen::TranspositionsBase::operator []	../include/Eigen/src/Core/Transpositions.h	/^    inline const Index& operator[](Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i) const
Eigen::TranspositionsBase::operator ()	../include/Eigen/src/Core/Transpositions.h	/^    inline Index& operator()(Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i)
Eigen::TranspositionsBase::operator []	../include/Eigen/src/Core/Transpositions.h	/^    inline Index& operator[](Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i)
Eigen::TranspositionsBase::resize	../include/Eigen/src/Core/Transpositions.h	/^    inline void resize(int size)$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(int size)
Eigen::TranspositionsBase::setIdentity	../include/Eigen/src/Core/Transpositions.h	/^    void setIdentity()$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:()
Eigen::TranspositionsBase::size	../include/Eigen/src/Core/Transpositions.h	/^    inline Index size() const { return indices().size(); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
Eigen::TranspositionsBase::Traits	../include/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::TranspositionsBase	access:private
Eigen::TranspositionsBase::transpose	../include/Eigen/src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> transpose() const$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
EIGEN_TRANSPOSITIONS_H	../include/Eigen/src/Core/Transpositions.h	26;"	d
Eigen::Transpositions	../include/Eigen/src/Core/Transpositions.h	/^class Transpositions : public TranspositionsBase<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >$/;"	c	namespace:Eigen	inherits:TranspositionsBase
Eigen::Transpositions::Index	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Transpositions	access:public
Eigen::Transpositions::indices	../include/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Transpositions	access:public	signature:() const
Eigen::Transpositions::indices	../include/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Transpositions	access:public	signature:()
Eigen::Transpositions::IndicesType	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Transpositions	access:public
Eigen::Transpositions::m_indices	../include/Eigen/src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Transpositions	access:protected
Eigen::Transpositions::operator =	../include/Eigen/src/Core/Transpositions.h	/^    Transpositions& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
Eigen::Transpositions::operator =	../include/Eigen/src/Core/Transpositions.h	/^    Transpositions& operator=(const Transpositions& other)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const Transpositions& other)
Eigen::Transpositions::Traits	../include/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Transpositions> Traits;$/;"	t	class:Eigen::Transpositions	access:private
Eigen::Transpositions::Transpositions	../include/Eigen/src/Core/Transpositions.h	/^    explicit inline Transpositions(const MatrixBase<Other>& indices) : m_indices(indices)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const MatrixBase<Other>& indices)
Eigen::Transpositions::Transpositions	../include/Eigen/src/Core/Transpositions.h	/^    inline Transpositions(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
Eigen::Transpositions::Transpositions	../include/Eigen/src/Core/Transpositions.h	/^    inline Transpositions(const Transpositions& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::Transpositions	access:public	signature:(const Transpositions& other)
Eigen::Transpositions::Transpositions	../include/Eigen/src/Core/Transpositions.h	/^    inline Transpositions() {}$/;"	f	class:Eigen::Transpositions	access:public	signature:()
Eigen::Transpositions::Transpositions	../include/Eigen/src/Core/Transpositions.h	/^    inline Transpositions(Index size) : m_indices(size)$/;"	f	class:Eigen::Transpositions	access:public	signature:(Index size)
Eigen::TranspositionsWrapper::Base	../include/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<TranspositionsWrapper> Base;$/;"	t	class:Eigen::TranspositionsWrapper	access:public
Eigen::TranspositionsWrapper	../include/Eigen/src/Core/Transpositions.h	/^class TranspositionsWrapper$/;"	c	namespace:Eigen	inherits:TranspositionsBase
Eigen::TranspositionsWrapper::Index	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::TranspositionsWrapper	access:public
Eigen::TranspositionsWrapper::indices	../include/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:() const
Eigen::TranspositionsWrapper::indices	../include/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:()
Eigen::TranspositionsWrapper::IndicesType	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsWrapper	access:public
Eigen::TranspositionsWrapper::m_indices	../include/Eigen/src/Core/Transpositions.h	/^    const typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::TranspositionsWrapper	access:protected
Eigen::TranspositionsWrapper::operator =	../include/Eigen/src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
Eigen::TranspositionsWrapper::operator =	../include/Eigen/src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsWrapper& other)$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:(const TranspositionsWrapper& other)
Eigen::TranspositionsWrapper::Traits	../include/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<TranspositionsWrapper> Traits;$/;"	t	class:Eigen::TranspositionsWrapper	access:private
Eigen::TranspositionsWrapper::TranspositionsWrapper	../include/Eigen/src/Core/Transpositions.h	/^    inline TranspositionsWrapper(IndicesType& indices)$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:(IndicesType& indices)
Eigen::TriangularBase::check_coordinates	../include/Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase	access:protected	signature:(Index row, Index col) const
Eigen::TriangularBase::check_coordinates_internal	../include/Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index , Index ) const {}$/;"	f	class:Eigen::TriangularBase	access:protected	signature:(Index , Index ) const
Eigen::TriangularBase::check_coordinates_internal	../include/Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase	access:protected	signature:(Index row, Index col) const
Eigen::TriangularBase::coeff	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const  { return derived().coeff(row,col); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col) const
Eigen::TriangularBase::CoeffReadCost	../include/Eigen/src/Core/TriangularMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::TriangularBase::__anon233
Eigen::TriangularBase::coeffRef	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col) { return derived().coeffRef(row,col); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col)
Eigen::TriangularBase::ColsAtCompileTime	../include/Eigen/src/Core/TriangularMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon233
Eigen::TriangularBase::cols	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
Eigen::TriangularBase::copyCoeff	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, Other& other)$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col, Other& other)
Eigen::TriangularBase::DenseMatrixType	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularBase	access:public
Eigen::TriangularBase::DenseType	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::TriangularBase	access:public
Eigen::TriangularBase::derived	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
Eigen::TriangularBase::derived	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:()
Eigen::TriangularBase::evalTo	../include/Eigen/src/Core/TriangularMatrix.h	/^    void evalTo(MatrixBase<DenseDerived> &other) const;$/;"	p	class:Eigen::TriangularBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
Eigen::TriangularBase::evalTo	../include/Eigen/src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase	signature:(MatrixBase<DenseDerived> &other) const
Eigen::TriangularBase::evalToLazy	../include/Eigen/src/Core/TriangularMatrix.h	/^    void evalToLazy(MatrixBase<DenseDerived> &other) const;$/;"	p	class:Eigen::TriangularBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
Eigen::TriangularBase::evalToLazy	../include/Eigen/src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalToLazy(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase	signature:(MatrixBase<DenseDerived> &other) const
Eigen::TriangularBase	../include/Eigen/src/Core/TriangularMatrix.h	/^template<typename Derived> class TriangularBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
Eigen::TriangularBase::Index	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::TriangularBase	access:public
Eigen::TriangularBase::innerStride	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return derived().innerStride(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
Eigen::TriangularBase::MaxColsAtCompileTime	../include/Eigen/src/Core/TriangularMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime$/;"	e	enum:Eigen::TriangularBase::__anon233
Eigen::TriangularBase::MaxRowsAtCompileTime	../include/Eigen/src/Core/TriangularMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon233
Eigen::TriangularBase::Mode	../include/Eigen/src/Core/TriangularMatrix.h	/^      Mode = internal::traits<Derived>::Mode,$/;"	e	enum:Eigen::TriangularBase::__anon233
Eigen::TriangularBase::operator ()	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar operator()(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col) const
Eigen::TriangularBase::operator ()	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col)
Eigen::TriangularBase::outerStride	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return derived().outerStride(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
Eigen::TriangularBase::RowsAtCompileTime	../include/Eigen/src/Core/TriangularMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon233
Eigen::TriangularBase::rows	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
Eigen::TriangularBase::Scalar	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::TriangularBase	access:public
Eigen::TriangularBase::StorageKind	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularBase	access:public
Eigen::TriangularBase::toDenseMatrix	../include/Eigen/src/Core/TriangularMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
Eigen::TriangularBase::TriangularBase	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularBase() { eigen_assert(!((Mode&UnitDiag) && (Mode&ZeroDiag))); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:()
EIGEN_TRIANGULARMATRIX_H	../include/Eigen/src/Core/TriangularMatrix.h	27;"	d
EIGEN_TRIANGULAR_MATRIX_MATRIX_H	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	26;"	d
EIGEN_TRIANGULAR_MATRIX_MATRIX_MKL_H	../include/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	34;"	d
EIGEN_TRIANGULARMATRIXVECTOR_H	../include/Eigen/src/Core/products/TriangularMatrixVector.h	26;"	d
EIGEN_TRIANGULAR_MATRIX_VECTOR_MKL_H	../include/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	34;"	d
Eigen::TriangularProduct	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false>$/;"	s	namespace:Eigen	inherits:ProductBase
Eigen::TriangularProduct	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct TriangularProduct<Mode,false,Lhs,true,Rhs,false>$/;"	s	namespace:Eigen	inherits:ProductBase
Eigen::TriangularProduct	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct TriangularProduct<Mode,true,Lhs,false,Rhs,true>$/;"	s	namespace:Eigen	inherits:ProductBase
Eigen::TriangularProduct::scaleAndAddTo	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(Dest& dst, Scalar alpha) const
Eigen::TriangularProduct::scaleAndAddTo	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(Dest& dst, Scalar alpha) const
Eigen::TriangularProduct::TriangularProduct	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Eigen::TriangularProduct::TriangularProduct	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
EIGEN_TRIANGULAR_SOLVER2_H	../include/Eigen/src/Eigen2Support/TriangularSolver.h	26;"	d
EIGEN_TRIANGULAR_SOLVER_MATRIX_H	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	26;"	d
EIGEN_TRIANGULAR_SOLVER_MATRIX_MKL_H	../include/Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	34;"	d
EIGEN_TRIANGULAR_SOLVER_VECTOR_H	../include/Eigen/src/Core/products/TriangularSolverVector.h	26;"	d
Eigen::TriangularView::adjoint	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline const TriangularView<const typename MatrixType::AdjointReturnType,TransposeMode> adjoint() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::assignProduct	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^TriangularView<MatrixType,UpLo>& TriangularView<MatrixType,UpLo>::assignProduct(const ProductBase<ProductDerived, _Lhs,_Rhs>& prod, const Scalar& alpha)$/;"	f	class:Eigen::TriangularView	signature:(const ProductBase<ProductDerived, _Lhs,_Rhs>& prod, const Scalar& alpha)
Eigen::TriangularView::assignProduct	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& assignProduct(const ProductBase<ProductDerived, Lhs,Rhs>& prod, const Scalar& alpha);$/;"	p	class:Eigen::TriangularView	access:protected	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& prod, const Scalar& alpha)
Eigen::TriangularView::Base	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularBase<TriangularView> Base;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::coeff	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(Index row, Index col) const
Eigen::TriangularView::coeffRef	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::TriangularView	access:public	signature:(Index row, Index col)
Eigen::TriangularView::cols	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::conjugate	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline const TriangularView<MatrixConjugateReturnType,Mode> conjugate() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::conjugate	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularView<MatrixConjugateReturnType,Mode> conjugate()$/;"	f	class:Eigen::TriangularView	access:public	signature:()
Eigen::TriangularView::DenseMatrixType	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::determinant	../include/Eigen/src/Core/TriangularMatrix.h	/^    Scalar determinant() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::eigen2_product_return_type::DenseMatrixType	../include/Eigen/src/Core/TriangularMatrix.h	/^      typedef typename TriangularView<MatrixType,Mode>::DenseMatrixType DenseMatrixType;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
Eigen::TriangularView::eigen2_product_return_type	../include/Eigen/src/Core/TriangularMatrix.h	/^    struct eigen2_product_return_type$/;"	s	class:Eigen::TriangularView	access:public
Eigen::TriangularView::eigen2_product_return_type::OtherPlainObject	../include/Eigen/src/Core/TriangularMatrix.h	/^      typedef typename OtherDerived::PlainObject::DenseType OtherPlainObject;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
Eigen::TriangularView::eigen2_product_return_type::ProdRetType	../include/Eigen/src/Core/TriangularMatrix.h	/^      typedef typename ProductReturnType<DenseMatrixType, OtherPlainObject>::Type ProdRetType;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
Eigen::TriangularView::eigen2_product_return_type::type	../include/Eigen/src/Core/TriangularMatrix.h	/^      typedef typename ProdRetType::PlainObject type;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
Eigen::TriangularView::fill	../include/Eigen/src/Core/TriangularMatrix.h	/^    void fill(const Scalar& value) { setConstant(value); }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const Scalar& value)
Eigen::TriangularView	../include/Eigen/src/Core/TriangularMatrix.h	/^template<typename _MatrixType, unsigned int _Mode> class TriangularView$/;"	c	namespace:Eigen	inherits:TriangularBase
Eigen::TriangularView::Index	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Index Index;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::innerStride	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::isApprox	../include/Eigen/src/Core/TriangularMatrix.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
Eigen::TriangularView::isApprox	../include/Eigen/src/Core/TriangularMatrix.h	/^    bool isApprox(const TriangularView<OtherMatrixType, Mode>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const TriangularView<OtherMatrixType, Mode>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
Eigen::TriangularView::lazyAssign	../include/Eigen/src/Core/TriangularMatrix.h	/^    void lazyAssign(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::TriangularView::lazyAssign	../include/Eigen/src/Core/TriangularMatrix.h	/^    void lazyAssign(const TriangularBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const TriangularBase<OtherDerived>& other)
Eigen::TriangularView::lazyAssign	../include/Eigen/src/Core/TriangularMatrix.h	/^void TriangularView<MatrixType, Mode>::lazyAssign(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<OtherDerived>& other)
Eigen::TriangularView::lazyAssign	../include/Eigen/src/Core/TriangularMatrix.h	/^void TriangularView<MatrixType, Mode>::lazyAssign(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const TriangularBase<OtherDerived>& other)
Eigen::TriangularView::MatrixConjugateReturnType	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;$/;"	t	class:Eigen::TriangularView	access:protected
Eigen::TriangularView::MatrixType	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::MatrixTypeNestedCleaned	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::TriangularView	access:protected
Eigen::TriangularView::MatrixTypeNested	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::TriangularView	access:protected
Eigen::TriangularView::MatrixTypeNestedNonRef	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedNonRef MatrixTypeNestedNonRef;$/;"	t	class:Eigen::TriangularView	access:protected
Eigen::TriangularView::m_matrix	../include/Eigen/src/Core/TriangularMatrix.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::TriangularView	access:protected
Eigen::TriangularView::Mode	../include/Eigen/src/Core/TriangularMatrix.h	/^      Mode = _Mode,$/;"	e	enum:Eigen::TriangularView::__anon235
Eigen::TriangularView::nestedExpression	../include/Eigen/src/Core/TriangularMatrix.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::nestedExpression	../include/Eigen/src/Core/TriangularMatrix.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }$/;"	f	class:Eigen::TriangularView	access:public	signature:()
Eigen::TriangularView::operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::TriangularView::operator -=	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::TriangularView::operator +=	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
Eigen::TriangularView::operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ScaledProduct<ProductDerived>& other)
Eigen::TriangularView::operator -=	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator-=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ScaledProduct<ProductDerived>& other)
Eigen::TriangularView::operator +=	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator+=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ScaledProduct<ProductDerived>& other)
Eigen::TriangularView::operator *	../include/Eigen/src/Core/TriangularMatrix.h	/^    operator*(const EigenBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const EigenBase<OtherDerived>& rhs) const
Eigen::TriangularView::operator *	../include/Eigen/src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const TriangularView& rhs)$/;"	f	class:Eigen::TriangularView	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const TriangularView& rhs)
Eigen::TriangularView::operator *	../include/Eigen/src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& rhs) const
Eigen::TriangularView::operator -=	../include/Eigen/src/Core/TriangularMatrix.h	/^    template<typename Other> TriangularView&  operator-=(const DenseBase<Other>& other) { return *this = m_matrix - other.derived(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const DenseBase<Other>& other)
Eigen::TriangularView::operator +=	../include/Eigen/src/Core/TriangularMatrix.h	/^    template<typename Other> TriangularView&  operator+=(const DenseBase<Other>& other) { return *this = m_matrix + other.derived(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const DenseBase<Other>& other)
Eigen::TriangularView::operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^TriangularView<MatrixType, Mode>::operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<OtherDerived>& other)
Eigen::TriangularView::operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^TriangularView<MatrixType, Mode>::operator=(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const TriangularBase<OtherDerived>& other)
Eigen::TriangularView::operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other)
Eigen::TriangularView::operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const TriangularBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const TriangularBase<OtherDerived>& other)
Eigen::TriangularView::operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const TriangularView& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const TriangularView& other)
Eigen::TriangularView::operator /=	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView&  operator\/=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix \/ other; }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const typename internal::traits<MatrixType>::Scalar& other)
Eigen::TriangularView::operator *=	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView&  operator*=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix * other; }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const typename internal::traits<MatrixType>::Scalar& other)
Eigen::TriangularView::outerStride	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::PlainObject	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType PlainObject;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::rows	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::Scalar	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Scalar Scalar;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::selfadjointView	../include/Eigen/src/Core/TriangularMatrix.h	/^    const SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::selfadjointView	../include/Eigen/src/Core/TriangularMatrix.h	/^    SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView()$/;"	f	class:Eigen::TriangularView	access:public	signature:()
Eigen::TriangularView::setConstant	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& setConstant(const Scalar& value)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const Scalar& value)
Eigen::TriangularView::setOnes	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& setOnes() { return setConstant(Scalar(1)); }$/;"	f	class:Eigen::TriangularView	access:public	signature:()
Eigen::TriangularView::setZero	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& setZero() { return setConstant(Scalar(0)); }$/;"	f	class:Eigen::TriangularView	access:public	signature:()
Eigen::TriangularView::solve	../include/Eigen/src/Core/SolveTriangular.h	/^TriangularView<Derived,Mode>::solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<Other>& other) const
Eigen::TriangularView::solve	../include/Eigen/src/Core/TriangularMatrix.h	/^    solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<Other>& other) const
Eigen::TriangularView::solve	../include/Eigen/src/Core/TriangularMatrix.h	/^    solve(const MatrixBase<Other>& other) const;$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<Other>& other) const
Eigen::TriangularView::solveInPlace	../include/Eigen/src/Core/SolveTriangular.h	/^void TriangularView<MatrixType,Mode>::solveInPlace(const MatrixBase<OtherDerived>& _other) const$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<OtherDerived>& _other) const
Eigen::TriangularView::solveInPlace	../include/Eigen/src/Core/TriangularMatrix.h	/^    void solveInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::TriangularView::solveInPlace	../include/Eigen/src/Core/TriangularMatrix.h	/^    void solveInPlace(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::TriangularView::StorageKind	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularView	access:public
Eigen::TriangularView::swap	../include/Eigen/src/Core/TriangularMatrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(MatrixBase<OtherDerived> const & other)
Eigen::TriangularView::swap	../include/Eigen/src/Core/TriangularMatrix.h	/^    void swap(TriangularBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(TriangularBase<OtherDerived> const & other)
Eigen::TriangularView::transpose	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline const TriangularView<Transpose<MatrixType>,TransposeMode> transpose() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
Eigen::TriangularView::transpose	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularView<Transpose<MatrixType>,TransposeMode> transpose()$/;"	f	class:Eigen::TriangularView	access:public	signature:()
Eigen::TriangularView::TransposeMode	../include/Eigen/src/Core/TriangularMatrix.h	/^      TransposeMode = (Mode & Upper ? Lower : 0)$/;"	e	enum:Eigen::TriangularView::__anon235
Eigen::TriangularView::TriangularView	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularView(const MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixType& matrix)
Eigen::Tridiagonalization::CoeffVectorType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::compute	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization& compute(const MatrixType& matrix)$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:(const MatrixType& matrix)
Eigen::Tridiagonalization::diagonal	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    DiagonalReturnType diagonal() const;$/;"	p	class:Eigen::Tridiagonalization	access:public	signature:() const
Eigen::Tridiagonalization::diagonal	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::diagonal() const$/;"	f	class:Eigen::Tridiagonalization	signature:() const
Eigen::Tridiagonalization::DiagonalReturnType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^            >::type DiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::DiagonalType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type DiagonalType;$/;"	t	class:Eigen::Tridiagonalization	access:public
EIGEN_TRIDIAGONALIZATION_H	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	27;"	d
Eigen::Tridiagonalization::householderCoefficients	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline CoeffVectorType householderCoefficients() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
Eigen::Tridiagonalization::HouseholderSequenceType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename HouseholderSequence<MatrixType,CoeffVectorType>::ConjugateReturnType HouseholderSequenceType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^template<typename _MatrixType> class Tridiagonalization$/;"	c	namespace:Eigen
Eigen::Tridiagonalization::Index	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::matrixQ	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
Eigen::Tridiagonalization::matrixT	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    MatrixTReturnType matrixT() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
Eigen::Tridiagonalization::MatrixTReturnType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef internal::TridiagonalizationMatrixTReturnType<MatrixTypeRealView> MatrixTReturnType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::MatrixType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::MatrixTypeRealView	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::remove_all<typename MatrixType::RealReturnType>::type MatrixTypeRealView;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::MaxSize	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon42
Eigen::Tridiagonalization::MaxSizeMinusOne	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : (MaxSize > 1 ? MaxSize - 1 : 1)$/;"	e	enum:Eigen::Tridiagonalization::__anon42
Eigen::Tridiagonalization::m_hCoeffs	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::Tridiagonalization	access:protected
Eigen::Tridiagonalization::m_isInitialized	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::Tridiagonalization	access:protected
Eigen::Tridiagonalization::m_matrix	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::Tridiagonalization	access:protected
Eigen::Tridiagonalization::Options	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::Tridiagonalization::__anon42
Eigen::Tridiagonalization::packedMatrix	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline const MatrixType& packedMatrix() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
Eigen::Tridiagonalization::RealScalar	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::Scalar	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::Size	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon42
Eigen::Tridiagonalization::SizeMinusOne	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : (Size > 1 ? Size - 1 : 1),$/;"	e	enum:Eigen::Tridiagonalization::__anon42
Eigen::Tridiagonalization::subDiagonal	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    SubDiagonalReturnType subDiagonal() const;$/;"	p	class:Eigen::Tridiagonalization	access:public	signature:() const
Eigen::Tridiagonalization::subDiagonal	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::subDiagonal() const$/;"	f	class:Eigen::Tridiagonalization	signature:() const
Eigen::Tridiagonalization::SubDiagonalReturnType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^            >::type SubDiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::SubDiagonalType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<RealScalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> SubDiagonalType;$/;"	t	class:Eigen::Tridiagonalization	access:public
Eigen::Tridiagonalization::Tridiagonalization	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:(const MatrixType& matrix)
Eigen::Tridiagonalization::Tridiagonalization	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:(Index size = Size==Dynamic ? 2 : Size)
Eigen::Triplet::col	../include/Eigen/src/SparseCore/SparseUtil.h	/^  const Index& col() const { return m_col; }$/;"	f	class:Eigen::Triplet	access:public	signature:() const
Eigen::Triplet	../include/Eigen/src/SparseCore/SparseUtil.h	/^class Triplet$/;"	c	namespace:Eigen
Eigen::Triplet::m_col	../include/Eigen/src/SparseCore/SparseUtil.h	/^  Index m_row, m_col;$/;"	m	class:Eigen::Triplet	access:protected
Eigen::Triplet::m_row	../include/Eigen/src/SparseCore/SparseUtil.h	/^  Index m_row, m_col;$/;"	m	class:Eigen::Triplet	access:protected
Eigen::Triplet::m_value	../include/Eigen/src/SparseCore/SparseUtil.h	/^  Scalar m_value;$/;"	m	class:Eigen::Triplet	access:protected
Eigen::Triplet::row	../include/Eigen/src/SparseCore/SparseUtil.h	/^  const Index& row() const { return m_row; }$/;"	f	class:Eigen::Triplet	access:public	signature:() const
Eigen::Triplet::Triplet	../include/Eigen/src/SparseCore/SparseUtil.h	/^  Triplet(const Index& i, const Index& j, const Scalar& v = Scalar(0))$/;"	f	class:Eigen::Triplet	access:public	signature:(const Index& i, const Index& j, const Scalar& v = Scalar(0))
Eigen::Triplet::Triplet	../include/Eigen/src/SparseCore/SparseUtil.h	/^  Triplet() : m_row(0), m_col(0), m_value(0) {}$/;"	f	class:Eigen::Triplet	access:public	signature:()
Eigen::Triplet::value	../include/Eigen/src/SparseCore/SparseUtil.h	/^  const Scalar& value() const { return m_value; }$/;"	f	class:Eigen::Triplet	access:public	signature:() const
EIGEN_TUNE_TRIANGULAR_PANEL_WIDTH	../include/Eigen/src/Core/arch/Default/Settings.h	53;"	d
EIGEN_UMEYAMA_H	../include/Eigen/src/Geometry/Umeyama.h	26;"	d
Eigen::umeyama	../include/Eigen/src/Geometry/Umeyama.h	/^umeyama(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)
Eigen::umfpack_free_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, double)$/;"	f	namespace:Eigen	signature:(void **Numeric, double)
Eigen::umfpack_free_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, std::complex<double>)$/;"	f	namespace:Eigen	signature:(void **Numeric, std::complex<double>)
Eigen::umfpack_free_symbolic	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, double)$/;"	f	namespace:Eigen	signature:(void **Symbolic, double)
Eigen::umfpack_free_symbolic	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, std::complex<double>)$/;"	f	namespace:Eigen	signature:(void **Symbolic, std::complex<double>)
Eigen::umfpack_get_determinant	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen	signature:(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])
Eigen::umfpack_get_determinant	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen	signature:(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])
Eigen::umfpack_get_lunz	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)$/;"	f	namespace:Eigen	signature:(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)
Eigen::umfpack_get_lunz	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)$/;"	f	namespace:Eigen	signature:(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)
Eigen::umfpack_get_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[],$/;"	f	namespace:Eigen	signature:(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[], int P[], int Q[], double Dx[], int *do_recip, double Rs[], void *Numeric)
Eigen::umfpack_get_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[],$/;"	f	namespace:Eigen	signature:(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[], int P[], int Q[], std::complex<double> Dx[], int *do_recip, double Rs[], void *Numeric)
Eigen::UmfPackLU::analyzePattern	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixType& matrix)
Eigen::UmfPackLU::cols	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline Index cols() const { return m_copyMatrix.cols(); }$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::compute	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixType& matrix)
Eigen::UmfPackLU::determinant	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    Scalar determinant() const;$/;"	p	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::determinant	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^typename UmfPackLU<MatrixType>::Scalar UmfPackLU<MatrixType>::determinant() const$/;"	f	class:Eigen::UmfPackLU	signature:() const
Eigen::UmfPackLU::extractData	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void extractData() const;$/;"	p	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::extractData	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^void UmfPackLU<MatrixType>::extractData() const$/;"	f	class:Eigen::UmfPackLU	signature:() const
Eigen::UmfPackLU::factorize	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixType& matrix)
Eigen::UmfPackLU::grapInput	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void grapInput(const MatrixType& mat)$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:(const MatrixType& mat)
Eigen::UmfPackLU	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^class UmfPackLU : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
Eigen::UmfPackLU::Index	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::info	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::init	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void init()$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:()
Eigen::UmfPackLU::IntColVectorType	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::IntRowVectorType	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::LUMatrixType	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::m_analysisIsOk	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::matrixL	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixL() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::MatrixType	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::matrixU	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixU() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::m_copyMatrix	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfpackMatrixType m_copyMatrix;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_extractedDataAreDirty	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_factorizationIsOk	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_info	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_innerIndexPtr	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    const int* m_innerIndexPtr;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_isInitialized	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_l	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void* m_numeric;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_outerIndexPtr	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    const int* m_outerIndexPtr;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_p	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_q	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_symbolic	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void* m_symbolic;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_u	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::m_valuePtr	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    const Scalar* m_valuePtr;$/;"	m	class:Eigen::UmfPackLU	access:protected
Eigen::UmfPackLU::permutationP	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::permutationQ	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::RealScalar	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::rows	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline Index rows() const { return m_copyMatrix.rows(); }$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
Eigen::UmfPackLU::Scalar	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::_solve	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    bool _solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const;$/;"	p	class:Eigen::UmfPackLU	access:public	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const
Eigen::UmfPackLU::_solve	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^bool UmfPackLU<MatrixType>::_solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const$/;"	f	class:Eigen::UmfPackLU	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const
Eigen::UmfPackLU::solve	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const internal::solve_retval<UmfPackLU, Rhs> solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixBase<Rhs>& b) const
Eigen::UmfPackLU::UmfPackLU	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixType& matrix)
Eigen::UmfPackLU::~UmfPackLU	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    ~UmfPackLU()$/;"	f	class:Eigen::UmfPackLU	access:public	signature:()
Eigen::UmfPackLU::UmfPackLU	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU() { init(); }$/;"	f	class:Eigen::UmfPackLU	access:public	signature:()
Eigen::UmfPackLU::UmfPackLU	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(UmfPackLU& ) { }$/;"	f	class:Eigen::UmfPackLU	access:private	signature:(UmfPackLU& )
Eigen::UmfPackLU::UmfpackMatrixType	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar,ColMajor,int> UmfpackMatrixType;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::UmfPackLU::Vector	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::UmfPackLU	access:public
Eigen::umfpack_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen	signature:( const int Ap[], const int Ai[], const double Ax[], void *Symbolic, void **Numeric, const double Control[UMFPACK_CONTROL],double Info [UMFPACK_INFO])
Eigen::umfpack_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen	signature:( const int Ap[], const int Ai[], const std::complex<double> Ax[], void *Symbolic, void **Numeric, const double Control[UMFPACK_CONTROL],double Info [UMFPACK_INFO])
Eigen::umfpack_solve	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen	signature:( int sys, const int Ap[], const int Ai[], const double Ax[], double X[], const double B[], void *Numeric, const double Control[UMFPACK_CONTROL], double Info[UMFPACK_INFO])
Eigen::umfpack_solve	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen	signature:( int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[], std::complex<double> X[], const std::complex<double> B[], void *Numeric, const double Control[UMFPACK_CONTROL], double Info[UMFPACK_INFO])
EIGEN_UMFPACKSUPPORT_H	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	26;"	d
Eigen::umfpack_symbolic	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_symbolic(int n_row,int n_col,$/;"	f	namespace:Eigen	signature:(int n_row,int n_col, const int Ap[], const int Ai[], const double Ax[], void **Symbolic, const double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])
Eigen::umfpack_symbolic	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_symbolic(int n_row,int n_col,$/;"	f	namespace:Eigen	signature:(int n_row,int n_col, const int Ap[], const int Ai[], const std::complex<double> Ax[], void **Symbolic, const double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])
Eigen::Unaligned	../include/Eigen/src/Core/util/Constants.h	/^  Unaligned=0, $/;"	e	enum:Eigen::__anon208
Eigen::UniformScaling::cast	../include/Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling<NewScalarType> cast() const$/;"	f	class:Eigen::UniformScaling	access:public	signature:() const
Eigen::UniformScaling::factor	../include/Eigen/src/Geometry/Scaling.h	/^  inline const Scalar& factor() const { return m_factor; }$/;"	f	class:Eigen::UniformScaling	access:public	signature:() const
Eigen::UniformScaling::factor	../include/Eigen/src/Geometry/Scaling.h	/^  inline Scalar& factor() { return m_factor; }$/;"	f	class:Eigen::UniformScaling	access:public	signature:()
Eigen::UniformScaling	../include/Eigen/src/Geometry/Scaling.h	/^class UniformScaling$/;"	c	namespace:Eigen
Eigen::UniformScaling::inverse	../include/Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling inverse() const$/;"	f	class:Eigen::UniformScaling	access:public	signature:() const
Eigen::UniformScaling::isApprox	../include/Eigen/src/Geometry/Scaling.h	/^  bool isApprox(const UniformScaling& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const UniformScaling& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
Eigen::UniformScaling::m_factor	../include/Eigen/src/Geometry/Scaling.h	/^  Scalar m_factor;$/;"	m	class:Eigen::UniformScaling	access:protected
Eigen::UniformScaling::operator *	../include/Eigen/src/Geometry/Scaling.h	/^  inline Matrix<Scalar,Dim,Dim> operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const RotationBase<Derived,Dim>& r) const
Eigen::UniformScaling::operator *	../include/Eigen/src/Geometry/Scaling.h	/^  inline Transform<Scalar,Dim,Affine> operator* (const Translation<Scalar,Dim>& t) const;$/;"	p	class:Eigen::UniformScaling	access:public	signature:(const Translation<Scalar,Dim>& t) const
Eigen::UniformScaling::operator *	../include/Eigen/src/Geometry/Scaling.h	/^  inline Transform<Scalar,Dim,Mode> operator* (const Transform<Scalar,Dim, Mode, Options>& t) const;$/;"	p	class:Eigen::UniformScaling	access:public	signature:(const Transform<Scalar,Dim, Mode, Options>& t) const
Eigen::UniformScaling::operator *	../include/Eigen/src/Geometry/Scaling.h	/^  inline typename internal::plain_matrix_type<Derived>::type operator* (const MatrixBase<Derived>& other) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const MatrixBase<Derived>& other) const
Eigen::UniformScaling::operator *	../include/Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling operator* (const UniformScaling& other) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const UniformScaling& other) const
Eigen::UniformScaling::operator *	../include/Eigen/src/Geometry/Scaling.h	/^UniformScaling<Scalar>::operator* (const Transform<Scalar,Dim, Mode, Options>& t) const$/;"	f	class:Eigen::UniformScaling	signature:(const Transform<Scalar,Dim, Mode, Options>& t) const
Eigen::UniformScaling::operator *	../include/Eigen/src/Geometry/Scaling.h	/^UniformScaling<Scalar>::operator* (const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::UniformScaling	signature:(const Translation<Scalar,Dim>& t) const
Eigen::UniformScaling::Scalar	../include/Eigen/src/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::UniformScaling	access:public
Eigen::UniformScaling::UniformScaling	../include/Eigen/src/Geometry/Scaling.h	/^  explicit inline UniformScaling(const Scalar& s) : m_factor(s) {}$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const Scalar& s)
Eigen::UniformScaling::UniformScaling	../include/Eigen/src/Geometry/Scaling.h	/^  inline explicit UniformScaling(const UniformScaling<OtherScalarType>& other)$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const UniformScaling<OtherScalarType>& other)
Eigen::UniformScaling::UniformScaling	../include/Eigen/src/Geometry/Scaling.h	/^  UniformScaling() {}$/;"	f	class:Eigen::UniformScaling	access:public	signature:()
Eigen::UnitDiagBit	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitDiagBit = UnitDiag;$/;"	m	namespace:Eigen
Eigen::UnitDiag	../include/Eigen/src/Core/util/Constants.h	/^  UnitDiag=0x4, $/;"	e	enum:Eigen::__anon207
Eigen::UnitLower	../include/Eigen/src/Core/util/Constants.h	/^  UnitLower=UnitDiag|Lower, $/;"	e	enum:Eigen::__anon207
Eigen::UnitLowerTriangular	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitLowerTriangular = UnitLower;$/;"	m	namespace:Eigen
Eigen::UnitUpper	../include/Eigen/src/Core/util/Constants.h	/^  UnitUpper=UnitDiag|Upper,$/;"	e	enum:Eigen::__anon207
Eigen::UnitUpperTriangular	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitUpperTriangular = UnitUpper;$/;"	m	namespace:Eigen
EIGEN_UNROLLING_LIMIT	../include/Eigen/src/Core/arch/Default/Settings.h	39;"	d
EIGEN_UNUSED	../include/Eigen/src/Core/util/Macros.h	250;"	d
EIGEN_UNUSED_VARIABLE	../include/Eigen/src/Core/util/Macros.h	256;"	d
Eigen::Upper	../include/Eigen/src/Core/util/Constants.h	/^  Upper=0x2,                      $/;"	e	enum:Eigen::__anon207
Eigen::UpperTriangularBit	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UpperTriangularBit = Upper;$/;"	m	namespace:Eigen
Eigen::UpperTriangular	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UpperTriangular = Upper;$/;"	m	namespace:Eigen
EIGEN_USE_BLAS	../include/Eigen/src/Core/util/MKL_support.h	38;"	d
EIGEN_USE_LAPACKE	../include/Eigen/src/Core/util/MKL_support.h	41;"	d
EIGEN_USE_LAPACKE	../include/Eigen/src/Core/util/MKL_support.h	49;"	d
EIGEN_USE_MKL	../include/Eigen/src/Core/util/MKL_support.h	53;"	d
EIGEN_USE_MKL_VML	../include/Eigen/src/Core/util/MKL_support.h	44;"	d
EIGEN_USER_ALIGN16	../include/Eigen/src/Core/util/Macros.h	286;"	d
EIGEN_USER_ALIGN_TO_BOUNDARY	../include/Eigen/src/Core/util/Macros.h	285;"	d
EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE_AND_SIZE	../include/Eigen/src/Core/Array.h	303;"	d
EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE	../include/Eigen/src/Core/Array.h	308;"	d
EIGEN_USING_ARRAY_TYPEDEFS	../include/Eigen/src/Core/Array.h	314;"	d
eigenvalues	../include/Eigen/src/Core/MatrixBase.h	/^    EigenvaluesReturnType eigenvalues() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
eigenvalues	../include/Eigen/src/Core/SelfAdjointView.h	/^    EigenvaluesReturnType eigenvalues() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
eigenvalues	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:() const
eigenvalues	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::EigenSolver	access:public	signature:() const
eigenvalues	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::eigenvalues() const$/;"	f	class:Eigen::MatrixBase	signature:() const
eigenvalues	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::eigenvalues() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
eigenvalues	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const RealVectorType& eigenvalues() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
EigenvaluesOnly	../include/Eigen/src/Core/util/Constants.h	/^  EigenvaluesOnly     = 0x40,$/;"	e	enum:Eigen::DecompositionOptions
EigenvaluesReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::traits<Derived>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::DenseBase	access:public
EigenvaluesReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef Matrix<std::complex<RealScalar>, internal::traits<Derived>::ColsAtCompileTime, 1, ColMajor> EigenvaluesReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
EigenvaluesReturnType	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef Matrix<RealScalar, internal::traits<MatrixType>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::SelfAdjointView	access:public
eigenvalues_selector	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector<Derived, false>$/;"	s	namespace:Eigen::internal
eigenvalues_selector	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector$/;"	s	namespace:Eigen::internal
EigenvalueType	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options&(~RowMajor), MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
EigenvalueType	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::EigenSolver	access:public
EigenvalueType	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealSchur	access:public
Eigen::VectorBlock::Base	../include/Eigen/src/Core/VectorBlock.h	/^                     internal::traits<VectorType>::Flags & RowMajorBit ? Size : 1> Base;$/;"	t	class:Eigen::VectorBlock	access:private
EIGEN_VECTORBLOCK_H	../include/Eigen/src/Core/VectorBlock.h	27;"	d
Eigen::VectorBlock	../include/Eigen/src/Core/VectorBlock.h	/^template<typename VectorType, int Size> class VectorBlock$/;"	c	namespace:Eigen	inherits:Block
Eigen::VectorBlock::IsColVector	../include/Eigen/src/Core/VectorBlock.h	/^      IsColVector = !(internal::traits<VectorType>::Flags & RowMajorBit)$/;"	e	enum:Eigen::VectorBlock::__anon49
Eigen::VectorBlock::VectorBlock	../include/Eigen/src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start)$/;"	f	class:Eigen::VectorBlock	access:public	signature:(VectorType& vector, Index start)
Eigen::VectorBlock::VectorBlock	../include/Eigen/src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start, Index size)$/;"	f	class:Eigen::VectorBlock	access:public	signature:(VectorType& vector, Index start, Index size)
eigenvectors	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvectorType& eigenvectors() const$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:() const
eigenvectors	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenvectorsType eigenvectors() const;$/;"	p	class:Eigen::EigenSolver	access:public	signature:() const
eigenvectors	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^typename EigenSolver<MatrixType>::EigenvectorsType EigenSolver<MatrixType>::eigenvectors() const$/;"	f	class:Eigen::EigenSolver	signature:() const
eigenvectors	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const MatrixType& eigenvectors() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
EigenvectorsType	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::EigenSolver	access:public
EigenvectorType	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorType;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Eigen::VectorwiseOp::all	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_all>::Type all() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::any	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_any>::Type any() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::blueNorm	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_blueNorm,RealScalar>::Type blueNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::count	../include/Eigen/src/Core/VectorwiseOp.h	/^    const PartialReduxExpr<ExpressionType, internal::member_count<Index>, Direction> count() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::cross	../include/Eigen/src/Core/VectorwiseOp.h	/^    const CrossReturnType cross(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::VectorwiseOp::cross	../include/Eigen/src/Geometry/OrthoMethods.h	/^VectorwiseOp<ExpressionType,Direction>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	signature:(const MatrixBase<OtherDerived>& other) const
Eigen::VectorwiseOp::CrossReturnType	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::PlainObject CrossReturnType;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::_expression	../include/Eigen/src/Core/VectorwiseOp.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::ExpressionTypeNestedCleaned	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::remove_all<ExpressionTypeNested>::type ExpressionTypeNestedCleaned;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::ExpressionTypeNested	../include/Eigen/src/Core/VectorwiseOp.h	/^        ExpressionType, ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::extendedTo	../include/Eigen/src/Core/VectorwiseOp.h	/^    extendedTo(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:(const DenseBase<OtherDerived>& other) const
Eigen::VectorwiseOp::ExtendedType	../include/Eigen/src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct ExtendedType {$/;"	s	class:Eigen::VectorwiseOp	access:protected
Eigen::VectorwiseOp::ExtendedType::Type	../include/Eigen/src/Core/VectorwiseOp.h	/^                        Direction==Horizontal ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::ExtendedType	access:public
Eigen::VectorwiseOp::HNormalized_Block	../include/Eigen/src/Core/VectorwiseOp.h	/^            HNormalized_Block;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::HNormalized_Factors	../include/Eigen/src/Core/VectorwiseOp.h	/^            HNormalized_Factors;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::hnormalized	../include/Eigen/src/Core/VectorwiseOp.h	/^    const HNormalizedReturnType hnormalized() const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::hnormalized	../include/Eigen/src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::hnormalized() const$/;"	f	class:Eigen::VectorwiseOp	signature:() const
Eigen::VectorwiseOp::HNormalizedReturnType	../include/Eigen/src/Core/VectorwiseOp.h	/^            HNormalizedReturnType;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::HNormalized_Size	../include/Eigen/src/Core/VectorwiseOp.h	/^      HNormalized_Size = Direction==Vertical ? internal::traits<ExpressionType>::RowsAtCompileTime$/;"	e	enum:Eigen::VectorwiseOp::__anon72
Eigen::VectorwiseOp::HNormalized_SizeMinusOne	../include/Eigen/src/Core/VectorwiseOp.h	/^      HNormalized_SizeMinusOne = HNormalized_Size==Dynamic ? Dynamic : HNormalized_Size-1$/;"	e	enum:Eigen::VectorwiseOp::__anon72
Eigen::VectorwiseOp::homogeneous	../include/Eigen/src/Core/VectorwiseOp.h	/^    Homogeneous<ExpressionType,Direction> homogeneous() const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::homogeneous	../include/Eigen/src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::homogeneous() const$/;"	f	class:Eigen::VectorwiseOp	signature:() const
Eigen::VectorwiseOp::hypotNorm	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_hypotNorm,RealScalar>::Type hypotNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp	../include/Eigen/src/Core/VectorwiseOp.h	/^template<typename ExpressionType, int Direction> class VectorwiseOp$/;"	c	namespace:Eigen
Eigen::VectorwiseOp::Index	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Index Index;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::IsHorizontal	../include/Eigen/src/Core/VectorwiseOp.h	/^      IsHorizontal = (Direction==Horizontal) ? 1 : 0$/;"	e	enum:Eigen::VectorwiseOp::__anon71
Eigen::VectorwiseOp::IsVertical	../include/Eigen/src/Core/VectorwiseOp.h	/^      IsVertical   = (Direction==Vertical) ? 1 : 0,$/;"	e	enum:Eigen::VectorwiseOp::__anon71
Eigen::VectorwiseOp::maxCoeff	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_maxCoeff>::Type maxCoeff() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::mean	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_mean>::Type mean() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::minCoeff	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_minCoeff>::Type minCoeff() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::m_matrix	../include/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::VectorwiseOp	access:protected
Eigen::VectorwiseOp::norm	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_norm,RealScalar>::Type norm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::operator =	../include/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::VectorwiseOp::operator -=	../include/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator-=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::VectorwiseOp::operator /=	../include/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator\/=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::VectorwiseOp::operator *=	../include/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator*=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::VectorwiseOp::operator +=	../include/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator+=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
Eigen::VectorwiseOp::operator -	../include/Eigen/src/Core/VectorwiseOp.h	/^    operator-(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
Eigen::VectorwiseOp::operator /	../include/Eigen/src/Core/VectorwiseOp.h	/^    operator\/(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
Eigen::VectorwiseOp::operator *	../include/Eigen/src/Core/VectorwiseOp.h	/^    operator*(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
Eigen::VectorwiseOp::operator +	../include/Eigen/src/Core/VectorwiseOp.h	/^    operator+(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
Eigen::VectorwiseOp::prod	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_prod>::Type prod() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::RealScalar	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::RealScalar RealScalar;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::redux	../include/Eigen/src/Core/VectorwiseOp.h	/^    redux(const BinaryOp& func = BinaryOp()) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const BinaryOp& func = BinaryOp()) const
Eigen::VectorwiseOp::ReduxReturnType	../include/Eigen/src/Core/VectorwiseOp.h	/^    template<typename BinaryOp> struct ReduxReturnType$/;"	s	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::ReduxReturnType::Type	../include/Eigen/src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReduxReturnType	access:public
Eigen::VectorwiseOp::replicate	../include/Eigen/src/Core/Replicate.h	/^VectorwiseOp<ExpressionType,Direction>::replicate(Index factor) const$/;"	f	class:Eigen::VectorwiseOp	signature:(Index factor) const
Eigen::VectorwiseOp::replicate	../include/Eigen/src/Core/VectorwiseOp.h	/^    const ReplicateReturnType replicate(Index factor) const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:(Index factor) const
Eigen::VectorwiseOp::replicate	../include/Eigen/src/Core/VectorwiseOp.h	/^    replicate(Index factor = Factor) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(Index factor = Factor) const
Eigen::VectorwiseOp::ReplicateReturnType	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef Replicate<ExpressionType,Direction==Vertical?Dynamic:1,Direction==Horizontal?Dynamic:1> ReplicateReturnType;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::ReturnType	../include/Eigen/src/Core/VectorwiseOp.h	/^                      typename Scalar=typename internal::traits<ExpressionType>::Scalar> struct ReturnType$/;"	s	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::ReturnType::Type	../include/Eigen/src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReturnType	access:public
Eigen::VectorwiseOp::reverse	../include/Eigen/src/Core/VectorwiseOp.h	/^    const Reverse<ExpressionType, Direction> reverse() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::Scalar	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::VectorwiseOp	access:public
Eigen::VectorwiseOp::squaredNorm	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_squaredNorm,RealScalar>::Type squaredNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::stableNorm	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_stableNorm,RealScalar>::Type stableNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::subVector	../include/Eigen/src/Core/VectorwiseOp.h	/^    SubVector subVector(Index i)$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:(Index i)
Eigen::VectorwiseOp::SubVector	../include/Eigen/src/Core/VectorwiseOp.h	/^                               typename ExpressionType::RowXpr>::type SubVector;$/;"	t	class:Eigen::VectorwiseOp	access:protected
Eigen::VectorwiseOp::subVectors	../include/Eigen/src/Core/VectorwiseOp.h	/^    Index subVectors() const$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:() const
Eigen::VectorwiseOp::sum	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_sum>::Type sum() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
Eigen::VectorwiseOp::VectorwiseOp	../include/Eigen/src/Core/VectorwiseOp.h	/^    inline VectorwiseOp(ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(ExpressionType& matrix)
EIGEN_VERSION_AT_LEAST	../include/Eigen/src/Core/util/Macros.h	33;"	d
Eigen::Vertical	../include/Eigen/src/Core/util/Constants.h	/^  Vertical, $/;"	e	enum:Eigen::DirectionType
Eigen::viewAsCholmod	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_dense viewAsCholmod(MatrixBase<Derived>& mat)$/;"	f	namespace:Eigen	signature:(MatrixBase<Derived>& mat)
Eigen::viewAsCholmod	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(const SparseSelfAdjointView<SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)$/;"	f	namespace:Eigen	signature:(const SparseSelfAdjointView<SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)
Eigen::viewAsCholmod	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen	signature:(SparseMatrix<_Scalar,_Options,_Index>& mat)
Eigen::viewAsCholmod	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^const cholmod_sparse viewAsCholmod(const SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen	signature:(const SparseMatrix<_Scalar,_Options,_Index>& mat)
Eigen::viewAsEigen	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> viewAsEigen(cholmod_sparse& cm)$/;"	f	namespace:Eigen	signature:(cholmod_sparse& cm)
EIGEN_VISITOR_H	../include/Eigen/src/Core/Visitor.h	26;"	d
EIGEN_WARNINGS_DISABLED	../include/Eigen/src/Core/util/DisableStupidWarnings.h	2;"	d
EIGEN_WARNINGS_DISABLED	../include/Eigen/src/Core/util/ReenableStupidWarnings.h	2;"	d
Eigen::WithFormat	../include/Eigen/src/Core/IO.h	/^class WithFormat$/;"	c	namespace:Eigen
Eigen::WithFormat::m_format	../include/Eigen/src/Core/IO.h	/^    IOFormat m_format;$/;"	m	class:Eigen::WithFormat	access:protected
Eigen::WithFormat::m_matrix	../include/Eigen/src/Core/IO.h	/^    const typename ExpressionType::Nested m_matrix;$/;"	m	class:Eigen::WithFormat	access:protected
Eigen::WithFormat::operator <<	../include/Eigen/src/Core/IO.h	/^    friend std::ostream & operator << (std::ostream & s, const WithFormat& wf)$/;"	f	class:Eigen::WithFormat	access:friend	signature:(std::ostream & s, const WithFormat& wf)
Eigen::WithFormat::WithFormat	../include/Eigen/src/Core/IO.h	/^    WithFormat(const ExpressionType& matrix, const IOFormat& format)$/;"	f	class:Eigen::WithFormat	access:public	signature:(const ExpressionType& matrix, const IOFormat& format)
EIGEN_WORKAROUND_MSVC_STL_SUPPORT	../include/Eigen/src/StlSupport/details.h	69;"	d
EIGEN_WORLD_VERSION	../include/Eigen/src/Core/util/Macros.h	29;"	d
Eigen::WriteAccessors	../include/Eigen/src/Core/util/Constants.h	/^  WriteAccessors, $/;"	e	enum:Eigen::AccessorLevels
EIGEN_XPRHELPER_H	../include/Eigen/src/Core/util/XprHelper.h	27;"	d
Eigen::ZeroDiag	../include/Eigen/src/Core/util/Constants.h	/^  ZeroDiag=0x8,$/;"	e	enum:Eigen::__anon207
EigVecMask	../include/Eigen/src/Core/util/Constants.h	/^  EigVecMask = EigenvaluesOnly | ComputeEigenvectors,$/;"	e	enum:Eigen::DecompositionOptions
ei_handmade_aligned_free	../include/Eigen/src/Eigen2Support/Memory.h	/^inline void  ei_handmade_aligned_free(void *ptr) { internal::handmade_aligned_free(ptr); }$/;"	f	namespace:Eigen	signature:(void *ptr)
ei_handmade_aligned_malloc	../include/Eigen/src/Eigen2Support/Memory.h	/^inline void* ei_handmade_aligned_malloc(size_t size) { return internal::handmade_aligned_malloc(size); }$/;"	f	namespace:Eigen	signature:(size_t size)
ei_imag	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_imag(const T& x) { return internal::imag(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_internal_assert	../include/Eigen/src/Eigen2Support/Macros.h	29;"	d
ei_isApprox	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^inline bool ei_isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
ei_isApproxOrLessThan	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^inline bool ei_isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
ei_isMuchSmallerThan	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^inline bool ei_isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen	signature:(const Scalar& x, const OtherScalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
ei_is_same_type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_is_same_type<T,T> { enum { ret = 1 }; };$/;"	s	namespace:Eigen
ei_is_same_type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T, typename U> struct ei_is_same_type { enum { ret = 0 }; };$/;"	s	namespace:Eigen
ei_log	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_log (const T& x) { return internal::log(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_meta_false	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_false { enum { ret = 0 }; };$/;"	s	namespace:Eigen
ei_meta_if	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if <false, Then, Else> { typedef Else ret; };$/;"	s	namespace:Eigen
ei_meta_if	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if { typedef Then ret; };$/;"	s	namespace:Eigen
ei_meta_sqrt	../include/Eigen/src/Eigen2Support/Meta.h	/^class ei_meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	c
ei_meta_sqrt::ret	../include/Eigen/src/Eigen2Support/Meta.h	/^class ei_meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:ei_meta_sqrt::__anon430
ei_meta_true	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_true {  enum { ret = 1 }; };$/;"	s	namespace:Eigen
ei_pow	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_pow (const T& x,const T& y) { return internal::pow(x,y); }$/;"	f	namespace:Eigen	signature:(const T& x,const T& y)
ei_quaternion_assign_impl	../include/Eigen/src/Eigen2Support/Geometry/All.h	61;"	d
ei_quaternion_assign_impl	../include/Eigen/src/Eigen2Support/Geometry/All.h	76;"	d
ei_quaternion_assign_impl	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^struct ei_quaternion_assign_impl<Other,3,3>$/;"	s	namespace:Eigen
ei_quaternion_assign_impl	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^struct ei_quaternion_assign_impl<Other,4,1>$/;"	s	namespace:Eigen
ei_quaternion_product	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^ei_quaternion_product(const Quaternion<Scalar>& a, const Quaternion<Scalar>& b)$/;"	f	namespace:Eigen	signature:(const Quaternion<Scalar>& a, const Quaternion<Scalar>& b)
ei_random	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_random (const T& x, const T& y) { return internal::random(x, y); }$/;"	f	namespace:Eigen	signature:(const T& x, const T& y)
ei_random	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_random () { return internal::random<T>(); }$/;"	f	namespace:Eigen	signature:()
ei_real	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_real(const T& x) { return internal::real(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_sin	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_sin (const T& x) { return internal::sin(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_sqrt	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_sqrt(const T& x) { return internal::sqrt(x); }$/;"	f	namespace:Eigen	signature:(const T& x)
ei_toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/All.h	60;"	d
ei_toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/All.h	75;"	d
ei_toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^static inline const MatrixBase<OtherDerived>& ei_toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen	signature:(const MatrixBase<OtherDerived>& mat)
ei_toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^static inline Matrix<Scalar,2,2> ei_toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen	signature:(const Scalar& s)
ei_toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^static inline Matrix<Scalar,Dim,Dim> ei_toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen	signature:(const RotationBase<OtherDerived,Dim>& r)
ei_traits	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^template<typename _Scalar> struct ei_traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen
ei_traits	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^template<typename _Scalar> struct ei_traits<Quaternion<_Scalar> >$/;"	s	namespace:Eigen
ei_traits	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^template<typename _Scalar> struct ei_traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen
ei_traits	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_traits : internal::traits<T>$/;"	s	namespace:Eigen	inherits:internal::traits
ei_transform_product_impl	../include/Eigen/src/Eigen2Support/Geometry/All.h	62;"	d
ei_transform_product_impl	../include/Eigen/src/Eigen2Support/Geometry/All.h	77;"	d
ei_transform_product_impl	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, Dim,1>$/;"	s	namespace:Eigen
ei_transform_product_impl	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen
ei_transform_product_impl	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, HDim,1>$/;"	s	namespace:Eigen
ei_transform_product_impl	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen
ei_unconst	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<const T> { typedef T type; };$/;"	s	namespace:Eigen
ei_unconst	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const *> { typedef T * type; };$/;"	s	namespace:Eigen
ei_unconst	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const &> { typedef T & type; };$/;"	s	namespace:Eigen
ei_unconst	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst { typedef T type; };$/;"	s	namespace:Eigen
ei_unpointer	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen
ei_unpointer	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*> { typedef T type; };$/;"	s	namespace:Eigen
ei_unpointer	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer { typedef T type; };$/;"	s	namespace:Eigen
ei_unref	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref<T&> { typedef T type; };$/;"	s	namespace:Eigen
ei_unref	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref { typedef T type; };$/;"	s	namespace:Eigen
elseMatrix	../include/Eigen/src/Core/Select.h	/^    const ElseMatrixType& elseMatrix() const$/;"	f	class:Eigen::Select	access:public	signature:() const
ElseMatrixNested	../include/Eigen/src/Core/Select.h	/^  typedef typename ElseMatrixType::Nested ElseMatrixNested;$/;"	t	struct:Eigen::internal::traits	access:public
enable_if	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct enable_if<true,T>$/;"	s	namespace:Eigen::internal
endFill	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void endFill() {}$/;"	f	class:Eigen::SparseVector	access:public	signature:()
end	../include/Eigen/src/Core/MatrixBase.h	/^    const VectorBlock<const Derived> end(Index size) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size) const
end	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Size> const VectorBlock<const Derived,Size> end() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
end	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Size> VectorBlock<Derived,Size> end();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
end	../include/Eigen/src/Core/MatrixBase.h	/^    VectorBlock<Derived> end(Index size);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size)
end	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end() const$/;"	f	class:Eigen::MatrixBase	signature:() const
end	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end()$/;"	f	class:Eigen::MatrixBase	signature:()
end	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end(Index size) const$/;"	f	class:Eigen::MatrixBase	signature:(Index size) const
end	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end(Index size)$/;"	f	class:Eigen::MatrixBase	signature:(Index size)
epsilon	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    RealScalar epsilon;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func	access:public
error	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar error() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
essentialVector	../include/Eigen/src/Householder/HouseholderSequence.h	/^    const EssentialVectorType essentialVector(Index k) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Index k) const
essentialVector	../include/Eigen/src/Householder/HouseholderSequence.h	/^  static inline const EssentialVectorType essentialVector(const HouseholderSequenceType& h, Index k)$/;"	f	struct:Eigen::internal::hseq_side_dependent_impl	access:public	signature:(const HouseholderSequenceType& h, Index k)
EssentialVectorType	../include/Eigen/src/Householder/HouseholderSequence.h	/^            EssentialVectorType;$/;"	t	class:Eigen::HouseholderSequence	access:private
EssentialVectorType	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef Block<const VectorsType, Dynamic, 1> EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
EssentialVectorType	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef Transpose<Block<const VectorsType, 1, Dynamic> > EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
eulerAngles	../include/Eigen/src/Core/MatrixBase.h	/^    Matrix<Scalar,3,1> eulerAngles(Index a0, Index a1, Index a2) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index a0, Index a1, Index a2) const
eulerAngles	../include/Eigen/src/Geometry/EulerAngles.h	/^MatrixBase<Derived>::eulerAngles(Index a0, Index a1, Index a2) const$/;"	f	class:Eigen::MatrixBase	signature:(Index a0, Index a1, Index a2) const
EvalBeforeAssigningBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int EvalBeforeAssigningBit = 0x4;$/;"	m	namespace:Eigen
EvalBeforeNestingBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int EvalBeforeNestingBit = 0x2;$/;"	m	namespace:Eigen
eval	../include/Eigen/src/Core/DenseBase.h	/^    EIGEN_STRONG_INLINE EvalReturnType eval() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
eval	../include/Eigen/src/Core/PermutationMatrix.h	/^    PlainPermutationType eval() const { return *this; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
eval	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const typename internal::eval<Derived>::type eval() const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
eval	../include/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct eval<T,Sparse>$/;"	s	namespace:Eigen::internal	inherits:sparse_eval
EvalReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::add_const_on_value_type<typename internal::eval<Derived>::type>::type EvalReturnType;$/;"	t	class:Eigen::DenseBase	access:public
evalTo	../include/Eigen/src/Cholesky/LDLT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Cholesky/LLT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline void evalTo(Dest& dst) const { dst = m_expression; }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Core/BandMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Core/DenseBase.h	/^    template<typename Dest> inline void evalTo(Dest& ) const$/;"	f	class:Eigen::DenseBase	access:public	signature:(Dest& ) const
evalTo	../include/Eigen/src/Core/DiagonalMatrix.h	/^void DiagonalBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase	signature:(MatrixBase<DenseDerived> &other) const
evalTo	../include/Eigen/src/Core/DiagonalMatrix.h	/^    void evalTo(MatrixBase<DenseDerived> &other) const;$/;"	p	class:Eigen::DiagonalBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
evalTo	../include/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Core/PermutationMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::PermutationBase	access:public	signature:(MatrixBase<DenseDerived>& other) const
evalTo	../include/Eigen/src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::Transpose	access:public	signature:(MatrixBase<DenseDerived>& other) const
evalTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst,Scalar(1)); }$/;"	f	class:Eigen::ProductBase	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst, Scalar(1)); }$/;"	f	class:Eigen::ScaledProduct	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Core/ReturnByValue.h	/^    inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::ReturnByValue	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Core/SolveTriangular.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Core/Transpositions.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Core/TriangularMatrix.h	/^    void evalTo(MatrixBase<DenseDerived> &other) const;$/;"	p	class:Eigen::TriangularBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
evalTo	../include/Eigen/src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase	signature:(MatrixBase<DenseDerived> &other) const
evalTo	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:(ResultType& result) const
evalTo	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:(ResultType& result) const
evalTo	../include/Eigen/src/Geometry/Homogeneous.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Geometry/Homogeneous.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/Householder/HouseholderSequence.h	/^    template<typename DestType> inline void evalTo(DestType& dst) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(DestType& dst) const
evalTo	../include/Eigen/src/Householder/HouseholderSequence.h	/^    void evalTo(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Dest& dst, Workspace& workspace) const
evalTo	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/LU/Inverse.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/LU/PartialPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/misc/Image.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/misc/Kernel.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/misc/Solve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/misc/SparseSolve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/misc/SparseSolve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:(ResultType& result) const
evalTo	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result, WorkVectorType& workspace) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:(ResultType& result, WorkVectorType& workspace) const
evalTo	../include/Eigen/src/QR/HouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      void evalTo(MatrixBase<DenseDerived>& dst) const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(MatrixBase<DenseDerived>& dst) const
evalTo	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/SparseCore/SparseProduct.h	/^    void evalTo(Dest& result) const$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(Dest& result) const
evalTo	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestScalar,int StorageOrder> void evalTo(SparseMatrix<DestScalar,StorageOrder,Index>& _dest) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(SparseMatrix<DestScalar,StorageOrder,Index>& _dest) const
evalTo	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestScalar> void evalTo(DynamicSparseMatrix<DestScalar,ColMajor,Index>& _dest) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(DynamicSparseMatrix<DestScalar,ColMajor,Index>& _dest) const
evalTo	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestType,unsigned int DestUpLo> void evalTo(SparseSelfAdjointView<DestType,DestUpLo>& dest) const$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:(SparseSelfAdjointView<DestType,DestUpLo>& dest) const
evalTo	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    void evalTo(SparseMatrix<DestScalar,Options,DstIndex>& _dest) const$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:(SparseMatrix<DestScalar,Options,DstIndex>& _dest) const
evalTo	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/SVD/JacobiSVD.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval	access:public	signature:(Dest& dst) const
evalTo	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval	access:public	signature:(Dest& dst) const
evalToLazy	../include/Eigen/src/Core/TriangularMatrix.h	/^    void evalToLazy(MatrixBase<DenseDerived> &other) const;$/;"	p	class:Eigen::TriangularBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
evalToLazy	../include/Eigen/src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalToLazy(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase	signature:(MatrixBase<DenseDerived> &other) const
EvalToRowMajor	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      EvalToRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon87
EvalToRowMajor	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EvalToRowMajor = (RhsFlags & LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon17
exp	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixExponentialReturnValue<Derived> exp() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
exp	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_exp_op)      exp() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
exp	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::exp() const$/;"	f	class:Eigen::Cwise	signature:() const
exp	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^exp() const$/;"	f	signature:() const
_expression	../include/Eigen/src/Core/Flagged.h	/^    const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
_expression	../include/Eigen/src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& _expression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
expression	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    Lhs& expression() const $/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
expression	../include/Eigen/src/Core/Swap.h	/^    ExpressionType& expression() const { return m_expression; }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
_expression	../include/Eigen/src/Core/VectorwiseOp.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
_expression	../include/Eigen/src/Eigen2Support/Cwise.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::Cwise	access:public	signature:() const
ExpressionType	../include/Eigen/src/Core/SelfAdjointView.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits	access:public
ExpressionType	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits	access:public
ExpressionTypeNestedCleaned	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::remove_all<ExpressionTypeNested>::type ExpressionTypeNestedCleaned;$/;"	t	class:Eigen::VectorwiseOp	access:public
ExpressionTypeNested	../include/Eigen/src/Core/Flagged.h	/^        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::Flagged	access:public
ExpressionTypeNested	../include/Eigen/src/Core/VectorwiseOp.h	/^        ExpressionType, ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::VectorwiseOp	access:public
ExpressionTypeNested	../include/Eigen/src/Eigen2Support/Cwise.h	/^        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::Cwise	access:public
extendedTo	../include/Eigen/src/Core/VectorwiseOp.h	/^    extendedTo(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:(const DenseBase<OtherDerived>& other) const
ExtendedType	../include/Eigen/src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct ExtendedType {$/;"	s	class:Eigen::VectorwiseOp	access:protected
extend	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
extend	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const VectorType& p)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p)
extend	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b)
extend	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const MatrixBase<Derived>& a_p)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& a_p)
exteriorDistance	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline Scalar exteriorDistance(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p) const
exteriorDistance	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline NonInteger exteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
exteriorDistance	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline NonInteger exteriorDistance(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& p) const
extract_data	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename T> const typename T::Scalar* extract_data(const T& m)$/;"	f	namespace:Eigen::internal	signature:(const T& m)
extractData	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void extractData() const;$/;"	p	class:Eigen::SuperLUBase	access:protected	signature:() const
extractData	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLUBase<MatrixType,Derived>::extractData() const$/;"	f	class:Eigen::SuperLUBase	signature:() const
extractData	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void extractData() const;$/;"	p	class:Eigen::UmfPackLU	access:public	signature:() const
extractData	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^void UmfPackLU<MatrixType>::extractData() const$/;"	f	class:Eigen::UmfPackLU	signature:() const
extract_data_selector	../include/Eigen/src/Core/util/BlasUtil.h	/^struct extract_data_selector {$/;"	s	namespace:Eigen::internal
extract_data_selector	../include/Eigen/src/Core/util/BlasUtil.h	/^struct extract_data_selector<T,false> {$/;"	s	namespace:Eigen::internal
extract	../include/Eigen/src/Core/Transpose.h	/^  static inline const XprType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
extract	../include/Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
extract	../include/Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
extractScalarFactor	../include/Eigen/src/Core/util/BlasUtil.h	/^  static inline const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType&)
extractScalarFactor	../include/Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x)$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
extractScalarFactor	../include/Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return Base::extractScalarFactor(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
extractScalarFactor	../include/Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return conj(Base::extractScalarFactor(x.nestedExpression())); }$/;"	f	struct:Eigen::internal::blas_traits	access:public	signature:(const XprType& x)
ExtractType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef const XprType& ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
ExtractType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType>  ExtractType; \/\/ const to get rid of a compile error; anyway blas traits are only used on the RHS$/;"	t	struct:Eigen::internal::blas_traits	access:public
_ExtractType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType> _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
ExtractType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename Base::ExtractType ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
_ExtractType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef XprType _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Factor	../include/Eigen/src/Core/Replicate.h	/^    Factor = (RowFactor==Dynamic || ColFactor==Dynamic) ? Dynamic : RowFactor*ColFactor$/;"	e	enum:Eigen::internal::traits::__anon66
factor	../include/Eigen/src/Geometry/Scaling.h	/^  inline const Scalar& factor() const { return m_factor; }$/;"	f	class:Eigen::UniformScaling	access:public	signature:() const
factor	../include/Eigen/src/Geometry/Scaling.h	/^  inline Scalar& factor() { return m_factor; }$/;"	f	class:Eigen::UniformScaling	access:public	signature:()
factorizeAugmentedSystems	../include/abcd.h	/^    void factorizeAugmentedSystems();$/;"	p	class:abcd	access:private	signature:()
factorizeAugmentedSystems	../src/mumps.cpp	/^void abcd::factorizeAugmentedSystems()$/;"	f	class:abcd	signature:()
factorize	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixType& matrix)
factorize	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& factorize(const MatrixType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatrixType& mat)
factorize	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& factorize(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
factorize	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void factorize(const MatrixType& amat);$/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& amat)
factorize	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::factorize(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT	signature:(const _MatrixType& amat)
factorize	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& factorize(const MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const MatrixType& A)
factorize	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Derived& factorize(const MatrixType& matrix);$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixType& matrix)
factorize	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::factorize(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixType& a)
factorize	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(ColSpMatrix& mat);$/;"	p	class:Eigen::PastixBase	access:protected	signature:(ColSpMatrix& mat)
factorize	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
factorize	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
factorize	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
factorize	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::factorize(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase	signature:(ColSpMatrix& mat)
factorize	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& a)
factorize	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& a)
factorize	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& a)
factorize	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& a)
factorize	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void factorize(const MatrixType& matrix);$/;"	p	class:Eigen::SuperILU	access:public	signature:(const MatrixType& matrix)
factorize	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void factorize(const MatrixType& matrix);$/;"	p	class:Eigen::SuperLU	access:public	signature:(const MatrixType& matrix)
factorize	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperILU	signature:(const MatrixType& a)
factorize	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperLU	signature:(const MatrixType& a)
factorize	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixType& matrix)
factorize_preordered	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize_preordered(const CholMatrixType& a);$/;"	p	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const CholMatrixType& a)
factorize_preordered	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::factorize_preordered(const CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase	signature:(const CholMatrixType& ap)
FactorType	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,RowMajor> FactorType;$/;"	t	class:Eigen::IncompleteLUT	access:private
false_type	../include/Eigen/src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
fill	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE void DenseBase<Derived>::fill(const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& value)
fill	../include/Eigen/src/Core/DenseBase.h	/^    void fill(const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value)
fill	../include/Eigen/src/Core/TriangularMatrix.h	/^    void fill(const Scalar& value) { setConstant(value); }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const Scalar& value)
fill	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
fill	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index r, Index c)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index r, Index c)
fillrand	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
fillrand	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index r, Index c)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index r, Index c)
finalize	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void finalize()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
finalize	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline void finalize() {}$/;"	f	class:Eigen::SparseVector	access:public	signature:()
findSmallSubdiagEntry	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    Index findSmallSubdiagEntry(Index iu, Scalar norm);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index iu, Scalar norm)
findSmallSubdiagEntry	../include/Eigen/src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Index RealSchur<MatrixType>::findSmallSubdiagEntry(Index iu, Scalar norm)$/;"	f	class:Eigen::RealSchur	signature:(Index iu, Scalar norm)
finished	../include/Eigen/src/Core/CommaInitializer.h	/^  inline XprType& finished() { return m_xpr; }$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:()
first_aligned_impl	../include/Eigen/src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl<Derived, false>$/;"	s	namespace:Eigen::internal
first_aligned_impl	../include/Eigen/src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl$/;"	s	namespace:Eigen::internal
first_aligned	../include/Eigen/src/Core/DenseCoeffsBase.h	/^static inline typename Derived::Index first_aligned(const Derived& m)$/;"	f	namespace:Eigen::internal	signature:(const Derived& m)
first_aligned	../include/Eigen/src/Core/util/Memory.h	/^static inline Index first_aligned(const Scalar* array, Index size)$/;"	f	namespace:Eigen::internal	signature:(const Scalar* array, Index size)
first	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacket first;$/;"	m	struct:Eigen::internal::gebp_traits::DoublePacket	access:public
fitHyperplane	../include/Eigen/src/Eigen2Support/LeastSquares.h	/^void fitHyperplane(int numPoints,$/;"	f	namespace:Eigen	signature:(int numPoints, VectorType **points, HyperplaneType *result, typename NumTraits<typename VectorType::Scalar>::Real* soundness = 0)
FixedSegmentReturnType	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	s	class:Eigen::DenseBase	access:public
flagged	../include/Eigen/src/Core/DenseBase.h	/^    const Flagged<Derived, Added, Removed> flagged() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
flagged	../include/Eigen/src/Core/Flagged.h	/^DenseBase<Derived>::flagged() const$/;"	f	class:Eigen::DenseBase	signature:() const
Flagged	../include/Eigen/src/Core/Flagged.h	/^    inline Flagged(const ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Flagged	access:public	signature:(const ExpressionType& matrix)
Flagged	../include/Eigen/src/Core/Flagged.h	/^template<typename ExpressionType, unsigned int Added, unsigned int Removed> class Flagged$/;"	c	namespace:Eigen	inherits:MatrixBase
Flags0	../include/Eigen/src/Core/Block.h	/^    Flags0 = traits<XprType>::Flags & ( (HereditaryBits & ~RowMajorBit) |$/;"	e	enum:Eigen::internal::traits::__anon228
Flags0	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    Flags0 = (int(LhsFlags) | int(RhsFlags)) & ($/;"	e	enum:Eigen::internal::traits::__anon65
Flags0	../include/Eigen/src/Core/Map.h	/^    Flags0 = TraitsBase::Flags & (~NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon285
Flags0	../include/Eigen/src/Core/Transpose.h	/^    Flags0 = MatrixTypeNestedPlain::Flags & ~(LvalueBit | NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon73
Flags0	../include/Eigen/src/Core/VectorwiseOp.h	/^    Flags0 = (unsigned int)_MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon68
Flags1	../include/Eigen/src/Core/Map.h	/^    Flags1 = IsAligned ? (int(Flags0) | AlignedBit) : (int(Flags0) & ~AlignedBit),$/;"	e	enum:Eigen::internal::traits::__anon285
Flags1	../include/Eigen/src/Core/Transpose.h	/^    Flags1 = Flags0 | FlagsLvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon73
Flags2	../include/Eigen/src/Core/Map.h	/^    Flags2 = (bool(HasNoStride) || bool(PlainObjectType::IsVectorAtCompileTime))$/;"	e	enum:Eigen::internal::traits::__anon285
Flags3	../include/Eigen/src/Core/Map.h	/^    Flags3 = is_lvalue<PlainObjectType>::value ? int(Flags2) : (int(Flags2) & ~LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon285
Flags	../include/Eigen/src/Core/BandMatrix.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Flags	../include/Eigen/src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon81
Flags	../include/Eigen/src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon82
Flags	../include/Eigen/src/Core/Block.h	/^    Flags = Flags0 | FlagsLinearAccessBit | FlagsLvalueBit | FlagsRowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon228
Flags	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon65
Flags	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    Flags = (traits<PlainObjectType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon287
Flags	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    Flags = _XprTypeNested::Flags & ($/;"	e	enum:Eigen::internal::traits::__anon59
Flags	../include/Eigen/src/Core/CwiseUnaryView.h	/^    Flags = (traits<_MatrixTypeNested>::Flags & (HereditaryBits | LvalueBit | LinearAccessBit | DirectAccessBit)),$/;"	e	enum:Eigen::internal::traits::__anon232
Flags	../include/Eigen/src/Core/DenseBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::DenseBase::__anon216
Flags	../include/Eigen/src/Core/DiagonalMatrix.h	/^      Flags = 0$/;"	e	enum:Eigen::DiagonalBase::__anon279
Flags	../include/Eigen/src/Core/DiagonalMatrix.h	/^    Flags = LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon280
Flags	../include/Eigen/src/Core/DiagonalMatrix.h	/^    Flags =  traits<DiagonalVectorType>::Flags & LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon281
Flags	../include/Eigen/src/Core/DiagonalProduct.h	/^    Flags = (HereditaryBits & (unsigned int)(MatrixType::Flags)) | (_Vectorizable ? PacketAccessBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon77
Flags	../include/Eigen/src/Core/Flagged.h	/^  enum { Flags = (ExpressionType::Flags | Added) & ~Removed };$/;"	e	enum:Eigen::internal::traits::__anon56
flags	../include/Eigen/src/Core/IO.h	/^  int flags;$/;"	m	struct:Eigen::IOFormat	access:public
Flags	../include/Eigen/src/Core/Map.h	/^    Flags = KeepsPacketAccess ? int(Flags3) : (int(Flags3) & ~PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon285
Flags	../include/Eigen/src/Core/Matrix.h	/^    Flags = compute_matrix_flags<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::ret,$/;"	e	enum:Eigen::internal::traits::__anon289
Flags	../include/Eigen/src/Core/PermutationMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon118
Flags	../include/Eigen/src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::PermutationBase::__anon117
Flags	../include/Eigen/src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::Transpose::__anon119
Flags	../include/Eigen/src/Core/ProductBase.h	/^    Flags = (MaxRowsAtCompileTime==1 ? RowMajorBit : 0)$/;"	e	enum:Eigen::internal::traits::__anon288
Flags	../include/Eigen/src/Core/Product.h	/^    Flags = (MaxRowsAtCompileTime==1 ? RowMajorBit : 0), \/\/ TODO should be no storage order$/;"	e	enum:internal::traits::__anon48
Flags	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      Flags = ((unsigned int)(LhsFlags | RhsFlags) & HereditaryBits & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon87
Flags	../include/Eigen/src/Core/Replicate.h	/^    Flags = (_MatrixTypeNested::Flags & HereditaryBits & ~RowMajorBit) | (IsRowMajor ? RowMajorBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon67
Flags	../include/Eigen/src/Core/ReturnByValue.h	/^    Flags = (traits<typename traits<Derived>::ReturnType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon58
Flags	../include/Eigen/src/Core/Reverse.h	/^    Flags = int(_MatrixTypeNested::Flags) & (HereditaryBits | LvalueBit | PacketAccessBit | LinearAccess),$/;"	e	enum:Eigen::internal::traits::__anon115
Flags	../include/Eigen/src/Core/Select.h	/^    Flags = (unsigned int)ThenMatrixType::Flags & ElseMatrixType::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon60
Flags	../include/Eigen/src/Core/SelfAdjointView.h	/^    Flags =  MatrixTypeNestedCleaned::Flags & (HereditaryBits)$/;"	e	enum:Eigen::internal::traits::__anon83
Flags	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    Flags = traits<CwiseBinaryOp<BinaryOp,Lhs,Rhs> >::Flags | (Lhs::Flags&DirectAccessBit) | (Lhs::Flags&LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon50
Flags	../include/Eigen/src/Core/Transpose.h	/^    Flags = Flags1 ^ RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon73
Flags	../include/Eigen/src/Core/TriangularMatrix.h	/^    Flags = (MatrixTypeNestedCleaned::Flags & (HereditaryBits) & (~(PacketAccessBit | DirectAccessBit | LinearAccessBit))) | Mode,$/;"	e	enum:Eigen::internal::traits::__anon234
Flags	../include/Eigen/src/Core/VectorwiseOp.h	/^    Flags = (Flags0 & ~RowMajorBit) | (RowsAtCompileTime == 1 ? RowMajorBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon68
Flags	../include/Eigen/src/Eigen2Support/Minor.h	/^    Flags = _MatrixTypeNested::Flags & (HereditaryBits | LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon441
Flags	../include/Eigen/src/Geometry/Homogeneous.h	/^    Flags = ColsAtCompileTime==1 ? (TmpFlags & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon390
Flags	../include/Eigen/src/Geometry/Quaternion.h	/^    Flags = Eigen::internal::traits<Derived>::Flags$/;"	e	enum:Eigen::QuaternionBase::__anon385
Flags	../include/Eigen/src/Geometry/Quaternion.h	/^    Flags = IsAligned ? (AlignedBit | LvalueBit) : LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon386
Flags	../include/Eigen/src/Geometry/Quaternion.h	/^      Flags = TraitsBase::Flags$/;"	e	enum:Eigen::internal::traits::__anon388
Flags	../include/Eigen/src/Geometry/Quaternion.h	/^      Flags = TraitsBase::Flags & ~LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon389
Flags	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon7
Flags	../include/Eigen/src/SparseCore/SparseBlock.h	/^    Flags = MatrixType::Flags,$/;"	e	enum:Eigen::internal::traits::__anon20
Flags	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    Flags = Tr ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon30
Flags	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    Flags = (SparseFlags&RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon35
Flags	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
Flags	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon32
Flags	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = _Options | NestByRefBit | LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon31
Flags	../include/Eigen/src/SparseCore/SparseProduct.h	/^    Flags = (int(LhsFlags | RhsFlags) & HereditaryBits & RemovedBits)$/;"	e	enum:Eigen::internal::traits::__anon17
_Flags	../include/Eigen/src/SparseCore/SparseUtil.h	/^    enum { _Flags = traits<T>::Flags };$/;"	e	enum:Eigen::internal::sparse_eval::__anon13
_Flags	../include/Eigen/src/SparseCore/SparseUtil.h	/^    enum { _Flags = traits<T>::Flags| RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_eval::__anon11
_Flags	../include/Eigen/src/SparseCore/SparseUtil.h	/^    enum { _Flags = traits<T>::Flags & (~RowMajorBit) };$/;"	e	enum:Eigen::internal::sparse_eval::__anon12
_Flags	../include/Eigen/src/SparseCore/SparseUtil.h	/^          _Flags = traits<T>::Flags$/;"	e	enum:Eigen::internal::plain_matrix_type::__anon14
Flags	../include/Eigen/src/SparseCore/SparseVector.h	/^    Flags = _Options | NestByRefBit | LvalueBit | (IsColVector ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon25
Flags	../include/Eigen/src/SparseCore/SparseView.h	/^    Flags = int(traits<MatrixType>::Flags) & (RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon38
FlagsLinearAccessBit	../include/Eigen/src/Core/Block.h	/^    FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1) ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon228
FlagsLvalueBit	../include/Eigen/src/Core/Block.h	/^    FlagsLvalueBit = is_lvalue<XprType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon228
FlagsLvalueBit	../include/Eigen/src/Core/Transpose.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon73
FlagsRowMajorBit	../include/Eigen/src/Core/Block.h	/^    FlagsRowMajorBit = IsRowMajor ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon228
FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED	../include/Eigen/src/Core/util/StaticAssert.h	/^        FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
floor_log2_bogus	../include/Eigen/src/Core/MathFunctions.h	/^  floor_log2_bogus$/;"	e	enum:Eigen::internal::__anon262
floor_log2	../include/Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_bogus>$/;"	s	namespace:Eigen::internal
floor_log2	../include/Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_move_down>$/;"	s	namespace:Eigen::internal
floor_log2	../include/Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_move_up>$/;"	s	namespace:Eigen::internal
floor_log2	../include/Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_terminate>$/;"	s	namespace:Eigen::internal
floor_log2	../include/Eigen/src/Core/MathFunctions.h	/^struct floor_log2 {};$/;"	s	namespace:Eigen::internal
floor_log2_move_down	../include/Eigen/src/Core/MathFunctions.h	/^  floor_log2_move_down,$/;"	e	enum:Eigen::internal::__anon262
floor_log2_move_up	../include/Eigen/src/Core/MathFunctions.h	/^  floor_log2_move_up,$/;"	e	enum:Eigen::internal::__anon262
floor_log2_selector	../include/Eigen/src/Core/MathFunctions.h	/^template<unsigned int n, int lower, int upper> struct floor_log2_selector$/;"	s	namespace:Eigen::internal
floor_log2_terminate	../include/Eigen/src/Core/MathFunctions.h	/^  floor_log2_terminate,$/;"	e	enum:Eigen::internal::__anon262
forceAlignedAccessIf	../include/Eigen/src/Core/DenseBase.h	/^    template<bool Enable> inline const typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
forceAlignedAccessIf	../include/Eigen/src/Core/DenseBase.h	/^    template<bool Enable> inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
forceAlignedAccessIf	../include/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf() const$/;"	f	class:Eigen::MatrixBase	signature:() const
forceAlignedAccessIf	../include/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf()$/;"	f	class:Eigen::MatrixBase	signature:()
forceAlignedAccessIf	../include/Eigen/src/Core/MatrixBase.h	/^    template<bool Enable> inline typename internal::add_const_on_value_type<typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type>::type forceAlignedAccessIf() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
forceAlignedAccessIf	../include/Eigen/src/Core/MatrixBase.h	/^    template<bool Enable> inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
forceAlignedAccess	../include/Eigen/src/Core/DenseBase.h	/^    inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
forceAlignedAccess	../include/Eigen/src/Core/DenseBase.h	/^    inline ForceAlignedAccess<Derived> forceAlignedAccess();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
ForceAlignedAccess	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline ForceAlignedAccess(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(const ExpressionType& matrix)
forceAlignedAccess	../include/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess() const$/;"	f	class:Eigen::MatrixBase	signature:() const
forceAlignedAccess	../include/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess()$/;"	f	class:Eigen::MatrixBase	signature:()
ForceAlignedAccess	../include/Eigen/src/Core/ForceAlignedAccess.h	/^template<typename ExpressionType> class ForceAlignedAccess$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
forceAlignedAccess	../include/Eigen/src/Core/MatrixBase.h	/^    inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
forceAlignedAccess	../include/Eigen/src/Core/MatrixBase.h	/^    inline ForceAlignedAccess<Derived> forceAlignedAccess();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
format	../include/Eigen/src/Core/DenseBase.h	/^    inline const WithFormat<Derived> format(const IOFormat& fmt) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const IOFormat& fmt) const
format	../include/Eigen/src/Core/IO.h	/^DenseBase<Derived>::format(const IOFormat& fmt) const$/;"	f	class:Eigen::DenseBase	signature:(const IOFormat& fmt) const
fortran_to_c_numbering	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void fortran_to_c_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat)
fromPositionOrientationScale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  Transform& fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
fromPositionOrientationScale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
fromPositionOrientationScale	../include/Eigen/src/Geometry/Transform.h	/^  Transform& fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
fromPositionOrientationScale	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<PositionDerived> &position, const OrientationType& orientation, const MatrixBase<ScaleDerived> &scale)
fromRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
fromRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  Rotation2D& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::Rotation2D	access:public	signature:(const MatrixBase<Derived>& m)
fromRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D	signature:(const MatrixBase<Derived>& mat)
fromRotationMatrix	../include/Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
fromRotationMatrix	../include/Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis	signature:(const MatrixBase<Derived>& mat)
fromRotationMatrix	../include/Eigen/src/Geometry/Rotation2D.h	/^  Rotation2D& fromRotationMatrix(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::Rotation2D	access:public	signature:(const MatrixBase<Derived>& m)
fromRotationMatrix	../include/Eigen/src/Geometry/Rotation2D.h	/^Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D	signature:(const MatrixBase<Derived>& mat)
FromTwoVectors	../include/Eigen/src/Geometry/Quaternion.h	/^Quaternion<Scalar,Options> Quaternion<Scalar,Options>::FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
FromTwoVectors	../include/Eigen/src/Geometry/Quaternion.h	/^  static Quaternion FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
fullPivHouseholderQr	../include/Eigen/src/Core/MatrixBase.h	/^    const FullPivHouseholderQR<PlainObject> fullPivHouseholderQr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
FullPivHouseholderQR	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(const MatrixType& matrix)
FullPivHouseholderQR	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR()$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:()
FullPivHouseholderQR	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(Index rows, Index cols)
fullPivHouseholderQr	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^MatrixBase<Derived>::fullPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
FullPivHouseholderQR	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename _MatrixType> class FullPivHouseholderQR$/;"	c	namespace:Eigen
FullPivHouseholderQRMatrixQReturnType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  FullPivHouseholderQRMatrixQReturnType(const MatrixType&       qr,$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:(const MatrixType& qr, const HCoeffsType& hCoeffs, const IntColVectorType& rowsTranspositions)
FullPivHouseholderQRMatrixQReturnType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename MatrixType> struct FullPivHouseholderQRMatrixQReturnType$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
FullPivHouseholderQRPreconditioner	../include/Eigen/src/Core/util/Constants.h	/^  FullPivHouseholderQRPreconditioner$/;"	e	enum:Eigen::QRPreconditioners
fullPivLu	../include/Eigen/src/Core/MatrixBase.h	/^    const FullPivLU<PlainObject> fullPivLu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^    FullPivLU(const MatrixType& matrix);$/;"	p	class:Eigen::FullPivLU	access:public	signature:(const MatrixType& matrix)
FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^    FullPivLU(Index rows, Index cols);$/;"	p	class:Eigen::FullPivLU	access:public	signature:(Index rows, Index cols)
FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivLU	signature:(const MatrixType& matrix)
FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU()$/;"	f	class:Eigen::FullPivLU	signature:()
FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(Index rows, Index cols)$/;"	f	class:Eigen::FullPivLU	signature:(Index rows, Index cols)
FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^    FullPivLU();$/;"	p	class:Eigen::FullPivLU	access:public	signature:()
fullPivLu	../include/Eigen/src/LU/FullPivLU.h	/^MatrixBase<Derived>::fullPivLu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
FullPivLU	../include/Eigen/src/LU/FullPivLU.h	/^template<typename _MatrixType> class FullPivLU$/;"	c	namespace:Eigen
FullPrecision	../include/Eigen/src/Core/IO.h	/^       FullPrecision = -2 };$/;"	e	enum:Eigen::__anon55
FullyLazyCoeffBaseProductType	../include/Eigen/src/Core/ProductBase.h	/^    typedef CoeffBasedProduct<LhsNested, RhsNested, 0> FullyLazyCoeffBaseProductType;$/;"	t	class:Eigen::ProductBase	access:public
functor_allows_mixing_real_and_complex	../include/Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_allows_mixing_real_and_complex { enum { ret = 0 }; };$/;"	s	namespace:Eigen::internal
functor_allows_mixing_real_and_complex	../include/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_allows_mixing_real_and_complex	../include/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_has_linear_access	../include/Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_has_linear_access	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };$/;"	s	namespace:Eigen::internal
functor	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    const BinaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
functor	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    const NullaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:() const
functor	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    const UnaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
functor	../include/Eigen/src/Core/CwiseUnaryView.h	/^    const ViewOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
functor	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    const BinaryOp& functor() const $/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_abs2_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_abs_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_acos_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_add_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_asin_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_binary_pow_op<Scalar,OtherScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cast_op<Scalar,NewType> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_conj_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_conjugate_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_constant_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cos_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cube_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_difference_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_exp_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_hypot_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_identity_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_imag_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_imag_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_inverse_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_log_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_max_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_min_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_multiple2_op<Scalar1,Scalar2> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_multiple_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_opposite_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_pow_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_quotient1_impl<Scalar,false> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_quotient1_impl<Scalar,true> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_quotient1_op<Scalar> >$/;"	s	namespace:Eigen::internal	inherits:functor_traits
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_quotient_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_real_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_real_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_sin_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_sqrt_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_square_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_sum_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_tan_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::binary_compose<T0,T1,T2> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::binary_negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::binder1st<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::binder2nd<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::divides<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::equal_to<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::greater_equal<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::greater<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::less_equal<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::less<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::logical_and<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::logical_not<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::logical_or<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::minus<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::multiplies<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::not_equal_to<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::plus<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::project1st<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::project2nd<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::select1st<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::select2nd<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::unary_compose<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^struct functor_traits<std::unary_negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^template<> struct functor_traits<scalar_boolean_and_op> {$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^template<> struct functor_traits<scalar_boolean_or_op> {$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Functors.h	/^template <typename Scalar, bool RandomAccess> struct functor_traits< linspaced_op<Scalar,RandomAccess> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Random.h	/^struct functor_traits<scalar_random_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Visitor.h	/^struct functor_traits<max_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	../include/Eigen/src/Core/Visitor.h	/^struct functor_traits<min_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
FunctorType	../include/Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon193
FunctorType	../include/Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon194
gebp_kernel	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gebp_kernel$/;"	s	namespace:Eigen::internal
gebp_madd	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void gebp_madd(const CJ& cj, A& a, B& b, C& c, T& t)$/;"	f	namespace:Eigen::internal	signature:(const CJ& cj, A& a, B& b, C& c, T& t)
gebp_madd_selector	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename A, typename B, typename C, typename T> struct gebp_madd_selector {$/;"	s	namespace:Eigen::internal
gebp_madd_selector	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename T> struct gebp_madd_selector<CJ,T,T,T,T> {$/;"	s	namespace:Eigen::internal
gebp_traits	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits$/;"	c	namespace:Eigen::internal
gebp_traits	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<RealScalar, std::complex<RealScalar>, false, _ConjRhs >$/;"	c	namespace:Eigen::internal
gebp_traits	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, RealScalar, _ConjLhs, false>$/;"	c	namespace:Eigen::internal
gebp_traits	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, std::complex<RealScalar>, _ConjLhs, _ConjRhs >$/;"	c	namespace:Eigen::internal
gemm_blocking_space	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, false>$/;"	c	namespace:Eigen::internal	inherits:level3_blocking
gemm_blocking_space	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, true>$/;"	c	namespace:Eigen::internal	inherits:level3_blocking
gemm_blocking_space	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(DenseIndex \/*rows*\/, DenseIndex \/*cols*\/, DenseIndex \/*depth*\/)$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:(DenseIndex , DenseIndex , DenseIndex )
gemm_blocking_space	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(DenseIndex rows, DenseIndex cols, DenseIndex depth)$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:(DenseIndex rows, DenseIndex cols, DenseIndex depth)
~gemm_blocking_space	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    ~gemm_blocking_space()$/;"	f	class:Eigen::internal::gemm_blocking_space	access:public	signature:()
gemmColMat	splib_utils.cpp	/^MV_ColMat_double gemmColMat(MV_ColMat_double &L, MV_ColMat_double &R, bool transL, bool transR)$/;"	f
gemmColMat	splib_utils.cpp	/^MV_ColMat_double gemmColMat(MV_ColMat_double &L, MV_ColMat_double &R)$/;"	f
gemm_functor	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  gemm_functor(const Lhs& lhs, const Rhs& rhs, Dest& dest, Scalar actualAlpha,$/;"	f	struct:Eigen::internal::gemm_functor	access:public	signature:(const Lhs& lhs, const Rhs& rhs, Dest& dest, Scalar actualAlpha, BlockingType& blocking)
gemm_functor	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct gemm_functor$/;"	s	namespace:Eigen::internal
gemm_pack_lhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_lhs$/;"	s	namespace:Eigen::internal
gemm_pack_rhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, nr, ColMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemm_pack_rhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, nr, RowMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
GemmParallelInfo	../include/Eigen/src/Core/products/Parallelizer.h	/^  GemmParallelInfo() : sync(-1), users(0), rhs_start(0), rhs_length(0) {}$/;"	f	struct:Eigen::internal::GemmParallelInfo	access:public	signature:()
GemmParallelInfo	../include/Eigen/src/Core/products/Parallelizer.h	/^template<typename Index> struct GemmParallelInfo$/;"	s	namespace:Eigen::internal
GemmProduct	../include/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon215
GEMM_SPECIALIZATION	../include/Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	49;"	d
GemvProduct	../include/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon215
gemv_selector	../include/Eigen/src/Core/GeneralProduct.h	/^struct gemv_selector<OnTheLeft,StorageOrder,BlasCompatible>$/;"	s	namespace:Eigen::internal
gemv_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,ColMajor,false>$/;"	s	namespace:Eigen::internal
gemv_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,ColMajor,true>$/;"	s	namespace:Eigen::internal
gemv_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,RowMajor,false>$/;"	s	namespace:Eigen::internal
gemv_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,RowMajor,true>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	../include/Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,Dynamic,true>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	../include/Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,false>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	../include/Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,true>$/;"	s	namespace:Eigen::internal
GenEigMask	../include/Eigen/src/Core/util/Constants.h	/^  GenEigMask = Ax_lBx | ABx_lx | BAx_lx$/;"	e	enum:Eigen::DecompositionOptions
general_det3_helper	../include/Eigen/src/LU/Inverse.h	/^inline const typename Derived::Scalar general_det3_helper$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<Derived>& matrix, int i1, int i2, int i3, int j1, int j2, int j3)
GeneralizedSelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^class GeneralizedSelfAdjointEigenSolver : public SelfAdjointEigenSolver<_MatrixType>$/;"	c	namespace:Eigen	inherits:SelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver() : Base() {}$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:()
GeneralizedSelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB,$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, int options = ComputeEigenvectors|Ax_lBx)
GeneralizedSelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public	signature:(Index size)
general_matrix_matrix_product	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_product	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_rankupdate	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^struct general_matrix_matrix_rankupdate :$/;"	s	namespace:Eigen::internal	inherits:general_matrix_matrix_triangular_product
general_matrix_matrix_triangular_product	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_triangular_product	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product_gemv	../include/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^struct general_matrix_vector_product_gemv :$/;"	s	namespace:Eigen::internal	inherits:general_matrix_vector_product
general_matrix_vector_product	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,ColMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,RowMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
GeneralProduct	../include/Eigen/src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, GemvProduct>$/;"	c	namespace:Eigen	inherits:ProductBase
GeneralProduct	../include/Eigen/src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, InnerProduct>$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,Matrix
GeneralProduct	../include/Eigen/src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, OuterProduct>$/;"	c	namespace:Eigen	inherits:ProductBase
GeneralProduct	../include/Eigen/src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
GeneralProduct	../include/Eigen/src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
GeneralProduct	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class GeneralProduct<Lhs, Rhs, GemmProduct>$/;"	c	namespace:Eigen	inherits:ProductBase
GeneralProduct	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
generic_aligned_realloc	../include/Eigen/src/Core/util/Memory.h	/^inline void* generic_aligned_realloc(void* ptr, size_t size, size_t old_size)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t size, size_t old_size)
Generic	../include/Eigen/src/Core/util/Constants.h	/^    Generic = 0x0,$/;"	e	enum:Eigen::Architecture::Type
GenericNumTraits	../include/Eigen/src/Core/NumTraits.h	/^template<typename T> struct GenericNumTraits$/;"	s	namespace:Eigen
GetAction	../include/Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
get_factor	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename From,typename To> struct get_factor {$/;"	s	namespace:Eigen::internal
get_factor	../include/Eigen/src/Core/util/BlasUtil.h	/^template<typename Scalar> struct get_factor<Scalar,typename NumTraits<Scalar>::Real> {$/;"	s	namespace:Eigen::internal
getL	../include/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
getL	../include/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
getL	../include/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
getL	../include/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
getL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::traits	access:public	signature:(const MatrixType& m)
getMatrix	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT	access:public	signature:(const MatrixType& matrix)
getMatrix	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT	access:protected	signature:(const MatrixType& matrix)
getMatrix	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU	access:protected	signature:(const MatrixType& matrix)
getMumpsInfo	../include/abcd.h	/^    inline int getMumpsInfo(int i) { return mumps.info[ i - 1 ]; }$/;"	f	class:abcd	access:private	signature:(int i)
getMumpsRinfo	../include/abcd.h	/^    inline double getMumpsRinfo(int i) { return mumps.rinfo[ i - 1 ]; }$/;"	f	class:abcd	access:private	signature:(int i)
get_nrmres	utils.cpp	/^void abcd::get_nrmres(MV_ColMat_double &x, double &nrmR, double &nrmX, double &nrmXfmX)$/;"	f	class:abcd
getU	../include/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
getU	../include/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LDLT_Traits	access:public	signature:(const MatrixType& m)
getU	../include/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
getU	../include/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(const MatrixType& m)
getU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::traits	access:public	signature:(const MatrixType& m)
global_math_functions_filtering_base	../include/Eigen/src/Core/MathFunctions.h	/^struct global_math_functions_filtering_base$/;"	s	namespace:Eigen::internal
glob_to_local	../include/abcd.h	/^    std::map<int,int> glob_to_local;$/;"	m	class:abcd	access:public
gmgs	../include/abcd.h	/^    void gmgs(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, Eigen::SparseMatrix<double> G, int s, bool use_a);$/;"	p	class:abcd	access:private	signature:(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, Eigen::SparseMatrix<double> G, int s, bool use_a)
gmgs	../include/abcd.h	/^    void gmgs(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, int s, bool use_a);$/;"	p	class:abcd	access:private	signature:(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, int s, bool use_a)
gmgs	../src/bcg.cpp	/^void abcd::gmgs(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r,$/;"	f	class:abcd	signature:(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r, Eigen::SparseMatrix<double> g, int s, bool use_a)
gmgs	../src/bcg.cpp	/^void abcd::gmgs(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r, int s, bool use_a)$/;"	f	class:abcd	signature:(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r, int s, bool use_a)
gqr	../include/abcd.h	/^    int gqr(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, Eigen::SparseMatrix<double> G, int s, bool use_a);$/;"	p	class:abcd	access:private	signature:(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, Eigen::SparseMatrix<double> G, int s, bool use_a)
gqr	../include/abcd.h	/^    int gqr(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, int s, bool use_a);$/;"	p	class:abcd	access:private	signature:(Eigen::MatrixXd &P, Eigen::MatrixXd &AP, Eigen::MatrixXd &R, int s, bool use_a)
gqr	../src/bcg.cpp	/^int abcd::gqr(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r,$/;"	f	class:abcd	signature:(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r, Eigen::SparseMatrix<double> g, int s, bool use_a)
gqr	../src/bcg.cpp	/^int abcd::gqr(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r, int s, bool use_a)$/;"	f	class:abcd	signature:(Eigen::MatrixXd &p, Eigen::MatrixXd &ap, Eigen::MatrixXd &r, int s, bool use_a)
grabMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLDLT	access:protected	signature:(const MatrixType& matrix, ColSpMatrix& out)
grabMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLLT	access:protected	signature:(const MatrixType& matrix, ColSpMatrix& out)
grabMatrix	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLU	access:protected	signature:(const MatrixType& matrix, ColSpMatrix& out)
grapInput	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void grapInput(const MatrixType& mat)$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:(const MatrixType& mat)
HalfLength	../include/Eigen/src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon272
HalfLength	../include/Eigen/src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon274
handmade_aligned_free	../include/Eigen/src/Core/util/Memory.h	/^inline void handmade_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal	signature:(void *ptr)
handmade_aligned_malloc	../include/Eigen/src/Core/util/Memory.h	/^inline void* handmade_aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal	signature:(size_t size)
handmade_aligned_realloc	../include/Eigen/src/Core/util/Memory.h	/^inline void* handmade_aligned_realloc(void* ptr, size_t size, size_t = 0)$/;"	f	namespace:Eigen::internal	signature:(void* ptr, size_t size, size_t = 0)
HasAbs2	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
HasAbs2	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
HasAbs2	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
HasAbs2	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
HasAbs2	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
HasAbs2	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs2   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasAbs	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
HasAbs	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
HasAbs	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
HasAbs	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
HasAbs	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
HasAbs	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasACos	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasACos   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasAdd	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
HasAdd	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
HasAdd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
HasAdd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
HasAdd	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasAdd    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
HasAdd	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasASin	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasASin   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasATan	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasATan   = 0$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasConj	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasConj   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
HasConj	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasConj   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasCos	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
HasCos	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
HasCos	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasCos  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
HasCos	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasCos    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
has_direct_access	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^  enum { has_direct_access = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon206
has_direct_access	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct has_direct_access$/;"	s	namespace:Eigen::internal
_HasDirectAccess	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      _HasDirectAccess = (int(Flags)&DirectAccessBit) ? 1 : 0 \/\/ workaround sunCC$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
HasDiv	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
HasDiv	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
HasDiv	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
HasDiv	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
HasDiv	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
HasDiv	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
HasDiv	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasDiv    = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon245
HasDiv	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasDiv    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasExp	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
HasExp	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
HasExp	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
HasExp	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasExp    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasLog	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
HasLog	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
HasLog	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
HasLog	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasLog    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasMax	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
HasMax	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
HasMax	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
HasMax	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
HasMax	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
HasMax	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasMax    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasMin	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
HasMin	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
HasMin	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
HasMin	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
HasMin	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
HasMin	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasMin    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasMul	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
HasMul	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
HasMul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
HasMul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
HasMul	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasMul    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
HasMul	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasNegate	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
HasNegate	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
HasNegate	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
HasNegate	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
HasNegate	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasNegate = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
HasNegate	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasNoInnerStride	../include/Eigen/src/Core/Map.h	/^    HasNoInnerStride = InnerStrideAtCompileTime == 1,$/;"	e	enum:Eigen::internal::traits::__anon285
has_none	../include/Eigen/src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	s	namespace:Eigen::internal
HasNoOuterStride	../include/Eigen/src/Core/Map.h	/^    HasNoOuterStride = StrideType::OuterStrideAtCompileTime == 0,$/;"	e	enum:Eigen::internal::traits::__anon285
HasNoStride	../include/Eigen/src/Core/Map.h	/^    HasNoStride = HasNoInnerStride && HasNoOuterStride,$/;"	e	enum:Eigen::internal::traits::__anon285
HasPow	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasPow    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasSameStorageOrderAsXprType	../include/Eigen/src/Core/Block.h	/^    HasSameStorageOrderAsXprType = (IsRowMajor == XprTypeIsRowMajor),$/;"	e	enum:Eigen::internal::traits::__anon228
HasSetLinear	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon250
HasSetLinear	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon256
HasSetLinear	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon237
HasSetLinear	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon239
HasSetLinear	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon231
HasSetLinear	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasSetLinear = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasSin	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
HasSin	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
HasSin	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSin  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
HasSin	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasSin    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasSqrt	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon252
HasSqrt	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon258
HasSqrt	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon244
HasSqrt	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasSqrt   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
has_std_result_type	../include/Eigen/src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	s	namespace:Eigen::internal
HasSub	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
HasSub	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
HasSub	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
HasSub	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
HasSub	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasSub    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon231
HasSub	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
HasTan	../include/Eigen/src/Core/GenericPacketMath.h	/^    HasTan    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon229
has_tr1_result	../include/Eigen/src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	s	namespace:Eigen::internal
HasUnitDiag	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon93
HasUnitDiag	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon94
HasUnitDiag	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^           HasUnitDiag = (Mode&UnitDiag) ? 1 : 0$/;"	e	enum:Eigen::SparseTriangularView::__anon29
HasUsableDirectAccess	../include/Eigen/src/Core/util/BlasUtil.h	/^    HasUsableDirectAccess = (    (int(XprType::Flags)&DirectAccessBit)$/;"	e	enum:Eigen::internal::blas_traits::__anon202
has_write_access	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^         has_write_access = (traits<Derived>::Flags & LvalueBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon206
HasZeroDiag	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon93
HasZeroDiag	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon94
hCoeffs	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
hCoeffs	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
hCoeffs	../include/Eigen/src/QR/HouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
HCoeffsType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
HCoeffsType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
HCoeffsType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
HCoeffsType	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::HouseholderQR	access:public
HDim	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^    HDim = _Dim+1   \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon434
HDim	../include/Eigen/src/Geometry/Transform.h	/^    HDim = _Dim+1,  \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon374
HDim	../include/Eigen/src/Geometry/Transform.h	/^    HDim = Transform::HDim,$/;"	e	enum:Eigen::internal::transform_traits::__anon373
HDim	../include/Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon377
HDim	../include/Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon378
head	../include/Eigen/src/Core/DenseBase.h	/^    SegmentReturnType head(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
head	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> typename ConstFixedSegmentReturnType<Size>::Type head() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
head	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> typename FixedSegmentReturnType<Size>::Type head();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
head	../include/Eigen/src/Core/DenseBase.h	/^    typename DenseBase::ConstSegmentReturnType head(Index size) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size) const
head	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::head() const$/;"	f	class:Eigen::DenseBase	signature:() const
head	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::head()$/;"	f	class:Eigen::DenseBase	signature:()
head	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::head(Index size) const$/;"	f	class:Eigen::DenseBase	signature:(Index size) const
head	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::head(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
HereditaryBits	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int HereditaryBits = RowMajorBit$/;"	m	namespace:Eigen
HessenbergDecomposition	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition(const MatrixType& matrix)$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:(const MatrixType& matrix)
HessenbergDecomposition	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:(Index size = Size==Dynamic ? 2 : Size)
HessenbergDecomposition	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^template<typename _MatrixType> class HessenbergDecomposition$/;"	c	namespace:Eigen
HessenbergDecompositionMatrixHReturnType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecompositionMatrixHReturnType(const HessenbergDecomposition<MatrixType>& hess) : m_hess(hess) { }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:(const HessenbergDecomposition<MatrixType>& hess)
HessenbergDecompositionMatrixHReturnType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^template<typename MatrixType> struct HessenbergDecompositionMatrixHReturnType$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
HEX	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	295;"	d	file:
HNormalized_Block	../include/Eigen/src/Core/VectorwiseOp.h	/^            HNormalized_Block;$/;"	t	class:Eigen::VectorwiseOp	access:public
HNormalized_Factors	../include/Eigen/src/Core/VectorwiseOp.h	/^            HNormalized_Factors;$/;"	t	class:Eigen::VectorwiseOp	access:public
hnormalized	../include/Eigen/src/Core/MatrixBase.h	/^    const HNormalizedReturnType hnormalized() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
hnormalized	../include/Eigen/src/Core/VectorwiseOp.h	/^    const HNormalizedReturnType hnormalized() const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:() const
hnormalized	../include/Eigen/src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::hnormalized() const$/;"	f	class:Eigen::MatrixBase	signature:() const
hnormalized	../include/Eigen/src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::hnormalized() const$/;"	f	class:Eigen::VectorwiseOp	signature:() const
HNormalizedReturnType	../include/Eigen/src/Core/MatrixBase.h	/^                const ConstStartMinusOne > HNormalizedReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
HNormalizedReturnType	../include/Eigen/src/Core/VectorwiseOp.h	/^            HNormalizedReturnType;$/;"	t	class:Eigen::VectorwiseOp	access:public
HNormalized_Size	../include/Eigen/src/Core/VectorwiseOp.h	/^      HNormalized_Size = Direction==Vertical ? internal::traits<ExpressionType>::RowsAtCompileTime$/;"	e	enum:Eigen::VectorwiseOp::__anon72
HNormalized_SizeMinusOne	../include/Eigen/src/Core/VectorwiseOp.h	/^      HNormalized_SizeMinusOne = HNormalized_Size==Dynamic ? Dynamic : HNormalized_Size-1$/;"	e	enum:Eigen::VectorwiseOp::__anon72
HomogeneousDimension	../include/Eigen/src/Geometry/Umeyama.h	/^    HomogeneousDimension = int(MinRowsAtCompileTime) == Dynamic ? Dynamic : int(MinRowsAtCompileTime)+1$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon381
homogeneous	../include/Eigen/src/Core/MatrixBase.h	/^    HomogeneousReturnType homogeneous() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
homogeneous	../include/Eigen/src/Core/VectorwiseOp.h	/^    Homogeneous<ExpressionType,Direction> homogeneous() const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:() const
Homogeneous	../include/Eigen/src/Geometry/Homogeneous.h	/^    inline Homogeneous(const MatrixType& matrix)$/;"	f	class:Eigen::Homogeneous	access:public	signature:(const MatrixType& matrix)
homogeneous	../include/Eigen/src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::homogeneous() const$/;"	f	class:Eigen::MatrixBase	signature:() const
Homogeneous	../include/Eigen/src/Geometry/Homogeneous.h	/^template<typename MatrixType,int _Direction> class Homogeneous$/;"	c	namespace:Eigen	inherits:MatrixBase
homogeneous	../include/Eigen/src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::homogeneous() const$/;"	f	class:Eigen::VectorwiseOp	signature:() const
homogeneous_left_product_impl	../include/Eigen/src/Geometry/Homogeneous.h	/^  homogeneous_left_product_impl(const Lhs& lhs, const MatrixType& rhs)$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:(const Lhs& lhs, const MatrixType& rhs)
homogeneous_left_product_impl	../include/Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs>$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
HomogeneousReturnTypeDirection	../include/Eigen/src/Core/MatrixBase.h	/^    enum { HomogeneousReturnTypeDirection = ColsAtCompileTime==1?Vertical:Horizontal };$/;"	e	enum:Eigen::MatrixBase::__anon149
HomogeneousReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef Homogeneous<Derived, HomogeneousReturnTypeDirection> HomogeneousReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
homogeneous_right_product_impl	../include/Eigen/src/Geometry/Homogeneous.h	/^  homogeneous_right_product_impl(const MatrixType& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:(const MatrixType& lhs, const Rhs& rhs)
homogeneous_right_product_impl	../include/Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs>$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
Horizontal	../include/Eigen/src/Core/util/Constants.h	/^  Horizontal, $/;"	e	enum:Eigen::DirectionType
householderCoefficients	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const CoeffVectorType& householderCoefficients() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
householderCoefficients	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline CoeffVectorType householderCoefficients() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
householder	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    const MatrixType& householder() const { return m_householder; }$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:() const
householderQ	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^  ::householderQ() const$/;"	f	class:Eigen::ColPivHouseholderQR	signature:() const
householderQ	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    HouseholderSequenceType householderQ(void) const;$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:(void) const
householderQ	../include/Eigen/src/QR/HouseholderQR.h	/^    HouseholderSequenceType householderQ() const$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
householderQr	../include/Eigen/src/Core/MatrixBase.h	/^    const HouseholderQR<PlainObject> householderQr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
HouseholderQR	../include/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::HouseholderQR	access:public	signature:(const MatrixType& matrix)
HouseholderQR	../include/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::HouseholderQR	access:public	signature:(Index rows, Index cols)
HouseholderQR	../include/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR() : m_qr(), m_hCoeffs(), m_temp(), m_isInitialized(false) {}$/;"	f	class:Eigen::HouseholderQR	access:public	signature:()
householderQr	../include/Eigen/src/QR/HouseholderQR.h	/^MatrixBase<Derived>::householderQr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
HouseholderQR	../include/Eigen/src/QR/HouseholderQR.h	/^template<typename _MatrixType> class HouseholderQR$/;"	c	namespace:Eigen
householder_qr_inplace_blocked	../include/Eigen/src/QR/HouseholderQR.h	/^void householder_qr_inplace_blocked(MatrixQR& mat, HCoeffs& hCoeffs,$/;"	f	namespace:Eigen::internal	signature:(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Index maxBlockSize=32, typename MatrixQR::Scalar* tempData = 0)
householder_qr_inplace_unblocked	../include/Eigen/src/QR/HouseholderQR.h	/^void householder_qr_inplace_unblocked(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)$/;"	f	namespace:Eigen::internal	signature:(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)
HouseholderQRPreconditioner	../include/Eigen/src/Core/util/Constants.h	/^  HouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
HouseholderSequence	../include/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const HouseholderSequence& other)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(const HouseholderSequence& other)
HouseholderSequence	../include/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(const VectorsType& v, const CoeffsType& h)
householderSequence	../include/Eigen/src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType> householderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen	signature:(const VectorsType& v, const CoeffsType& h)
HouseholderSequence	../include/Eigen/src/Householder/HouseholderSequence.h	/^template<typename VectorsType, typename CoeffsType, int Side> class HouseholderSequence$/;"	c	namespace:Eigen	inherits:EigenBase
HouseholderSequenceType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename HouseholderSequence<MatrixType,CoeffVectorType>::ConjugateReturnType HouseholderSequenceType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
HouseholderSequenceType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename HouseholderSequence<MatrixType,CoeffVectorType>::ConjugateReturnType HouseholderSequenceType;$/;"	t	class:Eigen::Tridiagonalization	access:public
HouseholderSequenceType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::HouseholderSequenceType HouseholderSequenceType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
HouseholderSequenceType	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheLeft> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
HouseholderSequenceType	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheRight> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
HouseholderSequenceType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename HouseholderSequence<MatrixType,HCoeffsType>::ConjugateReturnType HouseholderSequenceType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
HouseholderSequenceType	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef typename HouseholderSequence<MatrixType,HCoeffsType>::ConjugateReturnType HouseholderSequenceType;$/;"	t	class:Eigen::HouseholderQR	access:public
householderU	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    const HouseholderUSequenceType householderU() const$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:() const
HouseholderUSequenceType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^            > HouseholderUSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
householderV	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    const HouseholderVSequenceType householderV() \/\/ const here gives nasty errors and i'm lazy$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:()
HouseholderVSequenceType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^            > HouseholderVSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
hseq_side_dependent_impl	../include/Eigen/src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl$/;"	s	namespace:Eigen::internal
hseq_side_dependent_impl	../include/Eigen/src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl<VectorsType, CoeffsType, OnTheRight>$/;"	s	namespace:Eigen::internal
Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/All.h	112;"	d
Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/All.h	57;"	d
Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)
~Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime>& other)
Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(int _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:(int _dim)
Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, const VectorType& e)
Hyperplane	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, Scalar d)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, Scalar d)
Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)
Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  Hyperplane(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)
~Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)
Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane() {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(Index _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane	access:public	signature:(Index _dim)
Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, const VectorType& e)
Hyperplane	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, Scalar d)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& n, Scalar d)
hypot_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct hypot_impl$/;"	s	namespace:Eigen::internal
hypot	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(hypot, Scalar) hypot(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
hypotNorm	../include/Eigen/src/Core/MatrixBase.h	/^    RealScalar hypotNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
hypotNorm	../include/Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::hypotNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
hypotNorm	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_hypotNorm,RealScalar>::Type hypotNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
hypot_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct hypot_retval$/;"	s	namespace:Eigen::internal
icamax	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(icamax)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
icamin	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(icamin)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
icc_11_workaround	../include/Eigen/src/Geometry/Transform.h	/^  template<int OtherMode,int OtherOptions> struct icc_11_workaround$/;"	s	class:Eigen::Transform	access:private
icmax	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(icmax) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
icmin	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(icmin)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
icntl	../include/abcd.h	/^    int icntl[10];$/;"	m	class:abcd	access:public
idamax	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(idamax)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
idamin	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(idamin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
Identity	../include/Eigen/src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity()$/;"	f	class:Eigen::MatrixBase	signature:()
Identity	../include/Eigen/src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity(Index rows, Index cols)$/;"	f	class:Eigen::MatrixBase	signature:(Index rows, Index cols)
Identity	../include/Eigen/src/Core/MatrixBase.h	/^    static const IdentityReturnType Identity(Index rows, Index cols);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index rows, Index cols)
Identity	../include/Eigen/src/Core/MatrixBase.h	/^    static const IdentityReturnType Identity();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
Identity	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  static inline Quaternion Identity() { return Quaternion(1, 0, 0, 0); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Identity	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  static const typename MatrixType::IdentityReturnType Identity()$/;"	f	class:Eigen::Transform	access:public	signature:()
Identity	../include/Eigen/src/Geometry/AngleAxis.h	/^  static inline const AngleAxis Identity() { return AngleAxis(0, Vector3::UnitX()); }$/;"	f	class:Eigen::AngleAxis	access:public	signature:()
Identity	../include/Eigen/src/Geometry/Quaternion.h	/^  static inline Quaternion<Scalar> Identity() { return Quaternion<Scalar>(1, 0, 0, 0); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Identity	../include/Eigen/src/Geometry/Rotation2D.h	/^  static inline Rotation2D Identity() { return Rotation2D(0); }$/;"	f	class:Eigen::Rotation2D	access:public	signature:()
Identity	../include/Eigen/src/Geometry/Transform.h	/^  static const Transform Identity()$/;"	f	class:Eigen::Transform	access:public	signature:()
Identity	../include/Eigen/src/Geometry/Translation.h	/^  static const Translation Identity() { return Translation(VectorType::Zero()); }$/;"	f	class:Eigen::Translation	access:public	signature:()
IdentityPreconditioner	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class IdentityPreconditioner$/;"	c	namespace:Eigen
IdentityPreconditioner	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner(const MatrixType& ) {}$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const MatrixType& )
IdentityPreconditioner	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner() {}$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:()
IdentityReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_identity_op<Scalar>,Derived> IdentityReturnType;$/;"	t	class:Eigen::MatrixBase	access:public
idmax	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(idmax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
idmin	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(idmin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
I	../include/Eigen/src/Core/SolveTriangular.h	/^    I = IsLower ? Index : Size - Index - 1,$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon364
image	../include/Eigen/src/Eigen2Support/LU.h	/^    const ImageResultType image() const$/;"	f	class:Eigen::LU	access:public	signature:() const
image	../include/Eigen/src/LU/FullPivLU.h	/^      image(const MatrixType& originalMatrix) const$/;"	f	class:Eigen::FullPivLU	access:public	signature:(const MatrixType& originalMatrix) const
ImageResultType	../include/Eigen/src/Eigen2Support/LU.h	/^    > ImageResultType;$/;"	t	class:Eigen::LU	access:public
image_retval_base	../include/Eigen/src/misc/Image.h	/^  image_retval_base(const DecompositionType& dec, const MatrixType& originalMatrix)$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:(const DecompositionType& dec, const MatrixType& originalMatrix)
image_retval_base	../include/Eigen/src/misc/Image.h	/^template<typename _DecompositionType> struct image_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
image_retval	../include/Eigen/src/LU/FullPivLU.h	/^struct image_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:image_retval_base
imag_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_impl$/;"	s	namespace:Eigen::internal
imag_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
imag	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag, Scalar) imag(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
imag	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^imag() const { return derived(); }$/;"	f	signature:() const
imag	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^imag() { return derived(); }$/;"	f	signature:()
imag_ref_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
imag_ref_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_default_impl$/;"	s	namespace:Eigen::internal
imag_ref_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_impl : imag_ref_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal	inherits:imag_ref_default_impl
imag_ref	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) imag_ref(Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(Scalar& x)
imag_ref	../include/Eigen/src/Core/MathFunctions.h	/^inline typename add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) >::type imag_ref(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
imag_ref_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_retval$/;"	s	namespace:Eigen::internal
ImagReturnType	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_imag_op<Scalar>, const Derived> ImagReturnType;$/;"	t
imag_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct imag_retval$/;"	s	namespace:Eigen::internal
impl	../include/Eigen/src/Core/Functors.h	/^  const linspaced_op_impl<Scalar,RandomAccess> impl;$/;"	m	struct:Eigen::internal::linspaced_op	access:public
IncompleteLUT	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^class IncompleteLUT : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
IncompleteLUT	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT(const MatrixType& mat, RealScalar droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixType& mat, RealScalar droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)
IncompleteLUT	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT()$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:()
incrementToNonZero	../include/Eigen/src/SparseCore/SparseView.h	/^  void incrementToNonZero()$/;"	f	class:Eigen::SparseView::InnerIterator	access:private	signature:()
Index	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::LDLT	access:public
Index	../include/Eigen/src/Cholesky/LLT.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::LLT	access:public
Index	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::CholmodBase	access:public
Index	../include/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::ArrayBase	access:public
Index	../include/Eigen/src/Core/Assign.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::assign_impl	access:public
Index	../include/Eigen/src/Core/Assign_MKL.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::vml_assign_impl	access:public
Index	../include/Eigen/src/Core/BandMatrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::internal::TridiagonalMatrix	access:private
Index	../include/Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename DenseMatrixType::Index Index;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Index	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Index Index;$/;"	t	class:Eigen::internal::BandMatrix	access:public
Index	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Index Index;$/;"	t	class:Eigen::internal::BandMatrixWrapper	access:public
Index	../include/Eigen/src/Core/CommaInitializer.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::CommaInitializer	access:public
Index	../include/Eigen/src/Core/CwiseBinaryOp.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/Core/CwiseNullaryOp.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::setIdentity_impl	access:public
Index	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Index Index; $/;"	t	class:Eigen::DenseBase	access:public
Index	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Index	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::DiagonalBase	access:public
Index	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::Index Index;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Index	../include/Eigen/src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::Index Index;$/;"	t	struct:Eigen::EigenBase	access:public
Index	../include/Eigen/src/Core/MapBase.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::MapBase	access:public
Index	../include/Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::MapBase	access:public
Index	../include/Eigen/src/Core/Map.h	/^  typedef typename PlainObjectType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::MatrixBase	access:public
Index	../include/Eigen/src/Core/Matrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef IndexType Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Map	access:public
Index	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::Index Index;$/;"	t	class:Eigen::PermutationBase	access:public
Index	../include/Eigen/src/Core/PlainObjectBase.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::conservative_resize_like_impl	access:public
Index	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::PlainObjectBase	access:public
Index	../include/Eigen/src/Core/ProductBase.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/Core/Product.h	/^                                      typename traits<RhsCleaned>::Index>::type Index;$/;"	t	struct:internal::traits	access:public
Index	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_impl	access:public
Index	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public
Index	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_vectorized_unroller	access:public
Index	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_packet_impl	access:public
Index	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^                                         typename traits<_RhsNested>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
index	../include/Eigen/src/Core/Redux.h	/^    index = Start * packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon275
Index	../include/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::redux_impl	access:public
Index	../include/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::triangular_assignment_selector	access:public
Index	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SelfAdjointView	access:public
Index	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::triangular_solve_retval	access:public
Index	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Index Index;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Index	../include/Eigen/src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::InnerStride	access:public
Index	../include/Eigen/src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::OuterStride	access:public
Index	../include/Eigen/src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::Stride	access:public
Index	../include/Eigen/src/Core/Transpositions.h	/^  typedef IndexType Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Map	access:public
Index	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Transpositions	access:public
Index	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::TranspositionsBase	access:public
Index	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::TranspositionsWrapper	access:public
Index	../include/Eigen/src/Core/Transpositions.h	/^  typedef typename _IndicesType::Scalar Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename TranspositionType::Index Index;$/;"	t	struct:Eigen::internal::transposition_matrix_product_retval	access:public
Index	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::triangular_assignment_selector	access:public
Index	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::TriangularBase	access:public
Index	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Index Index;$/;"	t	class:Eigen::TriangularView	access:public
Index	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Index Index;$/;"	t	class:Eigen::VectorwiseOp	access:public
Index	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::coeff_visitor	access:public
Index	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::max_coeff_visitor	access:public
Index	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::min_coeff_visitor	access:public
Index	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::visitor_impl	access:public
Index	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Index	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ComplexSchur	access:public
Index	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::EigenSolver	access:public
Index	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public
Index	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Index	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public
Index	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::RealSchur	access:public
Index	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Index	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::Tridiagonalization	access:public
Index	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Index	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public
Index	../include/Eigen/src/Geometry/AlignedBox.h	/^  typedef DenseIndex                                Index;$/;"	t	class:Eigen::AlignedBox	access:public
Index	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
Index	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl	access:public
Index	../include/Eigen/src/Geometry/Hyperplane.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::Hyperplane	access:public
Index	../include/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Index	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::ParametrizedLine	access:public
Index	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl	access:public
Index	../include/Eigen/src/Geometry/Transform.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::Transform	access:public
Index	../include/Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename VectorsType::Index Index;$/;"	t	class:Eigen::HouseholderSequence	access:private
Index	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Index Index;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl	access:public
Index	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef typename Vector::Index Index;$/;"	t	class:Eigen::DiagonalPreconditioner	access:private
Index	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::BiCGSTAB	access:public
Index	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ConjugateGradient	access:public
Index	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename FactorType::Index Index;$/;"	t	class:Eigen::IncompleteLUT	access:private
Index	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Index	../include/Eigen/src/LU/FullPivLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::FullPivLU	access:public
Index	../include/Eigen/src/LU/Inverse.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::inverse_impl	access:public
Index	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PartialPivLU	access:public
Index	../include/Eigen/src/LU/PartialPivLU.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
Index	../include/Eigen/src/misc/Image.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
Index	../include/Eigen/src/misc/Kernel.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::kernel_retval_base	access:public
Index	../include/Eigen/src/misc/Solve.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
Index	../include/Eigen/src/misc/SparseSolve.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
Index	../include/Eigen/src/misc/SparseSolve.h	/^  typedef typename DecompositionType::Index Index;$/;"	t	struct:Eigen::internal::solve_retval_with_guess	access:public
Index	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef long long int Index;$/;"	t	struct:Eigen::internal::pardiso_run_selector	access:public
Index	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Index	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::PardisoLLT	access:protected
Index	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Index Index;    $/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Index	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Index Index;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Index	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Index Index;$/;"	t	class:Eigen::PardisoImpl	access:public
Index	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PastixBase	access:public
Index	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PastixLU	access:public
Index	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Index Index;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
Index	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Index	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Index	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
Index	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::HouseholderQR	access:public
Index	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Index	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Index	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Index	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialLLT	access:public
Index	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Index                              Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Index                          Index;$/;"	t	struct:Eigen::internal::traits	access:public
index	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index index() const { return m_cachedIndex; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:() const
index	../include/Eigen/src/SparseCore/AmbiVector.h	/^      Index index;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl	access:public
Index	../include/Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::AmbiVector	access:public
index	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline const Index& index(size_t i) const { return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i) const
index	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index& index(size_t i) { return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i)
Index	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::CompressedStorage	access:public
index	../include/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_inner; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
Index	../include/Eigen/src/SparseCore/CoreIterators.h	/^    typedef typename Derived::Index Index;$/;"	t	class:Eigen::DenseBase::InnerIterator	access:protected
index	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index index() const { return m_matrix.innerIndexPtr()[m_id-1]; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
index	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index index() const { return m_matrix.innerIndexPtr()[m_id]; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
Index	../include/Eigen/src/SparseCore/SparseBlock.h	/^  typedef typename traits<MatrixType>::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
index	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_id; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
index	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_lhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
index	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_rhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
Index	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::CwiseBinaryOpImpl::InnerIterator	access:public
Index	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Index	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
Index	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:private
Index	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::SparseMatrixBase	access:public
index	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index index() const { return m_indices[m_id-1]; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
index	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index index() const { return m_indices[m_id]; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
Index	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeNestedCleaned::Index Index;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public
Index	../include/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename MatrixTypeNestedCleaned::Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/SparseCore/SparseProduct.h	/^                                         typename traits<_RhsNested>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Index	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
index	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index index() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
index	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index index() const { return m_data.index(m_id-1); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
index	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index index() const { return m_data.index(m_id); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
Index	../include/Eigen/src/SparseCore/SparseVector.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/SparseCore/SparseView.h	/^  typedef int Index;$/;"	t	struct:Eigen::internal::traits	access:public
Index	../include/Eigen/src/SparseCore/TriangularSolver.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector	access:public
Index	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::SuperILU	access:public
Index	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::SuperLU	access:public
Index	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SuperLUBase	access:public
Index	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
Index	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::JacobiSVD	access:public
Index	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename SVD::Index Index;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
Index	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Index	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::UmfPackLU	access:public
indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:() const
indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:() const
indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationWrapper	access:public	signature:() const
indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:()
indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:()
indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:()
indices	../include/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
indices	../include/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:() const
indices	../include/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Transpositions	access:public	signature:() const
indices	../include/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:() const
indices	../include/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:()
indices	../include/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map	access:public	signature:()
indices	../include/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Transpositions	access:public	signature:()
indices	../include/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:()
IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef Map<const Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose	access:private
IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map	access:public
IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationBase	access:public
IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationMatrix	access:public
IndicesType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationWrapper	access:public
IndicesType	../include/Eigen/src/Core/Transpositions.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
IndicesType	../include/Eigen/src/Core/Transpositions.h	/^  typedef Map<const Matrix<Index,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
IndicesType	../include/Eigen/src/Core/Transpositions.h	/^  typedef Matrix<Index, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits	access:public
IndicesType	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map	access:public
IndicesType	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Transpositions	access:public
IndicesType	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsBase	access:public
IndicesType	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsWrapper	access:public
IndicesType	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename TranspositionType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose	access:private
Infinity	../include/Eigen/src/Core/util/Constants.h	/^const int Infinity = -1;$/;"	m	namespace:Eigen
infNorm	splib_utils.cpp	/^double infNorm(MV_ColMat_double &V){$/;"	f
infNorm	splib_utils.cpp	/^double infNorm(VECTOR_double &V){$/;"	f
info_arch	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";$/;"	v
info_compiler	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";$/;"	v
info	../include/Eigen/src/Cholesky/LDLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
info	../include/Eigen/src/Cholesky/LLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
info	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
info	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexEigenSolver	access:public	signature:() const
info	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexSchur	access:public	signature:() const
info	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::EigenSolver	access:public	signature:() const
info	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::RealSchur	access:public	signature:() const
info	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
info	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:() const
info	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ComputationInfo info() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
info	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
info	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
info	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
info	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
info	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
info_platform	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";$/;"	v
info_version	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const info_version[] = {$/;"	v
_init2	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(const Scalar& x, const Scalar& y, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const Scalar& x, const Scalar& y, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)
_init2	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)
initAcc	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(AccPacket& p)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(AccPacket& p)
initAcc	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(DoublePacket& p)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(DoublePacket& p)
initAcc	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(Scalar& p) { p = Scalar(0); }$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(Scalar& p)
initAssignment	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void initAssignment(const Other& other)$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:(const Other& other)
initFactorization	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void initFactorization(const MatrixType& a)$/;"	f	class:Eigen::SuperLUBase	access:protected	signature:(const MatrixType& a)
initFrancisQRStep	../include/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)$/;"	f	class:Eigen::RealSchur	signature:(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)
initFrancisQRStep	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    void initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)
initializeCimmino	../include/abcd.h	/^    void initializeCimmino();$/;"	p	class:abcd	access:private	signature:()
initializeCimmino	../src/cimmino.cpp	/^void abcd::initializeCimmino()$/;"	f	class:abcd	signature:()
initialize	../include/abcd.h	/^    void initialize();$/;"	p	class:abcd	access:private	signature:()
initializeMumps	../include/abcd.h	/^    void initializeMumps(bool local);$/;"	p	class:abcd	access:private	signature:(bool local)
initializeMumps	../include/abcd.h	/^    void initializeMumps();$/;"	p	class:abcd	access:private	signature:()
initializeMumps	../src/mumps.cpp	/^void abcd::initializeMumps(bool local)$/;"	f	class:abcd	signature:(bool local)
initializeMumps	../src/mumps.cpp	/^void abcd::initializeMumps()$/;"	f	class:abcd	signature:()
initialize	../src/abcd.cpp	/^void abcd::initialize()$/;"	f	class:abcd	signature:()
init	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodDecomposition	access:protected	signature:()
init	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLDLT	access:protected	signature:()
init	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLLT	access:protected	signature:()
init	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSupernodalLLT	access:protected	signature:()
init	../include/Eigen/src/Core/Block.h	/^    void init()$/;"	f	class:Eigen::Block	access:protected	signature:()
init	../include/Eigen/src/Core/Visitor.h	/^  inline void init(const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::coeff_visitor	access:public	signature:(const Scalar& value, Index i, Index j)
init	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void init()$/;"	f	class:Eigen::IterativeSolverBase	access:protected	signature:()
init	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLDLT	access:protected	signature:()
init	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLLT	access:protected	signature:()
init	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLU	access:protected	signature:()
init	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init(); $/;"	p	class:Eigen::PastixBase	access:protected	signature:()
init	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::init()$/;"	f	class:Eigen::PastixBase	signature:()
init	../include/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::init(double estimatedDensity)$/;"	f	class:Eigen::internal::AmbiVector	signature:(double estimatedDensity)
init	../include/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::init(int mode)$/;"	f	class:Eigen::internal::AmbiVector	signature:(int mode)
init	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void init(double estimatedDensity);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(double estimatedDensity)
init	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void init(int mode);$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:(int mode)
init	../include/Eigen/src/SparseCore/SparseProduct.h	/^    void init()$/;"	f	class:Eigen::SparseSparseProduct	access:protected	signature:()
init	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperILU	access:protected	signature:()
init	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLU	access:protected	signature:()
init	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLUBase	access:protected	signature:()
init	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void init()$/;"	f	class:Eigen::UmfPackLU	access:protected	signature:()
initParallel	../include/Eigen/src/Core/products/Parallelizer.h	/^inline void initParallel()$/;"	f	namespace:Eigen	signature:()
initParallelSession	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  void initParallelSession() const$/;"	f	struct:Eigen::internal::gemm_functor	access:public	signature:() const
inner	../include/Eigen/src/Core/Assign.h	/^    inner = Index % Derived1::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::__anon224
inner	../include/Eigen/src/Core/Assign.h	/^    inner = Index % Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon225
inner	../include/Eigen/src/Core/Redux.h	/^    inner = index % int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon275
inner	../include/Eigen/src/Core/Redux.h	/^    inner = Start % Derived::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon273
inner	../include/Eigen/src/Core/Stride.h	/^    inline Index inner() const { return m_inner.value(); }$/;"	f	class:Eigen::Stride	access:public	signature:() const
innerIndexPtr	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline const Index* innerIndexPtr() const { return m_innerIndices; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
innerIndexPtr	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index* innerIndexPtr() { return m_innerIndices; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
innerIndexPtr	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Index* innerIndexPtr() const$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
innerIndexPtr	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline Index* innerIndexPtr()$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:()
innerIndexPtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Index* innerIndexPtr() const { return &m_data.index(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
innerIndexPtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index* innerIndexPtr() { return &m_data.index(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
innerIndexPtr	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Index* innerIndexPtr() const { return &m_data.index(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
innerIndexPtr	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index* innerIndexPtr() { return &m_data.index(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
innerInd	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int *innerInd;$/;"	m	struct:Eigen::SluMatrix::__anon1	access:public
InnerIterator	../include/Eigen/src/Core/Flagged.h	/^    typedef typename ExpressionType::InnerIterator InnerIterator;$/;"	t	class:Eigen::Flagged	access:public
InnerIterator	../include/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE InnerIterator(const Derived& expr, Index outer)$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:(const Derived& expr, Index outer)
InnerIterator	../include/Eigen/src/SparseCore/CoreIterators.h	/^template<typename Derived> class DenseBase<Derived>::InnerIterator$/;"	c	class:Eigen::DenseBase
InnerIterator	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix<Scalar,_Flags,_Index>::InnerIterator$/;"	c	class:Eigen::MappedSparseMatrix
InnerIterator	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    InnerIterator(const MappedSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:(const MappedSparseMatrix& mat, Index outer)
InnerIterator	../include/Eigen/src/SparseCore/SparseBlock.h	/^    class InnerIterator: public MatrixType::InnerIterator$/;"	c	class:Eigen::SparseInnerVectorSet	inherits:MatrixType::InnerIterator	access:public
InnerIterator	../include/Eigen/src/SparseCore/SparseBlock.h	/^        inline InnerIterator(const SparseInnerVectorSet& xpr, Index outer)$/;"	f	class:Eigen::SparseInnerVectorSet::InnerIterator	access:public	signature:(const SparseInnerVectorSet& xpr, Index outer)
InnerIterator	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp,Lhs,Rhs,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseBinaryOpImpl	inherits:internal::sparse_cwise_binary_op_inner_iterator_selector
InnerIterator	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseBinaryOpImpl& binOp, typename CwiseBinaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseBinaryOpImpl::InnerIterator	access:public	signature:(const CwiseBinaryOpImpl& binOp, typename CwiseBinaryOpImpl::Index outer)
InnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseUnaryOpImpl	inherits:CwiseUnaryOpImpl::MatrixTypeIterator
InnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseUnaryViewImpl	inherits:CwiseUnaryViewImpl::MatrixTypeIterator
InnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:public	signature:(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)
InnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)
InnerIterator	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^class SparseDenseOuterProduct<Lhs,Rhs,Transpose>::InnerIterator : public _LhsNested::InnerIterator$/;"	c	class:Eigen::SparseDenseOuterProduct	inherits:_LhsNested::InnerIterator
InnerIterator	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE InnerIterator(const SparseDenseOuterProduct& prod, Index outer)$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:(const SparseDenseOuterProduct& prod, Index outer)
InnerIterator	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^                <_LhsNested,_RhsNested,SparseDiagonalProduct,LhsMode,RhsMode> InnerIterator;$/;"	t	class:Eigen::SparseDiagonalProduct	access:public
InnerIterator	../include/Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::SparseMatrix
InnerIterator	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    InnerIterator(const SparseMatrix& mat, Index outer)$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:(const SparseMatrix& mat, Index outer)
InnerIterator	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    EIGEN_STRONG_INLINE InnerIterator(const TransposeImpl& trans, typename TransposeImpl<MatrixType,Sparse>::Index outer)$/;"	f	class:Eigen::TransposeImpl::InnerIterator	access:public	signature:(const TransposeImpl& trans, typename TransposeImpl<MatrixType,Sparse>::Index outer)
InnerIterator	../include/Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::TransposeImpl	inherits:_MatrixTypeNested::InnerIterator
InnerIterator	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^class SparseTriangularView<MatrixType,Mode>::InnerIterator : public MatrixTypeNestedCleaned::InnerIterator$/;"	c	class:Eigen::SparseTriangularView	inherits:MatrixTypeNestedCleaned::InnerIterator
InnerIterator	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator(const SparseTriangularView& view, Index outer)$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:(const SparseTriangularView& view, Index outer)
InnerIterator	../include/Eigen/src/SparseCore/SparseVector.h	/^class SparseVector<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::SparseVector
InnerIterator	../include/Eigen/src/SparseCore/SparseVector.h	/^    InnerIterator(const internal::CompressedStorage<Scalar,Index>& data)$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:(const internal::CompressedStorage<Scalar,Index>& data)
InnerIterator	../include/Eigen/src/SparseCore/SparseVector.h	/^    InnerIterator(const SparseVector& vec, Index outer=0)$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:(const SparseVector& vec, Index outer=0)
InnerIterator	../include/Eigen/src/SparseCore/SparseView.h	/^class SparseView<MatrixType>::InnerIterator : public _MatrixTypeNested::InnerIterator$/;"	c	class:Eigen::SparseView	inherits:_MatrixTypeNested::InnerIterator
InnerIterator	../include/Eigen/src/SparseCore/SparseView.h	/^  InnerIterator(const SparseView& view, Index outer) :$/;"	f	class:Eigen::SparseView::InnerIterator	access:public	signature:(const SparseView& view, Index outer)
InnerMaxSize	../include/Eigen/src/Core/Assign.h	/^    InnerMaxSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::assign_traits::__anon219
InnerMaxSize	../include/Eigen/src/Core/Assign_MKL.h	/^      InnerMaxSize  = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
InnerMaxSize	../include/Eigen/src/Core/Redux.h	/^    InnerMaxSize = int(Derived::IsRowMajor)$/;"	e	enum:Eigen::internal::redux_traits::__anon267
innerNonZeroPtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Index* innerNonZeroPtr() const { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
innerNonZeroPtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index* innerNonZeroPtr() { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
innerNonZeros	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const  Eigen::Map<const Matrix<Index,Dynamic,1> > innerNonZeros() const { return Eigen::Map<const Matrix<Index,Dynamic,1> >(m_innerNonZeros, m_innerNonZeros?m_outerSize:0); }$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:() const
innerNonZeros	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Eigen::Map<Matrix<Index,Dynamic,1> > innerNonZeros() { return Eigen::Map<Matrix<Index,Dynamic,1> >(m_innerNonZeros, m_innerNonZeros?m_outerSize:0); }$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:()
InnerProduct	../include/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon215
InnerRandomAccessPattern	../include/Eigen/src/SparseCore/SparseUtil.h	/^const int InnerRandomAccessPattern  = 0x2 | CoherentAccessPattern;$/;"	m	namespace:Eigen
InnerSizeAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::DenseBase::__anon216
InnerSize	../include/Eigen/src/Core/Assign.h	/^    InnerSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::assign_traits::__anon219
InnerSize	../include/Eigen/src/Core/Assign_MKL.h	/^      InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
InnerSize	../include/Eigen/src/Core/Block.h	/^    InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon228
innerSize	../include/Eigen/src/Core/DenseBase.h	/^    Index innerSize() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
InnerSize	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon87
InnerSize	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      InnerSize  = internal::traits<CoeffBasedProduct>::InnerSize,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon88
innerSize	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
innerSize	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Index innerSize() const { return (int(Flags)&RowMajorBit) ? this->cols() : this->rows(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
innerSize	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
InnerSize	../include/Eigen/src/SparseCore/SparseProduct.h	/^    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon17
innerSize	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index innerSize() const { return m_size; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
innerSize	../include/Eigen/src/SparseCore/SparseView.h	/^  inline Index innerSize() const { return m_matrix.innerSize(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
InnerStrideAtCompileTime	../include/Eigen/src/Core/Block.h	/^    InnerStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon228
InnerStrideAtCompileTime	../include/Eigen/src/Core/CwiseUnaryView.h	/^    InnerStrideAtCompileTime = MatrixTypeInnerStride == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon232
InnerStrideAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,$/;"	e	enum:Eigen::DenseBase::__anon216
inner_stride_at_compile_time	../include/Eigen/src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
inner_stride_at_compile_time	../include/Eigen/src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time$/;"	s	namespace:Eigen::internal
InnerStrideAtCompileTime	../include/Eigen/src/Core/Map.h	/^    InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon285
InnerStrideAtCompileTime	../include/Eigen/src/Core/Matrix.h	/^    InnerStrideAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon289
InnerStrideAtCompileTime	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    InnerStrideAtCompileTime = Lhs::InnerStrideAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon50
InnerStrideAtCompileTime	../include/Eigen/src/Core/Stride.h	/^      InnerStrideAtCompileTime = _InnerStrideAtCompileTime,$/;"	e	enum:Eigen::Stride::__anon57
InnerStrideAtCompileTime	../include/Eigen/src/Core/Transpose.h	/^    InnerStrideAtCompileTime = inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon73
innerStride	../include/Eigen/src/Core/Array.h	/^    inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Array	access:public	signature:() const
innerStride	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
innerStride	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
innerStride	../include/Eigen/src/Core/Block.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Block	access:public	signature:() const
innerStride	../include/Eigen/src/Core/Block.h	/^    inline Index innerStride() const;$/;"	p	class:Eigen::Block	access:public	signature:() const
innerStride	../include/Eigen/src/Core/CwiseUnaryView.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:() const
innerStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
innerStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void innerStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
innerStride	../include/Eigen/src/Core/Flagged.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
innerStride	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
innerStride	../include/Eigen/src/Core/Map.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Map	access:public	signature:() const
innerStride	../include/Eigen/src/Core/Matrix.h	/^    inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Matrix	access:public	signature:() const
innerStride	../include/Eigen/src/Core/NestByValue.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
innerStride	../include/Eigen/src/Core/Reverse.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Reverse	access:public	signature:() const
innerStride	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
innerStride	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
InnerStride	../include/Eigen/src/Core/Stride.h	/^class InnerStride : public Stride<0, Value>$/;"	c	namespace:Eigen	inherits:Stride
InnerStride	../include/Eigen/src/Core/Stride.h	/^    InnerStride() : Base() {}$/;"	f	class:Eigen::InnerStride	access:public	signature:()
InnerStride	../include/Eigen/src/Core/Stride.h	/^    InnerStride(Index v) : Base(0, v) {}$/;"	f	class:Eigen::InnerStride	access:public	signature:(Index v)
innerStride	../include/Eigen/src/Core/Swap.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
innerStride	../include/Eigen/src/Core/Transpose.h	/^    inline Index innerStride() const { return derived().nestedExpression().innerStride(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
innerStride	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return derived().innerStride(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
innerStride	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
InnerUnrolling	../include/Eigen/src/Core/util/Constants.h	/^  InnerUnrolling,$/;"	e	enum:Eigen::__anon210
innerVector	../include/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::innerVector(Index outer) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outer) const
innerVector	../include/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::innerVector(Index outer)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outer)
innerVector	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,1> innerVector(Index outer) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outer) const
innerVector	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,1> innerVector(Index outer);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outer)
InnerVectorizedTraversal	../include/Eigen/src/Core/util/Constants.h	/^  InnerVectorizedTraversal,$/;"	e	enum:Eigen::__anon209
innerVectors	../include/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outerStart, Index outerSize) const
innerVectors	../include/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index outerStart, Index outerSize)
innerVectors	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,Dynamic> innerVectors(Index outerStart, Index outerSize) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outerStart, Index outerSize) const
innerVectors	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,Dynamic> innerVectors(Index outerStart, Index outerSize);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index outerStart, Index outerSize)
inplace_decomposition	../include/Eigen/src/Cholesky/LLT.h	/^  static bool inplace_decomposition(MatrixType& m)$/;"	f	struct:Eigen::internal::LLT_Traits	access:public	signature:(MatrixType& m)
inplace_transpose_selector	../include/Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,false> { \/\/ non square matrix$/;"	s	namespace:Eigen::internal
inplace_transpose_selector	../include/Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,true> { \/\/ square matrix$/;"	s	namespace:Eigen::internal
InputScalar	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MatrixType::Scalar InputScalar;$/;"	t	struct:Eigen::internal::traits	access:public
insertBackByOuterInner	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index outer, Index inner)
insertBackByOuterInner	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index outer, Index inner)
insertBackByOuterInnerUnordered	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInnerUnordered(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index outer, Index inner)
insertBack	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBack(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
insertBack	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBack(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
insertBackUncompressed	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
insertByOuterInner	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertByOuterInner(Index j, Index i)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index j, Index i)
insertCompressed	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertCompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:(Index row, Index col)
insert	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index row, Index col)
insert	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index row, Index col)
insert	../include/Eigen/src/SparseCore/SparseVector.h	/^    Scalar& insert(Index i)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index i)
insert	../include/Eigen/src/StlSupport/StdDeque.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const_iterator position, const value_type& x)
insert	../include/Eigen/src/StlSupport/StdDeque.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const_iterator position, size_type new_size, const value_type& x)
insert	../include/Eigen/src/StlSupport/StdList.h	/^    iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::list	access:private	signature:(const_iterator position, const value_type& x)
insert	../include/Eigen/src/StlSupport/StdList.h	/^    void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::list	access:private	signature:(const_iterator position, size_type new_size, const value_type& x)
insert	../include/Eigen/src/StlSupport/StdVector.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::vector	access:private	signature:(const_iterator position, const value_type& x)
insert	../include/Eigen/src/StlSupport/StdVector.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::vector	access:private	signature:(const_iterator position, size_type new_size, const value_type& x)
insertUncompressed	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:(Index row, Index col)
instance_type	../include/abcd.h	/^    int instance_type; \/\/\/ The type of process : 0 for CG, 1 for MUMPS Slave$/;"	m	class:abcd	access:public
IntColVectorType	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1, MatrixType::Options, MatrixType::MaxRowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::LU	access:public
IntColVectorType	../include/Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;$/;"	t	class:Eigen::FullPivLU	access:public
IntColVectorType	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Index, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::PardisoImpl	access:public
IntColVectorType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
IntColVectorType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
IntColVectorType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;    $/;"	t	class:Eigen::SuperLUBase	access:public
IntColVectorType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntColVectorType IntColVectorType;    $/;"	t	class:Eigen::SuperLU	access:public
IntColVectorType	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::UmfPackLU	access:public
inter_comm	../include/abcd.h	/^    mpi::communicator inter_comm; \/\/\/ The communicator shared by CG masters$/;"	m	class:abcd	access:public
internal	../include/Eigen/src/Cholesky/LDLT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Cholesky/LLT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Cholesky/LLT.h	/^namespace internal{$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Cholesky/LLT_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/arch/NEON/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/arch/SSE/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Array.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/ArrayWrapper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Assign.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Assign_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/BandMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Block.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/BooleanRedux.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/CwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/CwiseNullaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/CwiseUnaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/CwiseUnaryView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/DenseCoeffsBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/DenseStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Diagonal.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/DiagonalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/DiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Dot.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Flagged.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/ForceAlignedAccess.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Functors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Fuzzy.h	/^namespace internal$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/GeneralProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/GenericPacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/GlobalFunctions.h	/^  namespace internal$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/IO.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Map.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Matrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/NestByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/PermutationMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/PlainObjectBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/ProductBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Product.h	/^namespace internal {$/;"	n
internal	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/Parallelizer.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Random.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Redux.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Replicate.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/ReturnByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Reverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Select.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/SelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/SolveTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/StableNorm.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Swap.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Transpose.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Transpositions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/TriangularMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/util/BlasUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/util/Macros.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/util/Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/util/Meta.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/util/MKL_support.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/util/StaticAssert.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/util/XprHelper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/VectorBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/VectorwiseOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Core/Visitor.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Eigen2Support/Minor.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Geometry/AngleAxis.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Geometry/Homogeneous.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Geometry/OrthoMethods.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Geometry/Quaternion.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Geometry/Rotation2D.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Geometry/RotationBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Geometry/Transform.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Geometry/Umeyama.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Householder/BlockHouseholder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Householder/Householder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Householder/HouseholderSequence.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/Jacobi/Jacobi.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/LU/Determinant.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/LU/FullPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/LU/Inverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/LU/PartialPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/LU/PartialPivLU_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/misc/Image.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/misc/Kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/misc/Solve.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/misc/SparseSolve.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/OrderingMethods/Amd.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace internal$/;"	n	namespace:Eigen
internal	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace internal$/;"	n	namespace:Eigen
internal	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/QR/HouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/QR/HouseholderQR_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/AmbiVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/CompressedStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparseBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparsePermutation.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparseUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparseVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/SparseView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SparseCore/TriangularSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/StlSupport/details.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SVD/JacobiSVD.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal::traits::CoeffReadCost	../include/Eigen/src/Core/Product.h	/^    CoeffReadCost = 0 \/\/ TODO CoeffReadCost should not be part of the expression traits$/;"	e	enum:internal::traits::__anon48
internal::traits::ColsAtCompileTime	../include/Eigen/src/Core/Product.h	/^    ColsAtCompileTime = RhsCleaned::ColsAtCompileTime,$/;"	e	enum:internal::traits::__anon48
internal::traits::Flags	../include/Eigen/src/Core/Product.h	/^    Flags = (MaxRowsAtCompileTime==1 ? RowMajorBit : 0), \/\/ TODO should be no storage order$/;"	e	enum:internal::traits::__anon48
internal::traits	../include/Eigen/src/Core/Product.h	/^struct traits<Product<Lhs, Rhs> >$/;"	s	namespace:internal
internal::traits::Index	../include/Eigen/src/Core/Product.h	/^                                      typename traits<RhsCleaned>::Index>::type Index;$/;"	t	struct:internal::traits	access:public
internal::traits::LhsCleaned	../include/Eigen/src/Core/Product.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:internal::traits	access:public
internal::traits::MaxColsAtCompileTime	../include/Eigen/src/Core/Product.h	/^    MaxColsAtCompileTime = RhsCleaned::MaxColsAtCompileTime,$/;"	e	enum:internal::traits::__anon48
internal::traits::MaxRowsAtCompileTime	../include/Eigen/src/Core/Product.h	/^    MaxRowsAtCompileTime = LhsCleaned::MaxRowsAtCompileTime,$/;"	e	enum:internal::traits::__anon48
internal::traits::RhsCleaned	../include/Eigen/src/Core/Product.h	/^  typedef typename remove_all<Rhs>::type RhsCleaned;$/;"	t	struct:internal::traits	access:public
internal::traits::RowsAtCompileTime	../include/Eigen/src/Core/Product.h	/^    RowsAtCompileTime = LhsCleaned::RowsAtCompileTime,$/;"	e	enum:internal::traits::__anon48
internal::traits::Scalar	../include/Eigen/src/Core/Product.h	/^  typedef typename scalar_product_traits<typename traits<LhsCleaned>::Scalar, typename traits<RhsCleaned>::Scalar>::ReturnType Scalar;$/;"	t	struct:internal::traits	access:public
internal::traits::StorageKind	../include/Eigen/src/Core/Product.h	/^                                        typename traits<RhsCleaned>::StorageKind>::ret StorageKind;$/;"	t	struct:internal::traits	access:public
internal::traits::XprKind	../include/Eigen/src/Core/Product.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:internal::traits	access:public
intersection	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  VectorType intersection(const Hyperplane& other)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane& other)
intersection	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim>::intersection(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
intersection	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  Scalar intersection(const Hyperplane<_Scalar, _AmbientDim>& hyperplane);$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
intersection	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox intersection(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
intersection	../include/Eigen/src/Geometry/Hyperplane.h	/^  VectorType intersection(const Hyperplane& other) const$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane& other) const
intersection	../include/Eigen/src/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
intersection	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  Scalar intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
intersectionParameter	../include/Eigen/src/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionParameter(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
intersectionParameter	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  Scalar intersectionParameter(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
intersectionPoint	../include/Eigen/src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
intersectionPoint	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const
intra_comm	../include/abcd.h	/^    mpi::communicator intra_comm; \/\/\/ The communicator of local slaves$/;"	m	class:abcd	access:public
IntRowVectorType	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime, MatrixType::Options, 1, MatrixType::MaxColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::LU	access:public
IntRowVectorType	../include/Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::FullPivLU	access:public
IntRowVectorType	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Index, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::PardisoImpl	access:public
IntRowVectorType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
IntRowVectorType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef Matrix<Index, 1, ColsAtCompileTime, RowMajor, 1, MaxColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
IntRowVectorType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::SuperLUBase	access:public
IntRowVectorType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntRowVectorType IntRowVectorType;$/;"	t	class:Eigen::SuperLU	access:public
IntRowVectorType	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::UmfPackLU	access:public
InvalidInput	../include/Eigen/src/Core/util/Constants.h	/^  InvalidInput = 3$/;"	e	enum:Eigen::ComputationInfo
INVALID_MATRIXBASE_TEMPLATE_PARAMETERS	../include/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIXBASE_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION	../include/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
INVALID_MATRIX_PRODUCT	../include/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
INVALID_MATRIX_TEMPLATE_PARAMETERS	../include/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION	../include/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
InvalidTraversal	../include/Eigen/src/Core/util/Constants.h	/^  InvalidTraversal$/;"	e	enum:Eigen::__anon209
INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS	../include/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
inverse_impl	../include/Eigen/src/LU/Inverse.h	/^  inverse_impl(const MatrixType& matrix)$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:(const MatrixType& matrix)
inverse_impl	../include/Eigen/src/LU/Inverse.h	/^struct inverse_impl : public ReturnByValue<inverse_impl<MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
inverse	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inverse() const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
inverse	../include/Eigen/src/Core/MatrixBase.h	/^    const internal::inverse_impl<Derived> inverse() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
inverse	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Transpose<PermutationBase> inverse() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
inverse	../include/Eigen/src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> inverse() const$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
inverse	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_inverse_op)  inverse() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
inverse	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::inverse() const$/;"	f	class:Eigen::Cwise	signature:() const
inverse	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
inverse	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::inverse() const$/;"	f	class:Eigen::Quaternion	signature:() const
inverse	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion inverse(void) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(void) const
inverse	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D inverse() const { return -m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
inverse	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
inverse	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling inverse() const$/;"	f	class:Eigen::Scaling	access:public	signature:() const
inverse	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline const MatrixType inverse(TransformTraits traits = Affine) const;$/;"	p	class:Eigen::Transform	access:public	signature:(TransformTraits traits = Affine) const
inverse	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::inverse(TransformTraits traits) const$/;"	f	class:Eigen::Transform	signature:(TransformTraits traits) const
inverse	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
inverse	../include/Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis	access:public	signature:() const
inverse	../include/Eigen/src/Geometry/Quaternion.h	/^inline Quaternion<typename internal::traits<Derived>::Scalar> QuaternionBase<Derived>::inverse() const$/;"	f	class:Eigen::QuaternionBase	signature:() const
inverse	../include/Eigen/src/Geometry/Quaternion.h	/^  Quaternion<Scalar> inverse() const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:() const
inverse	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D inverse() const { return -m_angle; }$/;"	f	class:Eigen::Rotation2D	access:public	signature:() const
inverse	../include/Eigen/src/Geometry/RotationBase.h	/^    inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
inverse	../include/Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling inverse() const$/;"	f	class:Eigen::UniformScaling	access:public	signature:() const
inverse	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform inverse(TransformTraits traits = (TransformTraits)Mode) const;$/;"	p	class:Eigen::Transform	access:public	signature:(TransformTraits traits = (TransformTraits)Mode) const
inverse	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::inverse(TransformTraits hint) const$/;"	f	class:Eigen::Transform	signature:(TransformTraits hint) const
inverse	../include/Eigen/src/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
inverse	../include/Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType inverse() const { return adjoint(); }$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
inverse	../include/Eigen/src/LU/FullPivLU.h	/^    inline const internal::solve_retval<FullPivLU,typename MatrixType::IdentityReturnType> inverse() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
inverse	../include/Eigen/src/LU/Inverse.h	/^inline const internal::inverse_impl<Derived> MatrixBase<Derived>::inverse() const$/;"	f	class:Eigen::MatrixBase	signature:() const
inverse	../include/Eigen/src/LU/PartialPivLU.h	/^    inline const internal::solve_retval<PartialPivLU,typename MatrixType::IdentityReturnType> inverse() const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
inverse	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^inverse() const$/;"	f	signature:() const
inverse	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inverse() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
inverse	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inverse() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
IOFormat	../include/Eigen/src/Core/IO.h	/^  IOFormat(int _precision = StreamPrecision, int _flags = 0,$/;"	f	struct:Eigen::IOFormat	access:public	signature:(int _precision = StreamPrecision, int _flags = 0, const std::string& _coeffSeparator = , const std::string& _rowSeparator = , const std::string& _rowPrefix=, const std::string& _rowSuffix=, const std::string& _matPrefix=, const std::string& _matSuffix=)
IOFormat	../include/Eigen/src/Core/IO.h	/^struct IOFormat$/;"	s	namespace:Eigen
iparm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Array<Index,IPARM_SIZE,1>& iparm()$/;"	f	class:Eigen::PastixBase	access:public	signature:()
iparm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int& iparm(int idxparam)$/;"	f	class:Eigen::PastixBase	access:public	signature:(int idxparam)
ip_comp	../include/abcd.h	/^bool ip_comp(const dipair &, const dipair &);$/;"	p	signature:(const dipair &, const dipair &)
ip_comp	../src/utils.cpp	/^bool ip_comp(const dipair &l, const dipair &r)$/;"	f	signature:(const dipair &l, const dipair &r)
ip_comp	utils.cpp	/^bool ip_comp(const dipair &l, const dipair &r)$/;"	f
iqamax	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(iqamax)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
iqamin	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(iqamin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
iqmax	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(iqmax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
iqmin	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(iqmin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
irn	../include/abcd.h	/^    int *irn;$/;"	m	class:abcd	access:public
IsAligned	../include/Eigen/src/Core/Map.h	/^    IsAligned = bool(EIGEN_ALIGN) && ((int(MapOptions)&Aligned)==Aligned),$/;"	e	enum:Eigen::internal::traits::__anon285
IsAligned	../include/Eigen/src/Geometry/Quaternion.h	/^  enum { IsAligned = internal::traits<Quaternion>::IsAligned };$/;"	e	enum:Eigen::Quaternion::__anon387
IsAligned	../include/Eigen/src/Geometry/Quaternion.h	/^    IsAligned = internal::traits<Coefficients>::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::traits::__anon386
IsAligned	../include/Eigen/src/Geometry/Quaternion.h	/^      IsAligned = TraitsBase::IsAligned,$/;"	e	enum:Eigen::internal::traits::__anon388
IsAligned	../include/Eigen/src/Geometry/Quaternion.h	/^      IsAligned = TraitsBase::IsAligned,$/;"	e	enum:Eigen::internal::traits::__anon389
isamax	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(isamax)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
isamin	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(isamin)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
isApprox	../include/Eigen/src/Core/DenseBase.h	/^    bool isApprox(const DenseBase<OtherDerived>& other,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/Core/DiagonalMatrix.h	/^    bool isApprox(const DiagonalBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(const DiagonalBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/Core/DiagonalMatrix.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isApprox($/;"	f	class:Eigen::DenseBase	signature:( const DenseBase<OtherDerived>& other, RealScalar prec ) const
isApprox	../include/Eigen/src/Core/MathFunctions.h	/^inline bool isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
isApprox	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(bool x, bool y, bool)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl	access:public	signature:(bool x, bool y, bool)
isApprox	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar&)
isApprox	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar& prec)
isApprox	../include/Eigen/src/Core/TriangularMatrix.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/Core/TriangularMatrix.h	/^    bool isApprox(const TriangularView<OtherMatrixType, Mode>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const TriangularView<OtherMatrixType, Mode>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  bool isApprox(const AlignedBox& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  bool isApprox(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  bool isApprox(const Hyperplane& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  bool isApprox(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  bool isApprox(const Quaternion& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  bool isApprox(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  bool isApprox(const Scaling& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  bool isApprox(const Transform& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  bool isApprox(const Translation& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const
isApprox	../include/Eigen/src/Geometry/AlignedBox.h	/^  bool isApprox(const AlignedBox& other, RealScalar prec = ScalarTraits::dummy_precision()) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& other, RealScalar prec = ScalarTraits::dummy_precision()) const
isApprox	../include/Eigen/src/Geometry/AngleAxis.h	/^  bool isApprox(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/Geometry/Hyperplane.h	/^  bool isApprox(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  bool isApprox(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/Geometry/Quaternion.h	/^  bool isApprox(const QuaternionBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/Geometry/Rotation2D.h	/^  bool isApprox(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/Geometry/Scaling.h	/^  bool isApprox(const UniformScaling& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const UniformScaling& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/Geometry/Transform.h	/^  bool isApprox(const Transform& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/Geometry/Translation.h	/^  bool isApprox(const Translation& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
isApprox	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const SparseMatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
isApproxOrLessThan	../include/Eigen/src/Core/MathFunctions.h	/^inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
isApproxOrLessThan	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const bool& x, const bool& y, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl	access:public	signature:(const bool& x, const bool& y, const bool&)
isApproxOrLessThan	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar&)
isApproxOrLessThan	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar& y, const RealScalar& prec)
isApprox_selector	../include/Eigen/src/Core/Fuzzy.h	/^struct isApprox_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
isApprox_selector	../include/Eigen/src/Core/Fuzzy.h	/^struct isApprox_selector$/;"	s	namespace:Eigen::internal
isApproxToConstant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isApproxToConstant$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& value, RealScalar prec) const
isApproxToConstant	../include/Eigen/src/Core/DenseBase.h	/^    bool isApproxToConstant(const Scalar& value, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
is_arithmetic	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	s	namespace:Eigen::internal
IsColMajor	../include/Eigen/src/Core/Reverse.h	/^      IsColMajor = !IsRowMajor,$/;"	e	enum:Eigen::Reverse::__anon116
IsColVector	../include/Eigen/src/Core/VectorBlock.h	/^      IsColVector = !(internal::traits<VectorType>::Flags & RowMajorBit)$/;"	e	enum:Eigen::VectorBlock::__anon49
IsColVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    enum { IsColVector = internal::traits<SparseVector>::IsColVector };$/;"	e	enum:Eigen::SparseVector::__anon26
IsColVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    IsColVector = (_Options & RowMajorBit) ? 0 : 1,$/;"	e	enum:Eigen::internal::traits::__anon25
IsComplex	../include/Eigen/src/Core/NumTraits.h	/^    IsComplex = 0,$/;"	e	enum:Eigen::GenericNumTraits::__anon277
IsComplex	../include/Eigen/src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon202
IsComplex	../include/Eigen/src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon203
isCompressed	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline bool isCompressed() const { return m_innerNonZeros==0; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
isConstant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isConstant$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& value, RealScalar prec) const
isConstant	../include/Eigen/src/Core/DenseBase.h	/^    bool isConstant(const Scalar& value, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
is_const	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
is_const	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
IsDense	../include/Eigen/src/Core/util/Constants.h	/^  IsDense         = 0,$/;"	e	enum:Eigen::__anon214
isDiagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^bool MatrixBase<Derived>::isDiagonal(RealScalar prec) const$/;"	f	class:Eigen::MatrixBase	signature:(RealScalar prec) const
isDiagonal	../include/Eigen/src/Core/MatrixBase.h	/^    bool isDiagonal(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
is_diagonal	../include/Eigen/src/Core/util/Meta.h	/^template<typename T, int S> struct is_diagonal<DiagonalMatrix<T,S> >$/;"	s	namespace:Eigen
is_diagonal	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_diagonal<DiagonalBase<T> >$/;"	s	namespace:Eigen
is_diagonal	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_diagonal<DiagonalWrapper<T> >$/;"	s	namespace:Eigen
is_diagonal	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_diagonal$/;"	s	namespace:Eigen
IsDynamicSize	../include/Eigen/src/Core/Map.h	/^    IsDynamicSize = PlainObjectType::SizeAtCompileTime==Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon285
isEmpty	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline bool isEmpty() const { return (m_min.array() > m_max.array()).any(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
isfinite	../include/Eigen/src/Core/MathFunctions.h	/^template<typename T> bool isfinite(const T& x)$/;"	f	namespace:Eigen::internal	signature:(const T& x)
isFullRank	../include/Eigen/src/Eigen2Support/QR.h	/^    bool isFullRank() const {$/;"	f	class:Eigen::QR	access:public	signature:() const
IsHorizontal	../include/Eigen/src/Core/VectorwiseOp.h	/^      IsHorizontal = (Direction==Horizontal) ? 1 : 0$/;"	e	enum:Eigen::VectorwiseOp::__anon71
isIdentity	../include/Eigen/src/Core/CwiseNullaryOp.h	/^bool MatrixBase<Derived>::isIdentity$/;"	f	class:Eigen::MatrixBase	signature:(RealScalar prec) const
isIdentity	../include/Eigen/src/Core/MatrixBase.h	/^    bool isIdentity(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
isInjective	../include/Eigen/src/LU/FullPivLU.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
isInjective	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
isInjective	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
IsInteger	../include/Eigen/src/Core/NumTraits.h	/^    IsInteger = std::numeric_limits<T>::is_integer,$/;"	e	enum:Eigen::GenericNumTraits::__anon277
isInvertible	../include/Eigen/src/LU/FullPivLU.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
isInvertible	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
isInvertible	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
is_large	../include/Eigen/src/Core/GeneralProduct.h	/^  enum { is_large = MaxSize == Dynamic ||$/;"	e	enum:Eigen::internal::product_size_category::__anon121
IsLower	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon102
IsLower	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon103
IsLower	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon93
IsLower	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon94
IsLower	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon104
IsLower	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon105
IsLower	../include/Eigen/src/Core/SolveTriangular.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon364
isLowerTriangular	../include/Eigen/src/Core/MatrixBase.h	/^    bool isLowerTriangular(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
isLowerTriangular	../include/Eigen/src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isLowerTriangular(RealScalar prec) const$/;"	f	class:Eigen::MatrixBase	signature:(RealScalar prec) const
is_malloc_allowed_impl	../include/Eigen/src/Core/util/Memory.h	/^inline bool is_malloc_allowed_impl(bool update, bool new_value = false)$/;"	f	namespace:Eigen::internal	signature:(bool update, bool new_value = false)
is_malloc_allowed	../include/Eigen/src/Core/util/Memory.h	/^inline bool is_malloc_allowed() { return is_malloc_allowed_impl(false); }$/;"	f	namespace:Eigen::internal	signature:()
ismax	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(ismax) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
ismin	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(ismin)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
isMuchSmallerThan	../include/Eigen/src/Core/DenseBase.h	/^    bool isMuchSmallerThan(const DenseBase<OtherDerived>& other,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
isMuchSmallerThan	../include/Eigen/src/Core/DenseBase.h	/^    bool isMuchSmallerThan(const RealScalar& other,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const RealScalar& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
isMuchSmallerThan	../include/Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isMuchSmallerThan($/;"	f	class:Eigen::DenseBase	signature:( const DenseBase<OtherDerived>& other, RealScalar prec ) const
isMuchSmallerThan	../include/Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isMuchSmallerThan($/;"	f	class:Eigen::DenseBase	signature:( const typename NumTraits<Scalar>::Real& other, RealScalar prec ) const
isMuchSmallerThan	../include/Eigen/src/Core/MathFunctions.h	/^inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const OtherScalar& y, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
isMuchSmallerThan	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const bool& x, const bool&, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl	access:public	signature:(const bool& x, const bool&, const bool&)
isMuchSmallerThan	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const OtherScalar& y, const RealScalar& prec)
isMuchSmallerThan	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const Scalar&, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public	signature:(const Scalar& x, const Scalar&, const RealScalar&)
isMuchSmallerThan_object_selector	../include/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_object_selector	../include/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_scalar_selector	../include/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector<Derived, true>$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_scalar_selector	../include/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector$/;"	s	namespace:Eigen::internal
isNegative	../include/Eigen/src/Cholesky/LDLT.h	/^    inline bool isNegative(void) const$/;"	f	class:Eigen::LDLT	access:public	signature:(void) const
isNull	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool isNull() const { return (m_min.cwise() > m_max).any(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
isNull	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline bool isNull() const { return isEmpty(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
Isometry2d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Isometry> Isometry2d;$/;"	t	namespace:Eigen
Isometry2f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Isometry> Isometry2f;$/;"	t	namespace:Eigen
Isometry3d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Isometry> Isometry3d;$/;"	t	namespace:Eigen
Isometry3f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Isometry> Isometry3f;$/;"	t	namespace:Eigen
Isometry	../include/Eigen/src/Core/util/Constants.h	/^  Isometry      = 0x1,$/;"	e	enum:Eigen::TransformTraits
IsometryTransformType	../include/Eigen/src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Isometry> IsometryTransformType;$/;"	t	class:Eigen::Translation	access:public
isOnes	../include/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isOnes$/;"	f	class:Eigen::DenseBase	signature:(RealScalar prec) const
isOnes	../include/Eigen/src/Core/DenseBase.h	/^    bool isOnes(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
isOrthogonal	../include/Eigen/src/Core/Dot.h	/^bool MatrixBase<Derived>::isOrthogonal$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other, RealScalar prec) const
isOrthogonal	../include/Eigen/src/Core/MatrixBase.h	/^    bool isOrthogonal(const MatrixBase<OtherDerived>& other,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
isPositiveDefinite	../include/Eigen/src/Cholesky/LDLT.h	/^    inline bool isPositiveDefinite() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
isPositiveDefinite	../include/Eigen/src/Cholesky/LLT.h	/^    bool isPositiveDefinite() const { return true; }$/;"	f	class:Eigen::LLT	access:public	signature:() const
isPositive	../include/Eigen/src/Cholesky/LDLT.h	/^    inline bool isPositive() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
IsProjective	../include/Eigen/src/Geometry/Transform.h	/^    IsProjective = (int(Mode)==int(Projective))$/;"	e	enum:Eigen::internal::transform_traits::__anon373
IsRepeatable	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon321
IsRepeatable	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon319
IsRepeatable	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon320
IsRepeatable	../include/Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon365
IsRowMajor	../include/Eigen/src/Core/Block.h	/^    IsRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon228
IsRowMajor	../include/Eigen/src/Core/DenseBase.h	/^      IsRowMajor = int(Flags) & RowMajorBit, \/**< True if this expression has row-major storage order. *\/$/;"	e	enum:Eigen::DenseBase::__anon216
IsRowMajor	../include/Eigen/src/Core/Replicate.h	/^    IsRowMajor = MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1 ? 1$/;"	e	enum:Eigen::internal::traits::__anon67
IsRowMajor	../include/Eigen/src/SparseCore/CoreIterators.h	/^    enum { IsRowMajor = (Derived::Flags&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::DenseBase::InnerIterator::__anon34
IsRowMajor	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::MappedSparseMatrix::__anon15
IsRowMajor	../include/Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<SparseInnerVectorSet>::IsRowMajor };$/;"	e	enum:Eigen::SparseInnerVectorSet::__anon21
IsRowMajor	../include/Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<SparseInnerVectorSet>::IsRowMajor };$/;"	e	enum:Eigen::SparseInnerVectorSet::__anon22
IsRowMajor	../include/Eigen/src/SparseCore/SparseBlock.h	/^    IsRowMajor = (int(MatrixType::Flags)&RowMajorBit)==RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon20
IsRowMajor	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Lhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::__anon23
IsRowMajor	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Rhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::__anon24
IsRowMajor	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      IsRowMajor = Flags&RowMajorBit ? 1 : 0,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
isRValue	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isRValue() const { return m_isRValue; }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
is_same	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
is_same	../include/Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
IsSigned	../include/Eigen/src/Core/NumTraits.h	/^    IsSigned = std::numeric_limits<T>::is_signed,$/;"	e	enum:Eigen::GenericNumTraits::__anon277
IsSparse	../include/Eigen/src/Core/util/Constants.h	/^  IsSparse$/;"	e	enum:Eigen::__anon214
IsSupported	../include/Eigen/src/Core/Assign_MKL.h	/^{ enum { IsSupported = 0 }; };$/;"	e	enum:Eigen::internal::vml_call::__anon282
isSurjective	../include/Eigen/src/LU/FullPivLU.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
isSurjective	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
isSurjective	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
IsTransposed	../include/Eigen/src/Core/util/BlasUtil.h	/^    IsTransposed = Base::IsTransposed ? 0 : 1$/;"	e	enum:Eigen::internal::blas_traits::__anon204
IsTransposed	../include/Eigen/src/Core/util/BlasUtil.h	/^    IsTransposed = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon202
isUnitary	../include/Eigen/src/Core/Dot.h	/^bool MatrixBase<Derived>::isUnitary(RealScalar prec) const$/;"	f	class:Eigen::MatrixBase	signature:(RealScalar prec) const
isUnitary	../include/Eigen/src/Core/MatrixBase.h	/^    bool isUnitary(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
isUpperTriangular	../include/Eigen/src/Core/MatrixBase.h	/^    bool isUpperTriangular(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
isUpperTriangular	../include/Eigen/src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isUpperTriangular(RealScalar prec) const$/;"	f	class:Eigen::MatrixBase	signature:(RealScalar prec) const
IsVectorAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1$/;"	e	enum:Eigen::DenseBase::__anon216
IsVectorAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^      IsVectorAtCompileTime = 0,$/;"	e	enum:Eigen::DiagonalBase::__anon279
IsVectorAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      IsVectorAtCompileTime = RowsAtCompileTime == 1 || ColsAtCompileTime == 1,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
isVector	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline bool isVector() const { return rows()==1 || cols()==1; }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
IsVertical	../include/Eigen/src/Core/VectorwiseOp.h	/^      IsVertical   = (Direction==Vertical) ? 1 : 0,$/;"	e	enum:Eigen::VectorwiseOp::__anon71
isZero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isZero(RealScalar prec) const$/;"	f	class:Eigen::DenseBase	signature:(RealScalar prec) const
isZero	../include/Eigen/src/Core/DenseBase.h	/^    bool isZero(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const
iterations	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int iterations() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
IterativeSolverBase	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^class IterativeSolverBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
IterativeSolverBase	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase(const MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const MatrixType& A)
~IterativeSolverBase	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ~IterativeSolverBase() {}$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
IterativeSolverBase	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase()$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
Iterator	../include/Eigen/src/SparseCore/AmbiVector.h	/^class AmbiVector<_Scalar,_Index>::Iterator$/;"	c	class:Eigen::internal::AmbiVector
Iterator	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Iterator(const AmbiVector& vec, RealScalar epsilon = 0)$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:(const AmbiVector& vec, RealScalar epsilon = 0)
IterBase	../include/Eigen/src/SparseCore/SparseView.h	/^  typedef typename _MatrixTypeNested::InnerIterator IterBase;$/;"	t	class:Eigen::SparseView::InnerIterator	access:public
itmax	../include/abcd.h	/^    int itmax;$/;"	m	class:abcd	access:public
ixamax	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(ixamax)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
ixamin	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(ixamin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
ixmax	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(ixmax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
ixmin	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(ixmin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
izamax	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(izamax)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
izamin	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(izamin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
izmax	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(izmax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
izmin	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(izmin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
JacobiRotation	../include/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation(const Scalar& c, const Scalar& s) : m_c(c), m_s(s) {}$/;"	f	class:Eigen::JacobiRotation	access:public	signature:(const Scalar& c, const Scalar& s)
JacobiRotation	../include/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation() {}$/;"	f	class:Eigen::JacobiRotation	access:public	signature:()
JacobiRotation	../include/Eigen/src/Jacobi/Jacobi.h	/^template<typename Scalar> class JacobiRotation$/;"	c	namespace:Eigen
jacobiSvd	../include/Eigen/src/Core/MatrixBase.h	/^    JacobiSVD<PlainObject> jacobiSvd(unsigned int computationOptions = 0) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(unsigned int computationOptions = 0) const
JacobiSVD	../include/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD(const MatrixType& matrix, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const MatrixType& matrix, unsigned int computationOptions = 0)
JacobiSVD	../include/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD()$/;"	f	class:Eigen::JacobiSVD	access:public	signature:()
JacobiSVD	../include/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD(Index rows, Index cols, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(Index rows, Index cols, unsigned int computationOptions = 0)
jacobiSvd	../include/Eigen/src/SVD/JacobiSVD.h	/^MatrixBase<Derived>::jacobiSvd(unsigned int computationOptions) const$/;"	f	class:Eigen::MatrixBase	signature:(unsigned int computationOptions) const
JacobiSVD	../include/Eigen/src/SVD/JacobiSVD.h	/^template<typename _MatrixType, int QRPreconditioner> class JacobiSVD$/;"	c	namespace:Eigen
JacobiSVDType	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<_MatrixType, QRPreconditioner> JacobiSVDType;$/;"	t	struct:Eigen::internal::solve_retval	access:public
jcn	../include/abcd.h	/^    int *jcn;$/;"	m	class:abcd	access:public
JointAlignment	../include/Eigen/src/Core/Assign.h	/^    JointAlignment = assign_traits<Derived1,Derived2>::JointAlignment$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon225
JointAlignment	../include/Eigen/src/Core/Assign.h	/^    JointAlignment = bool(DstIsAligned) && bool(SrcIsAligned) ? Aligned : Unaligned$/;"	e	enum:Eigen::internal::assign_traits::__anon218
kc	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex kc() const { return m_kc; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:() const
keep_diag	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    struct keep_diag {$/;"	s	class:Eigen::IncompleteLUT	access:protected
keep_diag	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    struct keep_diag {$/;"	s	class:Eigen::SimplicialCholeskyBase	access:protected
KeepsPacketAccess	../include/Eigen/src/Core/Map.h	/^    KeepsPacketAccess = bool(HasNoInnerStride)$/;"	e	enum:Eigen::internal::traits::__anon285
kernel	../include/Eigen/src/LU/FullPivLU.h	/^    inline const internal::kernel_retval<FullPivLU> kernel() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
KernelResultType	../include/Eigen/src/Eigen2Support/LU.h	/^    > KernelResultType;$/;"	t	class:Eigen::LU	access:public
kernel_retval_base	../include/Eigen/src/misc/Kernel.h	/^  kernel_retval_base(const DecompositionType& dec)$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:(const DecompositionType& dec)
kernel_retval_base	../include/Eigen/src/misc/Kernel.h	/^template<typename _DecompositionType> struct kernel_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
kernel_retval	../include/Eigen/src/LU/FullPivLU.h	/^struct kernel_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:kernel_retval_base
l1CacheSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l1CacheSize()$/;"	f	namespace:Eigen	signature:()
l2CacheSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l2CacheSize()$/;"	f	namespace:Eigen	signature:()
LargeEnough	../include/Eigen/src/Core/Assign_MKL.h	/^      LargeEnough = VmlSize==Dynamic || VmlSize>=EIGEN_MKL_VML_THRESHOLD,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
Large	../include/Eigen/src/Core/GeneralProduct.h	/^  Large = 2,$/;"	e	enum:Eigen::__anon120
LargeThreshold	../include/Eigen/src/Core/GeneralProduct.h	/^    LargeThreshold = EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD$/;"	e	enum:Eigen::internal::product_type::__anon122
lastCoeff	../include/Eigen/src/SparseCore/SparseBlock.h	/^    const Scalar& lastCoeff() const$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
lazyAssign	../include/Eigen/src/Core/Assign.h	/^  ::lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<OtherDerived>& other)
lazyAssign	../include/Eigen/src/Core/DenseBase.h	/^    Derived& lazyAssign(const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other)
lazyAssign	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& lazyAssign(const Flagged<OtherDerived, 0, EvalBeforeAssigningBit>& other)$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const Flagged<OtherDerived, 0, EvalBeforeAssigningBit>& other)
lazyAssign	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& lazyAssign(const ProductBase<ProductDerived, Lhs,Rhs>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
lazyAssign	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const DenseBase<OtherDerived>& other)
lazyAssign	../include/Eigen/src/Core/ProductBase.h	/^Derived& MatrixBase<Derived>::lazyAssign(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
lazyAssign	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE SelfCwiseBinaryOp& lazyAssign(const DenseBase<RhsDerived>& rhs)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(const DenseBase<RhsDerived>& rhs)
lazyAssign	../include/Eigen/src/Core/TriangularMatrix.h	/^    void lazyAssign(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other)
lazyAssign	../include/Eigen/src/Core/TriangularMatrix.h	/^    void lazyAssign(const TriangularBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const TriangularBase<OtherDerived>& other)
lazyAssign	../include/Eigen/src/Core/TriangularMatrix.h	/^void TriangularView<MatrixType, Mode>::lazyAssign(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<OtherDerived>& other)
lazyAssign	../include/Eigen/src/Core/TriangularMatrix.h	/^void TriangularView<MatrixType, Mode>::lazyAssign(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const TriangularBase<OtherDerived>& other)
LazyCoeffBasedProductMode	../include/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon215
LazyCoeffBasedProductType	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef CoeffBasedProduct<LhsNested,RhsNested,NestByRefBit> LazyCoeffBasedProductType;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
lazy	../include/Eigen/src/Core/MatrixBase.h	/^    const Flagged<Derived, 0, EvalBeforeAssigningBit> lazy() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
lazy	../include/Eigen/src/Eigen2Support/Lazy.h	/^MatrixBase<Derived>::lazy() const$/;"	f	class:Eigen::MatrixBase	signature:() const
lazyProduct	../include/Eigen/src/Core/GeneralProduct.h	/^MatrixBase<Derived>::lazyProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
lazyProduct	../include/Eigen/src/Core/MatrixBase.h	/^    lazyProduct(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
LazyProductReturnType	../include/Eigen/src/Core/GeneralProduct.h	/^struct LazyProductReturnType : public ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen	inherits:ProductReturnType
lda	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon1::__anon2	access:public
LDLT	../include/Eigen/src/Cholesky/LDLT.h	/^    LDLT(const MatrixType& matrix)$/;"	f	class:Eigen::LDLT	access:public	signature:(const MatrixType& matrix)
LDLT	../include/Eigen/src/Cholesky/LDLT.h	/^    LDLT(Index size)$/;"	f	class:Eigen::LDLT	access:public	signature:(Index size)
LDLT	../include/Eigen/src/Cholesky/LDLT.h	/^    LDLT() : m_matrix(), m_transpositions(), m_isInitialized(false) {}$/;"	f	class:Eigen::LDLT	access:public	signature:()
ldlt	../include/Eigen/src/Cholesky/LDLT.h	/^MatrixBase<Derived>::ldlt() const$/;"	f	class:Eigen::MatrixBase	signature:() const
ldlt	../include/Eigen/src/Cholesky/LDLT.h	/^SelfAdjointView<MatrixType, UpLo>::ldlt() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
LDLT	../include/Eigen/src/Cholesky/LDLT.h	/^template<typename _MatrixType, int _UpLo> class LDLT$/;"	c	namespace:Eigen
ldlt	../include/Eigen/src/Core/MatrixBase.h	/^    const LDLT<PlainObject> ldlt() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
ldlt	../include/Eigen/src/Core/SelfAdjointView.h	/^    const LDLT<PlainObject, UpLo> ldlt() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
ldlt_inplace	../include/Eigen/src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Lower>$/;"	s	namespace:Eigen::internal
ldlt_inplace	../include/Eigen/src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Upper>$/;"	s	namespace:Eigen::internal
LDLT_Traits	../include/Eigen/src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
LDLT_Traits	../include/Eigen/src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
LDLTTraits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT<MatrixType,UpLo> > LDLTTraits;$/;"	t	class:Eigen::SimplicialCholesky	access:public
LDLTType	../include/Eigen/src/Cholesky/LDLT.h	/^  typedef LDLT<_MatrixType,_UpLo> LDLTType;$/;"	t	struct:Eigen::internal::solve_retval	access:public
leftCols	../include/Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr leftCols(Index n)$/;"	f	signature:(Index n)
leftCols	../include/Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr leftCols(Index n) const$/;"	f	signature:(Index n) const
leftCols	../include/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type leftCols() const$/;"	f	signature:() const
leftCols	../include/Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type leftCols()$/;"	f	signature:()
length	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Index length() const { return m_length; }  \/**< \\brief Returns the length of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
level3_blocking	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class level3_blocking$/;"	c	namespace:Eigen::internal
level3_blocking	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    level3_blocking()$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:()
LhsBlasTraits	../include/Eigen/src/Core/ProductBase.h	/^    typedef internal::blas_traits<_LhsNested> LhsBlasTraits;$/;"	t	class:Eigen::ProductBase	access:public
LhsCleaned	../include/Eigen/src/Core/Product.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:internal::traits	access:public
LhsCleaned	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public
LhsCoeffReadCost	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon65
LhsCoeffReadCost	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon87
LhsCoeffReadCost	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    LhsCoeffReadCost = traits<_LhsNested>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon30
LhsCoeffReadCost	../include/Eigen/src/SparseCore/SparseProduct.h	/^    LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon17
LhsFlags	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon65
LhsFlags	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon87
LhsFlags	../include/Eigen/src/SparseCore/SparseProduct.h	/^    LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon17
lhs	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
_Lhs	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::product_type	access:public
lhs	../include/Eigen/src/Core/ProductBase.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
Lhs	../include/Eigen/src/Core/ProductBase.h	/^  typedef typename remove_all<_Lhs>::type Lhs;$/;"	t	struct:Eigen::internal::traits	access:public
lhs	../include/Eigen/src/Core/Product.h	/^    const LhsNestedCleaned& lhs() const { return m_lhs; }$/;"	f	class:Product	access:public	signature:() const
lhs	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Lhs	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Lhs	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,LhsMode,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Lhs	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
lhs	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
Lhs	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<SparseLhsType>::type Lhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
lhs	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
_Lhs	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::traits	access:public
lhs	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
LhsInnerIterator	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::InnerIterator LhsInnerIterator;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
LhsIsSelfAdjoint	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsSelfAdjoint = (LhsMode&SelfAdjoint)==SelfAdjoint,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon112
LhsIsUpper	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsUpper = (LhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon112
LhsIterator	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename _LhsNested::InnerIterator LhsIterator;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
LhsMatrixTypeCleaned	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
LhsMatrixTypeCleaned	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
LhsMatrixType	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename take_matrix_for_product<Lhs>::type LhsMatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
LhsMatrixType	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename traits<homogeneous_left_product_impl>::LhsMatrixType LhsMatrixType;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
LhsMatrixTypeNested	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename LhsMatrixTypeCleaned::Nested>::type LhsMatrixTypeNested;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl	access:public
LhsMode	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      LhsMode = internal::is_diagonal<_LhsNested>::ret ? internal::SDP_IsDiagonal$/;"	e	enum:Eigen::SparseDiagonalProduct::__anon37
LhsNestedCleaned	../include/Eigen/src/Core/Product.h	/^    typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;$/;"	t	class:Product	access:public
LhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::nested<Lhs>::type LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
_LhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
LhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_LhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
LhsNested	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef typename internal::nested<Lhs, Rhs::ColsAtCompileTime, typename internal::plain_matrix_type<Lhs>::type >::type LhsNested;$/;"	t	struct:Eigen::ProductReturnType	access:public
_LhsNested	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::ProductBase	access:public
LhsNested	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Eigen::ProductBase	access:public
LhsNested	../include/Eigen/src/Core/Product.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Product	access:public
_LhsNested	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef typename internal::traits<CoeffBasedProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
_LhsNested	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_LhsNested	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::_LhsNested _LhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
LhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_LhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_LhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::_LhsNested _LhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
LhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::LhsNested LhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
_LhsNested	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
LhsNested	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
_LhsNested	../include/Eigen/src/SparseCore/SparseProduct.h	/^    typedef typename internal::traits<SparseSparseProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::SparseSparseProduct	access:private
_LhsNested	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
LhsNested	../include/Eigen/src/SparseCore/SparseProduct.h	/^    typename internal::nested<Lhs,Rhs::RowsAtCompileTime>::type>::type LhsNested;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
LhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
LhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,RealPacket,  Scalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
_LhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
LhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::LhsPacket LhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
LhsPacket	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
_LhsPacket	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
LhsPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
LhsPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
LhsPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
LhsPacketSize	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon91
LhsPacketSize	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon92
LhsProductTraits	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef blas_traits<Lhs> LhsProductTraits;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
LhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
LhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
LhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
LhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
LhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress   = Traits::LhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon99
LhsRowMajor	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      LhsRowMajor = LhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon87
LhsRowMajor	../include/Eigen/src/SparseCore/SparseProduct.h	/^    LhsRowMajor = internal::traits<Lhs>::Flags & RowMajorBit,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon16
LhsScalar	../include/Eigen/src/Core/GeneralProduct.h	/^    typedef typename Lhs::Scalar LhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
LhsScalar	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::traits<Lhs>::Scalar LhsScalar;$/;"	t	class:Eigen::ProductBase	access:public
LhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
LhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
LhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
LhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar> LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
LhsScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::level3_blocking	access:private
LhsScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_RhsScalar,_LhsScalar>::type LhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space	access:private
LhsScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename  Lhs::Scalar LhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
LhsScalar	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Lhs::Scalar LhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
LhsUpLo	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^    LhsUpLo = LhsMode&(Upper|Lower)$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon113
LinearAccessBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int LinearAccessBit = 0x10;$/;"	m	namespace:Eigen
LinearAccess	../include/Eigen/src/Core/Reverse.h	/^    LinearAccess = ( (Direction==BothDirections) && (int(_MatrixTypeNested::Flags)&PacketAccessBit) )$/;"	e	enum:Eigen::internal::traits::__anon115
linearExt	../include/Eigen/src/Geometry/Transform.h	/^  inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt()$/;"	f	class:Eigen::Transform	access:public	signature:()
linearExt	../include/Eigen/src/Geometry/Transform.h	/^  inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
linear	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline ConstLinearPart linear() const { return m_matrix.template block<Dim,Dim>(0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
linear	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline LinearPart linear() { return m_matrix.template block<Dim,Dim>(0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:()
linear	../include/Eigen/src/Geometry/Transform.h	/^  inline ConstLinearPart linear() const { return ConstLinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
linear	../include/Eigen/src/Geometry/Transform.h	/^  inline LinearPart linear() { return LinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform	access:public	signature:()
LinearMatrixType	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Scaling	access:public
LinearMatrixType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Transform	access:public
LinearMatrixType	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation	access:public
LinearMatrixType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim,Options> LinearMatrixType;$/;"	t	class:Eigen::Transform	access:public
LinearMatrixType	../include/Eigen/src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation	access:public
LinearPart	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim> LinearPart;$/;"	t	class:Eigen::Transform	access:public
LinearPart	../include/Eigen/src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim,int(Mode)==(AffineCompact)> LinearPart;$/;"	t	class:Eigen::Transform	access:public
linearRegression	../include/Eigen/src/Eigen2Support/LeastSquares.h	/^void linearRegression(int numPoints,$/;"	f	namespace:Eigen	signature:(int numPoints, VectorType **points, VectorType *result, int funcOfOthers )
LinearTraversal	../include/Eigen/src/Core/util/Constants.h	/^  LinearTraversal,$/;"	e	enum:Eigen::__anon209
LinearVectorizedTraversal	../include/Eigen/src/Core/util/Constants.h	/^  LinearVectorizedTraversal,$/;"	e	enum:Eigen::__anon209
LinSpaced	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& low, const Scalar& high)
LinSpaced	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const Scalar& low, const Scalar& high)
LinSpaced	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Sequential_t, const Scalar& low, const Scalar& high)
LinSpaced	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Sequential_t, Index size, const Scalar& low, const Scalar& high)
LinSpaced	../include/Eigen/src/Core/DenseBase.h	/^    LinSpaced(const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& low, const Scalar& high)
LinSpaced	../include/Eigen/src/Core/DenseBase.h	/^    LinSpaced(Index size, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const Scalar& low, const Scalar& high)
LinSpaced	../include/Eigen/src/Core/DenseBase.h	/^    LinSpaced(Sequential_t, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Sequential_t, const Scalar& low, const Scalar& high)
LinSpaced	../include/Eigen/src/Core/DenseBase.h	/^    LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Sequential_t, Index size, const Scalar& low, const Scalar& high)
linspaced_op_impl	../include/Eigen/src/Core/Functors.h	/^  linspaced_op_impl(Scalar low, Scalar step) :$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Scalar low, Scalar step)
linspaced_op_impl	../include/Eigen/src/Core/Functors.h	/^struct linspaced_op_impl<Scalar,false>$/;"	s	namespace:Eigen::internal
linspaced_op_impl	../include/Eigen/src/Core/Functors.h	/^struct linspaced_op_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
linspaced_op	../include/Eigen/src/Core/Functors.h	/^  linspaced_op(Scalar low, Scalar high, int num_steps) : impl((num_steps==1 ? high : low), (num_steps==1 ? Scalar() : (high-low)\/(num_steps-1))) {}$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Scalar low, Scalar high, int num_steps)
linspaced_op	../include/Eigen/src/Core/Functors.h	/^template <typename Scalar, bool RandomAccess> struct linspaced_op$/;"	s	namespace:Eigen::internal
list_base	../include/Eigen/src/StlSupport/StdList.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > list_base;$/;"	t	class:std::list	access:private
ListEl	../include/Eigen/src/SparseCore/AmbiVector.h	/^    struct ListEl$/;"	s	class:Eigen::internal::AmbiVector	access:protected
list	../include/Eigen/src/StlSupport/StdList.h	/^  class list<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std	inherits:list
LLT	../include/Eigen/src/Cholesky/LLT.h	/^    LLT(const MatrixType& matrix)$/;"	f	class:Eigen::LLT	access:public	signature:(const MatrixType& matrix)
LLT	../include/Eigen/src/Cholesky/LLT.h	/^    LLT(Index size) : m_matrix(size, size),$/;"	f	class:Eigen::LLT	access:public	signature:(Index size)
LLT	../include/Eigen/src/Cholesky/LLT.h	/^    LLT() : m_matrix(), m_isInitialized(false) {}$/;"	f	class:Eigen::LLT	access:public	signature:()
llt	../include/Eigen/src/Cholesky/LLT.h	/^MatrixBase<Derived>::llt() const$/;"	f	class:Eigen::MatrixBase	signature:() const
llt	../include/Eigen/src/Cholesky/LLT.h	/^SelfAdjointView<MatrixType, UpLo>::llt() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
LLT	../include/Eigen/src/Cholesky/LLT.h	/^template<typename _MatrixType, int _UpLo> class LLT$/;"	c	namespace:Eigen
llt	../include/Eigen/src/Core/MatrixBase.h	/^    const LLT<PlainObject>  llt() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
llt	../include/Eigen/src/Core/SelfAdjointView.h	/^    const LLT<PlainObject, UpLo> llt() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
llt_inplace	../include/Eigen/src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Lower>$/;"	s	namespace:Eigen::internal
llt_inplace	../include/Eigen/src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Upper>$/;"	s	namespace:Eigen::internal
llt_rank_update_lower	../include/Eigen/src/Cholesky/LLT.h	/^static typename MatrixType::Index llt_rank_update_lower(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)
LLT_Traits	../include/Eigen/src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
LLT_Traits	../include/Eigen/src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
LLTTraits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT<MatrixType,UpLo>  > LLTTraits;$/;"	t	class:Eigen::SimplicialCholesky	access:public
LLTType	../include/Eigen/src/Cholesky/LLT.h	/^  typedef LLT<_MatrixType,UpLo> LLTType;$/;"	t	struct:Eigen::internal::solve_retval	access:public
LMatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType, Lower|UnitDiag>  LMatrixType;$/;"	t	class:Eigen::SuperLU	access:public
loadLhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhs(const LhsScalar* a, LhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsScalar* a, LhsPacket& dest) const
loadRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, DoublePacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const RhsScalar* b, DoublePacket& dest) const
loadRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, ResPacket& dest) const { dest = *b; }$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const RhsScalar* b, ResPacket& dest) const
loadRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, RhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const RhsScalar* b, RhsPacket& dest) const
local_column_index	../include/abcd.h	/^    std::vector<std::vector<int> > local_column_index;$/;"	m	class:abcd	access:public
logAbsDeterminant	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR	signature:() const
logAbsDeterminant	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typename MatrixType::RealScalar logAbsDeterminant() const;$/;"	p	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
logAbsDeterminant	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR	signature:() const
logAbsDeterminant	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typename MatrixType::RealScalar logAbsDeterminant() const;$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
logAbsDeterminant	../include/Eigen/src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::HouseholderQR	signature:() const
logAbsDeterminant	../include/Eigen/src/QR/HouseholderQR.h	/^    typename MatrixType::RealScalar logAbsDeterminant() const;$/;"	p	class:Eigen::HouseholderQR	access:public	signature:() const
log	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixLogarithmReturnValue<Derived> log() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
log	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_log_op)      log() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
log	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::log() const$/;"	f	class:Eigen::Cwise	signature:() const
log	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^log() const$/;"	f	signature:() const
Lower	../include/Eigen/src/Core/util/Constants.h	/^  Lower=0x1,                      $/;"	e	enum:Eigen::__anon207
LowerTriangularBit	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int LowerTriangularBit = Lower;$/;"	m	namespace:Eigen
LowerTriangular	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int LowerTriangular = Lower;$/;"	m	namespace:Eigen
lpNorm	../include/Eigen/src/Core/DenseBase.h	/^    template<int p> RealScalar lpNorm() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
lpNorm	../include/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::lpNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
lpNorm	../include/Eigen/src/Core/MatrixBase.h	/^    template<int p> RealScalar lpNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
lpNorm_selector	../include/Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, 1>$/;"	s	namespace:Eigen::internal
lpNorm_selector	../include/Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, 2>$/;"	s	namespace:Eigen::internal
lpNorm_selector	../include/Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, Infinity>$/;"	s	namespace:Eigen::internal
lpNorm_selector	../include/Eigen/src/Core/Dot.h	/^struct lpNorm_selector$/;"	s	namespace:Eigen::internal
lu	../include/Eigen/src/Core/MatrixBase.h	/^    const LU<PlainObject> lu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
lu	../include/Eigen/src/Core/MatrixBase.h	/^    const PartialPivLU<PlainObject> lu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
LU	../include/Eigen/src/Eigen2Support/LU.h	/^class LU : public FullPivLU<MatrixType>$/;"	c	namespace:Eigen	inherits:FullPivLU
LU	../include/Eigen/src/Eigen2Support/LU.h	/^    explicit LU(const T& t) : Base(t), m_originalMatrix(t) {}$/;"	f	class:Eigen::LU	access:public	signature:(const T& t)
lu	../include/Eigen/src/Eigen2Support/LU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
lu	../include/Eigen/src/LU/PartialPivLU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
LUMatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::SuperLUBase	access:public
LUMatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::LUMatrixType LUMatrixType;$/;"	t	class:Eigen::SuperLU	access:public
LUMatrixType	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::UmfPackLU	access:public
LvalueBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int LvalueBit = 0x20;$/;"	m	namespace:Eigen
machine_epsilon	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T machine_epsilon () { return NumTraits<T>::epsilon(); }$/;"	f	namespace:Eigen	signature:()
m_actualAlpha	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Scalar m_actualAlpha;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
madd_impl	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const
madd_impl	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& \/*tmp*\/, const false_type&) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& , const false_type&) const
MADD	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	121;"	d
MADD	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	146;"	d
madd	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, AccPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, AccPacket& c, AccPacket& tmp) const
madd	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const
madd	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, DoublePacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, DoublePacket& c, RhsPacket& ) const
madd	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& ) const
m_adjoint	../include/Eigen/src/SVD/JacobiSVD.h	/^  TransposeTypeWithSameStorageOrder m_adjoint;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
main	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^int main(int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	../test/src/main.cpp	/^int main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
makeAffine	../include/Eigen/src/Geometry/Transform.h	/^  void makeAffine()$/;"	f	class:Eigen::Transform	access:public	signature:()
make_block_householder_triangular_factor	../include/Eigen/src/Householder/BlockHouseholder.h	/^void make_block_householder_triangular_factor(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal	signature:(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)
makeCompressed	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void makeCompressed()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
makeGivens	../include/Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)$/;"	f	class:Eigen::JacobiRotation	signature:(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)
makeGivens	../include/Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)$/;"	f	class:Eigen::JacobiRotation	signature:(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)
makeGivens	../include/Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* z)$/;"	f	class:Eigen::JacobiRotation	signature:(const Scalar& p, const Scalar& q, Scalar* z)
makeGivens	../include/Eigen/src/Jacobi/Jacobi.h	/^    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z=0);$/;"	p	class:Eigen::JacobiRotation	access:public	signature:(const Scalar& p, const Scalar& q, Scalar* z=0)
makeGivens	../include/Eigen/src/Jacobi/Jacobi.h	/^    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z, internal::false_type);$/;"	p	class:Eigen::JacobiRotation	access:protected	signature:(const Scalar& p, const Scalar& q, Scalar* z, internal::false_type)
makeGivens	../include/Eigen/src/Jacobi/Jacobi.h	/^    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z, internal::true_type);$/;"	p	class:Eigen::JacobiRotation	access:protected	signature:(const Scalar& p, const Scalar& q, Scalar* z, internal::true_type)
makeHouseholder	../include/Eigen/src/Core/MatrixBase.h	/^    void makeHouseholder(EssentialPart& essential,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(EssentialPart& essential, Scalar& tau, RealScalar& beta) const
makeHouseholder	../include/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholder($/;"	f	class:Eigen::MatrixBase	signature:( EssentialPart& essential, Scalar& tau, RealScalar& beta) const
makeHouseholderInPlace	../include/Eigen/src/Core/MatrixBase.h	/^    void makeHouseholderInPlace(Scalar& tau, RealScalar& beta);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Scalar& tau, RealScalar& beta)
makeHouseholderInPlace	../include/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholderInPlace(Scalar& tau, RealScalar& beta)$/;"	f	class:Eigen::MatrixBase	signature:(Scalar& tau, RealScalar& beta)
makeJacobi	../include/Eigen/src/Jacobi/Jacobi.h	/^bool JacobiRotation<Scalar>::makeJacobi(RealScalar x, Scalar y, RealScalar z)$/;"	f	class:Eigen::JacobiRotation	signature:(RealScalar x, Scalar y, RealScalar z)
makeJacobi	../include/Eigen/src/Jacobi/Jacobi.h	/^    bool makeJacobi(const MatrixBase<Derived>&, typename Derived::Index p, typename Derived::Index q);$/;"	p	class:Eigen::JacobiRotation	access:public	signature:(const MatrixBase<Derived>&, typename Derived::Index p, typename Derived::Index q)
makeJacobi	../include/Eigen/src/Jacobi/Jacobi.h	/^    bool makeJacobi(RealScalar x, Scalar y, RealScalar z);$/;"	p	class:Eigen::JacobiRotation	access:public	signature:(RealScalar x, Scalar y, RealScalar z)
makeJacobi	../include/Eigen/src/Jacobi/Jacobi.h	/^inline bool JacobiRotation<Scalar>::makeJacobi(const MatrixBase<Derived>& m, typename Derived::Index p, typename Derived::Index q)$/;"	f	class:Eigen::JacobiRotation	signature:(const MatrixBase<Derived>& m, typename Derived::Index p, typename Derived::Index q)
m_allocatedElements	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_allocatedElements;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_allocatedSize	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_allocatedSize;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_allocatedSize	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    size_t m_allocatedSize;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
m_alpha	../include/Eigen/src/Core/ProductBase.h	/^    Scalar m_alpha;$/;"	m	class:Eigen::ScaledProduct	access:protected
manage_caching_sizes_helper	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t manage_caching_sizes_helper(std::ptrdiff_t a, std::ptrdiff_t b)$/;"	f	namespace:Eigen::internal	signature:(std::ptrdiff_t a, std::ptrdiff_t b)
manage_caching_sizes	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void manage_caching_sizes(Action action, std::ptrdiff_t* l1=0, std::ptrdiff_t* l2=0)$/;"	f	namespace:Eigen::internal	signature:(Action action, std::ptrdiff_t* l1=0, std::ptrdiff_t* l2=0)
manageErrorCode	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void manageErrorCode(Index error)$/;"	f	class:Eigen::PardisoImpl	access:protected	signature:(Index error)
manage_multi_threading	../include/Eigen/src/Core/products/Parallelizer.h	/^inline void manage_multi_threading(Action action, int* v)$/;"	f	namespace:Eigen::internal	signature:(Action action, int* v)
m_analysisIsOk	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::CholmodBase	access:protected
m_analysisIsOk	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_analysisIsOk	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_analysisIsOk	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_analysisIsOk	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::PastixBase	access:protected
m_analysisIsOk	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_analysisIsOk	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_analysisIsOk	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_angle	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis	access:protected
m_angle	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D	access:protected
m_angle	../include/Eigen/src/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis	access:protected
m_angle	../include/Eigen/src/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D	access:protected
MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data)
MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols)
MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size)
MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data)
MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols)
MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size)
MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, const Stride<Outer, Inner>& stride)
MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size, const Stride<Outer, Inner>& stride)
MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, const Stride<Outer, Inner>& stride)
MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
MapAligned	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)
MapBase	../include/Eigen/src/Core/MapBase.h	/^    explicit inline MapBase(PointerType data) : Base(data) {}$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType data)
MapBase	../include/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data, Index rows, Index cols) : Base(data, rows, cols) {}$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType data, Index rows, Index cols)
MapBase	../include/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data, Index rows, Index cols)$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType data, Index rows, Index cols)
MapBase	../include/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data, Index size) : Base(data, size) {}$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType data, Index size)
MapBase	../include/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data, Index size)$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType data, Index size)
MapBase	../include/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data) : m_data(data), m_rows(RowsAtCompileTime), m_cols(ColsAtCompileTime)$/;"	f	class:Eigen::MapBase	access:public	signature:(PointerType data)
MapBase	../include/Eigen/src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
MapBase	../include/Eigen/src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, WriteAccessors>$/;"	c	namespace:Eigen	inherits:MapBase
Map	../include/Eigen/src/Core/Map.h	/^    inline Map(PointerArgType data, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType data, const StrideType& stride = StrideType())
Map	../include/Eigen/src/Core/Map.h	/^    inline Map(PointerArgType data, Index rows, Index cols, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType data, Index rows, Index cols, const StrideType& stride = StrideType())
Map	../include/Eigen/src/Core/Map.h	/^    inline Map(PointerArgType data, Index size, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map	access:public	signature:(PointerArgType data, Index size, const StrideType& stride = StrideType())
Map	../include/Eigen/src/Core/Map.h	/^template<typename PlainObjectType, int MapOptions, typename StrideType> class Map$/;"	c	namespace:Eigen	inherits:MapBase
Map	../include/Eigen/src/Core/PermutationMatrix.h	/^class Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess>$/;"	c	namespace:Eigen	inherits:PermutationBase
Map	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Map(const Index* indices)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indices)
Map	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Map(const Index* indices, Index size)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indices, Index size)
Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data)
Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols)
Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size)
Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data)
Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols)
Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size)
Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, const Stride<Outer, Inner>& stride)
Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)
Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, const Stride<Outer, Inner>& stride)
Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
Map	../include/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Scalar* data, Index size, const Stride<Outer, Inner>& stride)
Map	../include/Eigen/src/Core/Transpositions.h	/^class Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,PacketAccess>$/;"	c	namespace:Eigen	inherits:TranspositionsBase
Map	../include/Eigen/src/Core/Transpositions.h	/^    inline Map(const Index* indices)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indices)
Map	../include/Eigen/src/Core/Transpositions.h	/^    inline Map(const Index* indices, Index size)$/;"	f	class:Eigen::Map	access:public	signature:(const Index* indices, Index size)
Map	../include/Eigen/src/Geometry/Quaternion.h	/^class Map<const Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen	inherits:QuaternionBase
Map	../include/Eigen/src/Geometry/Quaternion.h	/^class Map<Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen	inherits:QuaternionBase
Map	../include/Eigen/src/Geometry/Quaternion.h	/^    EIGEN_STRONG_INLINE Map(const Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map	access:public	signature:(const Scalar* coeffs)
Map	../include/Eigen/src/Geometry/Quaternion.h	/^    EIGEN_STRONG_INLINE Map(Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map	access:public	signature:(Scalar* coeffs)
Map	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    static CompressedStorage Map(Index* indices, Scalar* values, size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index* indices, Scalar* values, size_t size)
Map	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef MappedSparseMatrix<Scalar,Flags> Map;$/;"	t	class:Eigen::SparseMatrix	access:public
Map	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(MatrixBase<MatrixType>& _mat)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(MatrixBase<MatrixType>& _mat)
Map	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(SparseMatrixBase<MatrixType>& mat)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(SparseMatrixBase<MatrixType>& mat)
MapLU	../include/Eigen/src/LU/PartialPivLU.h	/^  typedef Map<Matrix<Scalar, Dynamic, Dynamic, StorageOrder> > MapLU;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
MappedRhs	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef Map<Matrix<RhsScalar,Dynamic,1>, Aligned> MappedRhs;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
MappedSparseMatrix	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
~MappedSparseMatrix	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline ~MappedSparseMatrix() {}$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
MappedSparseMatrix	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline MappedSparseMatrix(Index rows, Index cols, Index nnz, Index* outerIndexPtr, Index* innerIndexPtr, Scalar* valuePtr)$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:(Index rows, Index cols, Index nnz, Index* outerIndexPtr, Index* innerIndexPtr, Scalar* valuePtr)
map_superlu	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> map_superlu(SluMatrix& sluMat)$/;"	f	namespace:Eigen::internal	signature:(SluMatrix& sluMat)
MapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Unaligned>  MapType;$/;"	t	class:Eigen::PlainObjectBase	access:public
markAsRValue	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& markAsRValue() { m_isRValue = true; return derived(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
marked	../include/Eigen/src/Core/MatrixBase.h	/^    const Flagged<Derived, Added, 0> marked() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
marked	../include/Eigen/src/Eigen2Support/Lazy.h	/^MatrixBase<Derived>::marked() const$/;"	f	class:Eigen::MatrixBase	signature:() const
MaskAlignedBit	../include/Eigen/src/Core/Block.h	/^    MaskAlignedBit = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic) && (((OuterStrideAtCompileTime * int(sizeof(Scalar))) % 16) == 0)) ? AlignedBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon228
MaskPacketAccessBit	../include/Eigen/src/Core/Block.h	/^    MaskPacketAccessBit = (InnerSize == Dynamic || (InnerSize % packet_traits<Scalar>::size) == 0)$/;"	e	enum:Eigen::internal::traits::__anon228
matPrefix	../include/Eigen/src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat	access:public
Matrix2	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D	access:public
Matrix2	../include/Eigen/src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D	access:public
Matrix3	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis	access:public
Matrix3	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::Quaternion	access:public
Matrix3	../include/Eigen/src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis	access:public
Matrix3	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::QuaternionBase	access:public
MatrixAlignment	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment     = bool(MatrixType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon398
MatrixAlignment	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment = bool(MatrixType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon399
MatrixBase	../include/Eigen/src/Core/MatrixBase.h	/^    explicit MatrixBase(int);$/;"	p	class:Eigen::MatrixBase	access:private	signature:(int)
MatrixBase	../include/Eigen/src/Core/MatrixBase.h	/^    MatrixBase() : Base() {}$/;"	f	class:Eigen::MatrixBase	access:protected	signature:()
MatrixBase	../include/Eigen/src/Core/MatrixBase.h	/^    MatrixBase(int,int);$/;"	p	class:Eigen::MatrixBase	access:private	signature:(int,int)
MatrixBase	../include/Eigen/src/Core/MatrixBase.h	/^template<typename Derived> class MatrixBase$/;"	c	namespace:Eigen	inherits:DenseBase
MatrixBase	../include/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> explicit MatrixBase(const MatrixBase<OtherDerived>&);$/;"	p	class:Eigen::MatrixBase	access:private	signature:(const MatrixBase<OtherDerived>&)
MatrixCols	../include/Eigen/src/Core/Block.h	/^    MatrixCols = traits<XprType>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon228
MatrixConjugateReturnType	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;$/;"	t	class:Eigen::TriangularView	access:protected
matrixFunction	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> matrixFunction(StemFunction f) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(StemFunction f) const
matrixH	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixHReturnType matrixH() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
MatrixHReturnType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef internal::HessenbergDecompositionMatrixHReturnType<MatrixType> MatrixHReturnType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
matrix	../include/Eigen/src/Core/ArrayBase.h	/^    const MatrixWrapper<const Derived> matrix() const { return derived(); }$/;"	f	class:Eigen::ArrayBase	access:public	signature:() const
matrix	../include/Eigen/src/Core/ArrayBase.h	/^    MatrixWrapper<Derived> matrix() { return derived(); }$/;"	f	class:Eigen::ArrayBase	access:public	signature:()
Matrix	../include/Eigen/src/Core/Map.h	/^  ::Matrix(const Scalar *data)$/;"	f	class:Eigen::Matrix	signature:(const Scalar *data)
matrix	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixBase<Derived>& matrix() const { return *this; }$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
matrix	../include/Eigen/src/Core/MatrixBase.h	/^    MatrixBase<Derived>& matrix() { return *this; }$/;"	f	class:Eigen::MatrixBase	access:public	signature:()
Matrix	../include/Eigen/src/Core/Matrix.h	/^class Matrix$/;"	c	namespace:Eigen	inherits:PlainObjectBase
Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE explicit Matrix() : Base()$/;"	f	class:Eigen::Matrix	access:public	signature:()
Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE explicit Matrix(Index dim)$/;"	f	class:Eigen::Matrix	access:public	signature:(Index dim)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const EigenBase<OtherDerived> &other)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const MatrixBase<OtherDerived>& other)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Matrix& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Matrix& other)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& z)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const T0& x, const T1& y)$/;"	f	class:Eigen::Matrix	access:public	signature:(const T0& x, const T1& y)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    explicit Matrix(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    explicit Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    explicit Matrix(const Scalar *data);$/;"	p	class:Eigen::Matrix	access:public	signature:(const Scalar *data)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    Matrix(const Scalar& x, const Scalar& y);$/;"	p	class:Eigen::Matrix	access:public	signature:(const Scalar& x, const Scalar& y)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    Matrix(Index rows, Index cols);$/;"	p	class:Eigen::Matrix	access:public	signature:(Index rows, Index cols)
Matrix	../include/Eigen/src/Core/Matrix.h	/^    Matrix(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Matrix	access:public	signature:(internal::constructor_without_unaligned_array_assert)
Matrix	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
matrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:() const
matrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:()
matrix	../include/Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType matrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
Matrix	../include/Eigen/src/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
matrix	../include/Eigen/src/Geometry/Transform.h	/^  inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:() const
matrix	../include/Eigen/src/Geometry/Transform.h	/^  inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform	access:public	signature:()
matrix	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const _MatrixTypeNested& matrix() const { return m_matrix; }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:() const
matrix	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    _MatrixTypeNested& matrix() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:()
matrixLDLT	../include/Eigen/src/Cholesky/LDLT.h	/^    inline const MatrixType& matrixLDLT() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
matrixL	../include/Eigen/src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
MatrixL	../include/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
MatrixL	../include/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
matrixL	../include/Eigen/src/Cholesky/LLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
MatrixL	../include/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
MatrixL	../include/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
matrixL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
matrixL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:() const
MatrixL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<CholMatrixType, Eigen::Lower>  MatrixL;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<CholMatrixType, Eigen::UnitLower>  MatrixL;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLDLT	access:public
MatrixL	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLLT	access:public
matrixL	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const LMatrixType& matrixL() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
matrixL	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixL() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
matrixLLT	../include/Eigen/src/Cholesky/LLT.h	/^    inline const MatrixType& matrixLLT() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
matrixLU	../include/Eigen/src/LU/FullPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
matrixLU	../include/Eigen/src/LU/PartialPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
MatrixMarketBanner	../include/mmio.h	13;"	d
MatrixOptions	../include/Eigen/src/SVD/JacobiSVD.h	/^      MatrixOptions = MatrixType::Options$/;"	e	enum:Eigen::JacobiSVD::__anon419
matrixQ	../include/Eigen/src/Eigen2Support/QR.h	/^    MatrixType matrixQ(void) const {$/;"	f	class:Eigen::QR	access:public	signature:(void) const
matrixQ	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
matrixQ	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
matrixQ	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^inline typename FullPivHouseholderQR<MatrixType>::MatrixQReturnType FullPivHouseholderQR<MatrixType>::matrixQ() const$/;"	f	class:Eigen::FullPivHouseholderQR	signature:() const
matrixQ	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    MatrixQReturnType matrixQ(void) const;$/;"	p	class:Eigen::FullPivHouseholderQR	access:public	signature:(void) const
MatrixQReturnType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef internal::FullPivHouseholderQRMatrixQReturnType<MatrixType> MatrixQReturnType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
matrixQR	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
matrixQR	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
matrixQR	../include/Eigen/src/QR/HouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
MatrixQType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, Options, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
MatrixQType	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, (MatrixType::Flags&RowMajorBit) ? RowMajor : ColMajor, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::HouseholderQR	access:public
MatrixRBlockType	../include/Eigen/src/Eigen2Support/QR.h	/^    typedef Block<const MatrixType, MatrixType::ColsAtCompileTime, MatrixType::ColsAtCompileTime> MatrixRBlockType;$/;"	t	class:Eigen::QR	access:public
matrixR	../include/Eigen/src/Eigen2Support/QR.h	/^    matrixR(void) const$/;"	f	class:Eigen::QR	access:public	signature:(void) const
MatrixRows	../include/Eigen/src/Core/Block.h	/^    MatrixRows = traits<XprType>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon228
matrix_swap_impl	../include/Eigen/src/Core/PlainObjectBase.h	/^struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>$/;"	s	namespace:Eigen::internal
matrix_swap_impl	../include/Eigen/src/Core/PlainObjectBase.h	/^struct matrix_swap_impl$/;"	s	namespace:Eigen::internal
matrixT	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixT() const$/;"	f	class:Eigen::ComplexSchur	access:public	signature:() const
matrixT	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixT() const$/;"	f	class:Eigen::RealSchur	access:public	signature:() const
matrixT	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    MatrixTReturnType matrixT() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
MatrixTReturnType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef internal::TridiagonalizationMatrixTReturnType<MatrixTypeRealView> MatrixTReturnType;$/;"	t	class:Eigen::Tridiagonalization	access:public
MatrixTypeCleaned	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LDLT	access:public
MatrixType	../include/Eigen/src/Cholesky/LLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LLT	access:public
MatrixType	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodBase	access:public
MatrixType	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodDecomposition	access:public
MatrixType	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLDLT	access:public
MatrixType	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLLT	access:public
MatrixType	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSupernodalLLT	access:public
MatrixType	../include/Eigen/src/Core/GeneralProduct.h	/^    typedef typename internal::conditional<int(Side)==OnTheRight,_LhsNested,_RhsNested>::type MatrixType;$/;"	t	class:Eigen::GeneralProduct	access:public
MatrixType	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::TriangularView	access:public
MatrixType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,HDim,HDim> MatrixType;$/;"	t	class:Eigen::Transform	access:public
MatrixType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
MatrixType	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
MatrixType	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexSchur	access:public
MatrixType	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::EigenSolver	access:public
MatrixType	../include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver	access:public
MatrixType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
MatrixType	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealSchur	access:public
MatrixType	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
MatrixType	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
MatrixType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::Tridiagonalization	access:public
MatrixType	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename internal::make_proper_matrix_type<Scalar,Rows,HDim,Options>::type MatrixType;$/;"	t	class:Eigen::Transform	access:public
MatrixType	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename Transform<Scalar,Dim,AffineCompact,Options>::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
MatrixType	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
MatrixType	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part	access:public
MatrixType	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::DiagonalPreconditioner	access:public
MatrixType	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::BiCGSTAB	access:public
MatrixType	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ConjugateGradient	access:public
MatrixType	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::IncompleteLUT	access:public
MatrixType	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::IterativeSolverBase	access:public
MatrixType	../include/Eigen/src/LU/FullPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivLU	access:public
MatrixType	../include/Eigen/src/LU/PartialPivLU.h	/^  typedef Block<MapLU, Dynamic, Dynamic> MatrixType;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
MatrixType	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PartialPivLU	access:public
MatrixType	../include/Eigen/src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::image_retval_base	access:public
MatrixType	../include/Eigen/src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	../include/Eigen/src/misc/Kernel.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	../include/Eigen/src/misc/Solve.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	../include/Eigen/src/misc/SparseSolve.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
MatrixType	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::MatrixType MatrixType;$/;"	t	class:Eigen::PardisoImpl	access:public
MatrixType	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixBase	access:public
MatrixType	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLDLT	access:public
MatrixType	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLLT	access:public
MatrixType	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLU	access:public
MatrixType	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
_MatrixType	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename internal::pastix_traits<Derived>::MatrixType _MatrixType;$/;"	t	class:Eigen::PastixBase	access:public
MatrixType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
MatrixType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
MatrixType	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HouseholderQR	access:public
MatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholesky	access:public
MatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLDLT	access:public
MatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLLT	access:public
MatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
MatrixType	../include/Eigen/src/SparseCore/SparseBlock.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> MatrixType;$/;"	t	class:Eigen::SparseInnerVectorSet	access:private
MatrixType	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef SparseMatrix<_Scalar, _Options, _Index> MatrixType;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef Derived MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper	access:public
MatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef Matrix<Scalar,Rows,Cols,Options,MRows,MCols> MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper	access:public
MatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperILU	access:public
MatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLU	access:public
MatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLUBase	access:public
MatrixType	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::JacobiSVD	access:public
MatrixType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
MatrixType	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::UmfPackLU	access:public
MatrixTypeInnerStride	../include/Eigen/src/Core/CwiseUnaryView.h	/^    MatrixTypeInnerStride =  inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon232
MatrixTypeIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::InnerIterator MatrixTypeIterator;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:protected
MatrixTypeIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::InnerIterator MatrixTypeIterator;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:protected
MatrixTypeNestedCleaned	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::permut_matrix_product_retval	access:public
MatrixTypeNestedCleaned	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SelfAdjointView	access:public
MatrixTypeNestedCleaned	../include/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNestedCleaned	../include/Eigen/src/Core/Transpositions.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::transposition_matrix_product_retval	access:public
MatrixTypeNestedCleaned	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::TriangularView	access:protected
MatrixTypeNestedCleaned	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNestedCleaned	../include/Eigen/src/LU/Inverse.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::inverse_impl	access:public
MatrixTypeNestedCleaned	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public
MatrixTypeNestedCleaned	../include/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNestedCleaned	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SparseTriangularView	access:public
MatrixTypeNested	../include/Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	../include/Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	../include/Eigen/src/Core/Diagonal.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	../include/Eigen/src/Core/Diagonal.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	../include/Eigen/src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::Replicate	access:private
MatrixTypeNested	../include/Eigen/src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::Replicate	access:private
MatrixTypeNested	../include/Eigen/src/Core/Replicate.h	/^  typedef typename nested<MatrixType,Factor>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	../include/Eigen/src/Core/Replicate.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	../include/Eigen/src/Core/Reverse.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	../include/Eigen/src/Core/Reverse.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::SelfAdjointView	access:public
MatrixTypeNested	../include/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	../include/Eigen/src/Core/Transpose.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::TriangularView	access:protected
MatrixTypeNested	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::traits<PartialReduxExpr>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::PartialReduxExpr	access:public
MatrixTypeNested	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::traits<PartialReduxExpr>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::PartialReduxExpr	access:public
MatrixTypeNested	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	../include/Eigen/src/Eigen2Support/Minor.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	../include/Eigen/src/Eigen2Support/Minor.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNested	../include/Eigen/src/LU/Inverse.h	/^  typedef typename internal::eval<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::inverse_impl	access:public
_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename internal::traits<Derived>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:protected
_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename internal::traits<Derived>::_XprTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:protected
MatrixTypeNested	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
MatrixTypeNested	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
MatrixTypeNested	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename internal::remove_all<typename MatrixType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::TransposeImpl	access:private
MatrixTypeNested	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseTriangularView	access:public
_MatrixTypeNested	../include/Eigen/src/SparseCore/SparseView.h	/^  typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseView	access:private
MatrixTypeNested	../include/Eigen/src/SparseCore/SparseView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseView	access:private
MatrixTypeNestedNonRef	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedNonRef MatrixTypeNestedNonRef;$/;"	t	class:Eigen::TriangularView	access:protected
MatrixTypeNestedNonRef	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeNestedNonRef	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	class:Eigen::SparseTriangularView	access:public
MatrixTypeNestedPlain	../include/Eigen/src/Core/Transpose.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedPlain;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixTypeRealView	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::remove_all<typename MatrixType::RealReturnType>::type MatrixTypeRealView;$/;"	t	class:Eigen::Tridiagonalization	access:public
MatrixTypeReverseIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator MatrixTypeReverseIterator;$/;"	t	class:Eigen::CwiseUnaryOpImpl	access:protected
MatrixTypeReverseIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator MatrixTypeReverseIterator;$/;"	t	class:Eigen::CwiseUnaryViewImpl	access:protected
matrix_type_times_scalar_type	../include/Eigen/src/Householder/HouseholderSequence.h	/^template<typename OtherScalarType, typename MatrixType> struct matrix_type_times_scalar_type$/;"	s	namespace:Eigen::internal
matrixU	../include/Eigen/src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
MatrixU	../include/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
MatrixU	../include/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits	access:public
matrixU	../include/Eigen/src/Cholesky/LLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LLT	access:public	signature:() const
MatrixU	../include/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
MatrixU	../include/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits	access:public
matrixU	../include/Eigen/src/Eigen2Support/SVD.h	/^    const MatrixUType& matrixU() const { return m_matU; }$/;"	f	class:Eigen::SVD	access:public	signature:() const
matrixU	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixU() const$/;"	f	class:Eigen::ComplexSchur	access:public	signature:() const
matrixU	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixU() const$/;"	f	class:Eigen::RealSchur	access:public	signature:() const
matrixU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
matrixU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:() const
MatrixU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<typename CholMatrixType::AdjointReturnType, Eigen::UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<typename CholMatrixType::AdjointReturnType, Eigen::Upper>   MatrixU;$/;"	t	struct:Eigen::internal::traits	access:public
MatrixU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLDLT	access:public
MatrixU	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLLT	access:public
matrixU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const UMatrixType& matrixU() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
matrixU	../include/Eigen/src/SVD/JacobiSVD.h	/^    const MatrixUType& matrixU() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
matrixU	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixU() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
MatrixUType	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, MinSize> MatrixUType;$/;"	t	class:Eigen::SVD	access:private
MatrixUType	../include/Eigen/src/SVD/JacobiSVD.h	/^            MatrixUType;$/;"	t	class:Eigen::JacobiSVD	access:public
matrixV	../include/Eigen/src/Eigen2Support/SVD.h	/^    const MatrixVType& matrixV() const { return m_matV; }$/;"	f	class:Eigen::SVD	access:public	signature:() const
matrixV	../include/Eigen/src/SVD/JacobiSVD.h	/^    const MatrixVType& matrixV() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
MatrixVType	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::ColsAtCompileTime, MatrixType::ColsAtCompileTime> MatrixVType;$/;"	t	class:Eigen::SVD	access:private
MatrixVType	../include/Eigen/src/SVD/JacobiSVD.h	/^            MatrixVType;$/;"	t	class:Eigen::JacobiSVD	access:public
MatrixWrapper	../include/Eigen/src/Core/ArrayWrapper.h	/^class MatrixWrapper : public MatrixBase<MatrixWrapper<ExpressionType> >$/;"	c	namespace:Eigen	inherits:MatrixBase
MatrixWrapper	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline MatrixWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(ExpressionType& matrix)
MatrixXpr	../include/Eigen/src/Core/util/Constants.h	/^struct MatrixXpr {};$/;"	s	namespace:Eigen
matSuffix	../include/Eigen/src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat	access:public
maxCoeff	../include/Eigen/src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar maxCoeff() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
maxCoeff	../include/Eigen/src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* index) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* index) const
maxCoeff	../include/Eigen/src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* row, IndexType* col) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* row, IndexType* col) const
maxCoeff	../include/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::maxCoeff() const$/;"	f	class:Eigen::DenseBase	signature:() const
maxCoeff	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_maxCoeff>::Type maxCoeff() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
maxCoeff	../include/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* index) const
maxCoeff	../include/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* row, IndexType* col) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* row, IndexType* col) const
max_coeff_visitor	../include/Eigen/src/Core/Visitor.h	/^struct max_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal	inherits:coeff_visitor
MaxColsAtCompileTime	../include/Eigen/src/Cholesky/LDLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon405
MaxColsAtCompileTime	../include/Eigen/src/Cholesky/LLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::LLT::__anon403
MaxColsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon81
MaxColsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon82
MaxColsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
MaxColsAtCompileTime	../include/Eigen/src/Core/Block.h	/^    MaxColsAtCompileTime = BlockCols==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon228
MaxColsAtCompileTime	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    MaxColsAtCompileTime = traits<Ancestor>::MaxColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon64
MaxColsAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon216
MaxColsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^      MaxColsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon279
MaxColsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^    MaxColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon281
MaxColsAtCompileTime	../include/Eigen/src/Core/DiagonalProduct.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon77
MaxColsAtCompileTime	../include/Eigen/src/Core/Matrix.h	/^    MaxColsAtCompileTime = _MaxCols,$/;"	e	enum:Eigen::internal::traits::__anon289
MaxColsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^    MaxColsAtCompileTime = IndicesType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon118
MaxColsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::PermutationBase::__anon117
MaxColsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::Transpose::__anon119
MaxColsAtCompileTime	../include/Eigen/src/Core/ProductBase.h	/^    MaxColsAtCompileTime = traits<Rhs>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
MaxColsAtCompileTime	../include/Eigen/src/Core/Product.h	/^    MaxColsAtCompileTime = RhsCleaned::MaxColsAtCompileTime,$/;"	e	enum:internal::traits::__anon48
MaxColsAtCompileTime	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon87
MaxColsAtCompileTime	../include/Eigen/src/Core/Replicate.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon67
MaxColsAtCompileTime	../include/Eigen/src/Core/Reverse.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon115
MaxColsAtCompileTime	../include/Eigen/src/Core/Select.h	/^    MaxColsAtCompileTime = ConditionMatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon60
MaxColsAtCompileTime	../include/Eigen/src/Core/Transpose.h	/^    MaxColsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon73
MaxColsAtCompileTime	../include/Eigen/src/Core/TriangularMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime$/;"	e	enum:Eigen::TriangularBase::__anon233
MaxColsAtCompileTime	../include/Eigen/src/Core/VectorwiseOp.h	/^    MaxColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon68
MaxColsAtCompileTime	../include/Eigen/src/Eigen2Support/Minor.h	/^    MaxColsAtCompileTime = (MatrixType::MaxColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon441
MaxColsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexEigenSolver::__anon43
MaxColsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexSchur::__anon41
MaxColsAtCompileTime	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::EigenSolver::__anon44
MaxColsAtCompileTime	../include/Eigen/src/Eigenvalues/RealSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealSchur::__anon39
MaxColsAtCompileTime	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon40
MaxColsAtCompileTime	../include/Eigen/src/Geometry/Homogeneous.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon390
MaxColsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^      MaxColsAtCompileTime = internal::traits<HouseholderSequence>::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderSequence::__anon8
MaxColsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^    MaxColsAtCompileTime = MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon7
MaxColsAtCompileTime	../include/Eigen/src/LU/FullPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivLU::__anon395
MaxColsAtCompileTime	../include/Eigen/src/LU/PartialPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::PartialPivLU::__anon394
MaxColsAtCompileTime	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon4
MaxColsAtCompileTime	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon6
MaxColsAtCompileTime	../include/Eigen/src/QR/HouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderQR::__anon5
MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseBlock.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon20
MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    MaxColsAtCompileTime = Tr ? int(traits<Lhs>::MaxColsAtCompileTime)  : int(traits<Rhs>::MaxColsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon30
MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    MaxColsAtCompileTime = _Rhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon35
MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon32
MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon31
MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseProduct.h	/^    MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon17
MaxColsAtCompileTime	../include/Eigen/src/SparseCore/SparseVector.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon25
MaxColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon416
MaxColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon417
MaxColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
MaxColsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon419
MaxCols	../include/Eigen/src/Core/GeneralProduct.h	/^    MaxCols  = _Rhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon122
MaxDepthAtCompileTime	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      MaxDepthAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(Lhs::MaxColsAtCompileTime,Rhs::MaxRowsAtCompileTime)$/;"	e	enum:Eigen::GeneralProduct::__anon109
MaxDepth	../include/Eigen/src/Core/GeneralProduct.h	/^    MaxDepth = EIGEN_SIZE_MIN_PREFER_FIXED(_Lhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon122
MaxDiagSizeAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^      MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime,MaxColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon419
max	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
max	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
max	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
max	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Max	../include/Eigen/src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
max	../include/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^(max)(const Scalar &other) const$/;"	f	signature:(const Scalar &other) const
m_axis	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis	access:protected
m_axis	../include/Eigen/src/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis	access:protected
maxIterations	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int maxIterations() const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
maxPivot	../include/Eigen/src/LU/FullPivLU.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
maxPivot	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
maxPivot	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
MaxRowsAtCompileTime	../include/Eigen/src/Cholesky/LDLT.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon405
MaxRowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
MaxRowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon81
MaxRowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon82
MaxRowsAtCompileTime	../include/Eigen/src/Core/Block.h	/^    MaxRowsAtCompileTime = BlockRows==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon228
MaxRowsAtCompileTime	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    MaxRowsAtCompileTime = traits<Ancestor>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon64
MaxRowsAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon216
MaxRowsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^      MaxRowsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon279
MaxRowsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^    MaxRowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon281
MaxRowsAtCompileTime	../include/Eigen/src/Core/DiagonalProduct.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon77
MaxRowsAtCompileTime	../include/Eigen/src/Core/Matrix.h	/^    MaxRowsAtCompileTime = _MaxRows,$/;"	e	enum:Eigen::internal::traits::__anon289
MaxRowsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^    MaxRowsAtCompileTime = IndicesType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon118
MaxRowsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon117
MaxRowsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon119
MaxRowsAtCompileTime	../include/Eigen/src/Core/ProductBase.h	/^    MaxRowsAtCompileTime = traits<Lhs>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
MaxRowsAtCompileTime	../include/Eigen/src/Core/Product.h	/^    MaxRowsAtCompileTime = LhsCleaned::MaxRowsAtCompileTime,$/;"	e	enum:internal::traits::__anon48
MaxRowsAtCompileTime	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon87
MaxRowsAtCompileTime	../include/Eigen/src/Core/Replicate.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon67
MaxRowsAtCompileTime	../include/Eigen/src/Core/Reverse.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon115
MaxRowsAtCompileTime	../include/Eigen/src/Core/Select.h	/^    MaxRowsAtCompileTime = ConditionMatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon60
MaxRowsAtCompileTime	../include/Eigen/src/Core/Transpose.h	/^    MaxRowsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon73
MaxRowsAtCompileTime	../include/Eigen/src/Core/TriangularMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon233
MaxRowsAtCompileTime	../include/Eigen/src/Core/VectorwiseOp.h	/^    MaxRowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon68
MaxRowsAtCompileTime	../include/Eigen/src/Eigen2Support/Minor.h	/^    MaxRowsAtCompileTime = (MatrixType::MaxRowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon441
MaxRowsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon43
MaxRowsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon41
MaxRowsAtCompileTime	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon44
MaxRowsAtCompileTime	../include/Eigen/src/Eigenvalues/RealSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon39
MaxRowsAtCompileTime	../include/Eigen/src/Geometry/Homogeneous.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon390
MaxRowsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^      MaxRowsAtCompileTime = internal::traits<HouseholderSequence>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon8
MaxRowsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^    MaxRowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon7
MaxRowsAtCompileTime	../include/Eigen/src/LU/FullPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon395
MaxRowsAtCompileTime	../include/Eigen/src/LU/PartialPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon394
MaxRowsAtCompileTime	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon4
MaxRowsAtCompileTime	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon6
MaxRowsAtCompileTime	../include/Eigen/src/QR/HouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon5
MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseBlock.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon20
MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    MaxRowsAtCompileTime = Tr ? int(traits<Rhs>::MaxRowsAtCompileTime)  : int(traits<Lhs>::MaxRowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon30
MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    MaxRowsAtCompileTime = _Lhs::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon35
MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon31
MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon32
MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseProduct.h	/^    MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon17
MaxRowsAtCompileTime	../include/Eigen/src/SparseCore/SparseVector.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon25
MaxRowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon415
MaxRowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon416
MaxRowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon417
MaxRowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
MaxRowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon419
MaxRows	../include/Eigen/src/Core/GeneralProduct.h	/^    MaxRows  = _Lhs::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon122
MaxSizeAtCompileTime	../include/Eigen/src/Core/Assign.h	/^    MaxSizeAtCompileTime = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_traits::__anon219
MaxSizeAtCompileTime	../include/Eigen/src/Core/Assign_MKL.h	/^      MaxSizeAtCompileTime = Dst::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
MaxSizeAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon216
MaxSizeAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
max_size	../include/Eigen/src/Core/util/Memory.h	/^    size_type max_size() const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:() const
MaxSize	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon45
MaxSize	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon42
MaxSizeMinusOne	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : MaxSize - 1$/;"	e	enum:Eigen::HessenbergDecomposition::__anon45
MaxSizeMinusOne	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : (MaxSize > 1 ? MaxSize - 1 : 1)$/;"	e	enum:Eigen::Tridiagonalization::__anon42
MaxSmallDimAtCompileTime	../include/Eigen/src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::image_retval::__anon397
MaxSmallDimAtCompileTime	../include/Eigen/src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::kernel_retval::__anon396
MayEnableVml	../include/Eigen/src/Core/Assign_MKL.h	/^      MayEnableVml = MightEnableVml && LargeEnough,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
MayInnerVectorize	../include/Eigen/src/Core/Assign.h	/^    MayInnerVectorize  = MightVectorize && int(InnerSize)!=Dynamic && int(InnerSize)%int(PacketSize)==0$/;"	e	enum:Eigen::internal::assign_traits::__anon220
MayLinearize	../include/Eigen/src/Core/Assign.h	/^    MayLinearize = StorageOrdersAgree && (int(Derived::Flags) & int(OtherDerived::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::assign_traits::__anon220
MayLinearize	../include/Eigen/src/Core/Assign_MKL.h	/^      MayLinearize = MayEnableVml && MightLinearize$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
MayLinearVectorize	../include/Eigen/src/Core/Assign.h	/^    MayLinearVectorize = MightVectorize && MayLinearize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::assign_traits::__anon220
MayLinearVectorize	../include/Eigen/src/Core/Redux.h	/^    MayLinearVectorize = MightVectorize && (int(Derived::Flags)&LinearAccessBit),$/;"	e	enum:Eigen::internal::redux_traits::__anon268
MaySliceVectorize	../include/Eigen/src/Core/Assign.h	/^    MaySliceVectorize  = MightVectorize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::assign_traits::__anon220
MaySliceVectorize	../include/Eigen/src/Core/Redux.h	/^    MaySliceVectorize  = MightVectorize && int(InnerMaxSize)>=3*PacketSize$/;"	e	enum:Eigen::internal::redux_traits::__anon268
MayUnrollCompletely	../include/Eigen/src/Core/Assign.h	/^    MayUnrollCompletely = int(Derived::SizeAtCompileTime) != Dynamic$/;"	e	enum:Eigen::internal::assign_traits::__anon222
MayUnrollInner	../include/Eigen/src/Core/Assign.h	/^    MayUnrollInner      = int(InnerSize) != Dynamic$/;"	e	enum:Eigen::internal::assign_traits::__anon222
m_base	../include/Eigen/src/Core/Functors.h	/^  mutable Packet m_base;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_bidiagonal	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    BidiagonalType m_bidiagonal;$/;"	m	class:Eigen::internal::UpperBidiagonalization	access:protected
m_blockA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    LhsScalar* m_blockA;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
m_blockB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockB;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
m_blockCols	../include/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::Block	access:protected
m_blocking	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    BlockingType& m_blocking;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
m_blockRows	../include/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::Block	access:protected
m_blockW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockW;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
m_buffer	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar* m_buffer;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
mc77ad_	../src/preprocess.cpp	/^    void mc77ad_(int *job, int *m, int *n, int *nnz, int *jcst, int *irn, double *a,$/;"	p	file:	signature:(int *job, int *m, int *n, int *nnz, int *jcst, int *irn, double *a, int *iw, int *liw, double *dw, int *ldw, int *icntl, double *cntl, int *info, double *rinfo)
mc77id_	../include/mc77.h	/^void mc77id_(int *, double *);/;"	p	signature:(int *, double *)
mc77id_	../src/preprocess.cpp	/^    void mc77id_(int *, double *);$/;"	p	file:	signature:(int *, double *)
m_cachedIndex	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_cachedIndex;          \/\/ current coordinate$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
m_cachedValue	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar m_cachedValue;       \/\/ current value$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
m_cholmodFactor	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    cholmod_factor* m_cholmodFactor;$/;"	m	class:Eigen::CholmodBase	access:protected
m_cholmod	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    mutable cholmod_common m_cholmod;$/;"	m	class:Eigen::CholmodBase	access:protected
mc	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex mc() const { return m_mc; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:() const
m_c	../include/Eigen/src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation	access:protected
m_coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    CoefficientsType m_coeffs;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
m_coeffs	../include/Eigen/src/Core/BandMatrix.h	/^    const CoefficientsType& m_coeffs;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
m_coeffs	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane	access:protected
m_coeffs	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion	access:protected
m_coeffs	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Scaling	access:protected
m_coeffs	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation	access:protected
m_coeffs	../include/Eigen/src/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane	access:protected
m_coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^    Coefficients m_coeffs;$/;"	m	class:Eigen::Map	access:protected
m_coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion	access:protected
m_coeffs	../include/Eigen/src/Geometry/Quaternion.h	/^    const Coefficients m_coeffs;$/;"	m	class:Eigen::Map	access:protected
m_coeffs	../include/Eigen/src/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation	access:protected
m_coeffs	../include/Eigen/src/Householder/HouseholderSequence.h	/^    typename CoeffsType::Nested m_coeffs;$/;"	m	class:Eigen::HouseholderSequence	access:protected
m_colFactor	../include/Eigen/src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, ColFactor> m_colFactor;$/;"	m	class:Eigen::Replicate	access:protected
m_col	../include/Eigen/src/Core/CommaInitializer.h	/^  Index m_col;              \/\/ current col id$/;"	m	struct:Eigen::CommaInitializer	access:public
m_col	../include/Eigen/src/Eigen2Support/Minor.h	/^    const Index m_row, m_col;$/;"	m	class:Eigen::Minor	access:protected
m_col	../include/Eigen/src/SparseCore/SparseUtil.h	/^  Index m_row, m_col;$/;"	m	class:Eigen::Triplet	access:protected
m_cols	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::CwiseNullaryOp	access:protected
m_cols	../include/Eigen/src/Core/DenseStorage.h	/^    DenseIndex m_cols;$/;"	m	class:Eigen::DenseStorage	access:private
m_cols	../include/Eigen/src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::MapBase	access:protected
m_cols	../include/Eigen/src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
m_cols	../include/Eigen/src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base	access:protected
m_cols	../include/Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_colsPermutation	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    PermutationType m_colsPermutation;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_cols_permutation	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    PermutationType m_cols_permutation;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_colSqNorms	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealRowVectorType m_colSqNorms;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_colsTranspositions	../include/Eigen/src/LU/FullPivLU.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::FullPivLU	access:protected
m_colsTranspositions	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_cols_transpositions	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    IntRowVectorType m_cols_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_comm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_comm; \/\/ The MPI communicator identifier$/;"	m	class:Eigen::PastixBase	access:protected
m_computationOptions	../include/Eigen/src/SVD/JacobiSVD.h	/^    unsigned int m_computationOptions;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_computeFullU	../include/Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_computeFullV	../include/Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_computeThinU	../include/Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_computeThinV	../include/Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_condition	../include/Eigen/src/Core/Select.h	/^    typename ConditionMatrixType::Nested m_condition;$/;"	m	class:Eigen::Select	access:protected
m_conservative	../include/Eigen/src/SparseCore/SparseProduct.h	/^    bool m_conservative;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
m_copyMatrix	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfpackMatrixType m_copyMatrix;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_countPerCol	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    mutable VectorI m_countPerCol;$/;"	m	class:Eigen::SparseSelfAdjointView	access:protected
m_countPerRow	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    mutable VectorI m_countPerRow;$/;"	m	class:Eigen::SparseSelfAdjointView	access:protected
m_currentBlockRows	../include/Eigen/src/Core/CommaInitializer.h	/^  Index m_currentBlockRows; \/\/ current block height$/;"	m	struct:Eigen::CommaInitializer	access:public
m_currentEl	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_currentEl;            \/\/ the current element in sparse\/linked-list mode$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
m_data	../include/Eigen/src/Core/DenseStorage.h	/^    internal::plain_array<T,Size,_Options> m_data;$/;"	m	class:Eigen::DenseStorage	access:private
m_data	../include/Eigen/src/Core/DenseStorage.h	/^    T *m_data;$/;"	m	class:Eigen::DenseStorage	access:private
m_data	../include/Eigen/src/Core/GeneralProduct.h	/^  internal::plain_array<Scalar,EIGEN_SIZE_MIN_PREFER_FIXED(Size,MaxSize),0> m_data;$/;"	m	struct:Eigen::internal::gemv_static_vector_if	access:public
m_data	../include/Eigen/src/Core/MapBase.h	/^    PointerType m_data;$/;"	m	class:Eigen::MapBase	access:protected
m_data	../include/Eigen/src/Core/util/BlasUtil.h	/^    const Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::const_blas_data_mapper	access:protected
m_data	../include/Eigen/src/Core/util/BlasUtil.h	/^    Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::blas_data_mapper	access:protected
m_data	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseMatrix	access:protected
m_data	../include/Eigen/src/SparseCore/SparseVector.h	/^    const internal::CompressedStorage<Scalar,Index>& m_data;$/;"	m	class:Eigen::SparseVector::InnerIterator	access:protected
m_data	../include/Eigen/src/SparseCore/SparseVector.h	/^    const internal::CompressedStorage<Scalar,Index>& m_data;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator	access:protected
m_data	../include/Eigen/src/SparseCore/SparseVector.h	/^    internal::CompressedStorage<Scalar,Index> m_data;$/;"	m	class:Eigen::SparseVector	access:public
m_deallocate	../include/Eigen/src/Core/util/Memory.h	/^    bool m_deallocate;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler	access:protected
m_dec	../include/Eigen/src/misc/Image.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
m_dec	../include/Eigen/src/misc/Kernel.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::kernel_retval_base	access:protected
m_dec	../include/Eigen/src/misc/Solve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::solve_retval_base	access:protected
m_dec	../include/Eigen/src/misc/SparseSolve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::solve_retval_with_guess	access:protected
m_dec	../include/Eigen/src/misc/SparseSolve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::sparse_solve_retval_base	access:protected
m_dest	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Dest& m_dest;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
m_det_p	../include/Eigen/src/LU/PartialPivLU.h	/^    Index m_det_p;$/;"	m	class:Eigen::PartialPivLU	access:protected
m_det_pq	../include/Eigen/src/LU/FullPivLU.h	/^    Index m_det_pq, m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU	access:protected
m_det_pq	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_det_pq	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_diag	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorType m_diag;                                \/\/ the diagonal coefficients (LDLT mode)$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalVectorType m_diagonal;$/;"	m	class:Eigen::DiagonalMatrix	access:protected
m_diagonal	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typename DiagonalVectorType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalWrapper	access:protected
m_diagonal	../include/Eigen/src/Core/DiagonalProduct.h	/^    typename DiagonalType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalProduct	access:protected
m_diagSize	../include/Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_direction	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
m_direction	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
m_dparm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<double,DPARM_SIZE,1> m_dparm; \/\/ Scalar vector for the input parameters$/;"	m	class:Eigen::PastixBase	access:protected
m_droptol	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    RealScalar m_droptol;$/;"	m	class:Eigen::IncompleteLUT	access:protected
mean	../include/Eigen/src/Core/DenseBase.h	/^    Scalar mean() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
mean	../include/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::mean() const$/;"	f	class:Eigen::DenseBase	signature:() const
mean	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_mean>::Type mean() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
m_eigenvectorsOk	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
m_eigenvectorsOk	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::EigenSolver	access:protected
m_eigenvectorsOk	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
m_eivalues	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
m_eivalues	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::EigenSolver	access:protected
m_eivalues	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    RealVectorType m_eivalues;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
m_eivec	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_eivec;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
m_eivec	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::EigenSolver	access:protected
m_eivec	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
m_else	../include/Eigen/src/Core/Select.h	/^    typename ElseMatrixType::Nested m_else;$/;"	m	class:Eigen::Select	access:protected
member_redux	../include/Eigen/src/Core/VectorwiseOp.h	/^  member_redux(const BinaryOp func) : m_functor(func) {}$/;"	f	struct:Eigen::internal::member_redux	access:public	signature:(const BinaryOp func)
member_redux	../include/Eigen/src/Core/VectorwiseOp.h	/^struct member_redux {$/;"	s	namespace:Eigen::internal
m_end	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_end;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_end	../include/Eigen/src/SparseCore/CoreIterators.h	/^    const Index m_end;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
m_end	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
m_end	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
m_end	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_end;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
m_end	../include/Eigen/src/SparseCore/SparseVector.h	/^    const Index m_end;$/;"	m	class:Eigen::SparseVector::InnerIterator	access:protected
m_epsilon	../include/Eigen/src/SparseCore/AmbiVector.h	/^    RealScalar m_epsilon;       \/\/ epsilon used to prune zero coefficients$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
m_epsilon	../include/Eigen/src/SparseCore/SparseView.h	/^  typename NumTraits<Scalar>::Real m_epsilon;$/;"	m	class:Eigen::SparseView	access:protected
merged	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox merged(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
m_error	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable RealScalar m_error;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
meta_sqrt	../include/Eigen/src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	c	namespace:Eigen
m_exponent	../include/Eigen/src/Core/Functors.h	/^  const Scalar m_exponent;$/;"	m	struct:Eigen::internal::scalar_pow_op	access:public
m_expression	../include/Eigen/src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::ArrayWrapper	access:protected
m_expression	../include/Eigen/src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::MatrixWrapper	access:protected
m_expression	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    const ExpressionType& m_expression;$/;"	m	class:Eigen::ForceAlignedAccess	access:protected
m_expression	../include/Eigen/src/Core/NestByValue.h	/^    const ExpressionType m_expression;$/;"	m	class:Eigen::NestByValue	access:protected
m_expression	../include/Eigen/src/Core/NoAlias.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::NoAlias	access:protected
m_expression	../include/Eigen/src/Core/Swap.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::SwapWrapper	access:protected
m_expression	../include/Eigen/src/SparseCore/CoreIterators.h	/^    const Derived& m_expression;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
m_extractedDataAreDirty	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_extractedDataAreDirty	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_factor	../include/Eigen/src/Geometry/Scaling.h	/^  Scalar m_factor;$/;"	m	class:Eigen::UniformScaling	access:protected
m_factor	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    Scalar m_factor;$/;"	m	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:protected
m_factorizationIsOk	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::CholmodBase	access:protected
m_factorizationIsOk	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_factorizationIsOk	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_factorizationIsOk	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_factorizationIsOk	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::PastixBase	access:protected
m_factorizationIsOk	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_factorizationIsOk	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_factorizationIsOk	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_fillfactor	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    int m_fillfactor;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_format	../include/Eigen/src/Core/IO.h	/^    IOFormat m_format;$/;"	m	class:Eigen::WithFormat	access:protected
m_functor	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    const BinaryOp m_functor;$/;"	m	class:Eigen::CwiseBinaryOp	access:protected
m_functor	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    const NullaryOp m_functor;$/;"	m	class:Eigen::CwiseNullaryOp	access:protected
m_functor	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOp	access:protected
m_functor	../include/Eigen/src/Core/CwiseUnaryView.h	/^    ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryView	access:protected
m_functor	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::SelfCwiseBinaryOp	access:protected
m_functor	../include/Eigen/src/Core/VectorwiseOp.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::member_redux	access:public
m_functor	../include/Eigen/src/Core/VectorwiseOp.h	/^    const MemberOp m_functor;$/;"	m	class:Eigen::PartialReduxExpr	access:protected
m_functor	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryFunc m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_functor	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryFunc& m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_functor	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_functor	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:protected
m_functor	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:protected
m_functor	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:protected
m_functor	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:protected
m_guess	../include/Eigen/src/misc/SparseSolve.h	/^    const typename Guess::Nested m_guess;$/;"	m	struct:Eigen::internal::solve_retval_with_guess	access:protected
m_hCoeffs	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
m_hCoeffs	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::Tridiagonalization	access:protected
m_hCoeffs	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_hCoeffs	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_hCoeffs	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typename HCoeffsType::Nested m_hCoeffs;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:protected
m_hCoeffs	../include/Eigen/src/QR/HouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::HouseholderQR	access:protected
m_hess	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_hess	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const HessenbergDecomposition<MatrixType>& m_hess;$/;"	m	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:protected
m_hess	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::RealSchur	access:private
m_householder	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    MatrixType m_householder;$/;"	m	class:Eigen::internal::UpperBidiagonalization	access:protected
middleCols	../include/Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr middleCols(Index startCol, Index numCols)$/;"	f	signature:(Index startCol, Index numCols)
middleCols	../include/Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr middleCols(Index startCol, Index numCols) const$/;"	f	signature:(Index startCol, Index numCols) const
middleCols	../include/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type middleCols(Index startCol) const$/;"	f	signature:(Index startCol) const
middleCols	../include/Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type middleCols(Index startCol)$/;"	f	signature:(Index startCol)
middleCols	../include/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::middleCols(Index start, Index size) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index start, Index size) const
middleCols	../include/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::middleCols(Index start, Index size)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index start, Index size)
middleCols	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,Dynamic> middleCols(Index start, Index size) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size) const
middleCols	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,Dynamic> middleCols(Index start, Index size);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size)
middleCol	splib_utils.cpp	/^VECTOR_double middleCol(CompCol_Mat_double &M, int col_num){$/;"	f
middleCol	splib_utils.cpp	/^VECTOR_double middleCol(CompCol_Mat_double &M, int col_num, VECTOR_int &ind){$/;"	f
middle	../include/Eigen/src/Core/MathFunctions.h	/^  enum { middle = (lower + upper) \/ 2,$/;"	e	enum:Eigen::internal::floor_log2_selector::__anon263
middleRows	../include/Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr middleRows(Index startRow, Index numRows) const$/;"	f	signature:(Index startRow, Index numRows) const
middleRows	../include/Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr middleRows(Index startRow, Index numRows)$/;"	f	signature:(Index startRow, Index numRows)
middleRows	../include/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type middleRows(Index startRow) const$/;"	f	signature:(Index startRow) const
middleRows	../include/Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type middleRows(Index startRow)$/;"	f	signature:(Index startRow)
middleRows	../include/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::middleRows(Index start, Index size) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index start, Index size) const
middleRows	../include/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::middleRows(Index start, Index size)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index start, Index size)
middleRows	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,Dynamic> middleRows(Index start, Index size) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size) const
middleRows	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,Dynamic> middleRows(Index start, Index size);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size)
m_id	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
m_id	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
m_id	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Index m_id;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_id	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
m_id	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
m_id	../include/Eigen/src/SparseCore/SparseVector.h	/^    Index m_id;$/;"	m	class:Eigen::SparseVector::InnerIterator	access:protected
m_id	../include/Eigen/src/SparseCore/SparseVector.h	/^    Index m_id;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator	access:protected
MightEnableVml	../include/Eigen/src/Core/Assign_MKL.h	/^      MightEnableVml =  vml_call<UnaryOp>::IsSupported && StorageOrdersAgree && DstHasDirectAccess && SrcHasDirectAccess$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
MightLinearize	../include/Eigen/src/Core/Assign_MKL.h	/^      MightLinearize = MightEnableVml && (int(Dst::Flags) & int(Src::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
MightVectorize	../include/Eigen/src/Core/Assign.h	/^    MightVectorize = StorageOrdersAgree$/;"	e	enum:Eigen::internal::assign_traits::__anon220
MightVectorize	../include/Eigen/src/Core/Redux.h	/^    MightVectorize = (int(Derived::Flags)&ActualPacketAccessBit)$/;"	e	enum:Eigen::internal::redux_traits::__anon268
m	../include/abcd.h	/^    int m;$/;"	m	class:abcd	access:public
minCoeff	../include/Eigen/src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar minCoeff() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
minCoeff	../include/Eigen/src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar minCoeff(IndexType* index) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* index) const
minCoeff	../include/Eigen/src/Core/DenseBase.h	/^    typename internal::traits<Derived>::Scalar minCoeff(IndexType* row, IndexType* col) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(IndexType* row, IndexType* col) const
minCoeff	../include/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::minCoeff() const$/;"	f	class:Eigen::DenseBase	signature:() const
minCoeff	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_minCoeff>::Type minCoeff() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
minCoeff	../include/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* index) const
minCoeff	../include/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* row, IndexType* col) const$/;"	f	class:Eigen::DenseBase	signature:(IndexType* row, IndexType* col) const
min_coeff_visitor	../include/Eigen/src/Core/Visitor.h	/^struct min_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal	inherits:coeff_visitor
m_index	../include/Eigen/src/SparseCore/SparseMatrix.h	/^        Index m_index;$/;"	m	class:Eigen::SparseMatrix::SingletonVector	access:private
m_indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map	access:protected
m_indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::PermutationMatrix	access:protected
m_indices	../include/Eigen/src/Core/PermutationMatrix.h	/^    typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::PermutationWrapper	access:protected
m_indices	../include/Eigen/src/Core/Transpositions.h	/^    const typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::TranspositionsWrapper	access:protected
m_indices	../include/Eigen/src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map	access:protected
m_indices	../include/Eigen/src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Transpositions	access:protected
m_indices	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    Index* m_indices;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
m_indices	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index* m_indices;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
m_indices	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index* m_indices;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
m_info	../include/Eigen/src/Cholesky/LLT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::LLT	access:protected
m_info	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::CholmodBase	access:protected
m_info	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_info	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::RealSchur	access:private
m_info	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
m_info	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_info	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable ComputationInfo m_info;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_info	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_info	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable ComputationInfo m_info; $/;"	m	class:Eigen::PastixBase	access:protected
m_info	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_info	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_info	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::UmfPackLU	access:protected
minimum_degree_ordering	../include/Eigen/src/OrderingMethods/Amd.h	/^void minimum_degree_ordering(SparseMatrix<Scalar,ColMajor,Index>& C, PermutationMatrix<Dynamic,Dynamic,Index>& perm)$/;"	f	namespace:Eigen::internal	signature:(SparseMatrix<Scalar,ColMajor,Index>& C, PermutationMatrix<Dynamic,Dynamic,Index>& perm)
min	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
min	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
min	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
min	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
Min	../include/Eigen/src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
min	../include/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^(min)(const Scalar &other) const$/;"	f	signature:(const Scalar &other) const
m_initialized	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_initisOk	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_initisOk; $/;"	m	class:Eigen::PastixBase	access:protected
m_inner	../include/Eigen/src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, InnerStrideAtCompileTime> m_inner;$/;"	m	class:Eigen::Stride	access:protected
m_inner	../include/Eigen/src/SparseCore/CoreIterators.h	/^    Index m_inner;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
m_innerIndexPtr	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    const int* m_innerIndexPtr;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_innerIndices	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index*  m_innerIndices;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
m_innerNonZeros	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index* m_innerNonZeros;     \/\/ optional, if null then the data is compressed$/;"	m	class:Eigen::SparseMatrix	access:protected
m_innerSize	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index   m_innerSize;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
m_innerSize	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_innerSize;$/;"	m	class:Eigen::SparseMatrix	access:protected
minor	../include/Eigen/src/Core/MatrixBase.h	/^    const Minor<Derived> minor(Index row, Index col) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index row, Index col) const
minor	../include/Eigen/src/Core/MatrixBase.h	/^    Minor<Derived> minor(Index row, Index col);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index row, Index col)
Minor	../include/Eigen/src/Eigen2Support/Minor.h	/^    inline Minor(const MatrixType& matrix,$/;"	f	class:Eigen::Minor	access:public	signature:(const MatrixType& matrix, Index row, Index col)
minor	../include/Eigen/src/Eigen2Support/Minor.h	/^MatrixBase<Derived>::minor(Index row, Index col) const$/;"	f	class:Eigen::MatrixBase	signature:(Index row, Index col) const
minor	../include/Eigen/src/Eigen2Support/Minor.h	/^MatrixBase<Derived>::minor(Index row, Index col)$/;"	f	class:Eigen::MatrixBase	signature:(Index row, Index col)
Minor	../include/Eigen/src/Eigen2Support/Minor.h	/^template<typename MatrixType> class Minor$/;"	c	namespace:Eigen	inherits:MatrixBase
MinRowsAtCompileTime	../include/Eigen/src/Geometry/Umeyama.h	/^    MinRowsAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, OtherMatrixType::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon381
MinSize	../include/Eigen/src/Eigen2Support/SVD.h	/^      MinSize = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, MatrixType::ColsAtCompileTime)$/;"	e	enum:Eigen::SVD::__anon440
m_interPacket	../include/Eigen/src/Core/Functors.h	/^  const Packet m_interPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_invdiag	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Vector m_invdiag;$/;"	m	class:Eigen::DiagonalPreconditioner	access:protected
m_invp	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<Index,Dynamic,1> m_invp;  \/\/ Inverse permutation vector$/;"	m	class:Eigen::PastixBase	access:protected
m_iparm	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable Array<Index,64,1> m_iparm;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_iparm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<int,IPARM_SIZE,1> m_iparm; \/\/ integer vector for the input parameters$/;"	m	class:Eigen::PastixBase	access:protected
m_isAllocated	../include/Eigen/src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_isDense	../include/Eigen/src/SparseCore/AmbiVector.h	/^    bool m_isDense;             \/\/ mode of the vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
m_isInitialized	../include/Eigen/src/Cholesky/LDLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LDLT	access:protected
m_isInitialized	../include/Eigen/src/Cholesky/LLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LLT	access:protected
m_isInitialized	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::CholmodBase	access:protected
m_isInitialized	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
m_isInitialized	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_isInitialized	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::EigenSolver	access:protected
m_isInitialized	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
m_isInitialized	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::RealSchur	access:private
m_isInitialized	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
m_isInitialized	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::Tridiagonalization	access:protected
m_isInitialized	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::DiagonalPreconditioner	access:protected
m_isInitialized	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_isInitialized	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_isInitialized	../include/Eigen/src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
m_isInitialized	../include/Eigen/src/LU/PartialPivLU.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PartialPivLU	access:protected
m_isInitialized	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PastixBase	access:protected
m_isInitialized	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_isInitialized	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_isInitialized	../include/Eigen/src/QR/HouseholderQR.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HouseholderQR	access:protected
m_isInitialized	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_isInitialized	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_isInitialized	../include/Eigen/src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_isInitialized	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::internal::UpperBidiagonalization	access:protected
m_isInitialized	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_isRValue	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool m_isRValue;$/;"	m	class:Eigen::SparseMatrixBase	access:protected
m_iterations	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable int m_iterations;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_kc	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_kc;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
m_LDLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_LDLT;$/;"	m	class:Eigen::SimplicialCholesky	access:protected
m_length	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Index m_length;$/;"	m	class:Eigen::HouseholderSequence	access:protected
m_lhs	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::CwiseBinaryOp	access:protected
m_lhs	../include/Eigen/src/Core/ProductBase.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::ProductBase	access:protected
m_lhs	../include/Eigen/src/Core/Product.h	/^    const LhsNested m_lhs;$/;"	m	class:Product	access:protected
m_lhs	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typename internal::add_const_on_value_type<LhsNested>::type m_lhs;$/;"	m	class:Eigen::CoeffBasedProduct	access:protected
m_lhs	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    const Lhs& m_lhs;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
m_lhs	../include/Eigen/src/Geometry/Homogeneous.h	/^  typename LhsMatrixTypeCleaned::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl	access:public
m_lhs	../include/Eigen/src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl	access:public
m_lhs	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseDenseOuterProduct	access:protected
m_lhs	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseDiagonalProduct	access:protected
m_lhs	../include/Eigen/src/SparseCore/SparseProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
m_lhsIter	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    LhsIterator m_lhsIter;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_l	../include/abcd.h	/^    int m_l, nz_l;$/;"	m	class:abcd	access:public
m_l	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_l	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_llCurrent	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_llCurrent;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_llSize	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_llSize;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_llStart	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_llStart;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_low	../include/Eigen/src/Core/Functors.h	/^  const Scalar m_low;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_lowPacket	../include/Eigen/src/Core/Functors.h	/^  const Packet m_lowPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_lu	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    FactorType m_lu;$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_lu	../include/Eigen/src/LU/FullPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::FullPivLU	access:protected
m_lu	../include/Eigen/src/LU/PartialPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::PartialPivLU	access:protected
MM_ARRAY_STR	../include/mmio.h	105;"	d
m_matrix	../include/Eigen/src/Cholesky/LDLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LDLT	access:protected
m_matrix	../include/Eigen/src/Cholesky/LLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LLT	access:protected
m_matrix	../include/Eigen/src/Core/CwiseUnaryView.h	/^    typename internal::nested<MatrixType>::type m_matrix;$/;"	m	class:Eigen::CwiseUnaryView	access:protected
m_matrix	../include/Eigen/src/Core/DiagonalProduct.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::DiagonalProduct	access:protected
m_matrix	../include/Eigen/src/Core/Flagged.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::Flagged	access:protected
m_matrix	../include/Eigen/src/Core/IO.h	/^    const typename ExpressionType::Nested m_matrix;$/;"	m	class:Eigen::WithFormat	access:protected
m_matrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::permut_matrix_product_retval	access:protected
m_matrix	../include/Eigen/src/Core/Replicate.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::Replicate	access:protected
m_matrix	../include/Eigen/src/Core/Reverse.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Reverse	access:protected
m_matrix	../include/Eigen/src/Core/SelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SelfAdjointView	access:protected
m_matrix	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    Lhs& m_matrix;$/;"	m	class:Eigen::SelfCwiseBinaryOp	access:protected
m_matrix	../include/Eigen/src/Core/Transpose.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Transpose	access:protected
m_matrix	../include/Eigen/src/Core/Transpositions.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::transposition_matrix_product_retval	access:protected
m_matrix	../include/Eigen/src/Core/TriangularMatrix.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::TriangularView	access:protected
m_matrix	../include/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::VectorwiseOp	access:protected
m_matrix	../include/Eigen/src/Core/VectorwiseOp.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::PartialReduxExpr	access:protected
m_matrix	../include/Eigen/src/Eigen2Support/Cwise.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::Cwise	access:protected
m_matrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform	access:protected
m_matrix	../include/Eigen/src/Eigen2Support/Minor.h	/^    const typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Minor	access:protected
m_matrix	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
m_matrix	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::Tridiagonalization	access:protected
m_matrix	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:protected
m_matrix	../include/Eigen/src/Geometry/Homogeneous.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Homogeneous	access:protected
m_matrix	../include/Eigen/src/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform	access:protected
m_matrix	../include/Eigen/src/LU/Inverse.h	/^  MatrixTypeNested m_matrix;$/;"	m	struct:Eigen::internal::inverse_impl	access:public
m_matrix	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable SparseMatrixType m_matrix;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_matrix	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    CholMatrixType m_matrix;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_matrix	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const MappedSparseMatrix& m_matrix;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
m_matrix	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const MappedSparseMatrix& m_matrix;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
m_matrix	../include/Eigen/src/SparseCore/SparseBlock.h	/^    const typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseInnerVectorSet	access:protected
m_matrix	../include/Eigen/src/SparseCore/SparseBlock.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseInnerVectorSet	access:protected
m_matrix	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::permut_sparsematrix_product_retval	access:protected
m_matrix	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct	access:protected
m_matrix	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseSelfAdjointView	access:protected
m_matrix	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseTriangularView	access:protected
m_matrix	../include/Eigen/src/SparseCore/SparseView.h	/^  MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseView	access:protected
m_matrix	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_matrix;  \/\/ copy of the factorized matrix$/;"	m	class:Eigen::SuperLUBase	access:protected
m_matrixU	../include/Eigen/src/SVD/JacobiSVD.h	/^    MatrixUType m_matrixU;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_matrixV	../include/Eigen/src/SVD/JacobiSVD.h	/^    MatrixVType m_matrixV;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_matT	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_matT	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::EigenSolver	access:protected
m_matT	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::RealSchur	access:private
m_matU	../include/Eigen/src/Eigen2Support/SVD.h	/^    MatrixUType m_matU;$/;"	m	class:Eigen::SVD	access:protected
m_matU	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_matU	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    MatrixType m_matU;$/;"	m	class:Eigen::RealSchur	access:private
m_matUisUptodate	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::ComplexSchur	access:protected
m_matUisUptodate	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::RealSchur	access:private
m_matV	../include/Eigen/src/Eigen2Support/SVD.h	/^    MatrixVType m_matV;$/;"	m	class:Eigen::SVD	access:protected
m_matX	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_matX;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
m_max	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
m_max	../include/Eigen/src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
m_maxIterations	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    static const int m_maxIterations = 30;$/;"	m	class:Eigen::ComplexSchur	access:public
m_maxIterations	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    static const int m_maxIterations = 40;$/;"	m	class:Eigen::RealSchur	access:public
m_maxIterations	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static const int m_maxIterations = 30;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:public
m_maxIterations	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int m_maxIterations;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_maxpivot	../include/Eigen/src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
m_maxpivot	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_maxpivot	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_mc	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_mc;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
mm_clear_typecode	../include/mmio.h	70;"	d
MM_COMPLEX_STR	../include/mmio.h	109;"	d
MM_COORDINATE_STR	../include/mmio.h	107;"	d
MM_COULD_NOT_READ_FILE	../include/mmio.h	79;"	d
MM_COULD_NOT_WRITE_FILE	../include/mmio.h	85;"	d
MM_DENSE_STR	../include/mmio.h	106;"	d
MM_GENERAL_STR	../include/mmio.h	112;"	d
MM_HERM_STR	../include/mmio.h	114;"	d
m_min	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
m_min	../include/Eigen/src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox	access:protected
mm_initialize_typecode	../include/mmio.h	73;"	d
MM_INT_STR	../include/mmio.h	111;"	d
MM_IO_H	../include/mmio.h	10;"	d
mm_is_array	../include/mmio.h	36;"	d
mm_is_complex	../include/mmio.h	38;"	d
mm_is_coordinate	../include/mmio.h	34;"	d
mm_is_dense	../include/mmio.h	35;"	d
mm_is_general	../include/mmio.h	44;"	d
mm_is_hermitian	../include/mmio.h	46;"	d
mm_is_integer	../include/mmio.h	41;"	d
mm_is_matrix	../include/mmio.h	31;"	d
mm_is_pattern	../include/mmio.h	40;"	d
mm_is_real	../include/mmio.h	39;"	d
mm_is_skew	../include/mmio.h	45;"	d
mm_is_sparse	../include/mmio.h	33;"	d
mm_is_symmetric	../include/mmio.h	43;"	d
mm_is_valid	../include/mmio.h	/^int mm_is_valid(MM_typecode matcode);		\/* too complex for a macro *\/$/;"	p	signature:(MM_typecode matcode)
mm_is_valid	../src/mmio.cpp	/^int mm_is_valid(MM_typecode matcode)$/;"	f	signature:(MM_typecode matcode)
MM_LINE_TOO_LONG	../include/mmio.h	84;"	d
MM_MAX_LINE_LENGTH	../include/mmio.h	12;"	d
MM_MAX_TOKEN_LENGTH	../include/mmio.h	14;"	d
MM_MTX_STR	../include/mmio.h	104;"	d
MM_NO_HEADER	../include/mmio.h	82;"	d
MM_NOT_MTX	../include/mmio.h	81;"	d
m_mode	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_mode;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
MM_PATTERN_STR	../include/mmio.h	116;"	d
MM_PREMATURE_EOF	../include/mmio.h	80;"	d
mm_read_banner	../include/mmio.h	/^int mm_read_banner(FILE *f, MM_typecode *matcode);$/;"	p	signature:(FILE *f, MM_typecode *matcode)
mm_read_banner	../src/mmio.cpp	/^int mm_read_banner(FILE *f, MM_typecode *matcode)$/;"	f	signature:(FILE *f, MM_typecode *matcode)
mm_read_mtx_array_size	../include/mmio.h	/^int mm_read_mtx_array_size(FILE *f, int *M, int *N);$/;"	p	signature:(FILE *f, int *M, int *N)
mm_read_mtx_array_size	../src/mmio.cpp	/^int mm_read_mtx_array_size(FILE *f, int *M, int *N)$/;"	f	signature:(FILE *f, int *M, int *N)
mm_read_mtx_crd_data	../include/mmio.h	/^int mm_read_mtx_crd_data(FILE *f, int M, int N, int nz, int I[], int J[],$/;"	p	signature:(FILE *f, int M, int N, int nz, int I[], int J[], double val[], MM_typecode matcode)
mm_read_mtx_crd_data	../src/mmio.cpp	/^int mm_read_mtx_crd_data(FILE *f, int M, int N, int nz, int I[], int J[],$/;"	f	signature:(FILE *f, int M, int N, int nz, int I[], int J[], double val[], MM_typecode matcode)
mm_read_mtx_crd_entry	../include/mmio.h	/^int mm_read_mtx_crd_entry(FILE *f, int *I, int *J, double *real, double *img,$/;"	p	signature:(FILE *f, int *I, int *J, double *real, double *img, MM_typecode matcode)
mm_read_mtx_crd_entry	../src/mmio.cpp	/^int mm_read_mtx_crd_entry(FILE *f, int *I, int *J,$/;"	f	signature:(FILE *f, int *I, int *J, double *real, double *imag, MM_typecode matcode)
mm_read_mtx_crd	../include/mmio.h	/^int mm_read_mtx_crd(char *fname, int *M, int *N, int *nz, int **I, int **J,$/;"	p	signature:(char *fname, int *M, int *N, int *nz, int **I, int **J, double **val, MM_typecode *matcode)
mm_read_mtx_crd_size	../include/mmio.h	/^int mm_read_mtx_crd_size(FILE *f, int *M, int *N, int *nz);$/;"	p	signature:(FILE *f, int *M, int *N, int *nz)
mm_read_mtx_crd_size	../src/mmio.cpp	/^int mm_read_mtx_crd_size(FILE *f, int *M, int *N, int *nz )$/;"	f	signature:(FILE *f, int *M, int *N, int *nz )
mm_read_mtx_crd	../src/mmio.cpp	/^int mm_read_mtx_crd(char *fname, int *M, int *N, int *nz, int **I, int **J,$/;"	f	signature:(char *fname, int *M, int *N, int *nz, int **I, int **J, double **val, MM_typecode *matcode)
mm_read_unsymmetric_sparse	../include/mmio.h	/^int mm_read_unsymmetric_sparse(const char *fname, int *M_, int *N_, int *nz_,$/;"	p	signature:(const char *fname, int *M_, int *N_, int *nz_, double **val_, int **I_, int **J_)
mm_read_unsymmetric_sparse	../src/mmio.cpp	/^int mm_read_unsymmetric_sparse(const char *fname, int *M_, int *N_, int *nz_,$/;"	f	signature:(const char *fname, int *M_, int *N_, int *nz_, double **val_, int **I_, int **J_)
MM_REAL_STR	../include/mmio.h	110;"	d
mm_set_array	../include/mmio.h	55;"	d
mm_set_complex	../include/mmio.h	59;"	d
mm_set_coordinate	../include/mmio.h	54;"	d
mm_set_dense	../include/mmio.h	56;"	d
mm_set_general	../include/mmio.h	66;"	d
mm_set_hermitian	../include/mmio.h	68;"	d
mm_set_integer	../include/mmio.h	62;"	d
mm_set_matrix	../include/mmio.h	53;"	d
mm_set_pattern	../include/mmio.h	61;"	d
mm_set_real	../include/mmio.h	60;"	d
mm_set_skew	../include/mmio.h	67;"	d
mm_set_sparse	../include/mmio.h	57;"	d
mm_set_symmetric	../include/mmio.h	65;"	d
m_msglvl	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl	access:protected
MM_SKEW_STR	../include/mmio.h	115;"	d
MM_SPARSE_STR	../include/mmio.h	108;"	d
mm_strdup	../include/mmio.h	/^char *mm_strdup(const char *);$/;"	p	signature:(const char *)
mm_strdup	../src/mmio.cpp	/^char *mm_strdup(const char *s)$/;"	f	signature:(const char *s)
MM_SYMM_STR	../include/mmio.h	113;"	d
MM_typecode	../include/mmio.h	/^typedef char MM_typecode[4];$/;"	t
mm_typecode_to_str	../include/mmio.h	/^char *mm_typecode_to_str(MM_typecode matcode);$/;"	p	signature:(MM_typecode matcode)
mm_typecode_to_str	../src/mmio.cpp	/^char  *mm_typecode_to_str(MM_typecode matcode)$/;"	f	signature:(MM_typecode matcode)
MM_UNSUPPORTED_TYPE	../include/mmio.h	83;"	d
mm_write_banner	../include/mmio.h	/^int mm_write_banner(FILE *f, MM_typecode matcode);$/;"	p	signature:(FILE *f, MM_typecode matcode)
mm_write_banner	../src/mmio.cpp	/^int mm_write_banner(FILE *f, MM_typecode matcode)$/;"	f	signature:(FILE *f, MM_typecode matcode)
mm_write_mtx_array_size	../include/mmio.h	/^int mm_write_mtx_array_size(FILE *f, int M, int N);$/;"	p	signature:(FILE *f, int M, int N)
mm_write_mtx_array_size	../src/mmio.cpp	/^int mm_write_mtx_array_size(FILE *f, int M, int N)$/;"	f	signature:(FILE *f, int M, int N)
mm_write_mtx_crd	../include/mmio.h	/^int mm_write_mtx_crd(char fname[], int M, int N, int nz, int I[], int J[],$/;"	p	signature:(char fname[], int M, int N, int nz, int I[], int J[], double val[], MM_typecode matcode)
mm_write_mtx_crd_size	../include/mmio.h	/^int mm_write_mtx_crd_size(FILE *f, int M, int N, int nz);$/;"	p	signature:(FILE *f, int M, int N, int nz)
mm_write_mtx_crd_size	../src/mmio.cpp	/^int mm_write_mtx_crd_size(FILE *f, int M, int N, int nz)$/;"	f	signature:(FILE *f, int M, int N, int nz)
mm_write_mtx_crd	../src/mmio.cpp	/^int mm_write_mtx_crd(char fname[], int M, int N, int nz, int I[], int J[],$/;"	f	signature:(char fname[], int M, int N, int nz, int I[], int J[], double val[], MM_typecode matcode)
m_nc	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_nc;$/;"	m	class:Eigen::internal::level3_blocking	access:protected
m_n	../include/abcd.h	/^    int m_n;$/;"	m	class:abcd	access:private
m_nnz	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index   m_nnz;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
m_nonzero_pivots	../include/Eigen/src/LU/FullPivLU.h	/^    Index m_det_pq, m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU	access:protected
m_nonzero_pivots	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_nonzero_pivots	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_nonzeroSingularValues	../include/Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_nonZerosPerCol	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorXi m_nonZerosPerCol;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void* m_numeric;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_nz	../include/abcd.h	/^    int m_nz;$/;"	m	class:abcd	access:private
Mode	../include/Eigen/src/Core/SelfAdjointView.h	/^      Mode = internal::traits<SelfAdjointView>::Mode$/;"	e	enum:Eigen::SelfAdjointView::__anon84
Mode	../include/Eigen/src/Core/SelfAdjointView.h	/^    Mode = UpLo | SelfAdjoint,$/;"	e	enum:Eigen::internal::traits::__anon83
Mode	../include/Eigen/src/Core/TriangularMatrix.h	/^      Mode = internal::traits<Derived>::Mode,$/;"	e	enum:Eigen::TriangularBase::__anon233
Mode	../include/Eigen/src/Core/TriangularMatrix.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::internal::traits::__anon234
Mode	../include/Eigen/src/Core/TriangularMatrix.h	/^      Mode = _Mode,$/;"	e	enum:Eigen::TriangularView::__anon235
Mode	../include/Eigen/src/Geometry/Transform.h	/^    Mode =$/;"	e	enum:Eigen::internal::transform_product_result::__anon376
Mode	../include/Eigen/src/Geometry/Transform.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::Transform::__anon374
Mode	../include/Eigen/src/Geometry/Transform.h	/^    Mode = Transform::Mode,$/;"	e	enum:Eigen::internal::transform_traits::__anon373
m_originalMatrix	../include/Eigen/src/Eigen2Support/LU.h	/^    const MatrixType& m_originalMatrix;$/;"	m	class:Eigen::LU	access:public
m_originalMatrix	../include/Eigen/src/misc/Image.h	/^    const MatrixType& m_originalMatrix;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
m_origin	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
m_origin	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine	access:protected
m_other	../include/Eigen/src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_add_op	access:public
m_other	../include/Eigen/src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_constant_op	access:public
m_other	../include/Eigen/src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_quotient1_impl	access:public
m_other	../include/Eigen/src/Core/Functors.h	/^  Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_inverse_mult_op	access:public
m_other	../include/Eigen/src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar2>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_multiple2_op	access:public
m_other	../include/Eigen/src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_multiple_op	access:public
m_other	../include/Eigen/src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_quotient1_impl	access:public
m_outer	../include/Eigen/src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, OuterStrideAtCompileTime> m_outer;$/;"	m	class:Eigen::Stride	access:protected
m_outer	../include/Eigen/src/SparseCore/CoreIterators.h	/^    const Index m_outer;$/;"	m	class:Eigen::DenseBase::InnerIterator	access:protected
m_outer	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
m_outer	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
m_outer	../include/Eigen/src/SparseCore/SparseBlock.h	/^        Index m_outer;$/;"	m	class:Eigen::SparseInnerVectorSet::InnerIterator	access:protected
m_outer	../include/Eigen/src/SparseCore/SparseBlock.h	/^        Index m_outer;$/;"	m	class:Eigen::SparseInnerVectorSet::ReverseInnerIterator	access:protected
m_outer	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const Index m_outer;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_outer	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    int m_outer;$/;"	m	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:protected
m_outer	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
m_outer	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
m_outerIndex	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index*  m_outerIndex;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
m_outerIndex	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index* m_outerIndex;$/;"	m	class:Eigen::SparseMatrix	access:protected
m_outerIndexPtr	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    const int* m_outerIndexPtr;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_outerSize	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index   m_outerSize;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
m_outerSize	../include/Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, Size> m_outerSize;$/;"	m	class:Eigen::SparseInnerVectorSet	access:protected
m_outerSize	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_outerSize;$/;"	m	class:Eigen::SparseMatrix	access:protected
m_outerStart	../include/Eigen/src/SparseCore/SparseBlock.h	/^    Index m_outerStart;$/;"	m	class:Eigen::SparseInnerVectorSet	access:protected
m_outerStride	../include/Eigen/src/Core/Block.h	/^    Index m_outerStride;$/;"	m	class:Eigen::Block	access:protected
MoveOuter	../include/Eigen/src/SparseCore/SparsePermutation.h	/^      MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::permut_sparsematrix_product_retval::__anon19
MoveOuter	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::traits::__anon18
m_packetStep	../include/Eigen/src/Core/Functors.h	/^  const Packet m_packetStep;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_parent	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorXi m_parent;                                \/\/ elimination tree$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_pastixdata	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable pastix_data_t *m_pastixdata; \/\/ Data structure for pastix$/;"	m	class:Eigen::PastixBase	access:protected
m_perm	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable IntColVectorType m_perm;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_perm	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<Index,Dynamic,1> m_perm;  \/\/ Permutation vector$/;"	m	class:Eigen::PastixBase	access:protected
m_perm	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const Perm& m_perm;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct	access:protected
m_permutation	../include/Eigen/src/Core/PermutationMatrix.h	/^    const PermutationType& m_permutation;$/;"	m	class:Eigen::Transpose	access:protected
m_permutation	../include/Eigen/src/Core/PermutationMatrix.h	/^    const PermutationType& m_permutation;$/;"	m	struct:Eigen::internal::permut_matrix_product_retval	access:protected
m_permutation	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    const PermutationType& m_permutation;$/;"	m	struct:Eigen::internal::permut_sparsematrix_product_retval	access:protected
M_PI	../include/Eigen/src/Eigen2Support/Geometry/All.h	7;"	d
m_P	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_P;     \/\/ Fill-reducing permutation$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_p	../include/Eigen/src/LU/FullPivLU.h	/^    PermutationPType m_p;$/;"	m	class:Eigen::FullPivLU	access:protected
m_p	../include/Eigen/src/LU/PartialPivLU.h	/^    PermutationType m_p;$/;"	m	class:Eigen::PartialPivLU	access:protected
m_P	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_P;     \/\/ the permutation$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_p	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_p	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_Pinv	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_Pinv;  \/\/ Inverse permutation$/;"	m	class:Eigen::IncompleteLUT	access:protected
m_Pinv	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_Pinv;  \/\/ the inverse permutation$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
mp_matrix	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const MatrixType* mp_matrix;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_precision	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_precision;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_preconditioner	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner m_preconditioner;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_prescribedThreshold	../include/Eigen/src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
m_prescribedThreshold	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_prescribedThreshold	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_prod	../include/Eigen/src/Core/ProductBase.h	/^    const NestedProduct& m_prod;$/;"	m	class:Eigen::ScaledProduct	access:protected
m_pt	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable void *m_pt[64];$/;"	m	class:Eigen::PardisoImpl	access:protected
m_ptr	../include/Eigen/src/Core/util/Memory.h	/^    T* m_ptr;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler	access:protected
m_q	../include/Eigen/src/LU/FullPivLU.h	/^    PermutationQType m_q;$/;"	m	class:Eigen::FullPivLU	access:protected
m_q	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_q	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_qr	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_qr	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_qr	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typename MatrixType::Nested m_qr;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:protected
m_qr	../include/Eigen/src/QR/HouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::HouseholderQR	access:protected
m_qr	../include/Eigen/src/SVD/JacobiSVD.h	/^  ColPivHouseholderQR<MatrixType> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_qr	../include/Eigen/src/SVD/JacobiSVD.h	/^  ColPivHouseholderQR<TransposeTypeWithSameStorageOrder> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_qr	../include/Eigen/src/SVD/JacobiSVD.h	/^  FullPivHouseholderQR<MatrixType> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_qr	../include/Eigen/src/SVD/JacobiSVD.h	/^  FullPivHouseholderQR<TransposeTypeWithSameStorageOrder> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_qr	../include/Eigen/src/SVD/JacobiSVD.h	/^  HouseholderQR<MatrixType> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_qr	../include/Eigen/src/SVD/JacobiSVD.h	/^  HouseholderQR<TransposeTypeWithSameStorageOrder> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_qr_precond_morecols	../include/Eigen/src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows> m_qr_precond_morecols;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_qr_precond_morerows	../include/Eigen/src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols> m_qr_precond_morerows;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_rank	../include/Eigen/src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base	access:protected
m_rank	../include/Eigen/src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base	access:protected
m_realSchur	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    RealSchur<MatrixType> m_realSchur;$/;"	m	class:Eigen::EigenSolver	access:protected
m_reference	../include/Eigen/src/SparseCore/SparseView.h	/^  Scalar m_reference;$/;"	m	class:Eigen::SparseView	access:protected
m_result	../include/Eigen/src/Core/ProductBase.h	/^    mutable PlainObject m_result;$/;"	m	class:Eigen::ProductBase	access:protected
m_result	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    mutable PlainObject m_result;$/;"	m	class:Eigen::CoeffBasedProduct	access:protected
m_returnOne	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    bool m_returnOne;$/;"	m	class:Eigen::SparseTriangularView::InnerIterator	access:protected
m_rhs	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::CwiseBinaryOp	access:protected
m_rhs	../include/Eigen/src/Core/ProductBase.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::ProductBase	access:protected
m_rhs	../include/Eigen/src/Core/Product.h	/^    const RhsNested m_rhs;$/;"	m	class:Product	access:protected
m_rhs	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typename internal::add_const_on_value_type<RhsNested>::type m_rhs;$/;"	m	class:Eigen::CoeffBasedProduct	access:protected
m_rhs	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    const Rhs& m_rhs;$/;"	m	struct:Eigen::internal::gemm_functor	access:protected
m_rhs	../include/Eigen/src/Core/SolveTriangular.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::triangular_solve_retval	access:protected
m_rhs	../include/Eigen/src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl	access:public
m_rhs	../include/Eigen/src/Geometry/Homogeneous.h	/^  typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl	access:public
m_rhs	../include/Eigen/src/misc/Solve.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::solve_retval_base	access:protected
m_rhs	../include/Eigen/src/misc/SparseSolve.h	/^    const typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::solve_retval_with_guess	access:protected
m_rhs	../include/Eigen/src/misc/SparseSolve.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::sparse_solve_retval_base	access:protected
m_rhs	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_rhs	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseDenseOuterProduct	access:protected
m_rhs	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseDiagonalProduct	access:protected
m_rhs	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
m_rhsIter	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsIterator m_rhsIter;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
mr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
mr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
mr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
mr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2*ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
m_rowFactor	../include/Eigen/src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, RowFactor> m_rowFactor;$/;"	m	class:Eigen::Replicate	access:protected
m_row	../include/Eigen/src/Core/CommaInitializer.h	/^  Index m_row;              \/\/ current row id$/;"	m	struct:Eigen::CommaInitializer	access:public
m_row	../include/Eigen/src/Eigen2Support/Minor.h	/^    const Index m_row, m_col;$/;"	m	class:Eigen::Minor	access:protected
m_row	../include/Eigen/src/SparseCore/SparseUtil.h	/^  Index m_row, m_col;$/;"	m	class:Eigen::Triplet	access:protected
m_rows	../include/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
m_rows	../include/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
m_rows	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::CwiseNullaryOp	access:protected
m_rows	../include/Eigen/src/Core/DenseStorage.h	/^    DenseIndex m_rows;$/;"	m	class:Eigen::DenseStorage	access:private
m_rows	../include/Eigen/src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::MapBase	access:protected
m_rows	../include/Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_rowsTranspositions	../include/Eigen/src/LU/FullPivLU.h	/^    IntColVectorType m_rowsTranspositions;$/;"	m	class:Eigen::FullPivLU	access:protected
m_rowsTranspositions	../include/Eigen/src/LU/PartialPivLU.h	/^    TranspositionType m_rowsTranspositions;$/;"	m	class:Eigen::PartialPivLU	access:protected
m_rows_transpositions	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    IntColVectorType m_rows_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_rowsTranspositions	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typename IntColVectorType::Nested m_rowsTranspositions;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:protected
m_schur	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexSchur<MatrixType> m_schur;$/;"	m	class:Eigen::ComplexEigenSolver	access:protected
m_shift	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Index m_shift;$/;"	m	class:Eigen::HouseholderSequence	access:protected
m_shiftOffset	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftOffset;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_shiftScale	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftScale;$/;"	m	class:Eigen::SimplicialCholeskyBase	access:protected
m_sigma	../include/Eigen/src/Eigen2Support/SVD.h	/^    SingularValuesType m_sigma;$/;"	m	class:Eigen::SVD	access:protected
m_sign	../include/Eigen/src/Cholesky/LDLT.h	/^    int m_sign;$/;"	m	class:Eigen::LDLT	access:protected
m_s	../include/Eigen/src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation	access:protected
m_singularValues	../include/Eigen/src/SVD/JacobiSVD.h	/^    SingularValuesType m_singularValues;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_sizeA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeA;$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
m_sizeB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeB;$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
m_size	../include/Eigen/src/Core/util/Memory.h	/^    size_t m_size;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler	access:protected
m_size	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_size;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_size	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_size; \/\/ Size of the matrix $/;"	m	class:Eigen::PastixBase	access:protected
m_size	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_size;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_size	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    size_t m_size;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
m_size	../include/Eigen/src/SparseCore/SparseVector.h	/^    Index m_size;$/;"	m	class:Eigen::SparseVector	access:public
m_sizeW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeW;$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
m_sluA	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluA;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluBerr	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluB	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluCscale	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluEqued	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable char m_sluEqued;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluEtree	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable std::vector<int> m_sluEtree;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluFerr	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluL	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluOptions	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable superlu_options_t m_sluOptions;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluRscale	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluStat	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperLUStat_t m_sluStat;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_sluX	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_startCol	../include/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::Block	access:protected
m_start	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_start;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
m_start	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator	access:protected
m_start	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:protected
m_start	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
m_start	../include/Eigen/src/SparseCore/SparseVector.h	/^    const Index m_start;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator	access:protected
m_startRow	../include/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::Block	access:protected
m_staticA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 LhsScalar m_staticA[SizeA];$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
m_staticB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 RhsScalar m_staticB[SizeB];$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
m_staticW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 RhsScalar m_staticW[SizeW];$/;"	m	class:Eigen::internal::gemm_blocking_space	access:private
m_step	../include/Eigen/src/Core/Functors.h	/^  const Scalar m_step;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_stepPacket	../include/Eigen/src/Core/Functors.h	/^  const Packet m_stepPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl	access:public
m_storage	../include/Eigen/src/Core/PlainObjectBase.h	/^    DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;$/;"	m	class:Eigen::PlainObjectBase	access:protected
m_stride	../include/Eigen/src/Core/Map.h	/^    StrideType m_stride;$/;"	m	class:Eigen::Map	access:protected
m_stride	../include/Eigen/src/Core/util/BlasUtil.h	/^    Index m_stride;$/;"	m	class:Eigen::internal::blas_data_mapper	access:protected
m_stride	../include/Eigen/src/Core/util/BlasUtil.h	/^    Index m_stride;$/;"	m	class:Eigen::internal::const_blas_data_mapper	access:protected
m_structureIsUptodate	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    bool m_structureIsUptodate;$/;"	m	class:Eigen::PastixLU	access:protected
m_subdiag	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typename TridiagonalizationType::SubDiagonalType m_subdiag;$/;"	m	class:Eigen::SelfAdjointEigenSolver	access:protected
m_subs	../include/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
m_subs	../include/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
m_supers	../include/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrix	access:protected
m_supers	../include/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrixWrapper	access:protected
m_symbolic	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void* m_symbolic;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_temp	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    VectorType m_temp;$/;"	m	class:Eigen::HessenbergDecomposition	access:protected
m_temp	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_temp	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_temp	../include/Eigen/src/QR/HouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::HouseholderQR	access:protected
m_temporary	../include/Eigen/src/Cholesky/LDLT.h	/^    TmpMatrixType m_temporary;$/;"	m	class:Eigen::LDLT	access:protected
m_then	../include/Eigen/src/Core/Select.h	/^    typename ThenMatrixType::Nested m_then;$/;"	m	class:Eigen::Select	access:protected
m_tmp	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    ColumnVectorType m_tmp;$/;"	m	class:Eigen::EigenSolver	access:protected
m_tolerance	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar m_tolerance;$/;"	m	class:Eigen::IterativeSolverBase	access:protected
m_tolerance	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RealScalar m_tolerance;$/;"	m	class:Eigen::SparseSparseProduct	access:protected
m_trans	../include/Eigen/src/Householder/HouseholderSequence.h	/^    bool m_trans;$/;"	m	class:Eigen::HouseholderSequence	access:protected
m_transpositions	../include/Eigen/src/Cholesky/LDLT.h	/^    TranspositionType m_transpositions;$/;"	m	class:Eigen::LDLT	access:protected
m_transpositions	../include/Eigen/src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	class:Eigen::Transpose	access:protected
m_transpositions	../include/Eigen/src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	struct:Eigen::internal::transposition_matrix_product_retval	access:protected
m_triangularMatrix	../include/Eigen/src/Core/SolveTriangular.h	/^    const TriangularType& m_triangularMatrix;$/;"	m	struct:Eigen::internal::triangular_solve_retval	access:protected
mtx	../include/abcd.h	/^    Eigen::SparseMatrix<double, RowMajor> mtx;$/;"	m	class:abcd	access:private
m_type	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl	access:protected
m_u	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::SuperLUBase	access:protected
m_u	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::UmfPackLU	access:protected
MulCost	../include/Eigen/src/Core/NumTraits.h	/^    MulCost = 1$/;"	e	enum:Eigen::GenericNumTraits::__anon277
mumps	../include/abcd.h	/^    DMUMPS_STRUC_C mumps;$/;"	m	class:abcd	access:private
m_usePrescribedThreshold	../include/Eigen/src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU	access:protected
m_usePrescribedThreshold	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR	access:protected
m_usePrescribedThreshold	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR	access:protected
m_value	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Scalar m_value;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
m_value	../include/Eigen/src/SparseCore/SparseMatrix.h	/^        Index m_value;$/;"	m	class:Eigen::SparseMatrix::SingletonVector	access:private
m_value	../include/Eigen/src/SparseCore/SparseUtil.h	/^  Scalar m_value;$/;"	m	class:Eigen::Triplet	access:protected
m_valuePtr	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    const Scalar* m_valuePtr;$/;"	m	class:Eigen::UmfPackLU	access:protected
m_values	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    Scalar* m_values;$/;"	m	class:Eigen::internal::CompressedStorage	access:protected
m_values	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Scalar* m_values;$/;"	m	class:Eigen::MappedSparseMatrix	access:protected
m_values	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseMatrix::InnerIterator	access:protected
m_values	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator	access:protected
m_vector	../include/Eigen/src/SparseCore/AmbiVector.h	/^    const AmbiVector& m_vector; \/\/ the target vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator	access:protected
m_vectors	../include/Eigen/src/Householder/HouseholderSequence.h	/^    typename VectorsType::Nested m_vectors;$/;"	m	class:Eigen::HouseholderSequence	access:protected
m_view	../include/Eigen/src/SparseCore/SparseView.h	/^  const SparseView& m_view;$/;"	m	class:Eigen::SparseView::InnerIterator	access:protected
m_workMatrix	../include/Eigen/src/SVD/JacobiSVD.h	/^    WorkMatrixType m_workMatrix;$/;"	m	class:Eigen::JacobiSVD	access:protected
m_workspace	../include/Eigen/src/SVD/JacobiSVD.h	/^  typename internal::plain_col_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_workspace	../include/Eigen/src/SVD/JacobiSVD.h	/^  typename internal::plain_row_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_workspace	../include/Eigen/src/SVD/JacobiSVD.h	/^  WorkspaceType m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl	access:private
m_workspaceVector	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    ColumnVectorType m_workspaceVector;$/;"	m	class:Eigen::RealSchur	access:private
m_xpr	../include/Eigen/src/Core/Block.h	/^    const typename XprType::Nested m_xpr;$/;"	m	class:Eigen::Block	access:protected
m_xpr	../include/Eigen/src/Core/Block.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::Block	access:protected
m_xpr	../include/Eigen/src/Core/CommaInitializer.h	/^  XprType& m_xpr;   \/\/ target expression$/;"	m	struct:Eigen::CommaInitializer	access:public
m_xpr	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::CwiseUnaryOp	access:protected
m_xpr	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const CwiseBinaryXpr& m_xpr;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:protected
my_master	../include/abcd.h	/^    int my_master;$/;"	m	class:abcd	access:private
my_slaves	../include/abcd.h	/^    std::vector<int> my_slaves;$/;"	m	class:abcd	access:private
m_zero	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar m_zero;$/;"	m	class:Eigen::internal::AmbiVector	access:protected
nbparts	../include/abcd.h	/^    int nbparts; \/\/\/ The number of partitions$/;"	m	class:abcd	access:public
nbrows	../include/abcd.h	/^    ArrayXi nbrows; \/\/\/ The number of rows per partition$/;"	m	class:abcd	access:public
nbThreads	../include/Eigen/src/Core/products/Parallelizer.h	/^inline int nbThreads()$/;"	f	namespace:Eigen	signature:()
nc	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex nc() const { return m_nc; }$/;"	f	class:Eigen::internal::level3_blocking	access:public	signature:() const
NColsBlockXpr	../include/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	s
NColsBlockXpr::Type	../include/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:NColsBlockXpr	access:public
NeedsToAlign	../include/Eigen/src/Core/PlainObjectBase.h	/^    enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };$/;"	e	enum:Eigen::PlainObjectBase::__anon62
NeedToConjugate	../include/Eigen/src/Core/util/BlasUtil.h	/^    NeedToConjugate = Base::NeedToConjugate ? 0 : IsComplex$/;"	e	enum:Eigen::internal::blas_traits::__anon203
NeedToConjugate	../include/Eigen/src/Core/util/BlasUtil.h	/^    NeedToConjugate = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon202
NestByRefBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int NestByRefBit = 0x100;$/;"	m	namespace:Eigen
nestByValue	../include/Eigen/src/Core/DenseBase.h	/^    inline const NestByValue<Derived> nestByValue() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
nestByValue	../include/Eigen/src/Core/NestByValue.h	/^DenseBase<Derived>::nestByValue() const$/;"	f	class:Eigen::DenseBase	signature:() const
NestByValue	../include/Eigen/src/Core/NestByValue.h	/^    inline NestByValue(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::NestByValue	access:public	signature:(const ExpressionType& matrix)
NestByValue	../include/Eigen/src/Core/NestByValue.h	/^template<typename ExpressionType> class NestByValue$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
nestedExpression	../include/Eigen/src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
nestedExpression	../include/Eigen/src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
nestedExpression	../include/Eigen/src/Core/Block.h	/^    const typename internal::remove_all<typename XprType::Nested>::type& nestedExpression() const $/;"	f	class:Eigen::Block	access:public	signature:() const
nestedExpression	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
nestedExpression	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    nestedExpression() { return m_xpr.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:()
nestedExpression	../include/Eigen/src/Core/CwiseUnaryView.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
nestedExpression	../include/Eigen/src/Core/CwiseUnaryView.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:()
nestedExpression	../include/Eigen/src/Core/Replicate.h	/^    const _MatrixTypeNested& nestedExpression() const$/;"	f	class:Eigen::Replicate	access:public	signature:() const
nestedExpression	../include/Eigen/src/Core/Reverse.h	/^    nestedExpression() const $/;"	f	class:Eigen::Reverse	access:public	signature:() const
nestedExpression	../include/Eigen/src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
nestedExpression	../include/Eigen/src/Core/SelfAdjointView.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:()
nestedExpression	../include/Eigen/src/Core/Transpose.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
nestedExpression	../include/Eigen/src/Core/Transpose.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::Transpose	access:public	signature:()
nestedExpression	../include/Eigen/src/Core/TriangularMatrix.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
nestedExpression	../include/Eigen/src/Core/TriangularMatrix.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }$/;"	f	class:Eigen::TriangularView	access:public	signature:()
nestedExpression	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:() const
NestedExpressionType	../include/Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;$/;"	t	class:Eigen::ArrayWrapper	access:public
NestedExpressionType	../include/Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;$/;"	t	class:Eigen::MatrixWrapper	access:public
Nested	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef const DiagonalMatrix& Nested;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Nested	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalWrapper Nested;$/;"	t	class:Eigen::DiagonalWrapper	access:public
nested	../include/Eigen/src/Core/ProductBase.h	/^struct nested<GeneralProduct<Lhs,Rhs,Mode>, N, PlainObject>$/;"	s	namespace:Eigen::internal
nested	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct nested<CoeffBasedProduct<Lhs,Rhs,EvalBeforeNestingBit|EvalBeforeAssigningBit>, N, PlainObject>$/;"	s	namespace:Eigen::internal
nested	../include/Eigen/src/Core/ReturnByValue.h	/^struct nested<ReturnByValue<Derived>, n, PlainObject>$/;"	s	namespace:Eigen::internal
nestedPermutation	../include/Eigen/src/Core/PermutationMatrix.h	/^    const PermutationType& nestedPermutation() const { return m_permutation; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
NewInf	../include/Eigen/src/Core/util/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen::internal
NewInf	../include/Eigen/src/Eigen2Support/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen
NewSup	../include/Eigen/src/Core/util/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen::internal
NewSup	../include/Eigen/src/Eigen2Support/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen
next	../include/Eigen/src/SparseCore/AmbiVector.h	/^      Index next;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl	access:public
n	../include/abcd.h	/^    int n;$/;"	m	class:abcd	access:public
nnz	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon1::__anon2	access:public
noalias	../include/Eigen/src/Core/MatrixBase.h	/^    NoAlias<Derived,Eigen::MatrixBase > noalias();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
NoAlias	../include/Eigen/src/Core/NoAlias.h	/^class NoAlias$/;"	c	namespace:Eigen
noalias	../include/Eigen/src/Core/NoAlias.h	/^NoAlias<Derived,MatrixBase> MatrixBase<Derived>::noalias()$/;"	f	class:Eigen::MatrixBase	signature:()
NoAlias	../include/Eigen/src/Core/NoAlias.h	/^    NoAlias(ExpressionType& expression) : m_expression(expression) {}$/;"	f	class:Eigen::NoAlias	access:public	signature:(ExpressionType& expression)
no_assignment_operator	../include/Eigen/src/Core/util/XprHelper.h	/^class no_assignment_operator$/;"	c	namespace:Eigen::internal
NoChange	../include/Eigen/src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	e	enum:Eigen::NoChange_t
NoChange_t	../include/Eigen/src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	g	namespace:Eigen
NoConvergence	../include/Eigen/src/Core/util/Constants.h	/^  NoConvergence = 2,$/;"	e	enum:Eigen::ComputationInfo
NonConstImagReturnType	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryView<internal::scalar_imag_ref_op<Scalar>, Derived> NonConstImagReturnType;$/;"	t
NonConstRealReturnType	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type NonConstRealReturnType;$/;"	t
noncopyable	../include/Eigen/src/Core/util/Meta.h	/^class noncopyable$/;"	c	namespace:Eigen::internal
noncopyable	../include/Eigen/src/Core/util/Meta.h	/^  noncopyable(const noncopyable&);$/;"	p	class:Eigen::internal::noncopyable	access:private	signature:(const noncopyable&)
~noncopyable	../include/Eigen/src/Core/util/Meta.h	/^  ~noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable	access:protected	signature:()
noncopyable	../include/Eigen/src/Core/util/Meta.h	/^  noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable	access:protected	signature:()
NonInteger	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::NonInteger NonInteger;$/;"	t	struct:Eigen::internal::random_default_impl	access:public
NonInteger	../include/Eigen/src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::NonInteger      NonInteger;$/;"	t	class:Eigen::AlignedBox	access:public
nonzeroPivots	../include/Eigen/src/LU/FullPivLU.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
nonzeroPivots	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
nonzeroPivots	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
nonZeros	../include/Eigen/src/Core/DenseBase.h	/^    inline Index nonZeros() const { return size(); }$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
nonZeros	../include/Eigen/src/SparseCore/AmbiVector.h	/^_Index AmbiVector<_Scalar,_Index>::nonZeros() const$/;"	f	class:Eigen::internal::AmbiVector	signature:() const
nonZeros	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index nonZeros() const;$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:() const
nonZeros	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index nonZeros() const  { return m_nnz; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
nonZeros	../include/Eigen/src/SparseCore/SparseBlock.h	/^    Index nonZeros() const$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
nonZeros	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index nonZeros() const { return derived().nonZeros(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
nonZeros	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index nonZeros() const$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
nonZeros	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    inline Index nonZeros() const { return derived().nestedExpression().nonZeros(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
nonZeros	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index nonZeros() const  { return static_cast<Index>(m_data.size()); }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
nonzeroSingularValues	../include/Eigen/src/SVD/JacobiSVD.h	/^    Index nonzeroSingularValues() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
NoPivoting	../include/Eigen/src/Core/util/Constants.h	/^  NoPivoting          = 0x02, $/;"	e	enum:Eigen::DecompositionOptions
NoQRPreconditioner	../include/Eigen/src/Core/util/Constants.h	/^  NoQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
norm1_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct norm1_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
norm1_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct norm1_default_impl$/;"	s	namespace:Eigen::internal
norm1_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct norm1_impl : norm1_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal	inherits:norm1_default_impl
norm1	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(norm1, Scalar) norm1(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
norm1_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct norm1_retval$/;"	s	namespace:Eigen::internal
normal	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const NormalReturnType normal() const { return NormalReturnType(*const_cast<Coefficients*>(&m_coeffs),0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
normal	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
normal	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline ConstNormalReturnType normal() const { return ConstNormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
normal	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
normalized	../include/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::normalized() const$/;"	f	class:Eigen::MatrixBase	signature:() const
normalized	../include/Eigen/src/Core/MatrixBase.h	/^    const PlainObject normalized() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
normalized	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion normalized() const { return Quaternion(m_coeffs.normalized()); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
normalized	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion<Scalar> normalized() const { return Quaternion<Scalar>(coeffs().normalized()); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
normalize	../include/Eigen/src/Core/Dot.h	/^inline void MatrixBase<Derived>::normalize()$/;"	f	class:Eigen::MatrixBase	signature:()
normalize	../include/Eigen/src/Core/MatrixBase.h	/^    void normalize();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
normalize	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  void normalize(void)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(void)
normalize	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline void normalize() { m_coeffs.normalize(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
normalize	../include/Eigen/src/Geometry/Hyperplane.h	/^  void normalize(void)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(void)
normalize	../include/Eigen/src/Geometry/Quaternion.h	/^  inline void normalize() { coeffs().normalize(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
NormalReturnType	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane	access:public
NormalReturnType	../include/Eigen/src/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane	access:public
norm	../include/Eigen/src/Core/Dot.h	/^inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::norm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
norm	../include/Eigen/src/Core/MatrixBase.h	/^    RealScalar norm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
norm	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_norm,RealScalar>::Type norm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
norm	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar norm() const { return m_coeffs.norm(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
norm	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar norm() const { return coeffs().norm(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
norm	../include/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::norm() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
norm	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    RealScalar norm()  const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
normres	../include/abcd.h	/^    std::vector<double> normres;$/;"	m	class:abcd	access:private
NoUnrolling	../include/Eigen/src/Core/util/Constants.h	/^  NoUnrolling,$/;"	e	enum:Eigen::__anon210
nrhs	../include/abcd.h	/^    int nrhs;$/;"	m	class:abcd	access:public
nr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 2,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
nr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
nr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = NumberOfRegisters\/4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
nr	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = NumberOfRegisters\/4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
nrmA	../include/abcd.h	/^    double nrmA;$/;"	m	class:abcd	access:private
NRowsBlockXpr	../include/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	s
NRowsBlockXpr::Type	../include/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:NRowsBlockXpr	access:public
NullaryExpr	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase	signature:(const CustomNullaryOp& func)
NullaryExpr	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols, const CustomNullaryOp& func)
NullaryExpr	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index size, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const CustomNullaryOp& func)
NullaryExpr	../include/Eigen/src/Core/DenseBase.h	/^    NullaryExpr(const CustomNullaryOp& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const CustomNullaryOp& func)
NullaryExpr	../include/Eigen/src/Core/DenseBase.h	/^    NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols, const CustomNullaryOp& func)
NullaryExpr	../include/Eigen/src/Core/DenseBase.h	/^    NullaryExpr(Index size, const CustomNullaryOp& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const CustomNullaryOp& func)
NumberOfRegisters	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
NumberOfRegisters	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
NumberOfRegisters	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
NumericalIssue	../include/Eigen/src/Core/util/Constants.h	/^  NumericalIssue = 1, $/;"	e	enum:Eigen::ComputationInfo
NUMERIC_TYPE_MUST_BE_REAL	../include/Eigen/src/Core/util/StaticAssert.h	/^        NUMERIC_TYPE_MUST_BE_REAL,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
nz	../include/abcd.h	/^    int nz;$/;"	m	class:abcd	access:public
nz_l	../include/abcd.h	/^    int m_l, nz_l;$/;"	m	class:abcd	access:public
OffsetCol	../include/Eigen/src/Core/Reverse.h	/^      OffsetCol  = ReverseCol && IsRowMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon116
offset	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
offset	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
offset	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:() const
offset	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:()
OffsetRow	../include/Eigen/src/Core/Reverse.h	/^      OffsetRow  = ReverseRow && IsColMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon116
Ones	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones()$/;"	f	class:Eigen::DenseBase	signature:()
Ones	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols)
Ones	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
Ones	../include/Eigen/src/Core/DenseBase.h	/^    static const ConstantReturnType Ones(Index rows, Index cols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Ones	../include/Eigen/src/Core/DenseBase.h	/^    static const ConstantReturnType Ones(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
Ones	../include/Eigen/src/Core/DenseBase.h	/^    static const ConstantReturnType Ones();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
OnTheLeft	../include/Eigen/src/Core/util/Constants.h	/^  OnTheLeft = 1,  $/;"	e	enum:Eigen::__anon213
OnTheRight	../include/Eigen/src/Core/util/Constants.h	/^  OnTheRight = 2  $/;"	e	enum:Eigen::__anon213
operator bool	../include/Eigen/src/SparseCore/AmbiVector.h	/^    operator bool() const { return m_cachedIndex>=0; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_inner < m_end && m_inner>=0; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end) && (m_id>=m_start); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline operator bool() const { return (m_id <= m_end) && (m_id>m_start); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_id>=0; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_lhsIter; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return (m_lhsIter && m_rhsIter); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_rhsIter; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
operator bool	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
operator const ExpressionType&	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
operator const ExpressionType&	../include/Eigen/src/Core/NestByValue.h	/^    operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
operator const PlainObject&	../include/Eigen/src/Core/ProductBase.h	/^    operator const PlainObject& () const$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
operator const PlainObject&	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE operator const PlainObject& () const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
operator const T&	../include/Eigen/src/StlSupport/details.h	/^    inline operator const T& () const { return *static_cast<const T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:() const
operator const typename Base::Scalar	../include/Eigen/src/Core/GeneralProduct.h	/^    operator const typename Base::Scalar() const {$/;"	f	class:Eigen::GeneralProduct	access:public	signature:() const
operator -=	../include/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator-=(const ArrayBase<OtherDerived> &other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived> &other)
operator /=	../include/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator\/=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived>& other)
operator *=	../include/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator*=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived>& other)
operator +=	../include/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator+=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase	signature:(const ArrayBase<OtherDerived>& other)
operator -=	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator-=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
operator /=	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator\/=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
operator *=	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator*=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
operator +=	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator+=(const ArrayBase<OtherDerived>& other);$/;"	p	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator=(const ArrayBase& other)$/;"	f	class:Eigen::ArrayBase	access:public	signature:(const ArrayBase& other)
operator -=	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator-=(const Scalar& scalar)$/;"	f	class:Eigen::ArrayBase	access:public	signature:(const Scalar& scalar)
operator +=	../include/Eigen/src/Core/ArrayBase.h	/^    Derived& operator+=(const Scalar& scalar)$/;"	f	class:Eigen::ArrayBase	access:public	signature:(const Scalar& scalar)
operator -=	../include/Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator-=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase	access:protected	signature:(const MatrixBase<OtherDerived>& )
operator +=	../include/Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator+=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase	access:protected	signature:(const MatrixBase<OtherDerived>& )
operator =	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::Array	access:public	signature:(const ArrayBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const Array& other)$/;"	f	class:Eigen::Array	access:public	signature:(const Array& other)
operator =	../include/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array	access:public	signature:(const EigenBase<OtherDerived> &other)
operator =	../include/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase& other)
operator =	../include/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const DenseBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const MatrixBase& other)$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase& other)
operator =	../include/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const ReturnByValue<OtherDerived>& other)
operator ,	../include/Eigen/src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(const DenseBase<OtherDerived>& other)
operator ,	../include/Eigen/src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer	access:public	signature:(const Scalar& s)
operator <<	../include/Eigen/src/Core/CommaInitializer.h	/^DenseBase<Derived>::operator<<(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<OtherDerived>& other)
operator <<	../include/Eigen/src/Core/CommaInitializer.h	/^inline CommaInitializer<Derived> DenseBase<Derived>::operator<< (const Scalar& s)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& s)
operator -=	../include/Eigen/src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator-=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived> &other)
operator +=	../include/Eigen/src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator+=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived>& other)
operator <<	../include/Eigen/src/Core/DenseBase.h	/^    CommaInitializer<Derived> operator<< (const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other)
operator <<	../include/Eigen/src/Core/DenseBase.h	/^    CommaInitializer<Derived> operator<< (const Scalar& s);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& s)
operator =	../include/Eigen/src/Core/DenseBase.h	/^    Derived& operator=(const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/DenseBase.h	/^    Derived& operator=(const DenseBase& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase& other)
operator =	../include/Eigen/src/Core/DenseBase.h	/^    Derived& operator=(const EigenBase<OtherDerived> &other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const EigenBase<OtherDerived> &other)
operator -=	../include/Eigen/src/Core/DenseBase.h	/^    Derived& operator-=(const EigenBase<OtherDerived> &other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const EigenBase<OtherDerived> &other)
operator +=	../include/Eigen/src/Core/DenseBase.h	/^    Derived& operator+=(const EigenBase<OtherDerived> &other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const EigenBase<OtherDerived> &other)
operator =	../include/Eigen/src/Core/DenseBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& func);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const ReturnByValue<OtherDerived>& func)
operator /=	../include/Eigen/src/Core/DenseBase.h	/^    inline Derived& operator\/=(const Scalar& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& other)
operator *=	../include/Eigen/src/Core/DenseBase.h	/^    inline Derived& operator*=(const Scalar& other);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& other)
operator ()	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType operator()(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col) const
operator ()	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
operator []	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    operator[](Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
operator ()	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index index)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index)
operator []	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    operator[](Index index)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index)
operator ()	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col)
operator =	../include/Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalMatrix& other)$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(const DiagonalMatrix& other)
operator *	../include/Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const MatrixBase<MatrixDerived> &matrix) const;$/;"	p	class:Eigen::DiagonalBase	access:public	signature:(const MatrixBase<MatrixDerived> &matrix) const
operator *	../include/Eigen/src/Core/DiagonalProduct.h	/^DiagonalBase<DiagonalDerived>::operator*(const MatrixBase<MatrixDerived> &matrix) const$/;"	f	class:Eigen::DiagonalBase	signature:(const MatrixBase<MatrixDerived> &matrix) const
operator *	../include/Eigen/src/Core/DiagonalProduct.h	/^MatrixBase<Derived>::operator*(const DiagonalBase<DiagonalDerived> &diagonal) const$/;"	f	class:Eigen::MatrixBase	signature:(const DiagonalBase<DiagonalDerived> &diagonal) const
operator =	../include/Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase	signature:(const EigenBase<OtherDerived> &other)
operator -=	../include/Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator-=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase	signature:(const EigenBase<OtherDerived> &other)
operator +=	../include/Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator+=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase	signature:(const EigenBase<OtherDerived> &other)
operator *=	../include/Eigen/src/Core/EigenBase.h	/^MatrixBase<Derived>::operator*=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase	signature:(const EigenBase<OtherDerived> &other)
operator =	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    ForceAlignedAccess& operator=(const ForceAlignedAccess&);$/;"	p	class:Eigen::ForceAlignedAccess	access:private	signature:(const ForceAlignedAccess&)
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a && b; }$/;"	f	struct:Eigen::internal::scalar_boolean_and_op	access:public	signature:(const bool& a, const bool& b) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a || b; }$/;"	f	struct:Eigen::internal::scalar_boolean_or_op	access:public	signature:(const bool& a, const bool& b) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const NewType operator() (const Scalar& a) const { return cast<Scalar, NewType>(a); }$/;"	f	struct:Eigen::internal::scalar_cast_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op	access:public	signature:(const LhsScalar& a, const RhsScalar& b) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a * b; }$/;"	f	struct:Eigen::internal::scalar_product_op	access:public	signature:(const LhsScalar& a, const RhsScalar& b) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return internal::abs2(a); }$/;"	f	struct:Eigen::internal::scalar_abs2_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return internal::abs(a); }$/;"	f	struct:Eigen::internal::scalar_abs_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return -a; }$/;"	f	struct:Eigen::internal::scalar_opposite_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return internal::conj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a - b; }$/;"	f	struct:Eigen::internal::scalar_difference_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a \/ b; }$/;"	f	struct:Eigen::internal::scalar_quotient_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }$/;"	f	struct:Eigen::internal::scalar_sum_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::max; return (max)(a, b); }$/;"	f	struct:Eigen::internal::scalar_max_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::min; return (min)(a, b); }$/;"	f	struct:Eigen::internal::scalar_min_op	access:public	signature:(const Scalar& a, const Scalar& b) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& _x, const Scalar& _y) const$/;"	f	struct:Eigen::internal::scalar_hypot_op	access:public	signature:(const Scalar& _x, const Scalar& _y) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const { return impl(i); }$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index i) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const { return m_low+i*m_step; }$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index i) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index, Index = 0) const { return m_other; }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(Index, Index = 0) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index row, Index col) const $/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index row, Index col) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index row, Index col) const { return row==col ? Scalar(1) : Scalar(0); }$/;"	f	struct:Eigen::internal::scalar_identity_op	access:public	signature:(Index row, Index col) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar1& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_multiple2_op	access:public	signature:(const Scalar1& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return internal::imag(a); }$/;"	f	struct:Eigen::internal::scalar_imag_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return internal::imag_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_imag_ref_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return internal::real(a); }$/;"	f	struct:Eigen::internal::scalar_real_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return internal::real_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_real_ref_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_quotient1_impl	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a \/ m_other; }$/;"	f	struct:Eigen::internal::scalar_quotient1_impl	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::acos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::asin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::exp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::log(a); }$/;"	f	struct:Eigen::internal::scalar_log_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::sin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::sqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::tan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a, const OtherScalar& b) const { return internal::pow(a, b); }$/;"	f	struct:Eigen::internal::scalar_binary_pow_op	access:public	signature:(const Scalar& a, const OtherScalar& b) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a*a*a; }$/;"	f	struct:Eigen::internal::scalar_cube_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a*a; }$/;"	f	struct:Eigen::internal::scalar_square_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a + m_other; }$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return internal::cos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return internal::pow(a, m_exponent); }$/;"	f	struct:Eigen::internal::scalar_pow_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return m_other \/ a; }$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op	access:public	signature:(const Scalar& a) const
operator ()	../include/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return Scalar(1)\/a; }$/;"	f	struct:Eigen::internal::scalar_inverse_op	access:public	signature:(const Scalar& a) const
operator *	../include/Eigen/src/Core/GeneralProduct.h	/^MatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
operator /	../include/Eigen/src/Core/GlobalFunctions.h	/^    operator\/(typename Derived::Scalar s, const Eigen::ArrayBase<Derived>& a)$/;"	f	namespace:Eigen	signature:(typename Derived::Scalar s, const Eigen::ArrayBase<Derived>& a)
operator <<	../include/Eigen/src/Core/IO.h	/^    friend std::ostream & operator << (std::ostream & s, const WithFormat& wf)$/;"	f	class:Eigen::WithFormat	access:friend	signature:(std::ostream & s, const WithFormat& wf)
operator <<	../include/Eigen/src/Core/IO.h	/^std::ostream & operator <<$/;"	f	namespace:Eigen	signature:(std::ostream & s, const DenseBase<Derived> & m)
operator =	../include/Eigen/src/Core/MapBase.h	/^    Derived& operator=(const MapBase& other)$/;"	f	class:Eigen::MapBase	access:public	signature:(const MapBase& other)
operator =	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator=(const DenseBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const DenseBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator=(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
operator *=	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator*=(const EigenBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const EigenBase<OtherDerived>& other)
operator -=	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator-=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
operator +=	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator+=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
operator -=	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator-=(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other)
operator +=	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator+=(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator=(const MatrixBase& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase& other)
operator =	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& other);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const ReturnByValue<OtherDerived>& other)
operator ==	../include/Eigen/src/Core/MatrixBase.h	/^    inline bool operator==(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator !=	../include/Eigen/src/Core/MatrixBase.h	/^    inline bool operator!=(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator *	../include/Eigen/src/Core/MatrixBase.h	/^    operator*(const DiagonalBase<DiagonalDerived> &diagonal) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const DiagonalBase<DiagonalDerived> &diagonal) const
operator *	../include/Eigen/src/Core/MatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
operator *	../include/Eigen/src/Core/MatrixBase.h	/^    ScalarMultipleReturnType operator*(const UniformScaling<Scalar>& s) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const UniformScaling<Scalar>& s) const
operator -=	../include/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator-=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase	access:protected	signature:(const ArrayBase<OtherDerived>& )
operator +=	../include/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator+=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase	access:protected	signature:(const ArrayBase<OtherDerived>& )
operator =	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const EigenBase<OtherDerived> &other)
operator =	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const MatrixBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const Matrix& other)$/;"	f	class:Eigen::Matrix	access:public	signature:(const Matrix& other)
operator =	../include/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::Matrix	access:public	signature:(const ReturnByValue<OtherDerived>& func)
operator =	../include/Eigen/src/Core/Matrix.h	/^    Matrix& operator=(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const eigen2_RotationBase<OtherDerived,ColsAtCompileTime>& r)
operator =	../include/Eigen/src/Core/Matrix.h	/^    Matrix& operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r);$/;"	p	class:Eigen::Matrix	access:public	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
operator -=	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)
operator +=	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)
operator -=	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
operator +=	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
operator =	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const StorageBase<OtherDerived>& other)
operator -=	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const StorageBase<OtherDerived>& other)
operator +=	../include/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias	access:public	signature:(const StorageBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const PermutationBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase& other)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const PermutationBase& other)
operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& tr)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const TranspositionsBase<OtherDerived>& tr)
operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const PermutationBase<Other>& other) const$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const PermutationBase<Other>& other) const
operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other) const$/;"	f	class:Eigen::PermutationBase	access:public	signature:(const Transpose<PermutationBase<Other> >& other) const
operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other, const PermutationBase& perm)$/;"	f	class:Eigen::PermutationBase	access:friend	signature:(const Transpose<PermutationBase<Other> >& other, const PermutationBase& perm)
operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map	access:public	signature:(const Map& other)
operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::Map	access:public	signature:(const PermutationBase<Other>& other)
operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::Map	access:public	signature:(const TranspositionsBase<Other>& tr)
operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^operator*(const MatrixBase<Derived>& matrix,$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& matrix, const PermutationBase<PermutationDerived> &permutation)
operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix) const$/;"	f	class:Eigen::Transpose	access:public	signature:(const MatrixBase<OtherDerived>& matrix) const
operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix, const Transpose& trPerm)$/;"	f	class:Eigen::Transpose	access:friend	signature:(const MatrixBase<OtherDerived>& matrix, const Transpose& trPerm)
operator *	../include/Eigen/src/Core/PermutationMatrix.h	/^operator*(const PermutationBase<PermutationDerived> &permutation,$/;"	f	namespace:Eigen	signature:(const PermutationBase<PermutationDerived> &permutation, const MatrixBase<Derived>& matrix)
operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationBase<Other>& other)
operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationMatrix& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationMatrix& other)
operator =	../include/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const TranspositionsBase<Other>& tr)
operator =	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const EigenBase<OtherDerived> &other)
operator =	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const PlainObjectBase& other)
operator =	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const ReturnByValue<OtherDerived>& func)
operator *	../include/Eigen/src/Core/ProductBase.h	/^operator*(const ProductBase<Derived,Lhs,Rhs>& prod, typename Derived::RealScalar x)$/;"	f	namespace:Eigen	signature:(const ProductBase<Derived,Lhs,Rhs>& prod, typename Derived::RealScalar x)
operator *	../include/Eigen/src/Core/ProductBase.h	/^operator*(const ProductBase<Derived,Lhs,Rhs>& prod, typename Derived::Scalar x)$/;"	f	namespace:Eigen	signature:(const ProductBase<Derived,Lhs,Rhs>& prod, typename Derived::Scalar x)
operator *	../include/Eigen/src/Core/ProductBase.h	/^operator*(typename Derived::RealScalar x,const ProductBase<Derived,Lhs,Rhs>& prod)$/;"	f	namespace:Eigen	signature:(typename Derived::RealScalar x,const ProductBase<Derived,Lhs,Rhs>& prod)
operator *	../include/Eigen/src/Core/ProductBase.h	/^operator*(typename Derived::Scalar x,const ProductBase<Derived,Lhs,Rhs>& prod)$/;"	f	namespace:Eigen	signature:(typename Derived::Scalar x,const ProductBase<Derived,Lhs,Rhs>& prod)
operator ()	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_DONT_INLINE void operator()(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows,$/;"	f	struct:Eigen::internal::gemm_pack_lhs	access:public	signature:(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows, Index stride=0, Index offset=0)
operator ()	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_DONT_INLINE void operator()(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols,$/;"	f	struct:Eigen::internal::gemm_pack_rhs	access:public	signature:(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols, Index stride=0, Index offset=0)
operator ()	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha,$/;"	f	struct:Eigen::internal::gebp_kernel	access:public	signature:(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0, RhsScalar* unpackedB = 0)
operator ()	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  void operator() (Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const$/;"	f	struct:Eigen::internal::gemm_functor	access:public	signature:(Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const
operator ()	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, ResScalar alpha, RhsScalar* workspace)$/;"	f	struct:Eigen::internal::tribb_kernel	access:public	signature:(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, ResScalar alpha, RhsScalar* workspace)
operator ()	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)$/;"	f	struct:Eigen::internal::symm_pack_lhs	access:public	signature:(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)
operator ()	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)$/;"	f	struct:Eigen::internal::symm_pack_rhs	access:public	signature:(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)
operator ()	../include/Eigen/src/Core/Random.h	/^  inline const Scalar operator() (Index, Index = 0) const { return random<Scalar>(); }$/;"	f	struct:Eigen::internal::scalar_random_op	access:public	signature:(Index, Index = 0) const
operator =	../include/Eigen/src/Core/ReturnByValue.h	/^Derived& DenseBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	signature:(const ReturnByValue<OtherDerived>& other)
operator =	../include/Eigen/src/Core/ReturnByValue.h	/^      Unusable& operator=(const Unusable&) {return *this;}$/;"	f	class:Eigen::ReturnByValue::Unusable	access:private	signature:(const Unusable&)
operator ()	../include/Eigen/src/Core/Reverse.h	/^    inline Scalar& operator()(Index index)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index)
operator ()	../include/Eigen/src/Core/Reverse.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col)
operator *	../include/Eigen/src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)$/;"	f	class:Eigen::SelfAdjointView	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)
operator *	../include/Eigen/src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<OtherDerived>& rhs) const
operator =	../include/Eigen/src/Core/SelfAdjointView.h	/^    SelfAdjointView& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/SelfAdjointView.h	/^    SelfAdjointView& operator=(const TriangularView<OtherMatrixType, OtherMode>& other)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(const TriangularView<OtherMatrixType, OtherMode>& other)
operator /=	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^inline Derived& DenseBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& other)
operator *=	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^inline Derived& DenseBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& other)
operator =	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    SelfCwiseBinaryOp& operator=(const Rhs& _rhs)$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(const Rhs& _rhs)
operator =	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    SelfCwiseBinaryOp& operator=(const SelfCwiseBinaryOp&);$/;"	p	class:Eigen::SelfCwiseBinaryOp	access:private	signature:(const SelfCwiseBinaryOp&)
operator =	../include/Eigen/src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase& other)$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(const TranspositionsBase& other)
operator ()	../include/Eigen/src/Core/Transpositions.h	/^    inline const Index& operator()(Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i) const
operator []	../include/Eigen/src/Core/Transpositions.h	/^    inline const Index& operator[](Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i) const
operator ()	../include/Eigen/src/Core/Transpositions.h	/^    inline Index& operator()(Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i)
operator []	../include/Eigen/src/Core/Transpositions.h	/^    inline Index& operator[](Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(Index i)
operator =	../include/Eigen/src/Core/Transpositions.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map	access:public	signature:(const Map& other)
operator =	../include/Eigen/src/Core/Transpositions.h	/^    Map& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Map	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
operator *	../include/Eigen/src/Core/Transpositions.h	/^    operator*(const MatrixBase<Derived>& matrix) const$/;"	f	class:Eigen::Transpose	access:public	signature:(const MatrixBase<Derived>& matrix) const
operator *	../include/Eigen/src/Core/Transpositions.h	/^    operator*(const MatrixBase<Derived>& matrix, const Transpose& trt)$/;"	f	class:Eigen::Transpose	access:friend	signature:(const MatrixBase<Derived>& matrix, const Transpose& trt)
operator *	../include/Eigen/src/Core/Transpositions.h	/^operator*(const MatrixBase<Derived>& matrix,$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& matrix, const TranspositionsBase<TranspositionsDerived> &transpositions)
operator *	../include/Eigen/src/Core/Transpositions.h	/^operator*(const TranspositionsBase<TranspositionDerived> &transpositions,$/;"	f	namespace:Eigen	signature:(const TranspositionsBase<TranspositionDerived> &transpositions, const MatrixBase<Derived>& matrix)
operator =	../include/Eigen/src/Core/Transpositions.h	/^    Transpositions& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/Transpositions.h	/^    Transpositions& operator=(const Transpositions& other)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const Transpositions& other)
operator =	../include/Eigen/src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsWrapper& other)$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:(const TranspositionsWrapper& other)
operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
operator -=	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
operator +=	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ProductBase<ProductDerived, Lhs,Rhs>& other)
operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ScaledProduct<ProductDerived>& other)
operator -=	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator-=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ScaledProduct<ProductDerived>& other)
operator +=	../include/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator+=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const ScaledProduct<ProductDerived>& other)
operator ()	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar operator()(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col) const
operator ()	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::TriangularBase	access:public	signature:(Index row, Index col)
operator *	../include/Eigen/src/Core/TriangularMatrix.h	/^    operator*(const EigenBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const EigenBase<OtherDerived>& rhs) const
operator *	../include/Eigen/src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const TriangularView& rhs)$/;"	f	class:Eigen::TriangularView	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const TriangularView& rhs)
operator *	../include/Eigen/src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& rhs) const
operator -=	../include/Eigen/src/Core/TriangularMatrix.h	/^    template<typename Other> TriangularView&  operator-=(const DenseBase<Other>& other) { return *this = m_matrix - other.derived(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const DenseBase<Other>& other)
operator +=	../include/Eigen/src/Core/TriangularMatrix.h	/^    template<typename Other> TriangularView&  operator+=(const DenseBase<Other>& other) { return *this = m_matrix + other.derived(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const DenseBase<Other>& other)
operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^TriangularView<MatrixType, Mode>::operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^TriangularView<MatrixType, Mode>::operator=(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView	signature:(const TriangularBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const MatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const TriangularBase<OtherDerived>& other);$/;"	p	class:Eigen::TriangularView	access:public	signature:(const TriangularBase<OtherDerived>& other)
operator =	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const TriangularView& other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const TriangularView& other)
operator /=	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView&  operator\/=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix \/ other; }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const typename internal::traits<MatrixType>::Scalar& other)
operator *=	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView&  operator*=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix * other; }$/;"	f	class:Eigen::TriangularView	access:public	signature:(const typename internal::traits<MatrixType>::Scalar& other)
operator ()	../include/Eigen/src/Core/util/BlasUtil.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i, Index j) const$/;"	f	class:Eigen::internal::const_blas_data_mapper	access:public	signature:(Index i, Index j) const
operator ()	../include/Eigen/src/Core/util/BlasUtil.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i, Index j)$/;"	f	class:Eigen::internal::blas_data_mapper	access:public	signature:(Index i, Index j)
operator ()	../include/Eigen/src/Core/util/BlasUtil.h	/^  inline const T& operator()(const T& x) { return x; }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
operator ()	../include/Eigen/src/Core/util/BlasUtil.h	/^  inline T operator()(const T& x) { return conj(x); }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
operator ==	../include/Eigen/src/Core/util/Memory.h	/^    bool operator==(const aligned_allocator<T>& ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:(const aligned_allocator<T>& ) const
operator !=	../include/Eigen/src/Core/util/Memory.h	/^    bool operator!=(const aligned_allocator<T>& ) const$/;"	f	class:Eigen::aligned_allocator	access:public	signature:(const aligned_allocator<T>& ) const
operator =	../include/Eigen/src/Core/util/Meta.h	/^  const noncopyable& operator=(const noncopyable&);$/;"	p	class:Eigen::internal::noncopyable	access:private	signature:(const noncopyable&)
operator =	../include/Eigen/src/Core/util/XprHelper.h	/^    no_assignment_operator& operator=(const no_assignment_operator&);$/;"	p	class:Eigen::internal::no_assignment_operator	access:private	signature:(const no_assignment_operator&)
operator =	../include/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
operator -=	../include/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator-=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
operator /=	../include/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator\/=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
operator *=	../include/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator*=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
operator +=	../include/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator+=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other)
operator ()	../include/Eigen/src/Core/VectorwiseOp.h	/^  inline result_type operator()(const DenseBase<Derived>& mat) const$/;"	f	struct:Eigen::internal::member_redux	access:public	signature:(const DenseBase<Derived>& mat) const
operator -	../include/Eigen/src/Core/VectorwiseOp.h	/^    operator-(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
operator /	../include/Eigen/src/Core/VectorwiseOp.h	/^    operator\/(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
operator *	../include/Eigen/src/Core/VectorwiseOp.h	/^    operator*(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
operator +	../include/Eigen/src/Core/VectorwiseOp.h	/^    operator+(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const DenseBase<OtherDerived>& other) const
operator ()	../include/Eigen/src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::max_coeff_visitor	access:public	signature:(const Scalar& value, Index i, Index j)
operator ()	../include/Eigen/src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::min_coeff_visitor	access:public	signature:(const Scalar& value, Index i, Index j)
operator -=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    ExpressionType& operator-=(const Scalar& scalar);$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar)
operator +=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    ExpressionType& operator+=(const Scalar& scalar);$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar)
operator /=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    inline ExpressionType& operator\/=(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other)
operator *=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    inline ExpressionType& operator*=(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other)
operator <=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator<=(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator <	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator<(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator ==	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator==(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator >=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator>=(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator >	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator>(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator !=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator!=(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator /	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator\/(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other) const
operator *	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator*(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const MatrixBase<OtherDerived> &other) const
operator +	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator+(const Scalar& scalar, const Cwise& mat)$/;"	f	class:Eigen::Cwise	access:friend	signature:(const Scalar& scalar, const Cwise& mat)
operator -	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator-(const Scalar& scalar) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar) const
operator +	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator+(const Scalar& scalar) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& scalar) const
operator <=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator<=(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
operator <	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator<(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
operator ==	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator==(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
operator >=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator>=(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
operator >	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator>(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
operator !=	../include/Eigen/src/Eigen2Support/Cwise.h	/^    operator!=(Scalar s) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(Scalar s) const
operator <=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator <	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator ==	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator==(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator >=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator >	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator !=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator!=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator /	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator\/(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator *	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other) const
operator -	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator-(const Scalar& scalar) const$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar) const
operator +	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator+(const Scalar& scalar) const$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar) const
operator <=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<=(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
operator <	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
operator ==	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator==(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
operator >=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>=(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
operator >	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
operator !=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator!=(Scalar s) const$/;"	f	class:Eigen::Cwise	signature:(Scalar s) const
operator /=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator\/=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other)
operator *=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator*=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Cwise	signature:(const MatrixBase<OtherDerived> &other)
operator -=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator-=(const Scalar& scalar)$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar)
operator +=	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator+=(const Scalar& scalar)$/;"	f	class:Eigen::Cwise	signature:(const Scalar& scalar)
operator =	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
operator =	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const QuaternionType& q);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& q)
operator =	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis	signature:(const MatrixBase<Derived>& mat)
operator =	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionType& q)$/;"	f	class:Eigen::AngleAxis	signature:(const QuaternionType& q)
operator *	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  friend inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis	access:friend	signature:(const QuaternionType& a, const AngleAxis& b)
operator *	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline friend Matrix3 operator* (const Matrix3& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis	access:friend	signature:(const Matrix3& a, const AngleAxis& b)
operator *	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline Matrix3 operator* (const Matrix3& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const Matrix3& other) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& other) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline Vector3 operator* (const Vector3& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const Vector3& other) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion operator* (const Quaternion& q) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& q) const
operator *=	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion& operator*= (const Quaternion& q);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& q)
operator =	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::Quaternion	signature:(const AngleAxisType& aa)
operator =	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const MatrixBase<Derived>& xpr)$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived>& xpr)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::operator* (const Quaternion& other) const$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other) const
operator =	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const Quaternion& other)$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other)
operator *=	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator*= (const Quaternion& other)$/;"	f	class:Eigen::Quaternion	signature:(const Quaternion& other)
operator =	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& operator=(const AngleAxisType& aa);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const AngleAxisType& aa)
operator =	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& operator=(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& m)
operator =	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& operator=(const Quaternion& other);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar>::operator* (const MatrixBase<Derived>& v) const$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived>& v) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Vector3 operator* (const MatrixBase<Derived>& vec) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& vec) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other) const
operator *=	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Vector2& vec) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const Scaling<Scalar,Dim>& s) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Scaling<Scalar,Dim>& s) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim> operator*(const Transform<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Transform<Scalar,Dim>& t) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Translation<Scalar,Dim>& t) const
operator =	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  friend inline LinearMatrixType operator* (const LinearMatrixType& other, const Scaling& s)$/;"	f	class:Eigen::Scaling	access:friend	signature:(const LinearMatrixType& other, const Scaling& s)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline LinearMatrixType operator* (const LinearMatrixType& other) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const LinearMatrixType& other) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline LinearMatrixType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const RotationBase<Derived,Dim>& r) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling operator* (const Scaling& other) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling& other) const
operator =	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling& operator=(const Scaling& other)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling& other)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline TransformType operator* (const TransformType& t) const;$/;"	p	class:Eigen::Scaling	access:public	signature:(const TransformType& t) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline TransformType operator* (const TranslationType& t) const;$/;"	p	class:Eigen::Scaling	access:public	signature:(const TranslationType& t) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Scaling	access:public	signature:(const VectorType& other) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^Scaling<Scalar,Dim>::operator* (const TransformType& t) const$/;"	f	class:Eigen::Scaling	signature:(const TransformType& t) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^Scaling<Scalar,Dim>::operator* (const TranslationType& t) const$/;"	f	class:Eigen::Scaling	signature:(const TranslationType& t) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  friend inline Transform operator*(const LinearMatrixType& mat, const Transform& t)$/;"	f	class:Eigen::Transform	access:friend	signature:(const LinearMatrixType& mat, const Transform& t)
operator ()	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Scalar operator() (int row, int col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(int row, int col) const
operator ()	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Scalar& operator() (int row, int col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(int row, int col)
operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived>& other)
operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform operator*(const RotationBase<Derived,Dim>& r) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r) const
operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const RotationBase<Derived,Dim>& r);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
operator *=	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform operator*(const ScalingType& s) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const ScalingType& s) const
operator *=	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const ScalingType& s) { return scale(s.coeffs()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const ScalingType& s)
operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const ScalingType& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const ScalingType& t)
operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform operator*(const TranslationType& t) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t) const
operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const TranslationType& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
operator *=	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r) const
operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const ScalingType& s) const$/;"	f	class:Eigen::Transform	signature:(const ScalingType& s) const
operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const ScalingType& s)$/;"	f	class:Eigen::Transform	signature:(const ScalingType& s)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t) const
operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  operator * (const MatrixBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform	access:friend	signature:(const MatrixBase<OtherDerived> &a, const Transform &b)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  operator * (const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  operator * (const Transform& other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other) const
operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
operator =	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  friend inline TransformType operator* (const LinearMatrixType& linear, const Translation& t)$/;"	f	class:Eigen::Translation	access:friend	signature:(const LinearMatrixType& linear, const Translation& t)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator* (const LinearMatrixType& linear) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const LinearMatrixType& linear) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation	access:public	signature:(const RotationBase<Derived,Dim>& r) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator* (const ScalingType& other) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const ScalingType& other) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator* (const TransformType& t) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const TransformType& t) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& other) const
operator =	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other)
operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const LinearMatrixType& linear) const$/;"	f	class:Eigen::Translation	signature:(const LinearMatrixType& linear) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const ScalingType& other) const$/;"	f	class:Eigen::Translation	signature:(const ScalingType& other) const
operator *	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const TransformType& t) const$/;"	f	class:Eigen::Translation	signature:(const TransformType& t) const
operator -=	../include/Eigen/src/Eigen2Support/Lazy.h	/^Derived& MatrixBase<Derived>::operator-=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	f	class:Eigen::MatrixBase	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
operator +=	../include/Eigen/src/Eigen2Support/Lazy.h	/^Derived& MatrixBase<Derived>::operator+=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	f	class:Eigen::MatrixBase	signature:(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0, EvalBeforeAssigningBit>& other)
operator =	../include/Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const MatrixBase<Derived>& m);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const MatrixBase<Derived>& m)
operator =	../include/Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis& operator=(const QuaternionBase<QuatDerived>& q);$/;"	p	class:Eigen::AngleAxis	access:public	signature:(const QuaternionBase<QuatDerived>& q)
operator =	../include/Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis	signature:(const MatrixBase<Derived>& mat)
operator =	../include/Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionBase<QuatDerived>& q)$/;"	f	class:Eigen::AngleAxis	signature:(const QuaternionBase<QuatDerived>& q)
operator *	../include/Eigen/src/Geometry/AngleAxis.h	/^  friend inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis	access:friend	signature:(const QuaternionType& a, const AngleAxis& b)
operator *	../include/Eigen/src/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const AngleAxis& other) const
operator *	../include/Eigen/src/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis	access:public	signature:(const QuaternionType& other) const
operator *	../include/Eigen/src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Lhs>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous	access:friend	signature:(const MatrixBase<Lhs>& lhs, const Homogeneous& rhs)
operator *	../include/Eigen/src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Rhs>& rhs) const$/;"	f	class:Eigen::Homogeneous	access:public	signature:(const MatrixBase<Rhs>& rhs) const
operator *	../include/Eigen/src/Geometry/Homogeneous.h	/^    operator* (const Transform<Scalar,Dim,Mode,Options>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous	access:friend	signature:(const Transform<Scalar,Dim,Mode,Options>& lhs, const Homogeneous& rhs)
operator =	../include/Eigen/src/Geometry/Quaternion.h	/^  Derived& operator=(const AngleAxisType& aa);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const AngleAxisType& aa)
operator =	../include/Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::QuaternionBase	signature:(const AngleAxisType& aa)
operator =	../include/Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other)
operator *=	../include/Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator*= (const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other)
operator =	../include/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_STRONG_INLINE QuaternionBase<Derived>& operator=(const QuaternionBase<Derived>& other);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<Derived>& other)
operator =	../include/Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE QuaternionBase<Derived>& QuaternionBase<Derived>::operator=(const QuaternionBase<Derived>& other)$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<Derived>& other)
operator =	../include/Eigen/src/Geometry/Quaternion.h	/^inline Derived& QuaternionBase<Derived>::operator=(const MatrixBase<MatrixDerived>& xpr)$/;"	f	class:Eigen::QuaternionBase	signature:(const MatrixBase<MatrixDerived>& xpr)
operator *	../include/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::operator* (const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase	signature:(const QuaternionBase<OtherDerived>& other) const
operator =	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> Derived& operator=(const MatrixBase<OtherDerived>& m);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const MatrixBase<OtherDerived>& m)
operator =	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_STRONG_INLINE Derived& operator=(const QuaternionBase<OtherDerived>& other);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& other)
operator *=	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_STRONG_INLINE Derived& operator*= (const QuaternionBase<OtherDerived>& q);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& q)
operator *	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_STRONG_INLINE Quaternion<Scalar> operator* (const QuaternionBase<OtherDerived>& q) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const QuaternionBase<OtherDerived>& q) const
operator *	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other) const
operator *=	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D& other)
operator *	../include/Eigen/src/Geometry/Rotation2D.h	/^  Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Vector2& vec) const
operator *	../include/Eigen/src/Geometry/RotationBase.h	/^    friend inline Transform<Scalar,Dim,Affine> operator*(const DiagonalMatrix<Scalar,Dim>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase	access:friend	signature:(const DiagonalMatrix<Scalar,Dim>& l, const Derived& r)
operator *	../include/Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const EigenBase<OtherDerived>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase	access:friend	signature:(const EigenBase<OtherDerived>& l, const Derived& r)
operator *	../include/Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const UniformScaling<Scalar>& s) const
operator *	../include/Eigen/src/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim,Isometry> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Translation<Scalar,Dim>& t) const
operator *	../include/Eigen/src/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim,Mode> operator*(const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const Transform<Scalar,Dim,Mode,Options>& t) const
operator *	../include/Eigen/src/Geometry/RotationBase.h	/^    operator*(const EigenBase<OtherDerived>& e) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const EigenBase<OtherDerived>& e) const
operator =	../include/Eigen/src/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix	signature:(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
operator *	../include/Eigen/src/Geometry/Scaling.h	/^  inline Matrix<Scalar,Dim,Dim> operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const RotationBase<Derived,Dim>& r) const
operator *	../include/Eigen/src/Geometry/Scaling.h	/^  inline Transform<Scalar,Dim,Affine> operator* (const Translation<Scalar,Dim>& t) const;$/;"	p	class:Eigen::UniformScaling	access:public	signature:(const Translation<Scalar,Dim>& t) const
operator *	../include/Eigen/src/Geometry/Scaling.h	/^  inline Transform<Scalar,Dim,Mode> operator* (const Transform<Scalar,Dim, Mode, Options>& t) const;$/;"	p	class:Eigen::UniformScaling	access:public	signature:(const Transform<Scalar,Dim, Mode, Options>& t) const
operator *	../include/Eigen/src/Geometry/Scaling.h	/^  inline typename internal::plain_matrix_type<Derived>::type operator* (const MatrixBase<Derived>& other) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const MatrixBase<Derived>& other) const
operator *	../include/Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling operator* (const UniformScaling& other) const$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const UniformScaling& other) const
operator *	../include/Eigen/src/Geometry/Scaling.h	/^MatrixBase<Derived>::operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::MatrixBase	signature:(const UniformScaling<Scalar>& s) const
operator *	../include/Eigen/src/Geometry/Scaling.h	/^UniformScaling<Scalar>::operator* (const Transform<Scalar,Dim, Mode, Options>& t) const$/;"	f	class:Eigen::UniformScaling	signature:(const Transform<Scalar,Dim, Mode, Options>& t) const
operator *	../include/Eigen/src/Geometry/Scaling.h	/^UniformScaling<Scalar>::operator* (const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::UniformScaling	signature:(const Translation<Scalar,Dim>& t) const
operator *	../include/Eigen/src/Geometry/Transform.h	/^  inline const Transform operator * (const Transform& other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other) const
operator ()	../include/Eigen/src/Geometry/Transform.h	/^  inline Scalar operator() (Index row, Index col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(Index row, Index col) const
operator ()	../include/Eigen/src/Geometry/Transform.h	/^  inline Scalar& operator() (Index row, Index col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform	access:public	signature:(Index row, Index col)
operator *=	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const DiagonalMatrix<Scalar,Dim>& s) { linear() *= s; return *this; }$/;"	f	class:Eigen::Transform	access:public	signature:(const DiagonalMatrix<Scalar,Dim>& s)
operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived>& other)
operator *=	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const EigenBase<OtherDerived>& other) { return *this = *this * other; }$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived>& other)
operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
operator *	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform operator*(const RotationBase<Derived,Dim>& r) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r) const
operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const RotationBase<Derived,Dim>& r);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
operator *=	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived,Dim>& r)
operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
operator *	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform operator*(const TranslationType& t) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t) const
operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const TranslationType& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
operator *=	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
operator *	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform operator*(const UniformScaling<Scalar>& s) const;$/;"	p	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& s) const
operator *=	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const UniformScaling<Scalar>& s) { return scale(s.factor()); }$/;"	f	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& s)
operator =	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const UniformScaling<Scalar>& t);$/;"	p	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& t)
operator *	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r) const
operator =	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform	signature:(const RotationBase<Derived,Dim>& r)
operator *	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t) const
operator =	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform	signature:(const TranslationType& t)
operator *	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::Transform	signature:(const UniformScaling<Scalar>& s) const
operator =	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform	signature:(const UniformScaling<Scalar>& s)
operator *	../include/Eigen/src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform	access:friend	signature:(const DiagonalBase<DiagonalDerived> &a, const Transform &b)
operator *	../include/Eigen/src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &b) const$/;"	f	class:Eigen::Transform	access:public	signature:(const DiagonalBase<DiagonalDerived> &b) const
operator *	../include/Eigen/src/Geometry/Transform.h	/^    operator * (const EigenBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform	access:friend	signature:(const EigenBase<OtherDerived> &a, const Transform &b)
operator *	../include/Eigen/src/Geometry/Transform.h	/^  operator * (const EigenBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived> &other) const
operator *	../include/Eigen/src/Geometry/Transform.h	/^    operator * (const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const
operator =	../include/Eigen/src/Geometry/Transform.h	/^  Transform& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const ReturnByValue<OtherDerived>& other)
operator =	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
operator =	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline AffineTransformType operator* (const EigenBase<OtherDerived>& linear) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const EigenBase<OtherDerived>& linear) const
operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline AffineTransformType operator*(const EigenBase<OtherDerived>& linear, const Translation& t)$/;"	f	class:Eigen::Translation	access:friend	signature:(const EigenBase<OtherDerived>& linear, const Translation& t)
operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline AffineTransformType operator* (const UniformScaling<Scalar>& other) const;$/;"	p	class:Eigen::Translation	access:public	signature:(const UniformScaling<Scalar>& other) const
operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline IsometryTransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation	access:public	signature:(const RotationBase<Derived,Dim>& r) const
operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline Transform<Scalar,Dim,Mode> operator* (const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Transform<Scalar,Dim,Mode,Options>& t) const
operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other) const
operator *	../include/Eigen/src/Geometry/Translation.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& other) const
operator =	../include/Eigen/src/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation& other)
operator *	../include/Eigen/src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const EigenBase<OtherDerived>& linear) const$/;"	f	class:Eigen::Translation	signature:(const EigenBase<OtherDerived>& linear) const
operator *	../include/Eigen/src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const UniformScaling<Scalar>& other) const$/;"	f	class:Eigen::Translation	signature:(const UniformScaling<Scalar>& other) const
operator *	../include/Eigen/src/Householder/HouseholderSequence.h	/^    typename internal::matrix_type_times_scalar_type<Scalar, OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(const MatrixBase<OtherDerived>& other) const
operator *	../include/Eigen/src/Householder/HouseholderSequence.h	/^typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)$/;"	f	namespace:Eigen	signature:(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)
operator ()	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::IncompleteLUT::keep_diag	access:public	signature:(const Index& row, const Index& col, const Scalar&) const
operator *	../include/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation operator*(const JacobiRotation& other)$/;"	f	class:Eigen::JacobiRotation	access:public	signature:(const JacobiRotation& other)
operator ||	../include/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator||(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
operator /	../include/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator\/(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
operator *	../include/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator*(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
operator &&	../include/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator&&(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f	signature:(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
operator -	../include/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator-(const Scalar& scalar,const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& other)$/;"	f	signature:(const Scalar& scalar,const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& other)
operator +	../include/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator+(const Scalar& scalar,const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& other)$/;"	f	signature:(const Scalar& scalar,const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& other)
operator -	../include/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator-(const Scalar& scalar) const$/;"	f	signature:(const Scalar& scalar) const
operator +	../include/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator+(const Scalar& scalar) const$/;"	f	signature:(const Scalar& scalar) const
operator *	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^const ScalarMultipleReturnType operator*(const RealScalar& scalar) const;$/;"	p	signature:(const RealScalar& scalar) const
operator -	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator-() const { return derived(); }$/;"	f	signature:() const
operator /	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator\/(const Scalar& scalar) const$/;"	f	signature:(const Scalar& scalar) const
operator *	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator*(const Scalar& scalar) const$/;"	f	signature:(const Scalar& scalar) const
operator *	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator*(const Scalar& scalar, const StorageBaseType& matrix)$/;"	f	signature:(const Scalar& scalar, const StorageBaseType& matrix)
operator *	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator*(const std::complex<Scalar>& scalar) const$/;"	f	signature:(const std::complex<Scalar>& scalar) const
operator *	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator*(const std::complex<Scalar>& scalar, const StorageBaseType& matrix)$/;"	f	signature:(const std::complex<Scalar>& scalar, const StorageBaseType& matrix)
operator ()	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::SimplicialCholeskyBase::keep_diag	access:public	signature:(const Index& row, const Index& col, const Scalar&) const
operator ++	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Iterator& operator++()$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:()
operator =	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage& operator=(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(const CompressedStorage& other)
operator ++	../include/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++() { m_inner++; return *this; }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:()
operator ++	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:()
operator --	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline ReverseInnerIterator& operator--() { m_id--; return *this; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:()
operator =	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseInnerVectorSet& operator=(const SparseInnerVectorSet& other)$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:(const SparseInnerVectorSet& other)
operator =	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseInnerVectorSet& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator ++	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Derived& operator++()$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:()
operator -=	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator-=(const SparseMatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived> &other)
operator +=	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator+=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived>& other)
operator ++	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:public	signature:()
operator ++	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:()
operator --	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:public	signature:()
operator --	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:()
operator /=	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const Scalar& other)
operator *=	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const Scalar& other)
operator =	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    DenseTimeSparseProduct& operator=(const DenseTimeSparseProduct&);$/;"	p	class:Eigen::DenseTimeSparseProduct	access:private	signature:(const DenseTimeSparseProduct&)
operator *	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^SparseMatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived> &other) const
operator =	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    SparseTimeDenseProduct& operator=(const SparseTimeDenseProduct&);$/;"	p	class:Eigen::SparseTimeDenseProduct	access:private	signature:(const SparseTimeDenseProduct&)
operator *	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^SparseMatrixBase<Derived>::operator*(const DiagonalBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const DiagonalBase<OtherDerived> &other) const
operator =	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const EigenBase<OtherDerived> &other)
operator =	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const ReturnByValue<OtherDerived>& other)
operator /=	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator\/=(const Scalar& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const Scalar& other)
operator *=	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator*=(const Scalar& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const Scalar& other)
operator -=	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator-=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator *=	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator*=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator +=	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator+=(const SparseMatrixBase<OtherDerived>& other);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator <<	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrixBase& m)$/;"	f	class:Eigen::SparseMatrixBase	access:friend	signature:(std::ostream & s, const SparseMatrixBase& m)
operator =	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const Derived& other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const Derived& other)
operator =	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator =	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const SparseSparseProduct<Lhs,Rhs>& product);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
operator *	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)$/;"	f	class:Eigen::SparseMatrixBase	access:friend	signature:(const DiagonalBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)
operator *	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const DiagonalBase<OtherDerived> &other) const
operator *	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const Derived& rhs)$/;"	f	class:Eigen::SparseMatrixBase	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const Derived& rhs)
operator *	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived> &other) const
operator *	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const SparseMatrixBase<OtherDerived> &other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const SparseMatrixBase<OtherDerived> &other) const
operator =	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE SparseMatrix& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator <<	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrix& m)$/;"	f	class:Eigen::SparseMatrix	access:friend	signature:(std::ostream & s, const SparseMatrix& m)
operator []	../include/Eigen/src/SparseCore/SparseMatrix.h	/^        Index operator[](Index i) const { return i==m_index ? m_value : 0; }$/;"	f	class:Eigen::SparseMatrix::SingletonVector	access:public	signature:(Index i) const
operator ()	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline bool operator() (const Index&, const Index&, const Scalar& value) const$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func	access:public	signature:(const Index&, const Index&, const Scalar& value) const
operator ++	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:()
operator --	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline ReverseInnerIterator& operator--() { --m_id; return *this; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:()
operator =	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const EigenBase<OtherDerived>& other)
operator =	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const ReturnByValue<OtherDerived>& other)
operator =	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrix& other)
operator =	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
operator *	../include/Eigen/src/SparseCore/SparsePermutation.h	/^operator*( const PermutationBase<PermDerived>& perm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen	signature:( const PermutationBase<PermDerived>& perm, const SparseMatrixBase<SparseDerived>& matrix)
operator *	../include/Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)$/;"	f	namespace:Eigen	signature:(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)
operator *	../include/Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const Transpose<PermutationBase<PermDerived> >& tperm)$/;"	f	namespace:Eigen	signature:(const SparseMatrixBase<SparseDerived>& matrix, const Transpose<PermutationBase<PermDerived> >& tperm)
operator *	../include/Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const Transpose<PermutationBase<PermDerived> >& tperm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen	signature:(const Transpose<PermutationBase<PermDerived> >& tperm, const SparseMatrixBase<SparseDerived>& matrix)
operator =	../include/Eigen/src/SparseCore/SparseProduct.h	/^inline Derived& SparseMatrixBase<Derived>::operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
operator *	../include/Eigen/src/SparseCore/SparseProduct.h	/^SparseMatrixBase<Derived>::operator*(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const SparseMatrixBase<OtherDerived> &other) const
operator =	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    DenseTimeSparseSelfAdjointProduct& operator=(const DenseTimeSparseSelfAdjointProduct&);$/;"	p	class:Eigen::DenseTimeSparseSelfAdjointProduct	access:private	signature:(const DenseTimeSparseSelfAdjointProduct&)
operator *	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView	access:friend	signature:(const MatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)
operator *	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const MatrixBase<OtherDerived>& rhs) const
operator =	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointTimeDenseProduct& operator=(const SparseSelfAdjointTimeDenseProduct&);$/;"	p	class:Eigen::SparseSelfAdjointTimeDenseProduct	access:private	signature:(const SparseSelfAdjointTimeDenseProduct&)
operator =	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView& src)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseSelfAdjointView& src)
operator =	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView<SrcMatrixType,SrcUpLo>& src)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseSelfAdjointView<SrcMatrixType,SrcUpLo>& src)
operator =	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSymmetricPermutationProduct<SrcMatrixType,SrcUpLo>& permutedMatrix)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseSymmetricPermutationProduct<SrcMatrixType,SrcUpLo>& permutedMatrix)
operator ++	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:()
operator --	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator--()$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:()
operator <<	../include/Eigen/src/SparseCore/SparseVector.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseVector& m)$/;"	f	class:Eigen::SparseVector	access:friend	signature:(std::ostream & s, const SparseVector& m)
operator ++	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:()
operator --	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline ReverseInnerIterator& operator--() { m_id--; return *this; }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:()
operator =	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
operator =	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseSparseProduct<Lhs,Rhs>& product)
operator =	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseVector& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseVector& other)
operator ++	../include/Eigen/src/SparseCore/SparseView.h	/^  EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::SparseView::InnerIterator	access:public	signature:()
operator =	../include/Eigen/src/StlSupport/details.h	/^    inline T& operator=(const OtherT& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:(const OtherT& other)
operator =	../include/Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support& operator=(const workaround_msvc_stl_support& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:(const workaround_msvc_stl_support& other)
operator =	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix& operator=(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(const SluMatrix& other)
operatorInverseSqrt	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorInverseSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
operatorNorm	../include/Eigen/src/Core/MatrixBase.h	/^    RealScalar operatorNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
operatorNorm	../include/Eigen/src/Core/SelfAdjointView.h	/^    RealScalar operatorNorm() const;$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:() const
operatorNorm	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::operatorNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
operatorNorm	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::operatorNorm() const$/;"	f	class:Eigen::SelfAdjointView	signature:() const
operatorSqrt	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:() const
operator T&	../include/Eigen/src/StlSupport/details.h	/^    inline operator T& () { return *static_cast<T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:()
Options	../include/Eigen/src/Cholesky/LDLT.h	/^      Options = MatrixType::Options & ~RowMajorBit, \/\/ these are the options for the TmpMatrixType, we need a ColMajor matrix here!$/;"	e	enum:Eigen::LDLT::__anon405
Options	../include/Eigen/src/Cholesky/LLT.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::LLT::__anon403
Options	../include/Eigen/src/Core/Array.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Array::__anon278
Options	../include/Eigen/src/Core/BandMatrix.h	/^      Options = internal::traits<Derived>::Options$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Options	../include/Eigen/src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon81
Options	../include/Eigen/src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon82
Options	../include/Eigen/src/Core/Map.h	/^  enum { Options }; \/\/ Expressions don't have Options$/;"	e	enum:Eigen::internal::traits::__anon286
Options	../include/Eigen/src/Core/Matrix.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Matrix::__anon290
Options	../include/Eigen/src/Core/Matrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon289
Options	../include/Eigen/src/Core/PlainObjectBase.h	/^    enum { Options = internal::traits<Derived>::Options };$/;"	e	enum:Eigen::PlainObjectBase::__anon61
Options	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon43
Options	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexSchur::__anon41
Options	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::EigenSolver::__anon44
Options	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon45
Options	../include/Eigen/src/Eigenvalues/RealSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::RealSchur::__anon39
Options	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon40
Options	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::Tridiagonalization::__anon42
Options	../include/Eigen/src/Geometry/Hyperplane.h	/^    Options = _Options$/;"	e	enum:Eigen::Hyperplane::__anon393
Options	../include/Eigen/src/Geometry/ParametrizedLine.h	/^    Options = _Options$/;"	e	enum:Eigen::ParametrizedLine::__anon372
Options	../include/Eigen/src/Geometry/Transform.h	/^    Options = _Options,$/;"	e	enum:Eigen::Transform::__anon374
Options	../include/Eigen/src/LU/FullPivLU.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::FullPivLU::__anon395
Options	../include/Eigen/src/LU/PartialPivLU.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::PartialPivLU::__anon394
Options	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon4
Options	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon6
Options	../include/Eigen/src/QR/HouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HouseholderQR::__anon5
Options	../include/Eigen/src/SparseCore/SparseMatrix.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseMatrix::__anon33
Options	../include/Eigen/src/SparseCore/SparseVector.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseVector::__anon27
options	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline superlu_options_t& options() { return m_sluOptions; }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
Options	../include/Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon416
Options	../include/Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon417
Options	../include/Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
ordering	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void ordering(const MatrixType& a, CholMatrixType& ap);$/;"	p	class:Eigen::SimplicialCholeskyBase	access:protected	signature:(const MatrixType& a, CholMatrixType& ap)
ordering	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::ordering(const MatrixType& a, CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase	signature:(const MatrixType& a, CholMatrixType& ap)
originalMatrix	../include/Eigen/src/misc/Image.h	/^  inline const MatrixType& originalMatrix() const { return m_originalMatrix; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
origin	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
origin	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
origin	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:() const
origin	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
OtherCols	../include/Eigen/src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon377
OtherCols	../include/Eigen/src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon378
other	../include/Eigen/src/Core/util/Memory.h	/^        typedef aligned_allocator<U> other;$/;"	t	struct:Eigen::aligned_allocator::rebind	access:public
other	../include/Eigen/src/StlSupport/details.h	/^      typedef aligned_allocator_indirection<U> other;$/;"	t	struct:Eigen::aligned_allocator_indirection::rebind	access:public
OtherPlainObject	../include/Eigen/src/Core/TriangularMatrix.h	/^      typedef typename OtherDerived::PlainObject::DenseType OtherPlainObject;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
OtherRows	../include/Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon377
OtherRows	../include/Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon378
outer	../include/Eigen/src/Core/Assign.h	/^    outer = Index \/ Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::__anon224
outer	../include/Eigen/src/Core/Assign.h	/^    outer = Index \/ Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon225
outer	../include/Eigen/src/Core/Redux.h	/^    outer = index \/ int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon275
outer	../include/Eigen/src/Core/Redux.h	/^    outer = Start \/ Derived::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon273
outer	../include/Eigen/src/Core/Stride.h	/^    inline Index outer() const { return m_outer.value(); }$/;"	f	class:Eigen::Stride	access:public	signature:() const
outer	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
outer	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
outer	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
outerIndexPtr	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline const Index* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
outerIndexPtr	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
outerIndexPtr	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Index* outerIndexPtr() const$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
outerIndexPtr	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline Index* outerIndexPtr()$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:()
outerIndexPtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Index* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
outerIndexPtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
outerInd	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int *outerInd;$/;"	m	struct:Eigen::SluMatrix::__anon1	access:public
OuterProduct	../include/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon215
outer_product_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<> struct outer_product_selector<ColMajor> {$/;"	s	namespace:Eigen::internal
outer_product_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<> struct outer_product_selector<RowMajor> {$/;"	s	namespace:Eigen::internal
OuterRandomAccessPattern	../include/Eigen/src/SparseCore/SparseUtil.h	/^const int OuterRandomAccessPattern  = 0x4 | CoherentAccessPattern;$/;"	m	namespace:Eigen
outerSize	../include/Eigen/src/Core/DenseBase.h	/^    Index outerSize() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
outerSize	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
outerSize	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Index outerSize() const { return (int(Flags)&RowMajorBit) ? this->rows() : this->cols(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
outerSize	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
outerSize	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index outerSize() const { return 1; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
outerSize	../include/Eigen/src/SparseCore/SparseView.h	/^  inline Index outerSize() const { return m_matrix.outerSize(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
OuterStrideAtCompileTime	../include/Eigen/src/Core/Block.h	/^    OuterStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon228
OuterStrideAtCompileTime	../include/Eigen/src/Core/CwiseUnaryView.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret$/;"	e	enum:Eigen::internal::traits::__anon232
OuterStrideAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret$/;"	e	enum:Eigen::DenseBase::__anon216
outer_stride_at_compile_time	../include/Eigen/src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
outer_stride_at_compile_time	../include/Eigen/src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time$/;"	s	namespace:Eigen::internal
OuterStrideAtCompileTime	../include/Eigen/src/Core/Map.h	/^    OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon285
OuterStrideAtCompileTime	../include/Eigen/src/Core/Matrix.h	/^    OuterStrideAtCompileTime = (Options&RowMajor) ? ColsAtCompileTime : RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon289
OuterStrideAtCompileTime	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    OuterStrideAtCompileTime = Lhs::OuterStrideAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon50
OuterStrideAtCompileTime	../include/Eigen/src/Core/Stride.h	/^      OuterStrideAtCompileTime = _OuterStrideAtCompileTime$/;"	e	enum:Eigen::Stride::__anon57
OuterStrideAtCompileTime	../include/Eigen/src/Core/Transpose.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret$/;"	e	enum:Eigen::internal::traits::__anon73
outerStride	../include/Eigen/src/Core/Array.h	/^    inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Array	access:public	signature:() const
outerStride	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
outerStride	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
outerStride	../include/Eigen/src/Core/Block.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Block	access:public	signature:() const
outerStride	../include/Eigen/src/Core/Block.h	/^    inline Index outerStride() const;$/;"	p	class:Eigen::Block	access:public	signature:() const
outerStride	../include/Eigen/src/Core/CwiseUnaryView.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl	access:public	signature:() const
outerStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
outerStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void outerStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
outerStride	../include/Eigen/src/Core/Flagged.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
outerStride	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
outerStride	../include/Eigen/src/Core/Map.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Map	access:public	signature:() const
outerStride	../include/Eigen/src/Core/Matrix.h	/^    inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Matrix	access:public	signature:() const
outerStride	../include/Eigen/src/Core/NestByValue.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
outerStride	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
outerStride	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
OuterStride	../include/Eigen/src/Core/Stride.h	/^class OuterStride : public Stride<Value, 0>$/;"	c	namespace:Eigen	inherits:Stride
OuterStride	../include/Eigen/src/Core/Stride.h	/^    OuterStride() : Base() {}$/;"	f	class:Eigen::OuterStride	access:public	signature:()
OuterStride	../include/Eigen/src/Core/Stride.h	/^    OuterStride(Index v) : Base(v,0) {}$/;"	f	class:Eigen::OuterStride	access:public	signature:(Index v)
outerStride	../include/Eigen/src/Core/Swap.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
outerStride	../include/Eigen/src/Core/Transpose.h	/^    inline Index outerStride() const { return derived().nestedExpression().outerStride(); }$/;"	f	class:Eigen::TransposeImpl	access:public	signature:() const
outerStride	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return derived().outerStride(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
outerStride	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
p16uc_COMPLEX_IM	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_IM   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 1), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);\/\/{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX_RE	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_RE   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);\/\/{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX_REV2	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_REV2 = vec_sld(p16uc_FORWARD, p16uc_FORWARD, 8);\/\/{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX_REV	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_REV  = vec_sld(p16uc_REVERSE, p16uc_REVERSE, 8);\/\/{ 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_DUPLICATE	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_DUPLICATE = {0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7};$/;"	m	namespace:Eigen::internal
p16uc_FORWARD	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_FORWARD = vec_lvsl(0, (float*)0);$/;"	m	namespace:Eigen::internal
p16uc_PSET_HI	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_PSET_HI = (Packet16uc) vec_mergeh((Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 1));\/\/{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_PSET_LO	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_PSET_LO = (Packet16uc) vec_mergeh((Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 2), (Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 3));\/\/{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_REVERSE	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_REVERSE = {12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3};$/;"	m	namespace:Eigen::internal
p2ui_CONJ_XOR	../include/Eigen/src/Core/arch/NEON/Complex.h	/^static uint32x2_t p2ui_CONJ_XOR = EIGEN_INIT_NEON_PACKET2(0x00000000, 0x80000000);$/;"	m	namespace:Eigen::internal
p4f_COUNTDOWN	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_COUNTDOWN = { 3.0, 2.0, 1.0, 0.0 };$/;"	m	namespace:Eigen::internal
p4f_ONE	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ONE = vec_ctf(p4i_ONE, 0);$/;"	m	namespace:Eigen::internal
p4f_ZERO_	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ZERO_ = (Packet4f) vec_sl((Packet4ui)p4i_MINUS1, (Packet4ui)p4i_MINUS1);$/;"	m	namespace:Eigen::internal
p4i_COUNTDOWN	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4i p4i_COUNTDOWN = { 3, 2, 1, 0 };$/;"	m	namespace:Eigen::internal
p4ui_CONJ_XOR	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet4ui  p4ui_CONJ_XOR = vec_mergeh((Packet4ui)p4i_ZERO, (Packet4ui)p4f_ZERO_);\/\/{ 0x00000000, 0x80000000, 0x00000000, 0x80000000 };$/;"	m	namespace:Eigen::internal
p4ui_CONJ_XOR	../include/Eigen/src/Core/arch/NEON/Complex.h	/^static uint32x4_t p4ui_CONJ_XOR = EIGEN_INIT_NEON_PACKET4(0x00000000, 0x80000000, 0x00000000, 0x80000000);$/;"	m	namespace:Eigen::internal
pabs	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pabs	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pabs	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vabsq_f32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pabs	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vabsq_s32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pabs	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
pabs	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pabs	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pabs	../include/Eigen/src/Core/GenericPacketMath.h	/^pabs(const Packet& a) { return abs(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
packedMatrix	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const MatrixType& packedMatrix() const$/;"	f	class:Eigen::HessenbergDecomposition	access:public	signature:() const
packedMatrix	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline const MatrixType& packedMatrix() const$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:() const
Packet16uc	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned char  Packet16uc;$/;"	t	namespace:Eigen::internal
Packet1cd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const __m128d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd	access:public	signature:(const __m128d& a)
Packet1cd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd	access:public	signature:()
Packet1cd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Packet2cf	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:(const Packet4f& a)
Packet2cf	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:()
Packet2cf	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:(const Packet4f& a)
Packet2cf	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:()
Packet2cf	../include/Eigen/src/Core/arch/NEON/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const __m128& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:(const __m128& a)
Packet2cf	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf	access:public	signature:()
Packet2cf	../include/Eigen/src/Core/arch/SSE/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2d	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef __m128d Packet2d;$/;"	t	namespace:Eigen::internal
Packet4bi	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector __bool int     Packet4bi;$/;"	t	namespace:Eigen::internal
Packet4f	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector float          Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef float32x4_t Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef __m128  Packet4f;$/;"	t	namespace:Eigen::internal
Packet4i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector int            Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef int32x4_t   Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef __m128i Packet4i;$/;"	t	namespace:Eigen::internal
Packet4ui	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned int   Packet4ui;$/;"	t	namespace:Eigen::internal
Packet4ui	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef uint32x4_t  Packet4ui;$/;"	t	namespace:Eigen::internal
Packet8i	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector short int      Packet8i;$/;"	t	namespace:Eigen::internal
PacketAccessBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int PacketAccessBit = 0x8;$/;"	m	namespace:Eigen
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon309
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon310
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon311
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon312
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon356
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon357
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon358
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon359
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon354
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon355
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon343
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon344
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon345
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon346
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon347
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon348
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon349
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon350
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon351
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon321
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon319
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon318
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon337
PacketAccess	../include/Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon298
PacketAccess	../include/Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon299
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon334
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon313
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon314
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon361
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon360
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon352
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon353
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon308
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon316
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon320
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon327
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon306
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon335
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon315
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon317
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon336
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon340
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon341
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon342
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon338
PacketAccess	../include/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon339
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon302
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon303
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMul$/;"	e	enum:Eigen::internal::functor_traits::__anon295
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasAbs$/;"	e	enum:Eigen::internal::functor_traits::__anon305
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasACos$/;"	e	enum:Eigen::internal::functor_traits::__anon332
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasAdd$/;"	e	enum:Eigen::internal::functor_traits::__anon291
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasASin$/;"	e	enum:Eigen::internal::functor_traits::__anon333
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasConj$/;"	e	enum:Eigen::internal::functor_traits::__anon307
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasCos$/;"	e	enum:Eigen::internal::functor_traits::__anon329
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasDiv$/;"	e	enum:Eigen::internal::functor_traits::__anon301
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasMax$/;"	e	enum:Eigen::internal::functor_traits::__anon297
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasMin$/;"	e	enum:Eigen::internal::functor_traits::__anon296
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasNegate };$/;"	e	enum:Eigen::internal::functor_traits::__anon304
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSin$/;"	e	enum:Eigen::internal::functor_traits::__anon330
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSqrt$/;"	e	enum:Eigen::internal::functor_traits::__anon328
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSub$/;"	e	enum:Eigen::internal::functor_traits::__anon300
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasTan$/;"	e	enum:Eigen::internal::functor_traits::__anon331
PacketAccess	../include/Eigen/src/Core/Functors.h	/^    PacketAccess = scalar_product_op<LhsScalar,RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon293
PacketAccess	../include/Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon365
PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1	../include/Eigen/src/Core/util/StaticAssert.h	/^        PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
packetByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packetByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
packet_impl	../include/Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet_impl(Index row, Index col, Index id, internal::false_type) const$/;"	f	class:Eigen::DiagonalProduct	access:protected	signature:(Index row, Index col, Index id, internal::false_type) const
packet_impl	../include/Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet_impl(Index row, Index col, Index id, internal::true_type) const$/;"	f	class:Eigen::DiagonalProduct	access:protected	signature:(Index row, Index col, Index id, internal::true_type) const
packet	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/Block.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::Block	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/Block.h	/^    inline PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Block	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CwiseBinaryOpImpl	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CwiseUnaryOpImpl	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/Diagonal.h	/^    template<int LoadMode> typename MatrixType::PacketReturnType packet(Index) const;$/;"	p	struct:Eigen::internal::traits	access:public	signature:(Index) const
packet	../include/Eigen/src/Core/Diagonal.h	/^    template<int LoadMode> typename MatrixType::PacketReturnType packet(Index,Index) const;$/;"	p	struct:Eigen::internal::traits	access:public	signature:(Index,Index) const
packet	../include/Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/Flagged.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/Flagged.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col) const
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::linspaced_op	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::linspaced_op_impl	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_acos_op	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_add_op	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_asin_op	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_constant_op	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_cos_op	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_exp_op	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_log_op	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_multiple_op	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_quotient1_impl	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_sin_op	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_sqrt_op	access:public
Packet	../include/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_tan_op	access:public
packet	../include/Eigen/src/Core/MapBase.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/MapBase.h	/^    inline PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:(Index row, Index col) const
Packet	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::PacketScalar Packet;$/;"	t	struct:Eigen::internal::product_coeff_impl	access:public
Packet	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::gemm_pack_rhs	access:public
packet	../include/Eigen/src/Core/Replicate.h	/^    inline PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Replicate	access:public	signature:(Index row, Index col) const
packet	../include/Eigen/src/Core/Reverse.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/Reverse.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col) const
Packet	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    typedef typename internal::packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::SelfCwiseBinaryOp	access:public
Packet	../include/Eigen/src/Core/Swap.h	/^    typedef typename internal::packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::SwapWrapper	access:public
packet	../include/Eigen/src/Core/Transpose.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index) const
packet	../include/Eigen/src/Core/Transpose.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index row, Index col) const
_PacketOnDiag	../include/Eigen/src/Core/DiagonalProduct.h	/^    _PacketOnDiag = !((int(_StorageOrder) == RowMajor && int(ProductOrder) == OnTheLeft)$/;"	e	enum:Eigen::internal::traits::__anon77
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs2_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_opposite_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_quotient1_impl	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_difference_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_max_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_min_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_product_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_quotient_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_sum_op	access:public	signature:(const Packet& a, const Packet& b) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const { return internal::pconj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index) const { return m_base = padd(m_base,m_packetStep); }$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index i) const$/;"	f	struct:Eigen::internal::linspaced_op_impl	access:public	signature:(Index i) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index i) const { return impl.packetOp(i); }$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index i) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index, Index = 0) const { return internal::pset1<Packet>(m_other); }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(Index, Index = 0) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index row, Index col) const$/;"	f	struct:Eigen::internal::linspaced_op	access:public	signature:(Index row, Index col) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_cube_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_square_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pacos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pasin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pcos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pexp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::plog(a); }$/;"	f	struct:Eigen::internal::scalar_log_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::psin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::psqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op	access:public	signature:(const Packet& a) const
packetOp	../include/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::ptan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op	access:public	signature:(const Packet& a) const
PacketReturnType	../include/Eigen/src/Core/DenseCoeffsBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
PacketReturnType	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
PacketScalar	../include/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::ArrayBase	access:public
PacketScalar	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseBase	access:public
PacketScalar	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
PacketScalar	../include/Eigen/src/Core/MapBase.h	/^    typedef typename Base::PacketScalar PacketScalar;$/;"	t	class:Eigen::MapBase	access:public
PacketScalar	../include/Eigen/src/Core/MapBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MapBase	access:public
PacketScalar	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MatrixBase	access:public
PacketScalar	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::PlainObjectBase	access:public
PacketScalar	../include/Eigen/src/Core/Redux.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::redux_impl	access:public
PacketScalar	../include/Eigen/src/Core/Redux.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller	access:public
PacketScalar	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::SparseMatrixBase	access:public
PacketSize	../include/Eigen/src/Cholesky/LLT.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::LLT::__anon404
PacketSize	../include/Eigen/src/Core/Assign.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size$/;"	e	enum:Eigen::internal::assign_traits::__anon219
PacketSize	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };$/;"	e	enum:Eigen::internal::product_coeff_impl::__anon90
PacketSize	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };$/;"	e	enum:Eigen::internal::product_coeff_vectorized_unroller::__anon89
PacketSize	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon88
PacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon100
PacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon101
PacketSize	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::symm_pack_rhs::__anon111
PacketSize	../include/Eigen/src/Core/Redux.h	/^    PacketSize = packet_traits<Scalar>::size,$/;"	e	enum:Eigen::internal::redux_impl::__anon276
PacketSize	../include/Eigen/src/Core/Redux.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_traits::__anon267
PacketSize	../include/Eigen/src/Core/Redux.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon274
PacketSize	../include/Eigen/src/Core/Reverse.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::Reverse::__anon116
PacketSize	../include/Eigen/src/Eigen2Support/SVD.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::SVD::__anon440
packet_traits	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
packet_traits	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename T> struct packet_traits : default_packet_traits$/;"	s	namespace:Eigen::internal	inherits:default_packet_traits
pack	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void pack(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)$/;"	f	struct:Eigen::internal::symm_pack_lhs	access:public	signature:(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)
pacos	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet pacos(const Packet& a) { return acos(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
padd	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_add(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
padd	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_add(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
padd	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_add(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
padd	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
padd	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vaddq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
padd	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vaddq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
padd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_add_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
padd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_add_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
padd	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
padd	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_add_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
padd	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_add_epi32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
padd	../include/Eigen/src/Core/GenericPacketMath.h	/^padd(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
palign_impl	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
palign_impl	../include/Eigen/src/Core/arch/NEON/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	../include/Eigen/src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
palign_impl	../include/Eigen/src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet2d>$/;"	s	namespace:Eigen::internal
palign_impl	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
palign_impl	../include/Eigen/src/Core/GenericPacketMath.h	/^struct palign_impl$/;"	s	namespace:Eigen::internal
palign	../include/Eigen/src/Core/GenericPacketMath.h	/^inline void palign(PacketType& first, const PacketType& second)$/;"	f	namespace:Eigen::internal	signature:(PacketType& first, const PacketType& second)
PALIGN_NEON	../include/Eigen/src/Core/arch/NEON/PacketMath.h	413;"	d
PALIGN_NEON	../include/Eigen/src/Core/arch/NEON/PacketMath.h	433;"	d
pand	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_and(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pand	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pand	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pand	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pand	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pand	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vandq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pand	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_and_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
pand	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_and_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pand	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_and_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pand	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_and_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pand	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_and_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pand	../include/Eigen/src/Core/GenericPacketMath.h	/^pand(const Packet& a, const Packet& b) { return a & b; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
pandnot	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_and(a.v, vec_nor(b.v,b.v))); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pandnot	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pandnot	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pandnot	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pandnot	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pandnot	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vbicq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pandnot	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_andnot_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
pandnot	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_andnot_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pandnot	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_andnot_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pandnot	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_andnot_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pandnot	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_andnot_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pandnot	../include/Eigen/src/Core/GenericPacketMath.h	/^pandnot(const Packet& a, const Packet& b) { return a & (!b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
parallel_cg	../include/abcd.h	/^    int parallel_cg; \/\/\/ The number of parallel CG instances$/;"	m	class:abcd	access:public
parallelize_gemm	../include/Eigen/src/Core/products/Parallelizer.h	/^void parallelize_gemm(const Functor& func, Index rows, Index cols, bool transpose)$/;"	f	namespace:Eigen::internal	signature:(const Functor& func, Index rows, Index cols, bool transpose)
ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/All.h	113;"	d
ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/All.h	58;"	d
ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  explicit ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim>& hyperplane);$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime>& other)
ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(int _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(int _dim)
ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^inline ParametrizedLine<_Scalar, _AmbientDim>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)
ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& origin, const VectorType& direction)
~ParametrizedLine	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  explicit ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane);$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane)
ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)
ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(Index _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(Index _dim)
ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^inline ParametrizedLine<_Scalar, _AmbientDim,_Options>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim,OtherOptions>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine	signature:(const Hyperplane<_Scalar, _AmbientDim,OtherOptions>& hyperplane)
ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const ParametrizedLine<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const ParametrizedLine<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)
ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& origin, const VectorType& direction)
~ParametrizedLine	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:()
PardisoImpl	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoImpl$/;"	c	namespace:Eigen
~PardisoImpl	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ~PardisoImpl()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
PardisoImpl	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
PardisoImpl	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl(PardisoImpl &) {}$/;"	f	class:Eigen::PardisoImpl	access:private	signature:(PardisoImpl &)
pardisoInit	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void pardisoInit(int type)$/;"	f	class:Eigen::PardisoImpl	access:protected	signature:(int type)
PardisoLDLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLDLT : public PardisoImpl< PardisoLDLT<MatrixType,Options> >$/;"	c	namespace:Eigen	inherits:PardisoImpl
PardisoLDLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT	access:public	signature:(const MatrixType& matrix)
PardisoLDLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT()$/;"	f	class:Eigen::PardisoLDLT	access:public	signature:()
PardisoLDLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT(PardisoLDLT& ) {}$/;"	f	class:Eigen::PardisoLDLT	access:private	signature:(PardisoLDLT& )
PardisoLLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLLT : public PardisoImpl< PardisoLLT<MatrixType,_UpLo> >$/;"	c	namespace:Eigen	inherits:PardisoImpl
PardisoLLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT	access:public	signature:(const MatrixType& matrix)
PardisoLLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT()$/;"	f	class:Eigen::PardisoLLT	access:public	signature:()
PardisoLLT	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT(PardisoLLT& ) {}$/;"	f	class:Eigen::PardisoLLT	access:private	signature:(PardisoLLT& )
PardisoLU	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLU : public PardisoImpl< PardisoLU<MatrixType> >$/;"	c	namespace:Eigen	inherits:PardisoImpl
PardisoLU	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU	access:public	signature:(const MatrixType& matrix)
PardisoLU	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU()$/;"	f	class:Eigen::PardisoLU	access:public	signature:()
PardisoLU	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU(PardisoLU& ) {}$/;"	f	class:Eigen::PardisoLU	access:private	signature:(PardisoLU& )
pardisoParameterArray	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Array<Index,64,1>& pardisoParameterArray()$/;"	f	class:Eigen::PardisoImpl	access:public	signature:()
pardisoRelease	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void pardisoRelease()$/;"	f	class:Eigen::PardisoImpl	access:protected	signature:()
pardiso_run_selector	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector<long long int>$/;"	s	namespace:Eigen::internal
pardiso_run_selector	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector$/;"	s	namespace:Eigen::internal
pardiso_traits	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLDLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
pardiso_traits	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
pardiso_traits	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
partial_lu_impl	../include/Eigen/src/LU/PartialPivLU.h	/^struct partial_lu_impl$/;"	s	namespace:Eigen::internal
partial_lu_inplace	../include/Eigen/src/LU/PartialPivLU.h	/^void partial_lu_inplace(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::Index& nb_transpositions)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::Index& nb_transpositions)
partialPivLu	../include/Eigen/src/Core/MatrixBase.h	/^    const PartialPivLU<PlainObject> partialPivLu() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
partialPivLu	../include/Eigen/src/LU/PartialPivLU.h	/^MatrixBase<Derived>::partialPivLu() const$/;"	f	class:Eigen::MatrixBase	signature:() const
PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^    PartialPivLU(const MatrixType& matrix);$/;"	p	class:Eigen::PartialPivLU	access:public	signature:(const MatrixType& matrix)
PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^    PartialPivLU(Index size);$/;"	p	class:Eigen::PartialPivLU	access:public	signature:(Index size)
PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(const MatrixType& matrix)$/;"	f	class:Eigen::PartialPivLU	signature:(const MatrixType& matrix)
PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU()$/;"	f	class:Eigen::PartialPivLU	signature:()
PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(Index size)$/;"	f	class:Eigen::PartialPivLU	signature:(Index size)
PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^    PartialPivLU();$/;"	p	class:Eigen::PartialPivLU	access:public	signature:()
PartialPivLU	../include/Eigen/src/LU/PartialPivLU.h	/^template<typename _MatrixType> class PartialPivLU$/;"	c	namespace:Eigen
PartialReduxExpr	../include/Eigen/src/Core/VectorwiseOp.h	/^class PartialReduxExpr : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
PartialReduxExpr	../include/Eigen/src/Core/VectorwiseOp.h	/^    PartialReduxExpr(const MatrixType& mat, const MemberOp& func = MemberOp())$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:(const MatrixType& mat, const MemberOp& func = MemberOp())
part	../include/Eigen/src/Core/MatrixBase.h	/^    const DiagonalWrapper<ConstDiagonalReturnType> part() const$/;"	f	class:Eigen::MatrixBase	access:public	signature:() const
part	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> const typename internal::eigen2_part_return_type<Derived, Mode>::type part() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
part	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> typename internal::eigen2_part_return_type<Derived, Mode>::type part();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
part	../include/Eigen/src/Core/TriangularMatrix.h	/^const typename internal::eigen2_part_return_type<Derived, Mode>::type MatrixBase<Derived>::part() const$/;"	f	class:Eigen::MatrixBase	signature:() const
part	../include/Eigen/src/Core/TriangularMatrix.h	/^typename internal::eigen2_part_return_type<Derived, Mode>::type MatrixBase<Derived>::part()$/;"	f	class:Eigen::MatrixBase	signature:()
partitioning_type	../include/abcd.h	/^    int partitioning_type;$/;"	m	class:abcd	access:public
partitionMatrix	../include/abcd.h	/^    void partitionMatrix();$/;"	p	class:abcd	access:private	signature:()
partitionMatrix	../src/structure.cpp	/^void abcd::partitionMatrix()$/;"	f	class:abcd	signature:()
partitionWeights	../include/abcd.h	/^    void partitionWeights(std::vector<int> &, std::vector<int>, int);$/;"	p	class:abcd	access:private	signature:(std::vector<int> &, std::vector<int>, int)
partitionWeights	../src/utils.cpp	/^void abcd::partitionWeights(std::vector<int> &parts, std::vector<int> weights, int nb_parts)$/;"	f	class:abcd	signature:(std::vector<int> &parts, std::vector<int> weights, int nb_parts)
partitionWeights	utils.cpp	/^void abcd::partitionWeights(std::vector<int> &parts, std::vector<int> weights, int nb_parts)$/;"	f	class:abcd
parts_id	../include/abcd.h	/^    std::vector<int> parts_id;$/;"	m	class:abcd	access:public
parts	../include/abcd.h	/^    std::vector<Eigen::SparseMatrix<double, RowMajor> > parts;$/;"	m	class:abcd	access:private
pasin	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet pasin(const Packet& a) { return asin(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
PastixBase	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
~PastixBase	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    ~PastixBase() $/;"	f	class:Eigen::PastixBase	access:public	signature:()
PastixBase	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixBase() : m_initisOk(false), m_analysisIsOk(false), m_factorizationIsOk(false), m_isInitialized(false), m_pastixdata(0), m_size(0)$/;"	f	class:Eigen::PastixBase	access:public	signature:()
PastixLDLT	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLDLT : public PastixBase< PastixLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:PastixBase
PastixLDLT	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT():Base()$/;"	f	class:Eigen::PastixLDLT	access:public	signature:()
PastixLDLT	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLDLT	access:public	signature:(const MatrixType& matrix)
PastixLLT	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLLT : public PastixBase< PastixLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen	inherits:PastixBase
PastixLLT	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT() : Base()$/;"	f	class:Eigen::PastixLLT	access:public	signature:()
PastixLLT	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLLT	access:public	signature:(const MatrixType& matrix)
PastixLU	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLU : public PastixBase< PastixLU<_MatrixType> >$/;"	c	namespace:Eigen	inherits:PastixBase
PastixLU	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU() : Base()$/;"	f	class:Eigen::PastixLU	access:public	signature:()
PastixLU	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLU	access:public	signature:(const MatrixType& matrix)
pastix_traits	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLDLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
pastix_traits	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
pastix_traits	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
pconj	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a) { return Packet2cf((Packet4f)vec_xor((Packet4ui)a.v, p4ui_CONJ_XOR)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pconj	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pconj	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
pconj	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pconj	../include/Eigen/src/Core/GenericPacketMath.h	/^pconj(const Packet& a) { return conj(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pconj	../include/Eigen/src/Core/util/BlasUtil.h	/^  inline const T& pconj(const T& x) { return x; }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
pconj	../include/Eigen/src/Core/util/BlasUtil.h	/^  inline T pconj(const T& x) { return internal::pconj(x); }$/;"	f	struct:Eigen::internal::conj_if	access:public	signature:(const T& x)
pcos	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f pcos<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
pcos	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet pcos(const Packet& a) { return cos(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pcplxflip	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& x)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& x)
pcplxflip	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pcplxflip	../include/Eigen/src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/*<Packet1cd>*\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& x)
pcplxflip	../include/Eigen/src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet2cf pcplxflip\/*<Packet2cf>*\/(const Packet2cf& x)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& x)
pcplxflip	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline Packet pcplxflip(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pdiv	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pdiv	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pdiv	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& , const Packet4i& )
pdiv	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pdiv	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pdiv	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& , const Packet4i& )
pdiv	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
pdiv	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pdiv	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_div_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pdiv	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_div_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pdiv	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& , const Packet4i& )
pdiv	../include/Eigen/src/Core/GenericPacketMath.h	/^pdiv(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
performFrancisQRStep	../include/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)$/;"	f	class:Eigen::RealSchur	signature:(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)
performFrancisQRStep	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    void performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)
Perm	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef PermutationMatrix<Dynamic,Dynamic,Index> Perm;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:protected
PermPermProduct	../include/Eigen/src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	e	enum:Eigen::internal::PermPermProduct_t
PermPermProduct_t	../include/Eigen/src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	g	namespace:Eigen::internal
PermutationBase	../include/Eigen/src/Core/PermutationMatrix.h	/^class PermutationBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^class PermutationMatrix : public PermutationBase<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >$/;"	c	namespace:Eigen	inherits:PermutationBase
PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    explicit inline PermutationMatrix(const MatrixBase<Other>& indices) : m_indices(indices)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const MatrixBase<Other>& indices)
PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    explicit PermutationMatrix(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const TranspositionsBase<Other>& tr)
PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationBase<OtherDerived>& other)
PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationMatrix& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const PermutationMatrix& other)
PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix()$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:()
PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(int size) : m_indices(size)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(int size)
PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix(const Transpose<PermutationBase<Other> >& other)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(const Transpose<PermutationBase<Other> >& other)
PermutationMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationMatrix	access:public	signature:(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)
permutationP	../include/Eigen/src/LU/FullPivLU.h	/^    inline const PermutationPType& permutationP() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
permutationP	../include/Eigen/src/LU/PartialPivLU.h	/^    inline const PermutationType& permutationP() const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
permutationP	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,Index>& permutationP() const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
permutationP	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
permutationP	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
permutationPinv	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,Index>& permutationPinv() const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
PermutationPType	../include/Eigen/src/LU/FullPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationPType;$/;"	t	class:Eigen::FullPivLU	access:public
permutationQ	../include/Eigen/src/LU/FullPivLU.h	/^    inline const PermutationQType& permutationQ() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
permutationQ	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::SuperLU	access:public	signature:() const
permutationQ	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
PermutationQType	../include/Eigen/src/LU/FullPivLU.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationQType;$/;"	t	class:Eigen::FullPivLU	access:public
PermutationStorage	../include/Eigen/src/Core/PermutationMatrix.h	/^struct PermutationStorage {};$/;"	s	namespace:Eigen
PermutationType	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::LDLT	access:public
PermutationType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef Derived PermutationType;$/;"	t	class:Eigen::Transpose	access:private
PermutationType	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::PartialPivLU	access:public
PermutationType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
PermutationType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
PermutationWrapper	../include/Eigen/src/Core/PermutationMatrix.h	/^class PermutationWrapper : public PermutationBase<PermutationWrapper<_IndicesType> >$/;"	c	namespace:Eigen	inherits:PermutationBase
PermutationWrapper	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationWrapper(const IndicesType& indices)$/;"	f	class:Eigen::PermutationWrapper	access:public	signature:(const IndicesType& indices)
permute_symm_to_fullsymm	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_fullsymm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0);$/;"	p	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0)
permute_symm_to_fullsymm	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_fullsymm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)
permute_symm_to_symm	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_symm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0);$/;"	p	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm = 0)
permute_symm_to_symm	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_symm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)
permut_matrix_product_retval	../include/Eigen/src/Core/PermutationMatrix.h	/^    permut_matrix_product_retval(const PermutationType& perm, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:(const PermutationType& perm, const MatrixType& matrix)
permut_matrix_product_retval	../include/Eigen/src/Core/PermutationMatrix.h	/^struct permut_matrix_product_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
permut_sparsematrix_product_retval	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    permut_sparsematrix_product_retval(const PermutationType& perm, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:(const PermutationType& perm, const MatrixType& matrix)
permut_sparsematrix_product_retval	../include/Eigen/src/SparseCore/SparsePermutation.h	/^struct permut_sparsematrix_product_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
PermutType	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,ColMajor> PermutType;$/;"	t	class:Eigen::IncompleteLUT	access:private
pexp	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
pexp	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet pexp(const Packet& a) { return exp(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pfirst	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pfirst	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; vec_st(a, 0, x); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pfirst	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x[4]; vec_st(a, 0, x); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pfirst	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pfirst	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; vst1q_f32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pfirst	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x[4]; vst1q_s32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pfirst	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
pfirst	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double x = _mm_cvtsd_f64(a); return x; }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return a.m128d_f64[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return _mm_cvtsd_f64(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float x = _mm_cvtss_f32(a); return x; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return a.m128_f32[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return _mm_cvtss_f32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int x = _mm_cvtsi128_si32(a); return x; }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pfirst	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { return _mm_cvtsi128_si32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pfirst	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type pfirst(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
Pivoting	../include/Eigen/src/Core/util/Constants.h	/^  Pivoting            = 0x01, $/;"	e	enum:Eigen::DecompositionOptions
plain_array	../include/Eigen/src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert) {}$/;"	f	struct:Eigen::internal::plain_array	access:public	signature:(constructor_without_unaligned_array_assert)
plain_array	../include/Eigen/src/Core/DenseStorage.h	/^  plain_array() { EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(0xf) }$/;"	f	struct:Eigen::internal::plain_array	access:public	signature:()
plain_array	../include/Eigen/src/Core/DenseStorage.h	/^  plain_array() {}$/;"	f	struct:Eigen::internal::plain_array	access:public	signature:()
plain_array	../include/Eigen/src/Core/DenseStorage.h	/^struct plain_array$/;"	s	namespace:Eigen::internal
plain_array	../include/Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>$/;"	s	namespace:Eigen::internal
plain_array	../include/Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 16>$/;"	s	namespace:Eigen::internal
plain_matrix_type	../include/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct plain_matrix_type<T,Sparse>$/;"	s	namespace:Eigen::internal
PlainObjectBase	../include/Eigen/src/Core/PlainObjectBase.h	/^class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base_dispatcher_for_doxygen
PlainObjectBase	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE explicit PlainObjectBase() : m_storage()$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:()
PlainObjectBase	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const EigenBase<OtherDerived> &other)
PlainObjectBase	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(Index size, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index size, Index rows, Index cols)
PlainObjectBase	../include/Eigen/src/Core/PlainObjectBase.h	/^    PlainObjectBase(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(internal::constructor_without_unaligned_array_assert)
PlainObject	../include/Eigen/src/Core/ArrayBase.h	/^          > PlainObject;$/;"	t	class:Eigen::ArrayBase	access:public
PlainObject	../include/Eigen/src/Core/Array.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Array	access:public
PlainObject	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalMatrix<Scalar,DiagonalVectorType::SizeAtCompileTime,DiagonalVectorType::MaxSizeAtCompileTime> PlainObject;$/;"	t	class:Eigen::DiagonalBase	access:public
PlainObject	../include/Eigen/src/Core/MatrixBase.h	/^          > PlainObject;$/;"	t	class:Eigen::MatrixBase	access:public
PlainObject	../include/Eigen/src/Core/Matrix.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Matrix	access:public
PlainObject	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::ProductBase	access:public
PlainObject	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::ScaledProduct	access:public
PlainObject	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::CoeffBasedProduct	access:public
PlainObject	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::SelfAdjointView	access:public
PlainObject	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType PlainObject;$/;"	t	class:Eigen::TriangularView	access:public
PlainObject	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef Quaternion<_Scalar,_Options> PlainObject;$/;"	t	struct:Eigen::internal::traits	access:public
PlainObject	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrix<Scalar, Flags&RowMajorBit ? RowMajor : ColMajor> PlainObject;$/;"	t	class:Eigen::SparseMatrixBase	access:public
PlainPermutationType	../include/Eigen/src/Core/PermutationMatrix.h	/^            PlainPermutationType;$/;"	t	class:Eigen::PermutationBase	access:public
PlainPermutationType	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::PlainPermutationType PlainPermutationType;$/;"	t	class:Eigen::Transpose	access:private
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	175;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	178;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	181;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	184;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	187;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	190;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	193;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	196;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	199;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	202;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	205;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	208;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	211;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	217;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	220;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	223;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	226;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	229;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	232;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	235;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	238;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	241;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	244;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	247;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	250;"	d	file:
PLATFORM_ID	../build/CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp	253;"	d	file:
__pld	../include/Eigen/src/Core/arch/NEON/PacketMath.h	68;"	d
ploaddup	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*     from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
ploaddup	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploaddup	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploaddup	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
ploaddup	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploaddup	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploaddup	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>* from)
ploaddup	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
ploaddup	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)$/;"	f	namespace:Eigen::internal	signature:(const double* from)
ploaddup	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploaddup	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploaddup	../include/Eigen/src/Core/GenericPacketMath.h	/^ploaddup(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
pload	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
pload	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) { EIGEN_DEBUG_ALIGNED_LOAD return vec_ld(0, from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
pload	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return vec_ld(0, from); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
pload	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
pload	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
pload	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*   from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
pload	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>* from)
pload	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>(&real_ref(*from))); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
pload	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }$/;"	f	namespace:Eigen::internal	signature:(const double* from)
pload	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_ps(from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
pload	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
pload	../include/Eigen/src/Core/GenericPacketMath.h	/^pload(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
ploadt	../include/Eigen/src/Core/GenericPacketMath.h	/^inline Packet ploadt(const typename unpacket_traits<Packet>::type* from)$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
ploadu	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
ploadu	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploadu	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploadu	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
ploadu	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from) { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploadu	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)   { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploadu	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>* from)
ploadu	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>(&real_ref(*from))); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>* from)
ploadu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }$/;"	f	namespace:Eigen::internal	signature:(const double* from)
ploadu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal	signature:(const double* from)
ploadu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploadu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal	signature:(const float* from)
ploadu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploadu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal	signature:(const int* from)
ploadu	../include/Eigen/src/Core/GenericPacketMath.h	/^ploadu(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type* from)
plog	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f plog<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
plog	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet plog(const Packet& a) { return log(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
plset	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a) { return vec_add(pset1<Packet4f>(a), p4f_COUNTDOWN); }$/;"	f	namespace:Eigen::internal	signature:(const float& a)
plset	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a)     { return vec_add(pset1<Packet4i>(a), p4i_COUNTDOWN); }$/;"	f	namespace:Eigen::internal	signature:(const int& a)
plset	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a)$/;"	f	namespace:Eigen::internal	signature:(const float& a)
plset	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a)$/;"	f	namespace:Eigen::internal	signature:(const int& a)
plset	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<double>(const double& a) { return _mm_add_pd(pset1<Packet2d>(a),_mm_set_pd(1,0)); }$/;"	f	namespace:Eigen::internal	signature:(const double& a)
plset	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a) { return _mm_add_ps(pset1<Packet4f>(a), _mm_set_ps(3,2,1,0)); }$/;"	f	namespace:Eigen::internal	signature:(const float& a)
plset	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a) { return _mm_add_epi32(pset1<Packet4i>(a),_mm_set_epi32(3,2,1,0)); }$/;"	f	namespace:Eigen::internal	signature:(const int& a)
plset	../include/Eigen/src/Core/GenericPacketMath.h	/^plset(const Scalar& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Scalar& a)
pmadd	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
pmadd	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vec_madd(a, b, c); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b, const Packet4f& c)
pmadd	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b, const Packet4i& c)
pmadd	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
pmadd	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vmlaq_f32(c,a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b, const Packet4f& c)
pmadd	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return vmlaq_s32(c,a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b, const Packet4i& c)
pmadd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
pmadd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const
pmadd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const
pmadd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
pmadd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const
pmadd	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const
pmadd	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b, const Packet4i& c)
pmadd	../include/Eigen/src/Core/GenericPacketMath.h	/^pmadd(const Packet&  a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b, const Packet& c)
pmadd	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const RealScalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const RealScalar& x, const Scalar& y, const Scalar& c) const
pmadd	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const RealScalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const RealScalar& y, const Scalar& c) const
pmadd	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& c) const
pmadd	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const { return internal::pmadd(x,y,c); }$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y, const Scalar& c) const
pmax	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmax	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmax	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmaxq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmax	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmaxq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmax	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_max_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pmax	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_max_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmax	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmax	../include/Eigen/src/Core/GenericPacketMath.h	/^pmax(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
pmin	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmin	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmin	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vminq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmin	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vminq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmin	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_min_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pmin	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_min_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmin	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmin	../include/Eigen/src/Core/GenericPacketMath.h	/^pmin(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
pmul	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& a, const Packet2cf& b) const
pmul	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pmul	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_madd(a,b,p4f_ZERO); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmul	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& a, const Packet2cf& b) const
pmul	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pmul	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmulq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmul	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmulq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& a, const Packet1cd& b) const
pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& x, const Packet2d& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet1cd& x, const Packet2d& y) const
pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet2d& x, const Packet1cd& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2d& x, const Packet1cd& y) const
pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& a, const Packet2cf& b) const
pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& x, const Packet4f& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet2cf& x, const Packet4f& y) const
pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet4f& x, const Packet2cf& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Packet4f& x, const Packet2cf& y) const
pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
pmul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pmul	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_mul_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pmul	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_mul_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pmul	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pmul	../include/Eigen/src/Core/GenericPacketMath.h	/^pmul(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
pmul	../include/Eigen/src/Core/GenericPacketMath.h	/^template<> inline std::complex<double> pmul(const std::complex<double>& a, const std::complex<double>& b)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>& a, const std::complex<double>& b)
pmul	../include/Eigen/src/Core/GenericPacketMath.h	/^template<> inline std::complex<float> pmul(const std::complex<float>& a, const std::complex<float>& b)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& a, const std::complex<float>& b)
pmul	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const RealScalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const RealScalar& x, const Scalar& y) const
pmul	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const RealScalar& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const RealScalar& y) const
pmul	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y) const
pmul	../include/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const { return internal::pmul(x,y); }$/;"	f	struct:Eigen::internal::conj_helper	access:public	signature:(const Scalar& x, const Scalar& y) const
pnegate	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pnegate	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return psub<Packet4f>(p4f_ZERO, a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pnegate	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return psub<Packet4i>(p4i_ZERO, a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pnegate	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate<Packet4f>(a.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pnegate	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return vnegq_f32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pnegate	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return vnegq_s32(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pnegate	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
pnegate	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
pnegate	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
pnegate	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
pnegate	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
pnegate	../include/Eigen/src/Core/GenericPacketMath.h	/^pnegate(const Packet& a) { return -a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pointAt	../include/Eigen/src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::pointAt( _Scalar t ) const$/;"	f	class:Eigen::ParametrizedLine	signature:( _Scalar t ) const
pointAt	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType pointAt( Scalar t ) const;$/;"	p	class:Eigen::ParametrizedLine	access:public	signature:( Scalar t ) const
PointerArgType	../include/Eigen/src/Core/Map.h	/^    typedef const Scalar* PointerArgType;$/;"	t	class:Eigen::Map	access:public
PointerArgType	../include/Eigen/src/Core/Map.h	/^    typedef PointerType PointerArgType;$/;"	t	class:Eigen::Map	access:public
pointer	../include/Eigen/src/Core/util/Memory.h	/^    typedef T*        pointer;$/;"	t	class:Eigen::aligned_allocator	access:public
pointer	../include/Eigen/src/StlSupport/details.h	/^    typedef T*        pointer;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
PointerType	../include/Eigen/src/Core/MapBase.h	/^                     PointerType;$/;"	t	class:Eigen::MapBase	access:public
PointerType	../include/Eigen/src/Core/MapBase.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::MapBase	access:public
PointerType	../include/Eigen/src/Core/Map.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::Map	access:public
por	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_or(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
por	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
por	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
por	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
por	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
por	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vorrq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
por	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_or_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
por	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_or_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
por	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_or_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
por	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_or_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
por	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_or_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
por	../include/Eigen/src/Core/GenericPacketMath.h	/^por(const Packet& a, const Packet& b) { return a | b; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
pow_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct pow_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
pow_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct pow_default_impl$/;"	s	namespace:Eigen::internal
pow_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct pow_impl : pow_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:pow_default_impl
pow	../include/Eigen/src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<Derived>& exponents) $/;"	f	namespace:std	signature:(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<Derived>& exponents)
pow	../include/Eigen/src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const typename Derived::Scalar& exponent) {$/;"	f	namespace:std	signature:(const Eigen::ArrayBase<Derived>& x, const typename Derived::Scalar& exponent)
pow	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(pow, Scalar) pow(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
pow	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_pow_op)      pow(const Scalar& exponent) const;$/;"	p	class:Eigen::Cwise	access:public	signature:(const Scalar& exponent) const
pow	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::pow(const Scalar& exponent) const$/;"	f	class:Eigen::Cwise	signature:(const Scalar& exponent) const
pow	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^pow(const Scalar& exponent) const$/;"	f	signature:(const Scalar& exponent) const
pow_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct pow_retval$/;"	s	namespace:Eigen::internal
precision	../include/Eigen/src/Core/IO.h	/^  int precision;$/;"	m	struct:Eigen::IOFormat	access:public
precision	../include/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T precision () { return NumTraits<T>::dummy_precision(); }$/;"	f	namespace:Eigen	signature:()
Preconditioner	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::BiCGSTAB	access:public
Preconditioner	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits	access:public
Preconditioner	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::ConjugateGradient	access:public
Preconditioner	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits	access:public
preconditioner	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Preconditioner& preconditioner() const { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
preconditioner	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner& preconditioner() { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:()
Preconditioner	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::Preconditioner Preconditioner;$/;"	t	class:Eigen::IterativeSolverBase	access:public
PreconditionIfMoreColsThanRows	../include/Eigen/src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon413
PreconditionIfMoreRowsThanCols	../include/Eigen/src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon413
predux	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
predux	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
predux	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
predux	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
predux	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
predux	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a) { return pfirst(_mm_hadd_pd(a, a)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
predux	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_product_op	access:public	signature:(const Packet& a) const
predux	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_max_op	access:public	signature:(const Packet& a) const
predux	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_min_op	access:public	signature:(const Packet& a) const
predux	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_sum_op	access:public	signature:(const Packet& a) const
predux	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
predux_max	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_max	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_max	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_max	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_max	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
predux_max	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_max	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_max	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_max(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
predux_min	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_min	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_min	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_min	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_min	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
predux_min	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_min	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_min	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_min(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
predux_mul	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
predux_mul	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_mul	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_mul	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
predux_mul	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_mul	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_mul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
predux_mul	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
predux_mul	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
predux_mul	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
predux_mul	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
predux_mul	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_mul(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
preduxp	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf* vecs)
preduxp	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f* vecs)
preduxp	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i* vecs)
preduxp	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf* vecs)
preduxp	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f* vecs)
preduxp	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i* vecs)
preduxp	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd* vecs)
preduxp	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf* vecs)
preduxp	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d* vecs)
preduxp	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f* vecs)
preduxp	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i* vecs)
preduxp	../include/Eigen/src/Core/GenericPacketMath.h	/^preduxp(const Packet* vecs) { return vecs[0]; }$/;"	f	namespace:Eigen::internal	signature:(const Packet* vecs)
prefetch	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { vec_dstt((float *)addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float> * addr)
prefetch	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) { vec_dstt(addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal	signature:(const float* addr)
prefetch	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr) { vec_dstt(addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal	signature:(const int* addr)
prefetch	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { __pld((float *)addr); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float> * addr)
prefetch	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) { __pld(addr); }$/;"	f	namespace:Eigen::internal	signature:(const float* addr)
prefetch	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr) { __pld(addr); }$/;"	f	namespace:Eigen::internal	signature:(const int* addr)
prefetch	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double> * addr)
prefetch	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float> * addr)
prefetch	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const double* addr)
prefetch	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const float* addr)
prefetch	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal	signature:(const int* addr)
prefetch	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar> inline void prefetch(const Scalar* addr)$/;"	f	namespace:Eigen::internal	signature:(const Scalar* addr)
preprocess	../include/abcd.h	/^    void preprocess();$/;"	p	class:abcd	access:private	signature:()
preprocess	preprocess.cpp	/^void abcd::preprocess()$/;"	f	class:abcd
preprocess	../src/preprocess.cpp	/^void abcd::preprocess()$/;"	f	class:abcd	signature:()
prerotate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& prerotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
prerotate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
prerotate	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& prerotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
prerotate	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
prescale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& prescale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
prescale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& prescale(Scalar s);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar s)
prescale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::prescale(Scalar s)$/;"	f	class:Eigen::Transform	signature:(Scalar s)
prescale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
prescale	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& prescale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
prescale	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& prescale(Scalar s);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar s)
prescale	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::prescale(Scalar s)$/;"	f	class:Eigen::Transform	signature:(Scalar s)
prescale	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
preshear	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  Transform& preshear(Scalar sx, Scalar sy);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar sx, Scalar sy)
preshear	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::preshear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform	signature:(Scalar sx, Scalar sy)
preshear	../include/Eigen/src/Geometry/Transform.h	/^  Transform& preshear(Scalar sx, Scalar sy);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar sx, Scalar sy)
preshear	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::preshear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform	signature:(Scalar sx, Scalar sy)
pretranslate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& pretranslate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
pretranslate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
pretranslate	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& pretranslate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
pretranslate	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
preverse	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
preverse	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) { return (Packet4f)vec_perm((Packet16uc)a,(Packet16uc)a, p16uc_REVERSE); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
preverse	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) { return (Packet4i)vec_perm((Packet16uc)a,(Packet16uc)a, p16uc_REVERSE); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
preverse	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
preverse	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) {$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
preverse	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) {$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
preverse	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a)
preverse	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a) { return Packet2cf(_mm_castpd_ps(preverse(_mm_castps_pd(a.v)))); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a)
preverse	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a)
preverse	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a)
preverse	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a)
preverse	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline Packet preverse(const Packet& a)$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
print_matrix	../include/Eigen/src/Core/IO.h	/^std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt)$/;"	f	namespace:Eigen::internal	signature:(std::ostream & s, const Derived& _m, const IOFormat& fmt)
print_matrix	../include/Eigen/src/Core/IO.h	/^std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt);$/;"	p	namespace:Eigen::internal	signature:(std::ostream & s, const Derived& _m, const IOFormat& fmt)
prod	../include/Eigen/src/Core/DenseBase.h	/^    Scalar prod() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
prod	../include/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::prod() const$/;"	f	class:Eigen::DenseBase	signature:() const
prod	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_prod>::Type prod() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
ProdRetType	../include/Eigen/src/Core/TriangularMatrix.h	/^      typedef typename ProductReturnType<DenseMatrixType, OtherPlainObject>::Type ProdRetType;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
ProductBase	../include/Eigen/src/Core/ProductBase.h	/^class ProductBase : public MatrixBase<Derived>$/;"	c	namespace:Eigen	inherits:MatrixBase
ProductBase	../include/Eigen/src/Core/ProductBase.h	/^    ProductBase(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::ProductBase	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Product::Base	../include/Eigen/src/Core/Product.h	/^                                                typename Rhs::StorageKind>::ret>::Base Base;$/;"	t	class:Product	access:public
product_coeff_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, 0, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, Dynamic, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, Dynamic, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,1>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,RhsCols>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,LhsRows,1>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_unroller	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_unroller<0, Lhs, Rhs, Packet>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_unroller	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_unroller$/;"	s	namespace:Eigen::internal
Product::cols	../include/Eigen/src/Core/Product.h	/^    inline Index cols() const { return m_rhs.cols(); }$/;"	f	class:Product	access:public	signature:() const
ProductImpl::Base	../include/Eigen/src/Core/Product.h	/^    typedef typename internal::dense_xpr_base<Product<Lhs, Rhs> >::type Base;$/;"	t	class:ProductImpl	access:public
ProductImpl::Derived	../include/Eigen/src/Core/Product.h	/^    typedef Product<Lhs, Rhs> Derived;$/;"	t	class:ProductImpl	access:private
ProductImpl	../include/Eigen/src/Core/Product.h	/^class ProductImpl<Lhs,Rhs,Dense> : public internal::dense_xpr_base<Product<Lhs,Rhs> >::type$/;"	c	inherits:internal::dense_xpr_base::type
Product	../include/Eigen/src/Core/Product.h	/^class Product : public ProductImpl<Lhs,Rhs,typename internal::promote_storage_type<typename internal::traits<Lhs>::StorageKind,$/;"	c	inherits:ProductImpl
Product	../include/Eigen/src/Core/Product.h	/^    Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)$/;"	f	class:Product	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
Product::lhs	../include/Eigen/src/Core/Product.h	/^    const LhsNestedCleaned& lhs() const { return m_lhs; }$/;"	f	class:Product	access:public	signature:() const
Product::LhsNestedCleaned	../include/Eigen/src/Core/Product.h	/^    typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;$/;"	t	class:Product	access:public
Product::LhsNested	../include/Eigen/src/Core/Product.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Product	access:public
Product::m_lhs	../include/Eigen/src/Core/Product.h	/^    const LhsNested m_lhs;$/;"	m	class:Product	access:protected
Product::m_rhs	../include/Eigen/src/Core/Product.h	/^    const RhsNested m_rhs;$/;"	m	class:Product	access:protected
product_packet_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
Product::Product	../include/Eigen/src/Core/Product.h	/^    Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)$/;"	f	class:Product	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
ProductReturnType	../include/Eigen/src/Core/GeneralProduct.h	/^struct ProductReturnType<Lhs,Rhs,CoeffBasedProductMode>$/;"	s	namespace:Eigen
ProductReturnType	../include/Eigen/src/Core/GeneralProduct.h	/^struct ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen
ProductReturnType	../include/Eigen/src/Core/GeneralProduct.h	/^struct ProductReturnType$/;"	s	namespace:Eigen
Product::rhs	../include/Eigen/src/Core/Product.h	/^    const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	class:Product	access:public	signature:() const
Product::RhsNestedCleaned	../include/Eigen/src/Core/Product.h	/^    typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;$/;"	t	class:Product	access:public
Product::RhsNested	../include/Eigen/src/Core/Product.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Product	access:public
Product::rows	../include/Eigen/src/Core/Product.h	/^    inline Index rows() const { return m_lhs.rows(); }$/;"	f	class:Product	access:public	signature:() const
product_selfadjoint_matrix	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,LhsSelfAdjoint,ConjugateLhs, RhsStorageOrder,RhsSelfAdjoint,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
product_size_category	../include/Eigen/src/Core/GeneralProduct.h	/^template<int Size, int MaxSize> struct product_size_category$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,false,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,LhsIsTriangular,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,true,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix_trmm	../include/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^struct product_triangular_matrix_matrix_trmm :$/;"	s	namespace:Eigen::internal	inherits:product_triangular_matrix_matrix
product_type	../include/Eigen/src/Core/GeneralProduct.h	/^template<typename Lhs, typename Rhs> struct product_type$/;"	s	namespace:Eigen::internal
ProductType	../include/Eigen/src/Geometry/Transform.h	/^    typedef internal::transform_transform_product_impl<Transform,Transform<Scalar,Dim,OtherMode,OtherOptions> > ProductType;$/;"	t	struct:Eigen::Transform::icc_11_workaround	access:public
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
projection	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
projection	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
projection	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
projection	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
Projective2d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Projective> Projective2d;$/;"	t	namespace:Eigen
Projective2f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Projective> Projective2f;$/;"	t	namespace:Eigen
Projective3d	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Projective> Projective3d;$/;"	t	namespace:Eigen
Projective3f	../include/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Projective> Projective3f;$/;"	t	namespace:Eigen
Projective	../include/Eigen/src/Core/util/Constants.h	/^  Projective    = 0x20$/;"	e	enum:Eigen::TransformTraits
projective_transform_inverse	../include/Eigen/src/Geometry/Transform.h	/^struct projective_transform_inverse$/;"	s	namespace:Eigen::internal
projective_transform_inverse	../include/Eigen/src/Geometry/Transform.h	/^struct projective_transform_inverse<TransformType, Projective>$/;"	s	namespace:Eigen::internal
promote_index_type	../include/Eigen/src/Core/util/XprHelper.h	/^struct promote_index_type$/;"	s	namespace:Eigen::internal
promote_storage_type	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^template<> struct promote_storage_type<Dense,Sparse>$/;"	s	namespace:Eigen::internal
promote_storage_type	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^template<> struct promote_storage_type<Sparse,Dense>$/;"	s	namespace:Eigen::internal
pruned	../include/Eigen/src/SparseCore/SparseProduct.h	/^    SparseSparseProduct pruned(Scalar reference = 0, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision()) const$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(Scalar reference = 0, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision()) const
prune	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    void prune(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())
prune	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void prune(const KeepFunc& keep = KeepFunc())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const KeepFunc& keep = KeepFunc())
prune	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void prune(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())
prune	../include/Eigen/src/SparseCore/SparseVector.h	/^    void prune(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseVector	access:public	signature:(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())
pset1	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& from)
pset1	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) {$/;"	f	namespace:Eigen::internal	signature:(const float& from)
pset1	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   {$/;"	f	namespace:Eigen::internal	signature:(const int& from)
pset1	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& from)
pset1	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return vdupq_n_f32(from); }$/;"	f	namespace:Eigen::internal	signature:(const float& from)
pset1	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   { return vdupq_n_s32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int& from)
pset1	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<double>& from)
pset1	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal	signature:(const std::complex<float>& from)
pset1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set1_pd(from); }$/;"	f	namespace:Eigen::internal	signature:(const double& from)
pset1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set_pd(from,from); }$/;"	f	namespace:Eigen::internal	signature:(const double& from)
pset1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set1_ps(from); }$/;"	f	namespace:Eigen::internal	signature:(const float& from)
pset1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps(from,from,from,from); }$/;"	f	namespace:Eigen::internal	signature:(const float& from)
pset1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set1_epi32(from); }$/;"	f	namespace:Eigen::internal	signature:(const int& from)
pset1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set_epi32(from,from,from,from); }$/;"	f	namespace:Eigen::internal	signature:(const int& from)
pset1	../include/Eigen/src/Core/GenericPacketMath.h	/^pset1(const typename unpacket_traits<Packet>::type& a) { return a; }$/;"	f	namespace:Eigen::internal	signature:(const typename unpacket_traits<Packet>::type& a)
pseudoEigenvalueMatrix	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^MatrixType EigenSolver<MatrixType>::pseudoEigenvalueMatrix() const$/;"	f	class:Eigen::EigenSolver	signature:() const
pseudoEigenvalueMatrix	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType pseudoEigenvalueMatrix() const;$/;"	p	class:Eigen::EigenSolver	access:public	signature:() const
pseudoEigenvectors	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    const MatrixType& pseudoEigenvectors() const$/;"	f	class:Eigen::EigenSolver	access:public	signature:() const
psin	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psin<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
psin	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet psin(const Packet& a) { return sin(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
psqrt	../include/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& _x)
psqrt	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet psqrt(const Packet& a) { return sqrt(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
pstore1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet2d>(double* to, const double& a)$/;"	f	namespace:Eigen::internal	signature:(double* to, const double& a)
pstore1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet4f>(float* to, const float& a)$/;"	f	namespace:Eigen::internal	signature:(float* to, const float& a)
pstore1	../include/Eigen/src/Core/GenericPacketMath.h	/^inline void pstore1(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)$/;"	f	namespace:Eigen::internal	signature:(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)
pstore	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
pstore	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vec_st(from, 0, to); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
pstore	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vec_st(from, 0, to); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
pstore	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
pstore	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
pstore	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
pstore	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<double> * to, const Packet1cd& from)
pstore	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore(&real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
pstore	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }$/;"	f	namespace:Eigen::internal	signature:(double* to, const Packet2d& from)
pstore	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
pstore	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_si128(reinterpret_cast<Packet4i*>(to), from); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
pstore	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> inline void pstore(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal	signature:(Scalar* to, const Packet& from)
pstoret	../include/Eigen/src/Core/GenericPacketMath.h	/^inline void pstoret(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal	signature:(Scalar* to, const Packet& from)
pstoreu	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
pstoreu	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from)$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
pstoreu	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from)$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
pstoreu	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
pstoreu	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
pstoreu	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
pstoreu	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<double> * to, const Packet1cd& from)
pstoreu	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(&real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal	signature:(std::complex<float> * to, const Packet2cf& from)
pstoreu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet2d& from) {$/;"	f	namespace:Eigen::internal	signature:(double* to, const Packet2d& from)
pstoreu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), _mm_castps_pd(from)); }$/;"	f	namespace:Eigen::internal	signature:(float* to, const Packet4f& from)
pstoreu	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), _mm_castsi128_pd(from)); }$/;"	f	namespace:Eigen::internal	signature:(int* to, const Packet4i& from)
pstoreu	../include/Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> inline void pstoreu(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal	signature:(Scalar* to, const Packet& from)
psub	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_sub(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
psub	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_sub(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
psub	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_sub(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
psub	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
psub	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vsubq_f32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
psub	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vsubq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
psub	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_sub_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
psub	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_sub_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
psub	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_sub_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
psub	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_sub_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
psub	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_sub_epi32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
psub	../include/Eigen/src/Core/GenericPacketMath.h	/^psub(const Packet& a,$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
ptan	../include/Eigen/src/Core/GenericPacketMath.h	/^Packet ptan(const Packet& a) { return tan(a); }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a)
punpackp	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^EIGEN_STRONG_INLINE void punpackp(Packet4f* vecs)$/;"	f	namespace:Eigen::internal	signature:(Packet4f* vecs)
push_back	../include/Eigen/src/StlSupport/StdDeque.h	/^  void push_back(const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const value_type& x)
push_back	../include/Eigen/src/StlSupport/StdList.h	/^    void push_back(const value_type& x)$/;"	f	class:std::list	access:private	signature:(const value_type& x)
push_back	../include/Eigen/src/StlSupport/StdVector.h	/^  void push_back(const value_type& x)$/;"	f	class:std::vector	access:private	signature:(const value_type& x)
push_front	../include/Eigen/src/StlSupport/StdDeque.h	/^  void push_front(const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const value_type& x)
pxor	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_xor(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pxor	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pxor	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pxor	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pxor	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pxor	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return veorq_s32(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pxor	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_xor_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet1cd& a, const Packet1cd& b)
pxor	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_xor_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2cf& a, const Packet2cf& b)
pxor	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_xor_pd(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet2d& a, const Packet2d& b)
pxor	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_xor_ps(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4f& a, const Packet4f& b)
pxor	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_xor_si128(a,b); }$/;"	f	namespace:Eigen::internal	signature:(const Packet4i& a, const Packet4i& b)
pxor	../include/Eigen/src/Core/GenericPacketMath.h	/^pxor(const Packet& a, const Packet& b) { return a ^ b; }$/;"	f	namespace:Eigen::internal	signature:(const Packet& a, const Packet& b)
qamax	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qamax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qamin	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qamin) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qasum	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qasum) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qaxpy	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(qaxpy) (int *, double *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *, double *, int *)
qcopy	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(qcopy) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
qdot	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qdot)  (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
qgbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qgbmv)(char *, int *, int *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
qgemm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qgemm)(char *, char *, int *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
qgemv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qgemv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
qger	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qger)(int *,    int *, double *, double *, int *,$/;"	p	signature:(int *, int *, double *, double *, int *, double *, int *, double *, int *)
qgesv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qgesv)(int *, int *, double *, int *, int *, double*, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, double*, int *, int *)
qgetf2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qgetf2)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
qgetrf	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qgetrf)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
qgetrs	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qgetrs)(char *, int *, int *, double *, int *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, int *, double *, int *, int *, double *, int *, int *)
qlaswp	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qlaswp)(int *, double *, int *, int *, int *, int *, int *);$/;"	p	signature:(int *, double *, int *, int *, int *, int *, int *)
qlauu2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qlauu2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
qlauum	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qlauum)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
qmax	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qmax)  (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qmin	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qmin)  (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qnrm2	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qnrm2) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qpotf2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qpotf2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
qpotrf	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qpotrf)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
qpotri	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qpotri)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
qr	../include/Eigen/src/Core/MatrixBase.h	/^    const QR<PlainObject> qr() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
QR	../include/Eigen/src/Eigen2Support/QR.h	/^class QR : public HouseholderQR<MatrixType>$/;"	c	namespace:Eigen	inherits:HouseholderQR
QR	../include/Eigen/src/Eigen2Support/QR.h	/^    explicit QR(const T& t) : Base(t) {}$/;"	f	class:Eigen::QR	access:public	signature:(const T& t)
qr	../include/Eigen/src/Eigen2Support/QR.h	/^MatrixBase<Derived>::qr() const$/;"	f	class:Eigen::MatrixBase	signature:() const
QR	../include/Eigen/src/Eigen2Support/QR.h	/^    QR() : Base() {}$/;"	f	class:Eigen::QR	access:public	signature:()
qrotg	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(qrotg) (double *, double *, double *, double *);$/;"	p	signature:(double *, double *, double *, double *)
qrot	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(qrot)  (int *, double *, int *, double *, int *, double *, double *);$/;"	p	signature:(int *, double *, int *, double *, int *, double *, double *)
qrotm	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(qrotm) (int *, double *, int *, double *, int *, double *);$/;"	p	signature:(int *, double *, int *, double *, int *, double *)
qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, QRPreconditioner, Case, false>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	../include/Eigen/src/SVD/JacobiSVD.h	/^> struct qr_preconditioner_impl {};$/;"	s	namespace:Eigen::internal
qr_preconditioner_should_do_anything	../include/Eigen/src/SVD/JacobiSVD.h	/^struct qr_preconditioner_should_do_anything$/;"	s	namespace:Eigen::internal
QRPreconditioners	../include/Eigen/src/Core/util/Constants.h	/^enum QRPreconditioners {$/;"	g	namespace:Eigen
qsbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qsbmv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
qscal	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(qscal) (int *,  double *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *)
qspmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qspmv) (char *, int *, double  *, double *,$/;"	p	signature:(char *, int *, double *, double *, double *, int *, double *, double *, int *)
qspr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qspr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *)
qspr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qspr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *)
qswap	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(qswap) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
qsymm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qsymm)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
qsymv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qsymv) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
qsyr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qsyr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, int *)
qsyr2k	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qsyr2k)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
qsyr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qsyr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *)
qsyrk	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qsyrk)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, double *, int *)
qtbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qtbmv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
qtbsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qtbsv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
qtpmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qtpmv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
qtpsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qtpsv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
qtrmm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qtrmm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
qtrmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qtrmv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
qtrsm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qtrsm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
qtrsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qtrsv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
qtrti2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qtrti2)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
qtrtri	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(qtrtri)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
quaternionbase_assign_impl	../include/Eigen/src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,3,3>$/;"	s	namespace:Eigen::internal
quaternionbase_assign_impl	../include/Eigen/src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,4,1>$/;"	s	namespace:Eigen::internal
QuaternionBase	../include/Eigen/src/Geometry/Quaternion.h	/^class QuaternionBase : public RotationBase<Derived, 3>$/;"	c	namespace:Eigen	inherits:RotationBase
Quaterniond	../include/Eigen/src/Eigen2Support/Geometry/All.h	31;"	d
Quaterniond	../include/Eigen/src/Eigen2Support/Geometry/All.h	86;"	d
Quaterniond	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Quaterniond	../include/Eigen/src/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Quaternionf	../include/Eigen/src/Eigen2Support/Geometry/All.h	30;"	d
Quaternionf	../include/Eigen/src/Eigen2Support/Geometry/All.h	85;"	d
Quaternionf	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
Quaternionf	../include/Eigen/src/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
Quaternion	../include/Eigen/src/Eigen2Support/Geometry/All.h	29;"	d
Quaternion	../include/Eigen/src/Eigen2Support/Geometry/All.h	84;"	d
Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^class Quaternion : public RotationBase<Quaternion<_Scalar>,3>$/;"	c	namespace:Eigen	inherits:RotationBase
Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const AngleAxisType& aa)
Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& other)
Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline explicit Quaternion(const Quaternion<OtherScalarType>& other)$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion<OtherScalarType>& other)
Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion(const Quaternion& other) { m_coeffs = other.m_coeffs; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion& other)
Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion() {}$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Quaternion	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion(Scalar w, Scalar x, Scalar y, Scalar z)$/;"	f	class:Eigen::Quaternion	access:public	signature:(Scalar w, Scalar x, Scalar y, Scalar z)
Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^class Quaternion : public QuaternionBase<Quaternion<_Scalar,_Options> >$/;"	c	namespace:Eigen	inherits:QuaternionBase
Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const AngleAxisType& aa)
Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived>& other)
Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const Quaternion<OtherScalar, OtherOptions>& other)$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Quaternion<OtherScalar, OtherOptions>& other)
Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion(const Scalar* data) : m_coeffs(data) {}$/;"	f	class:Eigen::Quaternion	access:public	signature:(const Scalar* data)
Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion() {}$/;"	f	class:Eigen::Quaternion	access:public	signature:()
Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion(Scalar w, Scalar x, Scalar y, Scalar z) : m_coeffs(x, y, z, w){}$/;"	f	class:Eigen::Quaternion	access:public	signature:(Scalar w, Scalar x, Scalar y, Scalar z)
Quaternion	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> EIGEN_STRONG_INLINE Quaternion(const QuaternionBase<Derived>& other) { this->Base::operator=(other); }$/;"	f	class:Eigen::Quaternion	access:public	signature:(const QuaternionBase<Derived>& other)
QuaternionMapAlignedd	../include/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, Aligned>  QuaternionMapAlignedd;$/;"	t	namespace:Eigen
QuaternionMapAlignedf	../include/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, Aligned>   QuaternionMapAlignedf;$/;"	t	namespace:Eigen
QuaternionMapd	../include/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, 0>        QuaternionMapd;$/;"	t	namespace:Eigen
QuaternionMapf	../include/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, 0>         QuaternionMapf;$/;"	t	namespace:Eigen
QuaternionType	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis	access:public
QuaternionType	../include/Eigen/src/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis	access:public
quat_product	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, double, Aligned>$/;"	s	namespace:Eigen::internal
quat_product	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, float, Aligned>$/;"	s	namespace:Eigen::internal
quat_product	../include/Eigen/src/Geometry/Quaternion.h	/^template<int Arch, class Derived1, class Derived2, typename Scalar, int _Options> struct quat_product$/;"	s	namespace:Eigen::internal
queryCacheSizes_amd	../include/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_amd(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
queryCacheSizes	../include/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
queryCacheSizes_intel_codes	../include/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_codes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
queryCacheSizes_intel_direct	../include/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_direct(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3)
queryCacheSizes_intel	../include/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel(int& l1, int& l2, int& l3, int max_std_funcs)$/;"	f	namespace:Eigen::internal	signature:(int& l1, int& l2, int& l3, int max_std_funcs)
queryL1CacheSize	../include/Eigen/src/Core/util/Memory.h	/^inline int queryL1CacheSize()$/;"	f	namespace:Eigen::internal	signature:()
queryTopLevelCacheSize	../include/Eigen/src/Core/util/Memory.h	/^inline int queryTopLevelCacheSize()$/;"	f	namespace:Eigen::internal	signature:()
QuickSplit	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^int IncompleteLUT<Scalar>::QuickSplit(VectorV &row, VectorI &ind, int ncut)$/;"	f	class:Eigen::IncompleteLUT	signature:(VectorV &row, VectorI &ind, int ncut)
QuickSplit	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    int QuickSplit(VectorV &row, VectorI &ind, int ncut);$/;"	p	class:Eigen::IncompleteLUT	access:protected	signature:(VectorV &row, VectorI &ind, int ncut)
qxamax	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qxamax)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qxamin	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qxamin)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qxasum	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qxasum)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qxmax	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qxmax) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qxmin	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qxmin) (int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
qxnrm2	../include/Eigen/src/misc/blas.h	/^double BLASFUNC(qxnrm2)(int *, double *, int *);$/;"	p	signature:(int *, double *, int *)
RandomAccessLinSpacedReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,true>,Derived> RandomAccessLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase	access:public
RandomAccessPattern	../include/Eigen/src/SparseCore/SparseUtil.h	/^const int RandomAccessPattern       = 0x8 | OuterRandomAccessPattern | InnerRandomAccessPattern;$/;"	m	namespace:Eigen
random_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
random_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
random_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
random_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl {};$/;"	s	namespace:Eigen::internal
random_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct random_impl : random_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:random_default_impl
random_impl	../include/Eigen/src/Core/MathFunctions.h	/^template<> struct random_impl<bool>$/;"	s	namespace:Eigen::internal
Random	../include/Eigen/src/Core/DenseBase.h	/^    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random(Index rows, Index cols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Random	../include/Eigen/src/Core/DenseBase.h	/^    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
Random	../include/Eigen/src/Core/DenseBase.h	/^    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
random	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
random	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random()$/;"	f	namespace:Eigen::internal	signature:()
random	../include/Eigen/src/Core/MathFunctions.h	/^template<typename Scalar> inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y);$/;"	p	namespace:Eigen::internal	signature:(const Scalar& x, const Scalar& y)
random	../include/Eigen/src/Core/MathFunctions.h	/^template<typename Scalar> inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random();$/;"	p	namespace:Eigen::internal	signature:()
Random	../include/Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random()$/;"	f	class:Eigen::DenseBase	signature:()
Random	../include/Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols)
Random	../include/Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
random_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct random_retval$/;"	s	namespace:Eigen::internal
rank	../include/Eigen/src/LU/FullPivLU.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
rank	../include/Eigen/src/misc/Image.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
rank	../include/Eigen/src/misc/Kernel.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
rank	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
rank	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
rankUpdate	../include/Eigen/src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::rankUpdate(const MatrixBase<Derived>& w,typename NumTraits<typename MatrixType::Scalar>::Real sigma)$/;"	f	class:Eigen::LDLT	signature:(const MatrixBase<Derived>& w,typename NumTraits<typename MatrixType::Scalar>::Real sigma)
rankUpdate	../include/Eigen/src/Cholesky/LDLT.h	/^    LDLT& rankUpdate(const MatrixBase<Derived>& w,RealScalar alpha=1);$/;"	p	class:Eigen::LDLT	access:public	signature:(const MatrixBase<Derived>& w,RealScalar alpha=1)
rankUpdate	../include/Eigen/src/Cholesky/LLT.h	/^LLT<_MatrixType,_UpLo> LLT<_MatrixType,_UpLo>::rankUpdate(const VectorType& v, const RealScalar& sigma)$/;"	f	class:Eigen::LLT	signature:(const VectorType& v, const RealScalar& sigma)
rankUpdate	../include/Eigen/src/Cholesky/LLT.h	/^    LLT rankUpdate(const VectorType& vec, const RealScalar& sigma = 1);$/;"	p	class:Eigen::LLT	access:public	signature:(const VectorType& vec, const RealScalar& sigma = 1)
rankUpdate	../include/Eigen/src/Cholesky/LLT.h	/^  static typename MatrixType::Index rankUpdate(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)
rankUpdate	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, Scalar alpha)$/;"	f	class:Eigen::SelfAdjointView	signature:(const MatrixBase<DerivedU>& u, Scalar alpha)
rankUpdate	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, Scalar alpha)$/;"	f	class:Eigen::SelfAdjointView	signature:(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, Scalar alpha)
rankUpdate	../include/Eigen/src/Core/SelfAdjointView.h	/^    SelfAdjointView& rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, Scalar alpha = Scalar(1));$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, Scalar alpha = Scalar(1))
rankUpdate	../include/Eigen/src/Core/SelfAdjointView.h	/^    SelfAdjointView& rankUpdate(const MatrixBase<DerivedU>& u, Scalar alpha = Scalar(1));$/;"	p	class:Eigen::SelfAdjointView	access:public	signature:(const MatrixBase<DerivedU>& u, Scalar alpha = Scalar(1))
rankUpdate	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<MatrixType,UpLo>::rankUpdate(const SparseMatrixBase<DerivedU>& u, Scalar alpha)$/;"	f	class:Eigen::SparseSelfAdjointView	signature:(const SparseMatrixBase<DerivedU>& u, Scalar alpha)
rankUpdate	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& rankUpdate(const SparseMatrixBase<DerivedU>& u, Scalar alpha = Scalar(1));$/;"	p	class:Eigen::SparseSelfAdjointView	access:public	signature:(const SparseMatrixBase<DerivedU>& u, Scalar alpha = Scalar(1))
rawMatrix	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const CholMatrixType rawMatrix() const {$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:() const
ReadCost	../include/Eigen/src/Core/NumTraits.h	/^    ReadCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon277
ReadOnlyAccessors	../include/Eigen/src/Core/util/Constants.h	/^  ReadOnlyAccessors, $/;"	e	enum:Eigen::AccessorLevels
real_2x2_jacobi_svd	../include/Eigen/src/SVD/JacobiSVD.h	/^void real_2x2_jacobi_svd(const MatrixType& matrix, Index p, Index q,$/;"	f	namespace:Eigen::internal	signature:(const MatrixType& matrix, Index p, Index q, JacobiRotation<RealScalar> *j_left, JacobiRotation<RealScalar> *j_right)
real_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct real_impl$/;"	s	namespace:Eigen::internal
real_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct real_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
real	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real, Scalar) real(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
Real	../include/Eigen/src/Core/NumTraits.h	/^  typedef T Real;$/;"	t	struct:Eigen::GenericNumTraits	access:public
real	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^real() const { return derived(); }$/;"	f	signature:() const
real	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^real() { return derived(); }$/;"	f	signature:()
reallocate	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void reallocate(Index size)$/;"	f	class:Eigen::internal::AmbiVector	access:protected	signature:(Index size)
reallocate	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline void reallocate(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:protected	signature:(size_t size)
reallocateSparse	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void reallocateSparse()$/;"	f	class:Eigen::internal::AmbiVector	access:protected	signature:()
RealPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RealScalar>::type RealPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RealPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacketSize  = Vectorizable ? packet_traits<RealScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
real_ref_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct real_ref_impl$/;"	s	namespace:Eigen::internal
real_ref	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) real_ref(Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(Scalar& x)
real_ref	../include/Eigen/src/Core/MathFunctions.h	/^inline typename add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) >::type real_ref(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
real_ref_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct real_ref_retval$/;"	s	namespace:Eigen::internal
RealReturnType	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type RealReturnType;$/;"	t
real_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct real_retval$/;"	s	namespace:Eigen::internal
RealRowVectorType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, RealScalar>::type RealRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
RealScalar	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LDLT	access:public
RealScalar	../include/Eigen/src/Cholesky/LLT.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::llt_inplace	access:public
RealScalar	../include/Eigen/src/Cholesky/LLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LLT	access:public
RealScalar	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::CholmodBase	access:public
RealScalar	../include/Eigen/src/Core/ArrayBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ArrayBase	access:public
RealScalar	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseBase	access:public
RealScalar	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
RealScalar	../include/Eigen/src/Core/Dot.h	/^  typedef typename NumTraits<typename traits<Derived>::Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::lpNorm_selector	access:public
RealScalar	../include/Eigen/src/Core/IO.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::significant_decimals_default_impl	access:public
RealScalar	../include/Eigen/src/Core/MapBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MapBase	access:public
RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef bool RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_impl	access:public
RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs2_impl	access:public
RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs_impl	access:public
RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::hypot_impl	access:public
RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_impl	access:public
RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_ref_default_impl	access:public
RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::norm1_default_impl	access:public
RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_impl	access:public
RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_ref_impl	access:public
RealScalar	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_default_impl	access:public
RealScalar	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixBase	access:public
RealScalar	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::PlainObjectBase	access:public
RealScalar	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointView	access:public
RealScalar	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::RealScalar RealScalar;$/;"	t	class:Eigen::VectorwiseOp	access:public
RealScalar	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::AlignedBox	access:public
RealScalar	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane	access:public
RealScalar	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
RealScalar	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LU	access:public
RealScalar	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::SVD	access:private
RealScalar	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
RealScalar	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexSchur	access:public
RealScalar	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::EigenSolver	access:public
RealScalar	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::HessenbergDecomposition	access:private
RealScalar	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
RealScalar	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
RealScalar	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Tridiagonalization	access:public
RealScalar	../include/Eigen/src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::Real               RealScalar;$/;"	t	class:Eigen::AlignedBox	access:public
RealScalar	../include/Eigen/src/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane	access:public
RealScalar	../include/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
RealScalar	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
RealScalar	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::QuaternionBase	access:public
RealScalar	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::BiCGSTAB	access:public
RealScalar	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ConjugateGradient	access:public
RealScalar	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::IncompleteLUT	access:private
RealScalar	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::IterativeSolverBase	access:public
RealScalar	../include/Eigen/src/Jacobi/Jacobi.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiRotation	access:public
RealScalar	../include/Eigen/src/LU/FullPivLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::FullPivLU	access:public
RealScalar	../include/Eigen/src/LU/PartialPivLU.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::partial_lu_impl	access:public
RealScalar	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::PartialPivLU	access:public
RealScalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLDLT	access:protected
RealScalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLLT	access:protected
RealScalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLU	access:protected
RealScalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
RealScalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoImpl	access:public
RealScalar	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::PastixBase	access:public
RealScalar	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
RealScalar	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
RealScalar	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
RealScalar	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::HouseholderQR	access:public
RealScalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholesky	access:public
RealScalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
RealScalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLDLT	access:public
RealScalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLLT	access:public
RealScalar	../include/Eigen/src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector	access:public
RealScalar	../include/Eigen/src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator	access:public
RealScalar	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::CompressedStorage	access:protected
RealScalar	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SparseMatrixBase	access:public
RealScalar	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename ResultType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector	access:public
RealScalar	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperILU	access:public
RealScalar	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLU	access:public
RealScalar	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLUBase	access:public
RealScalar	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
RealScalar	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiSVD	access:public
RealScalar	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
RealScalar	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::UmfPackLU	access:public
RealSchur	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur(const MatrixType& matrix, bool computeU = true)$/;"	f	class:Eigen::RealSchur	access:public	signature:(const MatrixType& matrix, bool computeU = true)
RealSchur	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::RealSchur	access:public	signature:(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)
RealSchur	../include/Eigen/src/Eigenvalues/RealSchur.h	/^template<typename _MatrixType> class RealSchur$/;"	c	namespace:Eigen
RealVectorType	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type RealVectorType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
rebind	../include/Eigen/src/Core/util/Memory.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator	access:public
rebind	../include/Eigen/src/StlSupport/details.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator_indirection	access:public
reconstructedMatrix	../include/Eigen/src/Cholesky/LDLT.h	/^MatrixType LDLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LDLT	signature:() const
reconstructedMatrix	../include/Eigen/src/Cholesky/LDLT.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::LDLT	access:public	signature:() const
reconstructedMatrix	../include/Eigen/src/Cholesky/LLT.h	/^MatrixType LLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LLT	signature:() const
reconstructedMatrix	../include/Eigen/src/Cholesky/LLT.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::LLT	access:public	signature:() const
reconstructedMatrix	../include/Eigen/src/LU/FullPivLU.h	/^MatrixType FullPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::FullPivLU	signature:() const
reconstructedMatrix	../include/Eigen/src/LU/FullPivLU.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::FullPivLU	access:public	signature:() const
reconstructedMatrix	../include/Eigen/src/LU/PartialPivLU.h	/^MatrixType PartialPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::PartialPivLU	signature:() const
reconstructedMatrix	../include/Eigen/src/LU/PartialPivLU.h	/^    MatrixType reconstructedMatrix() const;$/;"	p	class:Eigen::PartialPivLU	access:public	signature:() const
reduceToTriangularForm	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^void ComplexSchur<MatrixType>::reduceToTriangularForm(bool computeU)$/;"	f	class:Eigen::ComplexSchur	signature:(bool computeU)
reduceToTriangularForm	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    void reduceToTriangularForm(bool computeU);$/;"	p	class:Eigen::ComplexSchur	access:private	signature:(bool computeU)
redux_impl	../include/Eigen/src/Core/Redux.h	/^struct redux_impl<Func,Derived, DefaultTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal	inherits:redux_novec_unroller
redux_impl	../include/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, DefaultTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	../include/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	../include/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	../include/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, SliceVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux	../include/Eigen/src/Core/DenseBase.h	/^    redux(const BinaryOp& func) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const BinaryOp& func) const
redux	../include/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::redux(const Func& func) const$/;"	f	class:Eigen::DenseBase	signature:(const Func& func) const
redux	../include/Eigen/src/Core/VectorwiseOp.h	/^    redux(const BinaryOp& func = BinaryOp()) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(const BinaryOp& func = BinaryOp()) const
redux_novec_unroller	../include/Eigen/src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 0>$/;"	s	namespace:Eigen::internal
redux_novec_unroller	../include/Eigen/src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
redux_novec_unroller	../include/Eigen/src/Core/Redux.h	/^struct redux_novec_unroller$/;"	s	namespace:Eigen::internal
ReduxReturnType	../include/Eigen/src/Core/VectorwiseOp.h	/^    template<typename BinaryOp> struct ReduxReturnType$/;"	s	class:Eigen::VectorwiseOp	access:public
redux_traits	../include/Eigen/src/Core/Redux.h	/^struct redux_traits$/;"	s	namespace:Eigen::internal
redux_vec_unroller	../include/Eigen/src/Core/Redux.h	/^struct redux_vec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
redux_vec_unroller	../include/Eigen/src/Core/Redux.h	/^struct redux_vec_unroller$/;"	s	namespace:Eigen::internal
reference	../include/Eigen/src/Core/util/Memory.h	/^    typedef T&        reference;$/;"	t	class:Eigen::aligned_allocator	access:public
reference	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Scalar reference;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func	access:public
reference	../include/Eigen/src/StlSupport/details.h	/^    typedef T&        reference;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
remove_all	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	../include/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	../include/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	s	namespace:Eigen::internal
remove_const	../include/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	../include/Eigen/src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	s	namespace:Eigen::internal
RemovedBits	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RemovedBits = ~(EvalToRowMajor ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon17
remove_pointer	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_pointer	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_pointer	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_reference	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_reference	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	s	namespace:Eigen::internal
replicate	../include/Eigen/src/Core/DenseBase.h	/^    const Replicate<Derived,Dynamic,Dynamic> replicate(Index rowFacor,Index colFactor) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rowFacor,Index colFactor) const
replicate	../include/Eigen/src/Core/DenseBase.h	/^    const Replicate<Derived,RowFactor,ColFactor> replicate() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
replicate	../include/Eigen/src/Core/Replicate.h	/^DenseBase<Derived>::replicate() const$/;"	f	class:Eigen::DenseBase	signature:() const
replicate	../include/Eigen/src/Core/Replicate.h	/^DenseBase<Derived>::replicate(Index rowFactor,Index colFactor) const$/;"	f	class:Eigen::DenseBase	signature:(Index rowFactor,Index colFactor) const
Replicate	../include/Eigen/src/Core/Replicate.h	/^    inline explicit Replicate(const OriginalMatrixType& matrix)$/;"	f	class:Eigen::Replicate	access:public	signature:(const OriginalMatrixType& matrix)
Replicate	../include/Eigen/src/Core/Replicate.h	/^    inline Replicate(const OriginalMatrixType& matrix, Index rowFactor, Index colFactor)$/;"	f	class:Eigen::Replicate	access:public	signature:(const OriginalMatrixType& matrix, Index rowFactor, Index colFactor)
Replicate	../include/Eigen/src/Core/Replicate.h	/^template<typename MatrixType,int RowFactor,int ColFactor> class Replicate$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
replicate	../include/Eigen/src/Core/Replicate.h	/^VectorwiseOp<ExpressionType,Direction>::replicate(Index factor) const$/;"	f	class:Eigen::VectorwiseOp	signature:(Index factor) const
replicate	../include/Eigen/src/Core/VectorwiseOp.h	/^    const ReplicateReturnType replicate(Index factor) const;$/;"	p	class:Eigen::VectorwiseOp	access:public	signature:(Index factor) const
replicate	../include/Eigen/src/Core/VectorwiseOp.h	/^    replicate(Index factor = Factor) const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(Index factor = Factor) const
ReplicateReturnType	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef Replicate<ExpressionType,Direction==Vertical?Dynamic:1,Direction==Horizontal?Dynamic:1> ReplicateReturnType;$/;"	t	class:Eigen::VectorwiseOp	access:public
RequireInitialization	../include/Eigen/src/Core/NumTraits.h	/^    RequireInitialization = internal::is_arithmetic<T>::value ? 0 : 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon277
reserve	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    void reserve(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t size)
reserve	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::Scalar& enableif = typename SizesType::Scalar())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SizesType& reserveSizes, const typename SizesType::Scalar& enableif = typename SizesType::Scalar())
reserve	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::value_type& enableif = typename SizesType::value_type())$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SizesType& reserveSizes, const typename SizesType::value_type& enableif = typename SizesType::value_type())
reserve	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes);$/;"	p	class:Eigen::SparseMatrix	access:public	signature:(const SizesType& reserveSizes)
reserve	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(Index reserveSize)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index reserveSize)
reserve	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline void reserve(Index reserveSize) { m_data.reserve(reserveSize); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index reserveSize)
reserveInnerVectors	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserveInnerVectors(const SizesType& reserveSizes)$/;"	f	class:Eigen::SparseMatrix	access:protected	signature:(const SizesType& reserveSizes)
res	../include/Eigen/src/Core/Visitor.h	/^  Scalar res;$/;"	m	struct:Eigen::internal::coeff_visitor	access:public
Res	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseResType>::type Res;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
resize_columns	splib_utils.cpp	/^resize_columns ( CompCol_Mat_double &M, int new_size )$/;"	f
resize	../include/Eigen/src/Core/DenseBase.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
resize	../include/Eigen/src/Core/DenseBase.h	/^    void resize(Index size)$/;"	f	class:Eigen::DenseBase	access:public	signature:(Index size)
resize	../include/Eigen/src/Core/DenseStorage.h	/^    EIGEN_STRONG_INLINE void resize(DenseIndex size, DenseIndex, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex, DenseIndex cols)
resize	../include/Eigen/src/Core/DenseStorage.h	/^    EIGEN_STRONG_INLINE void resize(DenseIndex size, DenseIndex rows, DenseIndex)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex rows, DenseIndex)
resize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void resize(DenseIndex, DenseIndex, DenseIndex cols) { m_cols = cols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex, DenseIndex cols)
resize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void resize(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex,DenseIndex,DenseIndex)
resize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void resize(DenseIndex, DenseIndex rows, DenseIndex cols) { m_rows = rows; m_cols = cols; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex rows, DenseIndex cols)
resize	../include/Eigen/src/Core/DenseStorage.h	/^    inline void resize(DenseIndex, DenseIndex rows, DenseIndex) { m_rows = rows; }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex, DenseIndex rows, DenseIndex)
resize	../include/Eigen/src/Core/DenseStorage.h	/^    void resize(DenseIndex size, DenseIndex rows, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseIndex size, DenseIndex rows, DenseIndex cols)
resize	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline void resize(Index size) { m_diagonal.resize(size); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index size)
resize	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline void resize(Index size)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index size)
resize	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resize(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
resize	../include/Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(Index rows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, NoChange_t)
resize	../include/Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(Index size)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index size)
resize	../include/Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(NoChange_t, Index cols)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(NoChange_t, Index cols)
resize	../include/Eigen/src/Core/Transpositions.h	/^    inline void resize(int size)$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:(int size)
resize	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void resize(Index size)$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:(Index size)
resize	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    void resize(size_t size, float reserveSizeFactor = 0)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t size, float reserveSizeFactor = 0)
resize	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index rows, Index cols)
resize	../include/Eigen/src/SparseCore/SparseVector.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index newSize)
resize	../include/Eigen/src/SparseCore/SparseVector.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index rows, Index cols)
resize	../include/Eigen/src/StlSupport/StdDeque.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::deque	access:private	signature:(size_type new_size, const value_type& x)
resize	../include/Eigen/src/StlSupport/StdDeque.h	/^  void resize(size_type new_size)$/;"	f	class:std::deque	access:private	signature:(size_type new_size)
resize	../include/Eigen/src/StlSupport/StdList.h	/^    void resize(size_type new_size, const value_type& x)$/;"	f	class:std::list	access:private	signature:(size_type new_size, const value_type& x)
resize	../include/Eigen/src/StlSupport/StdList.h	/^    void resize(size_type new_size)$/;"	f	class:std::list	access:private	signature:(size_type new_size)
resize	../include/Eigen/src/StlSupport/StdVector.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::vector	access:private	signature:(size_type new_size, const value_type& x)
resize	../include/Eigen/src/StlSupport/StdVector.h	/^  void resize(size_type new_size)$/;"	f	class:std::vector	access:private	signature:(size_type new_size)
resizeLike	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(const EigenBase<OtherDerived>& _other)
resizeNonZeros	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void resizeNonZeros(Index size)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index size)
resizeNonZeros	../include/Eigen/src/SparseCore/SparseVector.h	/^    void resizeNonZeros(Index size) { m_data.resize(size); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index size)
_resize_to_match	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const EigenBase<OtherDerived>& other)
ResPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
ResPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,ScalarPacket,Scalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
_ResPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
ResPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResPacket ResPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
ResPacket	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
_ResPacket	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
ResPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Traits::ResPacketSize$/;"	e	enum:Eigen::internal::gebp_kernel::__anon99
ResPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
ResPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
ResPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize   = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
ResPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
ResPacketSize	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon91
ResPacketSize	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon92
ResScalar	../include/Eigen/src/Core/Dot.h	/^  typedef typename scalar_product_traits<typename traits<T>::Scalar,typename traits<U>::Scalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::dot_nocheck	access:public
ResScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      ResScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
ResScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  ResScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
ResScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
ResScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
ResScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef           Scalar      ResScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
ResScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product	access:public
ResScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product	access:public
ResScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_triangular_product	access:public
ResScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::tribb_kernel	access:public
ResScalar	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
ResScalar	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::triangular_matrix_vector_product	access:public
restart	../include/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::restart()$/;"	f	class:Eigen::internal::AmbiVector	signature:()
restart	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void restart();$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:()
ResultAlignment	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^    ResultAlignment     = bool(ResultType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon398
ResultAlignment	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^    ResultAlignment = bool(ResultType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon399
ResultMode	../include/Eigen/src/Geometry/Transform.h	/^  enum { ResultMode = transform_product_result<LhsMode,RhsMode>::Mode };$/;"	e	enum:Eigen::internal::transform_transform_product_impl::__anon379
result_of	../include/Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType0,ArgType1)> {$/;"	s	namespace:Eigen::internal
result_of	../include/Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType)> {$/;"	s	namespace:Eigen::internal
result_of	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct result_of {};$/;"	s	namespace:Eigen::internal
ResultScalar	../include/Eigen/src/Householder/HouseholderSequence.h	/^    ResultScalar;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type	access:public
result_type	../include/Eigen/src/Core/Functors.h	/^  typedef NewType result_type;$/;"	t	struct:Eigen::internal::scalar_cast_op	access:public
result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs2_op	access:public
result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs_op	access:public
result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_op	access:public
result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_ref_op	access:public
result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_op	access:public
result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_ref_op	access:public
result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_conj_product_op	access:public
result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_product_op	access:public
result_type	../include/Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<Scalar1,Scalar2>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_multiple2_op	access:public
result_type	../include/Eigen/src/Core/VectorwiseOp.h	/^                   >::type  result_type;$/;"	t	struct:Eigen::internal::member_redux	access:public
ResultType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
ResultType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
ResultType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef typename ProductReturnType<MatrixType,Other>::Type ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
ResultType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
ResultType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,ResultMode,LhsOptions> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
ResultType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Projective,Options> ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
ResultType	../include/Eigen/src/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
ResultType	../include/Eigen/src/Geometry/Transform.h	/^  typedef typename MatrixType::PlainObject ResultType;$/;"	t	struct:Eigen::internal::transform_right_product_impl	access:public
ResultType	../include/Eigen/src/Geometry/Transform.h	/^    typedef typename ProductType::ResultType ResultType;$/;"	t	struct:Eigen::Transform::icc_11_workaround	access:public
ret	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon367
ret	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon369
ret	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::InnerStrideAtCompileTime };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon366
ret	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::OuterStrideAtCompileTime };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon368
ret	../include/Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_allows_mixing_real_and_complex { enum { ret = 0 }; };$/;"	e	enum:Eigen::internal::functor_allows_mixing_real_and_complex::__anon324
ret	../include/Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon322
ret	../include/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_allows_mixing_real_and_complex::__anon326
ret	../include/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_allows_mixing_real_and_complex::__anon325
ret	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon323
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon126
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon125
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon127
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon135
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon134
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon136
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon129
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon138
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon137
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon143
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon146
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon133
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon141
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon144
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon139
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon128
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon132
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon142
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon145
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon131
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon140
ret	../include/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon130
ret	../include/Eigen/src/Core/Transpose.h	/^  enum { ret =    bool(blas_traits<DerivedA>::IsTransposed) != DestIsTransposed$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon75
ret	../include/Eigen/src/Core/Transpose.h	/^  enum { ret = bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed };$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon74
ret	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^  enum { ret = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0 };$/;"	e	enum:Eigen::internal::has_direct_access::__anon205
ret	../include/Eigen/src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:Eigen::meta_sqrt::__anon196
ret	../include/Eigen/src/Core/util/Meta.h	/^{ enum { ret = false }; };$/;"	e	enum:Eigen::is_diagonal::__anon197
ret	../include/Eigen/src/Core/util/Meta.h	/^    enum { ret = meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::internal::__anon195
ret	../include/Eigen/src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon198
ret	../include/Eigen/src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon199
ret	../include/Eigen/src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon200
ret	../include/Eigen/src/Eigen2Support/Meta.h	/^class ei_meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:ei_meta_sqrt::__anon430
ret	../include/Eigen/src/Eigen2Support/Meta.h	/^    enum { ret = ei_meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::__anon429
ret	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_false { enum { ret = 0 }; };$/;"	e	enum:Eigen::ei_meta_false::__anon426
ret	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if <false, Then, Else> { typedef Else ret; };$/;"	t	struct:Eigen::ei_meta_if	access:public
ret	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if { typedef Then ret; };$/;"	t	struct:Eigen::ei_meta_if	access:public
ret	../include/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_true {  enum { ret = 1 }; };$/;"	e	enum:Eigen::ei_meta_true::__anon425
ret	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_is_same_type<T,T> { enum { ret = 1 }; };$/;"	e	enum:Eigen::ei_is_same_type::__anon428
ret	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T, typename U> struct ei_is_same_type { enum { ret = 0 }; };$/;"	e	enum:Eigen::ei_is_same_type::__anon427
ret	../include/Eigen/src/Householder/Householder.h	/^    ret = n==Dynamic ? n : n-1$/;"	e	enum:Eigen::internal::decrement_size::__anon9
ret	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^{ typedef Sparse ret; };$/;"	t	struct:Eigen::internal::promote_storage_type	access:public
ret	../include/Eigen/src/SVD/JacobiSVD.h	/^         ret = !( (QRPreconditioner == NoQRPreconditioner) ||$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon414
ReturnByValue	../include/Eigen/src/Core/ReturnByValue.h	/^template<typename Derived> class ReturnByValue$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
ReturnOpposite	../include/Eigen/src/Core/BandMatrix.h	/^        ReturnOpposite = (Options&SelfAdjoint) && (((Index)>0 && Supers==0) || ((Index)<0 && Subs==0)),$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon80
ReturnType	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/Core/ReturnByValue.h	/^    typedef typename internal::traits<Derived>::ReturnType ReturnType;$/;"	t	class:Eigen::ReturnByValue	access:public
ReturnType	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename internal::plain_matrix_type_column_major<Rhs>::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/Core/Transpositions.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/Core/util/Meta.h	/^  typedef std::complex<T> ReturnType;$/;"	t	struct:Eigen::scalar_product_traits	access:public
ReturnType	../include/Eigen/src/Core/util/Meta.h	/^  typedef T ReturnType;$/;"	t	struct:Eigen::scalar_product_traits	access:public
ReturnType	../include/Eigen/src/Core/VectorwiseOp.h	/^                      typename Scalar=typename internal::traits<ExpressionType>::Scalar> struct ReturnType$/;"	s	class:Eigen::VectorwiseOp	access:public
ReturnType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^  typedef MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/Geometry/Homogeneous.h	/^                 MatrixTypeCleaned::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/Geometry/Homogeneous.h	/^                 Rhs::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,1> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector	access:public
ReturnType	../include/Eigen/src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,Dim> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector	access:public
ReturnType	../include/Eigen/src/Geometry/RotationBase.h	/^  typedef Transform<Scalar,Dim,Affine> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector	access:public
ReturnType	../include/Eigen/src/LU/Inverse.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/misc/Image.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/misc/Kernel.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/misc/Solve.h	/^                 Rhs::MaxColsAtCompileTime> ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/misc/SparseSolve.h	/^                 Rhs::MaxColsAtCompileTime> ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/misc/SparseSolve.h	/^  typedef SparseMatrix<typename Rhs::Scalar, Rhs::Options, typename Rhs::Index> ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
ReturnType	../include/Eigen/src/SparseCore/SparsePermutation.h	/^        SparseMatrix<Scalar,int(SrcStorageOrder)==RowMajor?ColMajor:RowMajor,Index> >::type ReturnType;$/;"	t	struct:Eigen::internal::traits	access:public
retval	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar retval;$/;"	t	struct:Eigen::internal::atan2_default_impl	access:public
retval	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar retval;$/;"	t	struct:Eigen::internal::pow_default_impl	access:public
ReverseCol	../include/Eigen/src/Core/Reverse.h	/^      ReverseCol = (Direction == Horizontal) || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon116
reverse	../include/Eigen/src/Core/DenseBase.h	/^    ConstReverseReturnType reverse() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
reverse	../include/Eigen/src/Core/DenseBase.h	/^    ReverseReturnType reverse();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
reverse	../include/Eigen/src/Core/Reverse.h	/^DenseBase<Derived>::reverse() const$/;"	f	class:Eigen::DenseBase	signature:() const
reverse	../include/Eigen/src/Core/Reverse.h	/^DenseBase<Derived>::reverse()$/;"	f	class:Eigen::DenseBase	signature:()
Reverse	../include/Eigen/src/Core/Reverse.h	/^    inline Reverse(const MatrixType& matrix) : m_matrix(matrix) { }$/;"	f	class:Eigen::Reverse	access:public	signature:(const MatrixType& matrix)
Reverse	../include/Eigen/src/Core/Reverse.h	/^template<typename MatrixType, int Direction> class Reverse$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
reverse	../include/Eigen/src/Core/VectorwiseOp.h	/^    const Reverse<ExpressionType, Direction> reverse() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
ReverseInnerIterator	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix<Scalar,_Flags,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::MappedSparseMatrix
ReverseInnerIterator	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    ReverseInnerIterator(const MappedSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:(const MappedSparseMatrix& mat, Index outer)
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseBlock.h	/^    class ReverseInnerIterator: public MatrixType::ReverseInnerIterator$/;"	c	class:Eigen::SparseInnerVectorSet	inherits:MatrixType::ReverseInnerIterator	access:public
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseBlock.h	/^        inline ReverseInnerIterator(const SparseInnerVectorSet& xpr, Index outer)$/;"	f	class:Eigen::SparseInnerVectorSet::ReverseInnerIterator	access:public	signature:(const SparseInnerVectorSet& xpr, Index outer)
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::CwiseUnaryOpImpl	inherits:CwiseUnaryOpImpl::MatrixTypeReverseIterator
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::CwiseUnaryViewImpl	inherits:CwiseUnaryViewImpl::MatrixTypeReverseIterator
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:public	signature:(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::SparseMatrix
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    ReverseInnerIterator(const SparseMatrix& mat, Index outer)$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:(const SparseMatrix& mat, Index outer)
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const TransposeImpl& xpr, typename TransposeImpl<MatrixType,Sparse>::Index outer)$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator	access:public	signature:(const TransposeImpl& xpr, typename TransposeImpl<MatrixType,Sparse>::Index outer)
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::TransposeImpl	inherits:_MatrixTypeNested::ReverseInnerIterator
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^class SparseTriangularView<MatrixType,Mode>::ReverseInnerIterator : public MatrixTypeNestedCleaned::ReverseInnerIterator$/;"	c	class:Eigen::SparseTriangularView	inherits:MatrixTypeNestedCleaned::ReverseInnerIterator
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const SparseTriangularView& view, Index outer)$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:(const SparseTriangularView& view, Index outer)
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseVector.h	/^class SparseVector<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::SparseVector
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseVector.h	/^    ReverseInnerIterator(const internal::CompressedStorage<Scalar,Index>& data)$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:(const internal::CompressedStorage<Scalar,Index>& data)
ReverseInnerIterator	../include/Eigen/src/SparseCore/SparseVector.h	/^    ReverseInnerIterator(const SparseVector& vec, Index outer=0)$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:(const SparseVector& vec, Index outer=0)
reverseInPlace	../include/Eigen/src/Core/DenseBase.h	/^    void reverseInPlace();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
reverseInPlace	../include/Eigen/src/Core/Reverse.h	/^inline void DenseBase<Derived>::reverseInPlace()$/;"	f	class:Eigen::DenseBase	signature:()
reverse_packet_cond	../include/Eigen/src/Core/Reverse.h	/^template<typename PacketScalar, bool ReversePacket> struct reverse_packet_cond$/;"	s	namespace:Eigen::internal
reverse_packet_cond	../include/Eigen/src/Core/Reverse.h	/^template<typename PacketScalar> struct reverse_packet_cond<PacketScalar,false>$/;"	s	namespace:Eigen::internal
ReversePacket	../include/Eigen/src/Core/Reverse.h	/^      ReversePacket = (Direction == BothDirections)$/;"	e	enum:Eigen::Reverse::__anon116
reverse_packet	../include/Eigen/src/Core/Reverse.h	/^    typedef internal::reverse_packet_cond<PacketScalar,ReversePacket> reverse_packet;$/;"	t	class:Eigen::Reverse	access:protected
ReverseReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef Reverse<Derived, BothDirections> ReverseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
ReverseRow	../include/Eigen/src/Core/Reverse.h	/^      ReverseRow = (Direction == Vertical)   || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon116
RhsBlasTraits	../include/Eigen/src/Core/ProductBase.h	/^    typedef internal::blas_traits<_RhsNested> RhsBlasTraits;$/;"	t	class:Eigen::ProductBase	access:public
RhsCleaned	../include/Eigen/src/Core/Product.h	/^  typedef typename remove_all<Rhs>::type RhsCleaned;$/;"	t	struct:internal::traits	access:public
RhsCoeffReadCost	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon65
RhsCoeffReadCost	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon87
RhsCoeffReadCost	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    RhsCoeffReadCost = traits<_RhsNested>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon30
RhsCoeffReadCost	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon17
RhsFlags	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon65
RhsFlags	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon87
RhsFlags	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon17
rhs	../include/abcd.h	/^    double *rhs;$/;"	m	class:abcd	access:public
rhs	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
_Rhs	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::product_type	access:public
rhs	../include/Eigen/src/Core/ProductBase.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
Rhs	../include/Eigen/src/Core/ProductBase.h	/^  typedef typename remove_all<_Rhs>::type Rhs;$/;"	t	struct:Eigen::internal::traits	access:public
rhs	../include/Eigen/src/Core/Product.h	/^    const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	class:Product	access:public	signature:() const
rhs	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
Rhs	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Rhs	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
Rhs	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,RhsMode,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl	access:public
rhs	../include/Eigen/src/misc/Solve.h	/^  inline const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
rhs	../include/Eigen/src/misc/SparseSolve.h	/^  inline const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
rhs	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
Rhs	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseRhsType>::type Rhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl	access:public
rhs	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
_Rhs	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::traits	access:public
rhs	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
RhsIsSelfAdjoint	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsSelfAdjoint = (RhsMode&SelfAdjoint)==SelfAdjoint$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon112
RhsIsUpper	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsUpper = (RhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon112
RhsIsVectorAtCompileTime	../include/Eigen/src/Core/SolveTriangular.h	/^      RhsIsVectorAtCompileTime = (Side==OnTheLeft ? Rhs::ColsAtCompileTime : Rhs::RowsAtCompileTime)==1$/;"	e	enum:Eigen::internal::trsolve_traits::__anon362
RhsIterator	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename _RhsNested::InnerIterator RhsIterator;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
rhs_length	../include/Eigen/src/Core/products/Parallelizer.h	/^  Index rhs_length;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
RhsMode	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      RhsMode = internal::is_diagonal<_RhsNested>::ret ? internal::SDP_IsDiagonal$/;"	e	enum:Eigen::SparseDiagonalProduct::__anon37
RhsNestedCleaned	../include/Eigen/src/Core/Product.h	/^    typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;$/;"	t	class:Product	access:public
RhsNestedCleaned	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::triangular_solve_retval	access:public
RhsNestedCleaned	../include/Eigen/src/misc/Solve.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::solve_retval_base	access:public
RhsNestedCleaned	../include/Eigen/src/misc/SparseSolve.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base	access:public
RhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::nested<Rhs>::type RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
_RhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp	access:public
_RhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
RhsNested	../include/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
RhsNested	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef typename internal::nested<Rhs, Lhs::RowsAtCompileTime, typename internal::plain_matrix_type<Rhs>::type >::type RhsNested;$/;"	t	struct:Eigen::ProductReturnType	access:public
_RhsNested	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::ProductBase	access:public
RhsNested	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Eigen::ProductBase	access:public
RhsNested	../include/Eigen/src/Core/Product.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Product	access:public
_RhsNested	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef typename internal::traits<CoeffBasedProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
_RhsNested	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
RhsNested	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNested;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl	access:public
_RhsNested	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::_RhsNested _RhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
RhsNested	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::RhsNested RhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
_RhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
RhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
_RhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::_RhsNested _RhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
RhsNested	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::RhsNested RhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:private
_RhsNested	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
RhsNested	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct	access:private
_RhsNested	../include/Eigen/src/SparseCore/SparseProduct.h	/^    typedef typename internal::traits<SparseSparseProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::SparseSparseProduct	access:private
_RhsNested	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits	access:public
RhsNested	../include/Eigen/src/SparseCore/SparseProduct.h	/^    typename internal::nested<Rhs,Lhs::RowsAtCompileTime>::type>::type RhsNested;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
RhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
_RhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RhsPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::RhsPacket RhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
RhsPacket	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
_RhsPacket	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product	access:public
RhsPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
RhsPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
RhsPacketSize	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
RhsPacketSize	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon91
RhsPacketSize	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon92
RhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = ResPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
RhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = RhsPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
RhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = RhsPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
RhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress   = Traits::RhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon99
RhsProgress	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = Vectorizable ? 2*ResPacketSize : 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
RhsRowMajor	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      RhsRowMajor = RhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon87
RhsRowMajor	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RhsRowMajor = internal::traits<Rhs>::Flags & RowMajorBit,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon16
RhsScalar	../include/Eigen/src/Core/GeneralProduct.h	/^    typedef typename Rhs::Scalar RhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
RhsScalar	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::traits<Rhs>::Scalar RhsScalar;$/;"	t	class:Eigen::ProductBase	access:public
RhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RhsScalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
RhsScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::level3_blocking	access:private
RhsScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_LhsScalar,_RhsScalar>::type RhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space	access:private
RhsScalar	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename  Rhs::Scalar RhsScalar;$/;"	t	class:Eigen::GeneralProduct	access:public
RhsScalar	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar RhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
rhs_start	../include/Eigen/src/Core/products/Parallelizer.h	/^  Index rhs_start;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
RhsUpLo	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^    RhsUpLo = RhsMode&(Upper|Lower)$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon114
RhsVectors	../include/Eigen/src/Core/SolveTriangular.h	/^      RhsVectors  = RhsIsVectorAtCompileTime ? 1 : Dynamic$/;"	e	enum:Eigen::internal::trsolve_traits::__anon363
rightCols	../include/Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr rightCols(Index n)$/;"	f	signature:(Index n)
rightCols	../include/Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr rightCols(Index n) const$/;"	f	signature:(Index n) const
rightCols	../include/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type rightCols() const$/;"	f	signature:() const
rightCols	../include/Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type rightCols()$/;"	f	signature:()
rightHouseholderSequence	../include/Eigen/src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType,OnTheRight> rightHouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen	signature:(const VectorsType& v, const CoeffsType& h)
rotate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& rotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
rotate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
rotate	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& rotate(const RotationType& rotation);$/;"	p	class:Eigen::Transform	access:public	signature:(const RotationType& rotation)
rotate	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform	signature:(const RotationType& rotation)
Rotation2Dd	../include/Eigen/src/Eigen2Support/Geometry/All.h	27;"	d
Rotation2Dd	../include/Eigen/src/Eigen2Support/Geometry/All.h	82;"	d
Rotation2Dd	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Rotation2Dd	../include/Eigen/src/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Rotation2Df	../include/Eigen/src/Eigen2Support/Geometry/All.h	26;"	d
Rotation2Df	../include/Eigen/src/Eigen2Support/Geometry/All.h	81;"	d
Rotation2Df	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
Rotation2Df	../include/Eigen/src/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
Rotation2D	../include/Eigen/src/Eigen2Support/Geometry/All.h	25;"	d
Rotation2D	../include/Eigen/src/Eigen2Support/Geometry/All.h	80;"	d
Rotation2D	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen	inherits:RotationBase
Rotation2D	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D<OtherScalarType>& other)
Rotation2D	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D(Scalar a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D	access:public	signature:(Scalar a)
Rotation2D	../include/Eigen/src/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen	inherits:RotationBase
Rotation2D	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D	access:public	signature:(const Rotation2D<OtherScalarType>& other)
Rotation2D	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D(Scalar a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D	access:public	signature:(Scalar a)
rotation_base_generic_product_selector	../include/Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector< RotationDerived, DiagonalMatrix<Scalar,Dim,MaxDim>, false >$/;"	s	namespace:Eigen::internal
rotation_base_generic_product_selector	../include/Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,MatrixType,false>$/;"	s	namespace:Eigen::internal
rotation_base_generic_product_selector	../include/Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,OtherVectorType,true>$/;"	s	namespace:Eigen::internal
RotationBase	../include/Eigen/src/Eigen2Support/Geometry/All.h	24;"	d
RotationBase	../include/Eigen/src/Eigen2Support/Geometry/All.h	79;"	d
RotationBase	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
RotationBase	../include/Eigen/src/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
rotation	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  LinearMatrixType rotation() const;$/;"	p	class:Eigen::Transform	access:public	signature:() const
rotation	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::rotation() const$/;"	f	class:Eigen::Transform	signature:() const
rotation	../include/Eigen/src/Geometry/Transform.h	/^  const LinearMatrixType rotation() const;$/;"	p	class:Eigen::Transform	access:public	signature:() const
rotation	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotation() const$/;"	f	class:Eigen::Transform	signature:() const
RotationMatrixType	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase	access:public
RotationMatrixType	../include/Eigen/src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase	access:public
row	../include/Eigen/src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::all_unroller::__anon226
row	../include/Eigen/src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::any_unroller::__anon227
row	../include/Eigen/src/Core/SelfAdjointView.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon85
row	../include/Eigen/src/Core/SelfAdjointView.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon86
row	../include/Eigen/src/Core/TriangularMatrix.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon236
row	../include/Eigen/src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor	access:public
row	../include/Eigen/src/Core/Visitor.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::visitor_impl::__anon51
row	../include/Eigen/src/plugins/BlockMethods.h	/^inline ConstRowXpr row(Index i) const$/;"	f	signature:(Index i) const
row	../include/Eigen/src/plugins/BlockMethods.h	/^inline RowXpr row(Index i)$/;"	f	signature:(Index i)
row	../include/Eigen/src/SparseCore/CoreIterators.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::row(Index i) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index i) const
row	../include/Eigen/src/SparseCore/SparseBlock.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::SparseInnerVectorSet::InnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseBlock.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::SparseInnerVectorSet::ReverseInnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::row(Index i)$/;"	f	class:Eigen::SparseMatrixBase	signature:(Index i)
row	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return Lhs::IsRowMajor ? m_lhsIter.row() : index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_lhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_rhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Index row() const { return Transpose ? Base::row() : m_outer; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,1> row(Index i) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index i) const
row	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,1> row(Index i);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index i)
row	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    inline typename TransposeImpl<MatrixType,Sparse>::Index row() const { return Base::col(); }$/;"	f	class:Eigen::TransposeImpl::InnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseTranspose.h	/^    inline typename TransposeImpl<MatrixType,Sparse>::Index row() const { return Base::col(); }$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index row() const { return Base::row(); }$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index row() const { return Base::row(); }$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseUtil.h	/^  const Index& row() const { return m_row; }$/;"	f	class:Eigen::Triplet	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index row() const { return IsColVector ? index() : 0; }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
row	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Index row() const { return IsColVector ? index() : 0; }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
rowIndexByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner) const
RowMajorBit	../include/Eigen/src/Core/util/Constants.h	/^const unsigned int RowMajorBit = 0x1;$/;"	m	namespace:Eigen
RowMajor	../include/Eigen/src/Core/util/Constants.h	/^  RowMajor = 0x1,  \/\/ it is only a coincidence that this is equal to RowMajorBit -- don't rely on that$/;"	e	enum:Eigen::__anon212
rowPrefix	../include/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
RowsAtCompileTime	../include/Eigen/src/Cholesky/LDLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon405
RowsAtCompileTime	../include/Eigen/src/Cholesky/LLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon403
RowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
RowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon81
RowsAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon82
RowsAtCompileTime	../include/Eigen/src/Core/Block.h	/^    RowsAtCompileTime = MatrixRows == 0 ? 0 : BlockRows,$/;"	e	enum:Eigen::internal::traits::__anon228
RowsAtCompileTime	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    RowsAtCompileTime = traits<Ancestor>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon64
RowsAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon216
RowsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^      RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon279
RowsAtCompileTime	../include/Eigen/src/Core/DiagonalMatrix.h	/^    RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon281
RowsAtCompileTime	../include/Eigen/src/Core/DiagonalProduct.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon77
RowsAtCompileTime	../include/Eigen/src/Core/MapBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon76
RowsAtCompileTime	../include/Eigen/src/Core/Matrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon289
RowsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^    RowsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon118
RowsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon117
RowsAtCompileTime	../include/Eigen/src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon119
RowsAtCompileTime	../include/Eigen/src/Core/ProductBase.h	/^    RowsAtCompileTime = traits<Lhs>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon288
RowsAtCompileTime	../include/Eigen/src/Core/Product.h	/^    RowsAtCompileTime = LhsCleaned::RowsAtCompileTime,$/;"	e	enum:internal::traits::__anon48
RowsAtCompileTime	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      RowsAtCompileTime = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon87
RowsAtCompileTime	../include/Eigen/src/Core/Replicate.h	/^    RowsAtCompileTime = RowFactor==Dynamic || int(MatrixType::RowsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon67
RowsAtCompileTime	../include/Eigen/src/Core/Reverse.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon115
RowsAtCompileTime	../include/Eigen/src/Core/Select.h	/^    RowsAtCompileTime = ConditionMatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon60
RowsAtCompileTime	../include/Eigen/src/Core/Transpose.h	/^    RowsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon73
RowsAtCompileTime	../include/Eigen/src/Core/TriangularMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon233
RowsAtCompileTime	../include/Eigen/src/Core/VectorwiseOp.h	/^    RowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon68
RowsAtCompileTime	../include/Eigen/src/Eigen2Support/Minor.h	/^    RowsAtCompileTime = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon441
RowsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon43
RowsAtCompileTime	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon41
RowsAtCompileTime	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon44
RowsAtCompileTime	../include/Eigen/src/Eigenvalues/RealSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon39
RowsAtCompileTime	../include/Eigen/src/Geometry/Homogeneous.h	/^    RowsAtCompileTime = Direction==Vertical  ?  RowsPlusOne : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon390
RowsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^      RowsAtCompileTime = internal::traits<HouseholderSequence>::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon8
RowsAtCompileTime	../include/Eigen/src/Householder/HouseholderSequence.h	/^    RowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon7
RowsAtCompileTime	../include/Eigen/src/LU/FullPivLU.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon395
RowsAtCompileTime	../include/Eigen/src/LU/PartialPivLU.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon394
RowsAtCompileTime	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon4
RowsAtCompileTime	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon6
RowsAtCompileTime	../include/Eigen/src/QR/HouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon5
RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseBlock.h	/^    RowsAtCompileTime = IsRowMajor ? Size : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon20
RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    RowsAtCompileTime    = Tr ? int(traits<Rhs>::RowsAtCompileTime)     : int(traits<Lhs>::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon30
RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    RowsAtCompileTime = _Lhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon35
RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon31
RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon32
RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseProduct.h	/^    RowsAtCompileTime    = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon17
RowsAtCompileTime	../include/Eigen/src/SparseCore/SparseVector.h	/^    RowsAtCompileTime = IsColVector ? Dynamic : 1,$/;"	e	enum:Eigen::internal::traits::__anon25
RowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon415
RowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon416
RowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon417
RowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon418
RowsAtCompileTime	../include/Eigen/src/SVD/JacobiSVD.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon419
RowsAtCompileTime	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon420
RowsBlockXpr	../include/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowsBlockXpr;$/;"	t
rowSeparator	../include/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
rows	../include/Eigen/src/Cholesky/LDLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LDLT	access:public	signature:() const
rows	../include/Eigen/src/Cholesky/LLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LLT	access:public	signature:() const
rows	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    inline Index rows() const { return m_cholmodFactor->n; }$/;"	f	class:Eigen::CholmodBase	access:public	signature:() const
rows	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:() const
rows	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:() const
rows	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
rows	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
rows	../include/Eigen/src/Core/Block.h	/^    inline Index rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::Block	access:public	signature:() const
rows	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const {$/;"	f	class:Eigen::CwiseBinaryOp	access:public	signature:() const
rows	../include/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::CwiseNullaryOp	access:public	signature:() const
rows	../include/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::CwiseUnaryOp	access:public	signature:() const
rows	../include/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::CwiseUnaryView	access:public	signature:() const
rows	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseIndex rows(void) const {return m_rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
rows	../include/Eigen/src/Core/DenseStorage.h	/^    inline DenseIndex rows(void) const {return _Rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void) const
rows	../include/Eigen/src/Core/DenseStorage.h	/^    static inline DenseIndex rows(void) {return _Rows;}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(void)
rows	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline Index rows() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
rows	../include/Eigen/src/Core/DiagonalProduct.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::DiagonalProduct	access:public	signature:() const
rows	../include/Eigen/src/Core/EigenBase.h	/^  inline Index rows() const { return derived().rows(); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
rows	../include/Eigen/src/Core/Flagged.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Flagged	access:public	signature:() const
rows	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:() const
Rows	../include/Eigen/src/Core/GeneralProduct.h	/^    Rows  = _Lhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon122
rows	../include/Eigen/src/Core/MapBase.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::MapBase	access:public	signature:() const
rows	../include/Eigen/src/Core/NestByValue.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::NestByValue	access:public	signature:() const
rows	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Index rows() const { return indices().size(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
rows	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::permut_matrix_product_retval	access:public	signature:() const
rows	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline int rows() const { return m_permutation.rows(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
rows	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:() const
rows	../include/Eigen/src/Core/ProductBase.h	/^    inline Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::ProductBase	access:public	signature:() const
rows	../include/Eigen/src/Core/Product.h	/^    inline Index rows() const { return m_lhs.rows(); }$/;"	f	class:Product	access:public	signature:() const
rows	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::CoeffBasedProduct	access:public	signature:() const
rows	../include/Eigen/src/Core/Replicate.h	/^    inline Index rows() const { return m_matrix.rows() * m_rowFactor.value(); }$/;"	f	class:Eigen::Replicate	access:public	signature:() const
rows	../include/Eigen/src/Core/ReturnByValue.h	/^    inline Index rows() const { return static_cast<const Derived*>(this)->rows(); }$/;"	f	class:Eigen::ReturnByValue	access:public	signature:() const
rows	../include/Eigen/src/Core/Reverse.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Reverse	access:public	signature:() const
rows	../include/Eigen/src/Core/Select.h	/^    Index rows() const { return m_condition.rows(); }$/;"	f	class:Eigen::Select	access:public	signature:() const
rows	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:() const
rows	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:() const
rows	../include/Eigen/src/Core/SolveTriangular.h	/^  inline Index rows() const { return m_rhs.rows(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:() const
rows	../include/Eigen/src/Core/Swap.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::SwapWrapper	access:public	signature:() const
rows	../include/Eigen/src/Core/Transpose.h	/^    inline Index rows() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
rows	../include/Eigen/src/Core/Transpositions.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:() const
rows	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
rows	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
rows	../include/Eigen/src/Core/VectorwiseOp.h	/^    Index rows() const { return (Direction==Vertical   ? 1 : m_matrix.rows()); }$/;"	f	class:Eigen::PartialReduxExpr	access:public	signature:() const
rows	../include/Eigen/src/Eigen2Support/Minor.h	/^    inline Index rows() const { return m_matrix.rows() - 1; }$/;"	f	class:Eigen::Minor	access:public	signature:() const
rows	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    Index rows() const { return m_hess.packedMatrix().rows(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType	access:public	signature:() const
rows	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:() const
rows	../include/Eigen/src/Geometry/Homogeneous.h	/^  inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl	access:public	signature:() const
rows	../include/Eigen/src/Geometry/Homogeneous.h	/^  inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl	access:public	signature:() const
rows	../include/Eigen/src/Geometry/Homogeneous.h	/^    inline Index rows() const { return m_matrix.rows() + (int(Direction)==Vertical   ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous	access:public	signature:() const
Rows	../include/Eigen/src/Geometry/Transform.h	/^    Rows = int(Mode)==(AffineCompact) ? Dim : HDim$/;"	e	enum:Eigen::Transform::__anon374
rows	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Index rows() const { return Side==OnTheLeft ? m_vectors.rows() : m_vectors.cols(); }$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
rows	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index rows() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:() const
rows	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:() const
rows	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index rows() const { return mp_matrix ? mp_matrix->rows() : 0; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
rows	../include/Eigen/src/LU/FullPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
rows	../include/Eigen/src/LU/Inverse.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::inverse_impl	access:public	signature:() const
rows	../include/Eigen/src/LU/PartialPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::PartialPivLU	access:public	signature:() const
rows	../include/Eigen/src/misc/Image.h	/^  inline Index rows() const { return m_dec.rows(); }$/;"	f	struct:Eigen::internal::image_retval_base	access:public	signature:() const
rows	../include/Eigen/src/misc/Kernel.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::kernel_retval_base	access:public	signature:() const
rows	../include/Eigen/src/misc/Solve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:() const
rows	../include/Eigen/src/misc/SparseSolve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:() const
rows	../include/Eigen/src/misc/SparseSolve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:() const
rows	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl	access:public	signature:() const
rows	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PastixBase	access:public	signature:() const
rows	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
rows	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public	signature:() const
rows	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
rows	../include/Eigen/src/QR/HouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::HouseholderQR	access:public	signature:() const
rows	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return Tr ? m_rhs.rows() : m_lhs.rows(); }$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsColVector ? m_size : 1; }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
rows	../include/Eigen/src/SparseCore/SparseView.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseView	access:public	signature:() const
rows	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SuperLUBase	access:public	signature:() const
rows	../include/Eigen/src/SVD/JacobiSVD.h	/^    inline Index rows() const { return m_rows; }$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
rows	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline Index rows() const { return m_copyMatrix.rows(); }$/;"	f	class:Eigen::UmfPackLU	access:public	signature:() const
rowSpacer	../include/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
RowsPlusOne	../include/Eigen/src/Geometry/Homogeneous.h	/^    RowsPlusOne = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon390
rows_select	../include/Eigen/src/Core/GeneralProduct.h	/^    rows_select = product_size_category<Rows,MaxRows>::value,$/;"	e	enum:Eigen::internal::product_type::__anon123
rowsTranspositions	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    const IntColVectorType& rowsTranspositions() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
rowStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index rowStride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
rowStride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void rowStride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
rowSuffix	../include/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat	access:public
RowType	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowType;$/;"	t	class:Eigen::JacobiSVD	access:public
RowVector	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::ColsAtCompileTime, 1> RowVector;$/;"	t	class:Eigen::SVD	access:private
RowVectorType	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<Scalar, 1, MatrixType::ColsAtCompileTime, MatrixType::Options, 1, MatrixType::MaxColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::LU	access:public
RowVectorType	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
RowVectorType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
RowVectorType	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::HouseholderQR	access:public
RowVectorType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, 1, ColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
rowwise	../include/Eigen/src/Core/DenseBase.h	/^    ConstRowwiseReturnType rowwise() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
rowwise	../include/Eigen/src/Core/DenseBase.h	/^    RowwiseReturnType rowwise();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
rowwise	../include/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise() const$/;"	f	class:Eigen::DenseBase	signature:() const
rowwise	../include/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise()$/;"	f	class:Eigen::DenseBase	signature:()
RowwiseReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;$/;"	t	class:Eigen::DenseBase	access:public
RowXpr	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::RowXpr RowXpr;$/;"	t	class:Eigen::MatrixBase	access:public
RowXpr	../include/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowXpr;$/;"	t
run	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2cf& first, const Packet2cf& second)
run	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4f& first, const Packet4f& second)
run	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4i& first, const Packet4i& second)
run	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE static void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2cf& first, const Packet2cf& second)
run	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet1cd& , const Packet1cd& )
run	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2cf& first, const Packet2cf& second)
run	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet2d& first, const Packet2d& second)
run	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4f& first, const Packet4f& second)
run	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(Packet4i& first, const Packet4i& second)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_DONT_INLINE void run(const Derived& src, OtherDerived& dst, typename Derived::Index start, typename Derived::Index end)$/;"	f	struct:Eigen::internal::unaligned_assign_impl	access:public	signature:(const Derived& src, OtherDerived& dst, typename Derived::Index start, typename Derived::Index end)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.eval()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose().eval()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose()); }$/;"	f	struct:Eigen::internal::assign_selector	access:public	signature:(Derived& dst, const OtherDerived& other)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(const Derived&, OtherDerived&, typename Derived::Index, typename Derived::Index) {}$/;"	f	struct:Eigen::internal::unaligned_assign_impl	access:public	signature:(const Derived&, OtherDerived&, typename Derived::Index, typename Derived::Index)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling	access:public	signature:(Derived1 &, const Derived2 &)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_innervec_CompleteUnrolling	access:public	signature:(Derived1 &, const Derived2 &)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_LinearTraversal_CompleteUnrolling	access:public	signature:(Derived1 &, const Derived2 &)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &, int) {}$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_InnerUnrolling	access:public	signature:(Derived1 &, const Derived2 &, int)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &, int) {}$/;"	f	struct:Eigen::internal::assign_innervec_InnerUnrolling	access:public	signature:(Derived1 &, const Derived2 &, int)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_impl	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_innervec_CompleteUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_LinearTraversal_CompleteUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src, int outer)$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_InnerUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src, int outer)
run	../include/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src, int outer)$/;"	f	struct:Eigen::internal::assign_innervec_InnerUnrolling	access:public	signature:(Derived1 &dst, const Derived2 &src, int outer)
run	../include/Eigen/src/Core/Assign.h	/^  static inline void run(Derived1 &, const Derived2 &) { }$/;"	f	struct:Eigen::internal::assign_impl	access:public	signature:(Derived1 &, const Derived2 &)
run	../include/Eigen/src/Core/Assign.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_impl	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	../include/Eigen/src/Core/Assign_MKL.h	/^  static inline void run(Derived1& dst, const CwiseUnaryOp<UnaryOp, Derived2>& src)$/;"	f	struct:Eigen::internal::vml_assign_impl	access:public	signature:(Derived1& dst, const CwiseUnaryOp<UnaryOp, Derived2>& src)
run	../include/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::all_unroller	access:public	signature:(const Derived &mat)
run	../include/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::any_unroller	access:public	signature:(const Derived &mat)
run	../include/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat) { return mat.coeff(0, 0); }$/;"	f	struct:Eigen::internal::all_unroller	access:public	signature:(const Derived &mat)
run	../include/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat) { return mat.coeff(0, 0); }$/;"	f	struct:Eigen::internal::any_unroller	access:public	signature:(const Derived &mat)
run	../include/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::all_unroller	access:public	signature:(const Derived &)
run	../include/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::any_unroller	access:public	signature:(const Derived &)
run	../include/Eigen/src/Core/CwiseNullaryOp.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& m)$/;"	f	struct:Eigen::internal::setIdentity_impl	access:public	signature:(Derived& m)
run	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  static inline typename Derived::Index run(const Derived&)$/;"	f	struct:Eigen::internal::first_aligned_impl	access:public	signature:(const Derived&)
run	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  static inline typename Derived::Index run(const Derived& m)$/;"	f	struct:Eigen::internal::first_aligned_impl	access:public	signature:(const Derived& m)
run	../include/Eigen/src/Core/Dot.h	/^  static inline RealScalar run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector	access:public	signature:(const MatrixBase<Derived>& m)
run	../include/Eigen/src/Core/Dot.h	/^  static inline ResScalar run(const MatrixBase<T>& a, const MatrixBase<U>& b)$/;"	f	struct:Eigen::internal::dot_nocheck	access:public	signature:(const MatrixBase<T>& a, const MatrixBase<U>& b)
run	../include/Eigen/src/Core/Dot.h	/^  static inline typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector	access:public	signature:(const MatrixBase<Derived>& m)
run	../include/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived&, typename Derived::RealScalar)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector	access:public	signature:(const Derived& x, const OtherDerived&, typename Derived::RealScalar)
run	../include/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, typename Derived::RealScalar)$/;"	f	struct:Eigen::internal::isApprox_selector	access:public	signature:(const Derived& x, const OtherDerived& y, typename Derived::RealScalar)
run	../include/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, typename Derived::RealScalar prec)$/;"	f	struct:Eigen::internal::isApprox_selector	access:public	signature:(const Derived& x, const OtherDerived& y, typename Derived::RealScalar prec)
run	../include/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, typename Derived::RealScalar prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector	access:public	signature:(const Derived& x, const OtherDerived& y, typename Derived::RealScalar prec)
run	../include/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar&, typename Derived::RealScalar)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector	access:public	signature:(const Derived& x, const typename Derived::RealScalar&, typename Derived::RealScalar)
run	../include/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar& y, typename Derived::RealScalar prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector	access:public	signature:(const Derived& x, const typename Derived::RealScalar& y, typename Derived::RealScalar prec)
run	../include/Eigen/src/Core/GeneralProduct.h	/^  static EIGEN_DONT_INLINE void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha) {$/;"	f	struct:Eigen::internal::outer_product_selector	access:public	signature:(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)
run	../include/Eigen/src/Core/GeneralProduct.h	/^  static inline void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)$/;"	f	struct:Eigen::internal::gemv_selector	access:public	signature:(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)
run	../include/Eigen/src/Core/GeneralProduct.h	/^  static void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)$/;"	f	struct:Eigen::internal::gemv_selector	access:public	signature:(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)
run	../include/Eigen/src/Core/GenericPacketMath.h	/^  static inline void run(PacketType&, const PacketType&) {}$/;"	f	struct:Eigen::internal::palign_impl	access:public	signature:(PacketType&, const PacketType&)
run	../include/Eigen/src/Core/IO.h	/^  static inline int run()$/;"	f	struct:Eigen::internal::significant_decimals_default_impl	access:public	signature:()
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline bool run()$/;"	f	struct:Eigen::internal::random_impl	access:public	signature:()
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(const Scalar& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl	access:public	signature:(const Scalar& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline const Scalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(const Scalar&)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline NewType run(const OldType& x)$/;"	f	struct:Eigen::internal::cast_impl	access:public	signature:(const OldType& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_impl	access:public	signature:(const Scalar&)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::hypot_impl	access:public	signature:(const Scalar& x, const Scalar& y)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs2_impl	access:public	signature:(const Scalar& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs_impl	access:public	signature:(const Scalar& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl	access:public	signature:(const Scalar& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_impl	access:public	signature:(const Scalar& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::abs2_impl	access:public	signature:(const std::complex<RealScalar>& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::imag_impl	access:public	signature:(const std::complex<RealScalar>& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::real_impl	access:public	signature:(const std::complex<RealScalar>& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(Scalar& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl	access:public	signature:(Scalar& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar&, const Scalar&)$/;"	f	struct:Eigen::internal::atan2_default_impl	access:public	signature:(const Scalar&, const Scalar&)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar&)$/;"	f	struct:Eigen::internal::sqrt_default_impl	access:public	signature:(const Scalar&)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::atan2_default_impl	access:public	signature:(const Scalar& x, const Scalar& y)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::pow_default_impl	access:public	signature:(const Scalar& x, const Scalar& y)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::random_default_impl	access:public	signature:(const Scalar& x, const Scalar& y)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::conj_impl	access:public	signature:(const Scalar& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl	access:public	signature:(const Scalar& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::sqrt_default_impl	access:public	signature:(const Scalar& x)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run()$/;"	f	struct:Eigen::internal::random_default_impl	access:public	signature:()
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl	access:public	signature:(Scalar&)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar x, Scalar y)$/;"	f	struct:Eigen::internal::pow_default_impl	access:public	signature:(Scalar x, Scalar y)
run	../include/Eigen/src/Core/MathFunctions.h	/^  static inline std::complex<RealScalar> run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::conj_impl	access:public	signature:(const std::complex<RealScalar>& x)
run	../include/Eigen/src/Core/PlainObjectBase.h	/^  static inline void run(MatrixTypeA& a, MatrixTypeB& b)$/;"	f	struct:Eigen::internal::matrix_swap_impl	access:public	signature:(MatrixTypeA& a, MatrixTypeB& b)
run	../include/Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl	access:public	signature:(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)
run	../include/Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index rows, Index cols)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl	access:public	signature:(DenseBase<Derived>& _this, Index rows, Index cols)
run	../include/Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index size)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl	access:public	signature:(DenseBase<Derived>& _this, Index size)
run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)$/;"	f	struct:Eigen::internal::product_packet_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)
run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet& res)$/;"	f	struct:Eigen::internal::product_packet_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet& res)
run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)
run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar& res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar& res)
run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::PacketScalar &pres)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_unroller	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::PacketScalar &pres)
run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index , Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index , Index , const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
run	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index \/*col*\/, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector	access:public	signature:(Index row, Index , const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
run	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, A& a, B& b, C& c, T& \/*t*\/)$/;"	f	struct:Eigen::internal::gebp_madd_selector	access:public	signature:(const CJ& cj, A& a, B& b, C& c, T& )
run	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, T& a, T& b, T& c, T& t)$/;"	f	struct:Eigen::internal::gebp_madd_selector	access:public	signature:(const CJ& cj, T& a, T& b, T& c, T& t)
run	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::general_matrix_matrix_product	access:public	signature:( Index rows, Index cols, Index depth, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha, level3_blocking<RhsScalar,LhsScalar>& blocking, GemmParallelInfo<Index>* info = 0)
run	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^static void run(Index rows, Index cols, Index depth,$/;"	f	struct:Eigen::internal::general_matrix_matrix_product	access:public	signature:(Index rows, Index cols, Index depth, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha, level3_blocking<LhsScalar,RhsScalar>& blocking, GemmParallelInfo<Index>* info = 0)
run	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product	access:public	signature:(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha)
run	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product	access:public	signature:(Index size, Index depth,const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha)
run	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE static void run($/;"	f	struct:Eigen::internal::general_matrix_vector_product	access:public	signature:( Index rows, Index cols, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsIncr, ResScalar* res, Index resIncr, ResScalar alpha)
run	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE static void run($/;"	f	struct:Eigen::internal::general_matrix_vector_product	access:public	signature:( Index rows, Index cols, const LhsScalar* lhs, Index lhsStride, const RhsScalar* rhs, Index rhsIncr, ResScalar* res, Index resIncr , RhsScalar alpha)
run	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::product_selfadjoint_matrix	access:public	signature:( Index rows, Index cols, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, Scalar alpha)
run	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_selfadjoint_matrix	access:public	signature:( Index rows, Index cols, const Scalar* lhs, Index lhsStride, const Scalar* rhs, Index rhsStride, Scalar* res, Index resStride, Scalar alpha)
run	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::selfadjoint_matrix_vector_product	access:public	signature:( Index size, const Scalar* lhs, Index lhsStride, const Scalar* _rhs, Index rhsIncr, Scalar* res, Scalar alpha)
run	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^  static void run(Index size, Scalar* mat, Index stride, const Scalar* vec, Scalar alpha)$/;"	f	struct:Eigen::selfadjoint_rank1_update	access:public	signature:(Index size, Scalar* mat, Index stride, const Scalar* vec, Scalar alpha)
run	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^  static void run(MatrixType& mat, const OtherType& other, typename MatrixType::Scalar alpha)$/;"	f	struct:Eigen::selfadjoint_product_selector	access:public	signature:(MatrixType& mat, const OtherType& other, typename MatrixType::Scalar alpha)
run	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^  static void run(Scalar* mat, Index stride, const UType& u, const VType& v, Scalar alpha)$/;"	f	struct:Eigen::internal::selfadjoint_rank2_update_selector	access:public	signature:(Scalar* mat, Index stride, const UType& u, const VType& v, Scalar alpha)
run	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::product_triangular_matrix_matrix	access:public	signature:( Index _rows, Index _cols, Index _depth, const Scalar* _lhs, Index lhsStride, const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, Scalar alpha)
run	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_triangular_matrix_matrix	access:public	signature:( Index rows, Index cols, Index depth, const Scalar* lhs, Index lhsStride, const Scalar* rhs, Index rhsStride, Scalar* res, Index resStride, Scalar alpha)
run	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^  static EIGEN_DONT_INLINE  void run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::triangular_matrix_vector_product	access:public	signature:(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsIncr, ResScalar* _res, Index resIncr, ResScalar alpha)
run	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^  static void run(const TriangularProduct<Mode,true,Lhs,false,Rhs,true>& prod, Dest& dest, typename TriangularProduct<Mode,true,Lhs,false,Rhs,true>::Scalar alpha)$/;"	f	struct:Eigen::internal::trmv_selector	access:public	signature:(const TriangularProduct<Mode,true,Lhs,false,Rhs,true>& prod, Dest& dest, typename TriangularProduct<Mode,true,Lhs,false,Rhs,true>::Scalar alpha)
run	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^  static void run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::triangular_matrix_vector_product	access:public	signature:(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride, const RhsScalar* _rhs, Index rhsIncr, ResScalar* _res, Index resIncr, ResScalar alpha)
run	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::triangular_solve_matrix	access:public	signature:( Index size, Index cols, const Scalar* tri, Index triStride, Scalar* _other, Index otherStride, level3_blocking<Scalar,Scalar>& blocking)
run	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::triangular_solve_matrix	access:public	signature:( Index size, Index otherSize, const Scalar* _tri, Index triStride, Scalar* _other, Index otherStride, level3_blocking<Scalar,Scalar>& blocking)
run	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^  static void run(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)$/;"	f	struct:Eigen::internal::triangular_solve_vector	access:public	signature:(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)
run	../include/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_vec_unroller	access:public	signature:(const Derived &mat, const Func&)
run	../include/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_vec_unroller	access:public	signature:(const Derived &mat, const Func& func)
run	../include/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived&, const Func&) { return Scalar(); }$/;"	f	struct:Eigen::internal::redux_novec_unroller	access:public	signature:(const Derived&, const Func&)
run	../include/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_novec_unroller	access:public	signature:(const Derived &mat, const Func&)
run	../include/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived& mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl	access:public	signature:(const Derived& mat, const Func& func)
run	../include/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_novec_unroller	access:public	signature:(const Derived &mat, const Func& func)
run	../include/Eigen/src/Core/Redux.h	/^  static Scalar run(const Derived& mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl	access:public	signature:(const Derived& mat, const Func& func)
run	../include/Eigen/src/Core/Reverse.h	/^  static inline PacketScalar run(const PacketScalar& x) { return preverse(x); }$/;"	f	struct:Eigen::internal::reverse_packet_cond	access:public	signature:(const PacketScalar& x)
run	../include/Eigen/src/Core/Reverse.h	/^  static inline PacketScalar run(const PacketScalar& x) { return x; }$/;"	f	struct:Eigen::internal::reverse_packet_cond	access:public	signature:(const PacketScalar& x)
run	../include/Eigen/src/Core/SelfAdjointView.h	/^  static inline void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &, const Derived2 &)
run	../include/Eigen/src/Core/SelfAdjointView.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	../include/Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_selector	access:public	signature:(const Lhs& lhs, Rhs& rhs)
run	../include/Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_unroller	access:public	signature:(const Lhs& lhs, Rhs& rhs)
run	../include/Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs&, Rhs&) {}$/;"	f	struct:Eigen::internal::triangular_solver_unroller	access:public	signature:(const Lhs&, Rhs&)
run	../include/Eigen/src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector	access:public	signature:(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)
run	../include/Eigen/src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const OtherDerived& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector	access:public	signature:(const Scalar* dest, const OtherDerived& src)
run	../include/Eigen/src/Core/Transpose.h	/^    static void run(const Derived&, const OtherDerived&)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl	access:public	signature:(const Derived&, const OtherDerived&)
run	../include/Eigen/src/Core/Transpose.h	/^    static void run(const Derived& dst, const OtherDerived& other)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl	access:public	signature:(const Derived& dst, const OtherDerived& other)
run	../include/Eigen/src/Core/Transpose.h	/^  static void run(MatrixType& m) {$/;"	f	struct:Eigen::internal::inplace_transpose_selector	access:public	signature:(MatrixType& m)
run	../include/Eigen/src/Core/TriangularMatrix.h	/^  static inline void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &, const Derived2 &)
run	../include/Eigen/src/Core/TriangularMatrix.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::triangular_assignment_selector	access:public	signature:(Derived1 &dst, const Derived2 &src)
run	../include/Eigen/src/Core/util/BlasUtil.h	/^  static const typename T::Scalar* run(const T& m)$/;"	f	struct:Eigen::internal::extract_data_selector	access:public	signature:(const T& m)
run	../include/Eigen/src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE To run(const From& x) { return x; }$/;"	f	struct:Eigen::internal::get_factor	access:public	signature:(const From& x)
run	../include/Eigen/src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE typename NumTraits<Scalar>::Real run(const Scalar& x) { return real(x); }$/;"	f	struct:Eigen::internal::get_factor	access:public	signature:(const Scalar& x)
run	../include/Eigen/src/Core/util/BlasUtil.h	/^  static typename T::Scalar* run(const T&) { return 0; }$/;"	f	struct:Eigen::internal::extract_data_selector	access:public	signature:(const T&)
run	../include/Eigen/src/Core/util/Memory.h	/^  static inline void run(const T* start, const T* end, T* target)$/;"	f	struct:Eigen::internal::smart_copy_helper	access:public	signature:(const T* start, const T* end, T* target)
run	../include/Eigen/src/Core/Visitor.h	/^  static inline void run(const Derived &mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl	access:public	signature:(const Derived &mat, Visitor& visitor)
run	../include/Eigen/src/Core/Visitor.h	/^  static inline void run(const Derived& mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl	access:public	signature:(const Derived& mat, Visitor& visitor)
run	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  static inline void run(Quaternion<Scalar>& q, const Other& mat)$/;"	f	struct:Eigen::ei_quaternion_assign_impl	access:public	signature:(Quaternion<Scalar>& q, const Other& mat)
run	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  static inline void run(Quaternion<Scalar>& q, const Other& vec)$/;"	f	struct:Eigen::ei_quaternion_assign_impl	access:public	signature:(Quaternion<Scalar>& q, const Other& vec)
run	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^    static inline void run(Transform *transform, const MatrixBase<OtherDerived>& other)$/;"	f	struct:Eigen::Transform::construct_from_matrix	access:public	signature:(Transform *transform, const MatrixBase<OtherDerived>& other)
run	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  static ResultType run(const TransformType& tr, const Other& other)$/;"	f	struct:Eigen::ei_transform_product_impl	access:public	signature:(const TransformType& tr, const Other& other)
run	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^  static void run(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)$/;"	f	struct:Eigen::internal::complex_schur_reduce_to_hessenberg	access:public	signature:(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)
run	../include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^  run(const MatrixBase<Derived>& m)$/;"	f	class:Eigen::internal::eigenvalues_selector::MatrixBase	access:public	signature:(const MatrixBase<Derived>& m)
run	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& eig, const typename SolverType::MatrixType& A, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(SolverType& eig, const typename SolverType::MatrixType& A, int options)
run	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& solver, const MatrixType& mat, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public	signature:(SolverType& solver, const MatrixType& mat, int options)
run	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public	signature:(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)
run	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public	signature:(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
run	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl	access:public	signature:(const VectorLhs& lhs, const VectorRhs& rhs)
run	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<double> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product	access:public	signature:(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)
run	../include/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<float> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product	access:public	signature:(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)
run	../include/Eigen/src/Geometry/Homogeneous.h	/^  static const type& run (const TransformType& x) { return x.matrix(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product	access:public	signature:(const TransformType& x)
run	../include/Eigen/src/Geometry/Homogeneous.h	/^  static const type& run(const type &x) { return x; }$/;"	f	struct:Eigen::internal::take_matrix_for_product	access:public	signature:(const type &x)
run	../include/Eigen/src/Geometry/Homogeneous.h	/^  static type run (const TransformType& x) { return x.affine(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product	access:public	signature:(const TransformType& x)
run	../include/Eigen/src/Geometry/OrthoMethods.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl	access:public	signature:(const VectorLhs& lhs, const VectorRhs& rhs)
run	../include/Eigen/src/Geometry/OrthoMethods.h	/^  static inline VectorType run(const Derived& src)$/;"	f	struct:Eigen::internal::unitOrthogonal_selector	access:public	signature:(const Derived& src)
run	../include/Eigen/src/Geometry/Quaternion.h	/^  static EIGEN_STRONG_INLINE Quaternion<Scalar> run(const QuaternionBase<Derived1>& a, const QuaternionBase<Derived2>& b){$/;"	f	struct:Eigen::internal::quat_product	access:public	signature:(const QuaternionBase<Derived1>& a, const QuaternionBase<Derived2>& b)
run	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> static inline void run(QuaternionBase<Derived>& q, const Other& mat)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl	access:public	signature:(QuaternionBase<Derived>& q, const Other& mat)
run	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> static inline void run(QuaternionBase<Derived>& q, const Other& vec)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl	access:public	signature:(QuaternionBase<Derived>& q, const Other& vec)
run	../include/Eigen/src/Geometry/RotationBase.h	/^  static EIGEN_STRONG_INLINE ReturnType run(const RotationDerived& r, const OtherVectorType& v)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector	access:public	signature:(const RotationDerived& r, const OtherVectorType& v)
run	../include/Eigen/src/Geometry/RotationBase.h	/^  static inline ReturnType run(const RotationDerived& r, const DiagonalMatrix<Scalar,Dim,MaxDim>& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector	access:public	signature:(const RotationDerived& r, const DiagonalMatrix<Scalar,Dim,MaxDim>& m)
run	../include/Eigen/src/Geometry/RotationBase.h	/^  static inline ReturnType run(const RotationDerived& r, const MatrixType& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector	access:public	signature:(const RotationDerived& r, const MatrixType& m)
run	../include/Eigen/src/Geometry/Transform.h	/^  static EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)$/;"	f	struct:Eigen::internal::transform_right_product_impl	access:public	signature:(const TransformType& T, const MatrixType& other)
run	../include/Eigen/src/Geometry/Transform.h	/^  static inline AffinePart run(MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(MatrixType& m)
run	../include/Eigen/src/Geometry/Transform.h	/^  static inline ConstAffinePart run(const MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(const MatrixType& m)
run	../include/Eigen/src/Geometry/Transform.h	/^  static inline const MatrixType& run(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(const MatrixType& m)
run	../include/Eigen/src/Geometry/Transform.h	/^  static inline MatrixType& run(MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part	access:public	signature:(MatrixType& m)
run	../include/Eigen/src/Geometry/Transform.h	/^  static inline void run(const TransformType& m, TransformType& res)$/;"	f	struct:Eigen::internal::projective_transform_inverse	access:public	signature:(const TransformType& m, TransformType& res)
run	../include/Eigen/src/Geometry/Transform.h	/^  static inline void run(const TransformType&, TransformType&)$/;"	f	struct:Eigen::internal::projective_transform_inverse	access:public	signature:(const TransformType&, TransformType&)
run	../include/Eigen/src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,AffineCompact,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix	access:public	signature:(Transform<typename Other::Scalar,Dim,AffineCompact,Options> *transform, const Other& other)
run	../include/Eigen/src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,Mode,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix	access:public	signature:(Transform<typename Other::Scalar,Dim,Mode,Options> *transform, const Other& other)
run	../include/Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::transform_transform_product_impl	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
run	../include/Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Other& other, const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl	access:public	signature:(const Other& other, const TransformType& tr)
run	../include/Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Other& other,const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl	access:public	signature:(const Other& other,const TransformType& tr)
run	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4	access:public	signature:(const MatrixType& matrix, ResultType& result)
run	../include/Eigen/src/LU/Determinant.h	/^  static inline typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl	access:public	signature:(const Derived& m)
run	../include/Eigen/src/LU/Determinant.h	/^  static typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl	access:public	signature:(const Derived& m)
run	../include/Eigen/src/LU/Inverse.h	/^  static inline void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse	access:public	signature:(const MatrixType& matrix, ResultType& result)
run	../include/Eigen/src/LU/Inverse.h	/^  static inline void run($/;"	f	struct:Eigen::internal::compute_inverse_and_det_with_check	access:public	signature:( const MatrixType& matrix, const typename MatrixType::RealScalar& absDeterminantThreshold, ResultType& inverse, typename ResultType::Scalar& determinant, bool& invertible )
run	../include/Eigen/src/LU/Inverse.h	/^  static inline void run($/;"	f	struct:Eigen::internal::compute_inverse_and_det_with_check	access:public	signature:( const MatrixType& matrix, const typename MatrixType::RealScalar& absDeterminantThreshold, ResultType& result, typename ResultType::Scalar& determinant, bool& invertible )
run	../include/Eigen/src/LU/Inverse.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4	access:public	signature:(const MatrixType& matrix, ResultType& result)
run	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    static Index run( _MKL_DSS_HANDLE_t pt, Index maxfct, Index mnum, Index type, Index phase, Index n, void *a,$/;"	f	struct:Eigen::internal::pardiso_run_selector	access:public	signature:( _MKL_DSS_HANDLE_t pt, Index maxfct, Index mnum, Index type, Index phase, Index n, void *a, Index *ia, Index *ja, Index *perm, Index nrhs, Index *iparm, Index msglvl, void *b, void *x)
run	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res)
run	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void run(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, typename Res::Scalar alpha)$/;"	f	struct:Eigen::internal::sparse_time_dense_product_impl	access:public	signature:(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, typename Res::Scalar alpha)
run	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res, RealScalar tolerance)$/;"	f	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector	access:public	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res, RealScalar tolerance)
run	../include/Eigen/src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_selector	access:public	signature:(const Lhs& lhs, Rhs& other)
run	../include/Eigen/src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_sparse_selector	access:public	signature:(const Lhs& lhs, Rhs& other)
run	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static void run(MatrixType& mat, SluMatrix& res)$/;"	f	struct:Eigen::SluMatrixMapHelper	access:public	signature:(MatrixType& mat, SluMatrix& res)
run	../include/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)
run	../include/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)
run	../include/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)
run	../include/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)$/;"	f	class:Eigen::internal::qr_preconditioner_impl	access:public	signature:(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)
run	../include/Eigen/src/SVD/JacobiSVD.h	/^  static void run(typename SVD::WorkMatrixType&, SVD&, Index, Index) {}$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public	signature:(typename SVD::WorkMatrixType&, SVD&, Index, Index)
run	../include/Eigen/src/SVD/JacobiSVD.h	/^  static void run(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q)$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public	signature:(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q)
samax	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(samax) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
SameType	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon65
SameType	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon87
_SameTypes	../include/Eigen/src/Core/DiagonalProduct.h	/^    _SameTypes = is_same<typename MatrixType::Scalar, typename DiagonalType::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon77
samin	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(samin) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
sample	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType sample() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
sasum	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(sasum) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
saxpy	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(saxpy) (int *, float  *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *, float *, int *)
scalar_abs2_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_abs2_op {$/;"	s	namespace:Eigen::internal
scalar_abs_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_abs_op {$/;"	s	namespace:Eigen::internal
scalar_acos_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_acos_op {$/;"	s	namespace:Eigen::internal
scalar_add_op	../include/Eigen/src/Core/Functors.h	/^  inline scalar_add_op(const scalar_add_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const scalar_add_op& other)
scalar_add_op	../include/Eigen/src/Core/Functors.h	/^  inline scalar_add_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_add_op	access:public	signature:(const Scalar& other)
scalar_add_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_add_op {$/;"	s	namespace:Eigen::internal
ScalarAddReturnType	../include/Eigen/src/Eigen2Support/Cwise.h	/^    typedef CwiseUnaryOp<internal::scalar_add_op<Scalar>, ExpressionType> ScalarAddReturnType;$/;"	t	class:Eigen::Cwise	access:public
scalar_asin_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_asin_op {$/;"	s	namespace:Eigen::internal
scalar_binary_pow_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar, typename OtherScalar> struct scalar_binary_pow_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_and_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_boolean_and_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_or_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_boolean_or_op {$/;"	s	namespace:Eigen::internal
scalar_cast_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_cast_op {$/;"	s	namespace:Eigen::internal
ScalarCoeffImpl	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^                                   _LhsNested, _RhsNested, Scalar> ScalarCoeffImpl;$/;"	t	class:Eigen::CoeffBasedProduct	access:private
scalar_conj_product_op	../include/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_conj_product_op {$/;"	s	namespace:Eigen::internal
scalar_conjugate_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_conjugate_op {$/;"	s	namespace:Eigen::internal
scalar_constant_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(const scalar_constant_op& other)
scalar_constant_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_constant_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op	access:public	signature:(const Scalar& other)
scalar_constant_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_constant_op {$/;"	s	namespace:Eigen::internal
scalar_cos_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_cos_op {$/;"	s	namespace:Eigen::internal
scalar_cube_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_cube_op {$/;"	s	namespace:Eigen::internal
scalar_difference_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_difference_op {$/;"	s	namespace:Eigen::internal
scalar_exp_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_exp_op {$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl {};$/;"	s	namespace:Eigen::internal
scalar_fuzzy_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_impl : scalar_fuzzy_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:scalar_fuzzy_default_impl
scalar_fuzzy_impl	../include/Eigen/src/Core/MathFunctions.h	/^template<> struct scalar_fuzzy_impl<bool>$/;"	s	namespace:Eigen::internal
scalar_hypot_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_hypot_op {$/;"	s	namespace:Eigen::internal
scalar_identity_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_identity_op {$/;"	s	namespace:Eigen::internal
scalar_imag_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_imag_op {$/;"	s	namespace:Eigen::internal
scalar_imag_ref_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_imag_ref_op {$/;"	s	namespace:Eigen::internal
Scalar	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LDLT	access:public
Scalar	../include/Eigen/src/Cholesky/LLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LLT	access:public
Scalar	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::CholmodBase	access:public
Scalar	../include/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::ArrayBase	access:public
Scalar	../include/Eigen/src/Core/Assign_MKL.h	/^  typedef typename Derived1::Scalar Scalar;$/;"	t	struct:Eigen::internal::vml_assign_impl	access:public
Scalar	../include/Eigen/src/Core/BandMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrix	access:public
Scalar	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixWrapper	access:public
Scalar	../include/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixBase	access:public
Scalar	../include/Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/CommaInitializer.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::CommaInitializer	access:public
Scalar	../include/Eigen/src/Core/CwiseBinaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/CwiseUnaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/CwiseUnaryView.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseBase	access:public
Scalar	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
Scalar	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalMatrix	access:public
Scalar	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	class:Eigen::DiagonalBase	access:public
Scalar	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/DiagonalProduct.h	/^  typedef typename scalar_product_traits<typename MatrixType::Scalar, typename DiagonalType::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/MapBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::MapBase	access:public
Scalar	../include/Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MapBase	access:public
Scalar	../include/Eigen/src/Core/Map.h	/^  typedef typename PlainObjectType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/MatrixBase.h	/^      typedef typename internal::scalar_product_traits<typename internal::traits<Derived>::Scalar,typename internal::traits<OtherDerived>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type	access:public
Scalar	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MatrixBase	access:public
Scalar	../include/Eigen/src/Core/Matrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/NoAlias.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::NoAlias	access:private
Scalar	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PermutationBase	access:public
Scalar	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::Transpose	access:public
Scalar	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::PlainObjectBase	access:public
Scalar	../include/Eigen/src/Core/ProductBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::ScaledProduct	access:public
Scalar	../include/Eigen/src/Core/ProductBase.h	/^  typedef typename scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/Product.h	/^  typedef typename scalar_product_traits<typename traits<LhsCleaned>::Scalar, typename traits<RhsCleaned>::Scalar>::ReturnType Scalar;$/;"	t	struct:internal::traits	access:public
Scalar	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename scalar_product_traits<typename _LhsNested::Scalar, typename _RhsNested::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  Scalar;$/;"	t	class:Eigen::internal::gebp_traits	access:public
Scalar	../include/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_impl	access:public
Scalar	../include/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_novec_unroller	access:public
Scalar	../include/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller	access:public
Scalar	../include/Eigen/src/Core/Replicate.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/Reverse.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::Scalar Scalar; $/;"	t	class:Eigen::SelfAdjointView	access:public
Scalar	../include/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector	access:public
Scalar	../include/Eigen/src/Core/Transpose.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Derived1::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_assignment_selector	access:public
Scalar	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::TriangularBase	access:public
Scalar	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Scalar Scalar;$/;"	t	class:Eigen::TriangularView	access:public
Scalar	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef std::complex<RealScalar> Scalar;$/;"	t	struct:Eigen::internal::conj_helper	access:public
Scalar	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename NestedXpr::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Scalar	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits	access:public
Scalar	../include/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::VectorwiseOp	access:public
Scalar	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::result_type Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::coeff_visitor	access:public
Scalar	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::max_coeff_visitor	access:public
Scalar	../include/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::min_coeff_visitor	access:public
Scalar	../include/Eigen/src/Eigen2Support/Cwise.h	/^    typedef typename internal::traits<ExpressionType>::Scalar Scalar;$/;"	t	class:Eigen::Cwise	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AlignedBox	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::ei_quaternion_assign_impl	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    typedef typename ei_traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Scaling	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
Scalar	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation	access:public
Scalar	../include/Eigen/src/Eigen2Support/LU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LU	access:public
Scalar	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SVD	access:private
Scalar	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexEigenSolver	access:public
Scalar	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexSchur	access:public
Scalar	../include/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::EigenSolver	access:public
Scalar	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HessenbergDecomposition	access:public
Scalar	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealSchur	access:public
Scalar	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
Scalar	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::Scalar Scalar;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
Scalar	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::Tridiagonalization	access:public
Scalar	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector	access:public
Scalar	../include/Eigen/src/Geometry/AlignedBox.h	/^  typedef _Scalar                                   Scalar;$/;"	t	class:Eigen::AlignedBox	access:public
Scalar	../include/Eigen/src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis	access:public
Scalar	../include/Eigen/src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane	access:public
Scalar	../include/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename traits<Derived>::Scalar Scalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Scalar	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine	access:public
Scalar	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::Map	access:public
Scalar	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion	access:public
Scalar	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::QuaternionBase	access:public
Scalar	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl	access:public
Scalar	../include/Eigen/src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D	access:public
Scalar	../include/Eigen/src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/Geometry/RotationBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase	access:public
Scalar	../include/Eigen/src/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::UniformScaling	access:public
Scalar	../include/Eigen/src/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform	access:public
Scalar	../include/Eigen/src/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation	access:public
Scalar	../include/Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename internal::traits<HouseholderSequence>::Scalar Scalar;$/;"	t	class:Eigen::HouseholderSequence	access:private
Scalar	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalPreconditioner	access:private
Scalar	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::BiCGSTAB	access:public
Scalar	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ConjugateGradient	access:public
Scalar	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::IncompleteLUT	access:private
Scalar	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::IterativeSolverBase	access:public
Scalar	../include/Eigen/src/LU/FullPivLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivLU	access:public
Scalar	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PartialPivLU	access:public
Scalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLDLT	access:protected
Scalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLLT	access:protected
Scalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLU	access:protected
Scalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pardiso_traits	access:public
Scalar	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PardisoImpl	access:public
Scalar	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PastixBase	access:public
Scalar	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pastix_traits	access:public
Scalar	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ColPivHouseholderQR	access:public
Scalar	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivHouseholderQR	access:public
Scalar	../include/Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HouseholderQR	access:public
Scalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Scalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
Scalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Scalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLLT	access:public
Scalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                             Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                         Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector	access:public
Scalar	../include/Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator	access:public
Scalar	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::CompressedStorage	access:public
Scalar	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename LhsCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public
Scalar	../include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector	access:public
Scalar	../include/Eigen/src/SparseCore/CoreIterators.h	/^    typedef typename Derived::Scalar Scalar;$/;"	t	class:Eigen::DenseBase::InnerIterator	access:protected
Scalar	../include/Eigen/src/SparseCore/SparseBlock.h	/^  typedef typename traits<MatrixType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename CwiseBinaryXpr::Scalar Scalar;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Scalar	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::Scalar Scalar;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:private
Scalar	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:private
Scalar	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:private
Scalar	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:private
Scalar	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:private
Scalar	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^                                            typename traits<Rhs>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename _Lhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Scalar	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeNestedCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval	access:public
Scalar	../include/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename MatrixTypeNestedCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename internal::traits<Lhs>::Scalar Scalar;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
Scalar	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename _LhsNested::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
Scalar	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
Scalar	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector	access:public
_Scalar	../include/Eigen/src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::plain_matrix_type	access:public
_Scalar	../include/Eigen/src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
Scalar	../include/Eigen/src/SparseCore/SparseVector.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits	access:public
Scalar	../include/Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_selector	access:public
Scalar	../include/Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector	access:public
Scalar	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperILU	access:public
Scalar	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperLU	access:public
Scalar	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SuperLUBase	access:public
Scalar	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
Scalar	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::JacobiSVD	access:public
Scalar	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
Scalar	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
Scalar	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::UmfPackLU	access:public
scalar_inverse_mult_op	../include/Eigen/src/Core/Functors.h	/^  scalar_inverse_mult_op(const Scalar& other) : m_other(other) {}$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op	access:public	signature:(const Scalar& other)
scalar_inverse_mult_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_inverse_mult_op {$/;"	s	namespace:Eigen::internal
scalar_inverse_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_inverse_op {$/;"	s	namespace:Eigen::internal
ScalarIsComplex	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^      ScalarIsComplex = NumTraits<Scalar>::IsComplex$/;"	e	enum:Eigen::PardisoImpl::__anon400
scalar_log_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_log_op {$/;"	s	namespace:Eigen::internal
scalar_max_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_max_op {$/;"	s	namespace:Eigen::internal
scalar_max_op	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_BINOP_RETURN_TYPE(internal::scalar_max_op)$/;"	f	class:Eigen::Cwise	access:public	signature:(max) const
scalar_min_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_min_op {$/;"	s	namespace:Eigen::internal
scalar_min_op	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_BINOP_RETURN_TYPE(internal::scalar_min_op)$/;"	f	class:Eigen::Cwise	access:public	signature:(min) const
scalar_multiple2_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple2_op(const Scalar2& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_multiple2_op	access:public	signature:(const Scalar2& other)
scalar_multiple2_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple2_op(const scalar_multiple2_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_multiple2_op	access:public	signature:(const scalar_multiple2_op& other)
scalar_multiple2_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_multiple2_op {$/;"	s	namespace:Eigen::internal
scalar_multiple_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple_op(const scalar_multiple_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const scalar_multiple_op& other)
scalar_multiple_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_multiple_op	access:public	signature:(const Scalar& other)
scalar_multiple_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_multiple_op {$/;"	s	namespace:Eigen::internal
ScalarMultipleReturnType	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_multiple_op<Scalar>, const Derived> ScalarMultipleReturnType;$/;"	t
scalar_opposite_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_opposite_op {$/;"	s	namespace:Eigen::internal
ScalarPacket	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type     ScalarPacket;$/;"	t	class:Eigen::internal::gebp_traits	access:public
scalar_pow_op	../include/Eigen/src/Core/Functors.h	/^  inline scalar_pow_op(const Scalar& exponent) : m_exponent(exponent) {}$/;"	f	struct:Eigen::internal::scalar_pow_op	access:public	signature:(const Scalar& exponent)
scalar_pow_op	../include/Eigen/src/Core/Functors.h	/^  inline scalar_pow_op(const scalar_pow_op& other) : m_exponent(other.m_exponent) { }$/;"	f	struct:Eigen::internal::scalar_pow_op	access:public	signature:(const scalar_pow_op& other)
scalar_pow_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_pow_op {$/;"	s	namespace:Eigen::internal
scalar_product_op	../include/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_product_op {$/;"	s	namespace:Eigen::internal
scalar_product_traits	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<std::complex<T>, T>$/;"	s	namespace:Eigen
scalar_product_traits	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<T,std::complex<T> >$/;"	s	namespace:Eigen
scalar_product_traits	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<T,T>$/;"	s	namespace:Eigen
scalar_quotient1_impl	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_impl(const Scalar& other) : m_other(other) {}$/;"	f	struct:Eigen::internal::scalar_quotient1_impl	access:public	signature:(const Scalar& other)
scalar_quotient1_impl	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_impl(const Scalar& other) : m_other(static_cast<Scalar>(1) \/ other) {}$/;"	f	struct:Eigen::internal::scalar_quotient1_impl	access:public	signature:(const Scalar& other)
scalar_quotient1_impl	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_impl(const scalar_quotient1_impl& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_quotient1_impl	access:public	signature:(const scalar_quotient1_impl& other)
scalar_quotient1_impl	../include/Eigen/src/Core/Functors.h	/^struct scalar_quotient1_impl<Scalar,true> {$/;"	s	namespace:Eigen::internal
scalar_quotient1_impl	../include/Eigen/src/Core/Functors.h	/^struct scalar_quotient1_impl {$/;"	s	namespace:Eigen::internal
scalar_quotient1_op	../include/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_op(const Scalar& other)$/;"	f	struct:Eigen::internal::scalar_quotient1_op	access:public	signature:(const Scalar& other)
scalar_quotient1_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_quotient1_op : scalar_quotient1_impl<Scalar, NumTraits<Scalar>::IsInteger > {$/;"	s	namespace:Eigen::internal	inherits:scalar_quotient1_impl
ScalarQuotient1ReturnType	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_quotient1_op<Scalar>, const Derived> ScalarQuotient1ReturnType;$/;"	t
scalar_quotient_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_quotient_op {$/;"	s	namespace:Eigen::internal
scalar_random_op	../include/Eigen/src/Core/Random.h	/^template<typename Scalar> struct scalar_random_op {$/;"	s	namespace:Eigen::internal
scalar_real_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_real_op {$/;"	s	namespace:Eigen::internal
scalar_real_ref_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_real_ref_op {$/;"	s	namespace:Eigen::internal
scalar_sin_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_sin_op {$/;"	s	namespace:Eigen::internal
scalar_sqrt_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_sqrt_op {$/;"	s	namespace:Eigen::internal
scalar_square_op	../include/Eigen/src/Core/Functors.h	/^struct scalar_square_op {$/;"	s	namespace:Eigen::internal
scalar_sum_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_sum_op {$/;"	s	namespace:Eigen::internal
scalar_tan_op	../include/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_tan_op {$/;"	s	namespace:Eigen::internal
ScalarTraits	../include/Eigen/src/Geometry/AlignedBox.h	/^  typedef NumTraits<Scalar>                         ScalarTraits;$/;"	t	class:Eigen::AlignedBox	access:public
ScalarWithConstIfNotLvalue	../include/Eigen/src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::ArrayWrapper	access:public
ScalarWithConstIfNotLvalue	../include/Eigen/src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MatrixWrapper	access:public
ScalarWithConstIfNotLvalue	../include/Eigen/src/Core/MapBase.h	/^                  >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MapBase	access:public
ScalarWithConstIfNotLvalue	../include/Eigen/src/Core/Swap.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::SwapWrapper	access:public
ScalarWithConstIfNotLvalue	../include/Eigen/src/Core/Transpose.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::TransposeImpl	access:public
scaleAndAddTo	../include/Eigen/src/Core/GeneralProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dest, Scalar alpha) const
scaleAndAddTo	../include/Eigen/src/Core/GeneralProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dst, Scalar alpha) const
scaleAndAddTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void scaleAndAddTo(Dest& dst,Scalar alpha) const { derived().scaleAndAddTo(dst,alpha); }$/;"	f	class:Eigen::ProductBase	access:public	signature:(Dest& dst,Scalar alpha) const
scaleAndAddTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void scaleAndAddTo(Dest& dst,Scalar alpha) const { m_prod.derived().scaleAndAddTo(dst,alpha * m_alpha); }$/;"	f	class:Eigen::ScaledProduct	access:public	signature:(Dest& dst,Scalar alpha) const
scaleAndAddTo	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	class:Eigen::GeneralProduct	access:public	signature:(Dest& dst, Scalar alpha) const
scaleAndAddTo	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(Dest& dst, Scalar alpha) const
scaleAndAddTo	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(Dest& dest, Scalar alpha) const
scaleAndAddTo	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(Dest& dst, Scalar alpha) const
scaleAndAddTo	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(Dest& dst, Scalar alpha) const
scaleAndAddTo	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	class:Eigen::DenseTimeSparseProduct	access:public	signature:(Dest& dest, Scalar alpha) const
scaleAndAddTo	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	class:Eigen::SparseTimeDenseProduct	access:public	signature:(Dest& dest, Scalar alpha) const
scaleAndAddTo	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename Dest> void scaleAndAddTo(Dest& \/*dest*\/, Scalar \/*alpha*\/) const$/;"	f	class:Eigen::DenseTimeSparseSelfAdjointProduct	access:public	signature:(Dest& , Scalar ) const
scaleAndAddTo	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	class:Eigen::SparseSelfAdjointTimeDenseProduct	access:public	signature:(Dest& dest, Scalar alpha) const
ScaledProduct	../include/Eigen/src/Core/ProductBase.h	/^class ScaledProduct$/;"	c	namespace:Eigen	inherits:ProductBase
ScaledProduct	../include/Eigen/src/Core/ProductBase.h	/^    ScaledProduct(const NestedProduct& prod, Scalar x)$/;"	f	class:Eigen::ScaledProduct	access:public	signature:(const NestedProduct& prod, Scalar x)
scale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::scale(Scalar s)$/;"	f	class:Eigen::Transform	signature:(Scalar s)
scale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& scale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
scale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& scale(Scalar s);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar s)
scale	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
scale	../include/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::scale(Scalar s)$/;"	f	class:Eigen::Transform	signature:(Scalar s)
scale	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& scale(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
scale	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& scale(Scalar s);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar s)
scale	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
scaleMatrix	../include/abcd.h	/^    void scaleMatrix(int norm);$/;"	p	class:abcd	access:private	signature:(int norm)
scaleMatrix	preprocess.cpp	/^void abcd::scaleMatrix(int norm)$/;"	f	class:abcd
scaleMatrix	../src/preprocess.cpp	/^void abcd::scaleMatrix(int norm)$/;"	f	class:abcd	signature:(int norm)
Scaling2d	../include/Eigen/src/Eigen2Support/Geometry/All.h	106;"	d
Scaling2d	../include/Eigen/src/Eigen2Support/Geometry/All.h	51;"	d
Scaling2d	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<double,2> Scaling2d;$/;"	t	namespace:Eigen
Scaling2f	../include/Eigen/src/Eigen2Support/Geometry/All.h	105;"	d
Scaling2f	../include/Eigen/src/Eigen2Support/Geometry/All.h	50;"	d
Scaling2f	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<float, 2> Scaling2f;$/;"	t	namespace:Eigen
Scaling3d	../include/Eigen/src/Eigen2Support/Geometry/All.h	108;"	d
Scaling3d	../include/Eigen/src/Eigen2Support/Geometry/All.h	53;"	d
Scaling3d	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<double,3> Scaling3d;$/;"	t	namespace:Eigen
Scaling3f	../include/Eigen/src/Eigen2Support/Geometry/All.h	107;"	d
Scaling3f	../include/Eigen/src/Eigen2Support/Geometry/All.h	52;"	d
Scaling3f	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<float, 3> Scaling3f;$/;"	t	namespace:Eigen
Scaling	../include/Eigen/src/Eigen2Support/Geometry/All.h	104;"	d
Scaling	../include/Eigen/src/Eigen2Support/Geometry/All.h	49;"	d
Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^class Scaling$/;"	c	namespace:Eigen
Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  explicit inline Scaling(const Scalar& s) { m_coeffs.setConstant(s); }$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scalar& s)
Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  explicit inline Scaling(const VectorType& coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Scaling	access:public	signature:(const VectorType& coeffs)
Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline explicit Scaling(const Scaling<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scaling<OtherScalarType,Dim>& other)
Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Scaling	access:public	signature:(const Scalar& sx, const Scalar& sy)
Scaling	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  Scaling() {}$/;"	f	class:Eigen::Scaling	access:public	signature:()
Scaling	../include/Eigen/src/Geometry/Scaling.h	/^static inline const DiagonalWrapper<const Derived> Scaling(const MatrixBase<Derived>& coeffs)$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& coeffs)
Scaling	../include/Eigen/src/Geometry/Scaling.h	/^static inline DiagonalMatrix<Scalar,2> Scaling(Scalar sx, Scalar sy)$/;"	f	namespace:Eigen	signature:(Scalar sx, Scalar sy)
Scaling	../include/Eigen/src/Geometry/Scaling.h	/^static inline DiagonalMatrix<Scalar,3> Scaling(Scalar sx, Scalar sy, Scalar sz)$/;"	f	namespace:Eigen	signature:(Scalar sx, Scalar sy, Scalar sz)
Scaling	../include/Eigen/src/Geometry/Scaling.h	/^static inline UniformScaling<double> Scaling(double s) { return UniformScaling<double>(s); }$/;"	f	namespace:Eigen	signature:(double s)
Scaling	../include/Eigen/src/Geometry/Scaling.h	/^static inline UniformScaling<float> Scaling(float s) { return UniformScaling<float>(s); }$/;"	f	namespace:Eigen	signature:(float s)
Scaling	../include/Eigen/src/Geometry/Scaling.h	/^static inline UniformScaling<std::complex<RealScalar> > Scaling(const std::complex<RealScalar>& s)$/;"	f	namespace:Eigen	signature:(const std::complex<RealScalar>& s)
ScalingType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Scaling<Scalar,Dim> ScalingType;$/;"	t	class:Eigen::Transform	access:public
ScalingType	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Scaling<Scalar,Dim> ScalingType;$/;"	t	class:Eigen::Translation	access:public
scamax	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(scamax)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
scamin	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(scamin)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
scasum	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(scasum)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
scmax	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(scmax) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
scmin	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(scmin) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
scnrm2	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(scnrm2)(int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
scomplex	../include/Eigen/src/Core/util/MKL_support.h	/^typedef std::complex<float>  scomplex;$/;"	t	namespace:Eigen
scopy	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(scopy) (int *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, int *, float *, int *)
sdot	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(sdot)  (int *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, int *, float *, int *)
SDP_IsDiagonal	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon36
SDP_IsSparseColMajor	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon36
SDP_IsSparseRowMajor	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon36
sdsdot	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(sdsdot)(int *, float  *,        float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *, float *, int *)
searchLowerIndex	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(Index key) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(Index key) const
searchLowerIndex	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(size_t start, size_t end, Index key) const$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t start, size_t end, Index key) const
second	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacket second;$/;"	m	struct:Eigen::internal::gebp_traits::DoublePacket	access:public
segment	../include/Eigen/src/Core/DenseBase.h	/^    SegmentReturnType segment(Index start, Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index start, Index size)
segment	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> typename ConstFixedSegmentReturnType<Size>::Type segment(Index start) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index start) const
segment	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> typename FixedSegmentReturnType<Size>::Type segment(Index start);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index start)
segment	../include/Eigen/src/Core/DenseBase.h	/^    typename DenseBase::ConstSegmentReturnType segment(Index start, Index size) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index start, Index size) const
segment	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::segment(Index start) const$/;"	f	class:Eigen::DenseBase	signature:(Index start) const
segment	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::segment(Index start)$/;"	f	class:Eigen::DenseBase	signature:(Index start)
segment	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::segment(Index start, Index size) const$/;"	f	class:Eigen::DenseBase	signature:(Index start, Index size) const
segment	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::segment(Index start, Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index start, Index size)
SegmentReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef VectorBlock<Derived> SegmentReturnType;$/;"	t	class:Eigen::DenseBase	access:public
select	../include/Eigen/src/Core/DenseBase.h	/^    select(const DenseBase<ThenDerived>& thenMatrix,$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<ThenDerived>& thenMatrix, const DenseBase<ElseDerived>& elseMatrix) const
select	../include/Eigen/src/Core/DenseBase.h	/^    select(const DenseBase<ThenDerived>& thenMatrix, typename ThenDerived::Scalar elseScalar) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(const DenseBase<ThenDerived>& thenMatrix, typename ThenDerived::Scalar elseScalar) const
select	../include/Eigen/src/Core/DenseBase.h	/^    select(typename ElseDerived::Scalar thenScalar, const DenseBase<ElseDerived>& elseMatrix) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(typename ElseDerived::Scalar thenScalar, const DenseBase<ElseDerived>& elseMatrix) const
Select	../include/Eigen/src/Core/Select.h	/^class Select : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,internal::dense_xpr_base::type
select	../include/Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<ThenDerived>& thenMatrix, const DenseBase<ElseDerived>& elseMatrix) const
select	../include/Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,$/;"	f	class:Eigen::DenseBase	signature:(const DenseBase<ThenDerived>& thenMatrix, typename ThenDerived::Scalar elseScalar) const
select	../include/Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(typename ElseDerived::Scalar thenScalar,$/;"	f	class:Eigen::DenseBase	signature:(typename ElseDerived::Scalar thenScalar, const DenseBase<ElseDerived>& elseMatrix) const
Select	../include/Eigen/src/Core/Select.h	/^    Select(const ConditionMatrixType& conditionMatrix,$/;"	f	class:Eigen::Select	access:public	signature:(const ConditionMatrixType& conditionMatrix, const ThenMatrixType& thenMatrix, const ElseMatrixType& elseMatrix)
selector	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef product_type_selector<rows_select, cols_select, depth_select> selector;$/;"	t	struct:Eigen::internal::product_type	access:private
SelfAdjointBit	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int SelfAdjointBit = SelfAdjoint;$/;"	m	namespace:Eigen
SelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)
SelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, bool computeEigenvectors)
SelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matrix, int options = ComputeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(const MatrixType& matrix, int options = ComputeEigenvectors)
SelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver()$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:()
SelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::SelfAdjointEigenSolver	access:public	signature:(Index size)
SelfAdjointEigenSolver	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename _MatrixType> class SelfAdjointEigenSolver$/;"	c	namespace:Eigen
SelfAdjoint	../include/Eigen/src/Core/util/Constants.h	/^  SelfAdjoint=0x10,$/;"	e	enum:Eigen::__anon207
selfadjoint_matrix_vector_product	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct selfadjoint_matrix_vector_product$/;"	s	namespace:Eigen::internal
selfadjoint_matrix_vector_product_symv	../include/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^struct selfadjoint_matrix_vector_product_symv :$/;"	s	namespace:Eigen::internal	inherits:selfadjoint_matrix_vector_product
SelfadjointProductMatrix	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SelfadjointProductMatrix	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false>$/;"	s	namespace:Eigen	inherits:ProductBase
SelfadjointProductMatrix	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::SelfadjointProductMatrix	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SelfadjointProductMatrix	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false>$/;"	s	namespace:Eigen	inherits:ProductBase
SelfadjointProductMatrix	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true>$/;"	s	namespace:Eigen	inherits:ProductBase
selfadjoint_product_selector	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,false>$/;"	s	namespace:Eigen
selfadjoint_product_selector	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,true>$/;"	s	namespace:Eigen
selfadjoint_rank1_update	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,ColMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
selfadjoint_rank1_update	../include/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,RowMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
selfadjoint_rank2_update_selector	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Lower>$/;"	s	namespace:Eigen::internal
selfadjoint_rank2_update_selector	../include/Eigen/src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Upper>$/;"	s	namespace:Eigen::internal
selfadjointView	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> typename ConstSelfAdjointViewReturnType<UpLo>::Type selfadjointView() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
selfadjointView	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> typename SelfAdjointViewReturnType<UpLo>::Type selfadjointView();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
SelfAdjointView	../include/Eigen/src/Core/SelfAdjointView.h	/^    inline SelfAdjointView(MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SelfAdjointView	access:public	signature:(MatrixType& matrix)
selfadjointView	../include/Eigen/src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::MatrixBase	signature:() const
selfadjointView	../include/Eigen/src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::MatrixBase	signature:()
SelfAdjointView	../include/Eigen/src/Core/SelfAdjointView.h	/^template<typename MatrixType, unsigned int UpLo> class SelfAdjointView$/;"	c	namespace:Eigen	inherits:TriangularBase
selfadjointView	../include/Eigen/src/Core/TriangularMatrix.h	/^    const SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
selfadjointView	../include/Eigen/src/Core/TriangularMatrix.h	/^    SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView()$/;"	f	class:Eigen::TriangularView	access:public	signature:()
selfadjointView	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> inline const SparseSelfAdjointView<Derived, UpLo> selfadjointView() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
selfadjointView	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> inline SparseSelfAdjointView<Derived, UpLo> selfadjointView();$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:()
selfadjointView	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^const SparseSelfAdjointView<Derived, UpLo> SparseMatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
selfadjointView	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<Derived, UpLo> SparseMatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::SparseMatrixBase	signature:()
SelfAdjointViewReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
SelfCwiseBinaryOp	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}$/;"	f	class:Eigen::SelfCwiseBinaryOp	access:public	signature:(Lhs& xpr, const BinaryOp& func = BinaryOp())
SelfCwiseBinaryOp	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^template<typename BinaryOp, typename Lhs, typename Rhs> class SelfCwiseBinaryOp$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
Sequential	../include/Eigen/src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	e	enum:Eigen::Sequential_t
SequentialLinSpacedReturnType	../include/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,false>,Derived> SequentialLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase	access:public
Sequential_t	../include/Eigen/src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	g	namespace:Eigen
SetAction	../include/Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
setBounds	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void setBounds(Index start, Index end) { m_start = start; m_end = end; }$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:(Index start, Index end)
setConstant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setConstant(const Scalar& value)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& value)
setConstant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index rows, Index cols, const Scalar& value)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index rows, Index cols, const Scalar& value)
setConstant	../include/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index size, const Scalar& value)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index size, const Scalar& value)
setConstant	../include/Eigen/src/Core/DenseBase.h	/^    Derived& setConstant(const Scalar& value);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& value)
setConstant	../include/Eigen/src/Core/PlainObjectBase.h	/^    Derived& setConstant(Index rows, Index cols, const Scalar& value);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols, const Scalar& value)
setConstant	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& setConstant(const Scalar& value)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const Scalar& value)
setCpuCacheSizes	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void setCpuCacheSizes(std::ptrdiff_t l1, std::ptrdiff_t l2)$/;"	f	namespace:Eigen	signature:(std::ptrdiff_t l1, std::ptrdiff_t l2)
SetDiag	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon102
SetDiag	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon103
setDroptol	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::setDroptol(RealScalar droptol)$/;"	f	class:Eigen::IncompleteLUT	signature:(RealScalar droptol)
setDroptol	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void setDroptol(RealScalar droptol); $/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(RealScalar droptol)
setEmpty	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline void setEmpty()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
setFillfactor	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::setFillfactor(int fillfactor)$/;"	f	class:Eigen::IncompleteLUT	signature:(int fillfactor)
setFillfactor	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void setFillfactor(int fillfactor); $/;"	p	class:Eigen::IncompleteLUT	access:public	signature:(int fillfactor)
set_from_triplets	../include/Eigen/src/SparseCore/SparseMatrix.h	/^void set_from_triplets(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, int Options = 0)$/;"	f	namespace:Eigen::internal	signature:(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, int Options = 0)
setFromTriplets	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void setFromTriplets(const InputIterators& begin, const InputIterators& end);$/;"	p	class:Eigen::SparseMatrix	access:public	signature:(const InputIterators& begin, const InputIterators& end)
setFromTriplets	../include/Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_Index>::setFromTriplets(const InputIterators& begin, const InputIterators& end)$/;"	f	class:Eigen::SparseMatrix	signature:(const InputIterators& begin, const InputIterators& end)
setFromTwoVectors	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
setFromTwoVectors	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion& setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);$/;"	p	class:Eigen::Quaternion	access:public	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
setFromTwoVectors	../include/Eigen/src/Geometry/Quaternion.h	/^  Derived& setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
setFromTwoVectors	../include/Eigen/src/Geometry/Quaternion.h	/^inline Derived& QuaternionBase<Derived>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::QuaternionBase	signature:(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
setIdentity_impl	../include/Eigen/src/Core/CwiseNullaryOp.h	/^struct setIdentity_impl<Derived, true>$/;"	s	namespace:Eigen::internal
setIdentity	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity()$/;"	f	class:Eigen::MatrixBase	signature:()
setIdentity	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity(Index rows, Index cols)$/;"	f	class:Eigen::MatrixBase	signature:(Index rows, Index cols)
setIdentity	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setIdentity(Index size) { m_diagonal.setOnes(size); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index size)
setIdentity	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setIdentity() { m_diagonal.setOnes(); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
setIdentity	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& setIdentity(Index rows, Index cols);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index rows, Index cols)
setIdentity	../include/Eigen/src/Core/MatrixBase.h	/^    Derived& setIdentity();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
setIdentity	../include/Eigen/src/Core/PermutationMatrix.h	/^    void setIdentity()$/;"	f	class:Eigen::PermutationBase	access:public	signature:()
setIdentity	../include/Eigen/src/Core/PermutationMatrix.h	/^    void setIdentity(Index size)$/;"	f	class:Eigen::PermutationBase	access:public	signature:(Index size)
setIdentity	../include/Eigen/src/Core/Transpositions.h	/^    void setIdentity()$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:()
setIdentity	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion& setIdentity() { m_coeffs << 0, 0, 0, 1; return *this; }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
setIdentity	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
setIdentity	../include/Eigen/src/Geometry/Quaternion.h	/^  inline QuaternionBase& setIdentity() { coeffs() << 0, 0, 0, 1; return *this; }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
setIdentity	../include/Eigen/src/Geometry/Transform.h	/^  void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform	access:public	signature:()
_set	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const DenseBase<OtherDerived>& other)
set_is_malloc_allowed	../include/Eigen/src/Core/util/Memory.h	/^inline bool set_is_malloc_allowed(bool new_value) { return is_malloc_allowed_impl(true, new_value); }$/;"	f	namespace:Eigen::internal	signature:(bool new_value)
setLength	../include/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setLength(Index length)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Index length)
setLinSpaced	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(const Scalar& low, const Scalar& high)
setLinSpaced	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase	signature:(Index size, const Scalar& low, const Scalar& high)
setLinSpaced	../include/Eigen/src/Core/DenseBase.h	/^    Derived& setLinSpaced(const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(const Scalar& low, const Scalar& high)
setLinSpaced	../include/Eigen/src/Core/DenseBase.h	/^    Derived& setLinSpaced(Index size, const Scalar& low, const Scalar& high);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size, const Scalar& low, const Scalar& high)
setMaxIterations	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setMaxIterations(int maxIters)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(int maxIters)
setMode	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void setMode(CholmodMode mode)$/;"	f	class:Eigen::CholmodDecomposition	access:public	signature:(CholmodMode mode)
setMode	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& setMode(SimplicialCholeskyMode mode)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(SimplicialCholeskyMode mode)
setMumpsCntl	../include/abcd.h	/^    inline void setMumpsCntl(int i, double v) { mumps.cntl[ i - 1 ] = v ; }$/;"	f	class:abcd	access:private	signature:(int i, double v)
setMumpsIcntl	../include/abcd.h	/^    inline void setMumpsIcntl(int i, int v) { mumps.icntl[ i - 1 ] = v ; }$/;"	f	class:abcd	access:private	signature:(int i, int v)
setNbThreads	../include/Eigen/src/Core/products/Parallelizer.h	/^inline void setNbThreads(int v)$/;"	f	namespace:Eigen	signature:(int v)
_set_noalias	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const DenseBase<OtherDerived>& other)
setNull	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline void setNull()$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
setNull	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline void setNull() { setEmpty(); }$/;"	f	class:Eigen::AlignedBox	access:public	signature:()
setOnes	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setOnes()$/;"	f	class:Eigen::DenseBase	signature:()
setOnes	../include/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index rows, Index cols)
setOnes	../include/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index size)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index size)
setOnes	../include/Eigen/src/Core/DenseBase.h	/^    Derived& setOnes();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
setOnes	../include/Eigen/src/Core/PlainObjectBase.h	/^    Derived& setOnes(Index rows, Index cols);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
setOnes	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& setOnes() { return setConstant(Scalar(1)); }$/;"	f	class:Eigen::TriangularView	access:public	signature:()
setRandom	../include/Eigen/src/Core/DenseBase.h	/^    Derived& setRandom();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
setRandom	../include/Eigen/src/Core/PlainObjectBase.h	/^    Derived& setRandom(Index rows, Index cols);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
setRandom	../include/Eigen/src/Core/Random.h	/^inline Derived& DenseBase<Derived>::setRandom()$/;"	f	class:Eigen::DenseBase	signature:()
setRandom	../include/Eigen/src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index rows, Index cols)
setRandom	../include/Eigen/src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index size)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index size)
setScalarType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  void setScalarType()$/;"	f	struct:Eigen::SluMatrix	access:public	signature:()
_set_selector	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::false_type&) { _set_noalias(other); }$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const OtherDerived& other, const internal::false_type&)
_set_selector	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::true_type&) { _set_noalias(other.eval()); }$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(const OtherDerived& other, const internal::true_type&)
setShift	../include/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setShift(Index shift)$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:(Index shift)
setShift	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Derived& setShift(const RealScalar& offset, const RealScalar& scale = 1)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const RealScalar& offset, const RealScalar& scale = 1)
setStorageType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  void setStorageType(Stype_t t)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(Stype_t t)
setThreshold	../include/Eigen/src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivLU	access:public	signature:(const RealScalar& threshold)
setThreshold	../include/Eigen/src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivLU	access:public	signature:(Default_t)
setThreshold	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(const RealScalar& threshold)
setThreshold	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(Default_t)
setThreshold	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(const RealScalar& threshold)
setThreshold	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(Default_t)
setTolerance	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setTolerance(RealScalar tolerance)$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(RealScalar tolerance)
setTrans	../include/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setTrans(bool trans)$/;"	f	class:Eigen::HouseholderSequence	access:protected	signature:(bool trans)
setZero	../include/Eigen/src/Cholesky/LDLT.h	/^    void setZero()$/;"	f	class:Eigen::LDLT	access:public	signature:()
setZero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setZero()$/;"	f	class:Eigen::DenseBase	signature:()
setZero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index rows, Index cols)
setZero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index size)$/;"	f	class:Eigen::PlainObjectBase	signature:(Index size)
setZero	../include/Eigen/src/Core/DenseBase.h	/^    Derived& setZero();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
setZero	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setZero(Index size) { m_diagonal.setZero(size); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:(Index size)
setZero	../include/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setZero() { m_diagonal.setZero(); }$/;"	f	class:Eigen::DiagonalMatrix	access:public	signature:()
setZero	../include/Eigen/src/Core/PlainObjectBase.h	/^    Derived& setZero(Index rows, Index cols);$/;"	p	class:Eigen::PlainObjectBase	access:public	signature:(Index rows, Index cols)
setZero	../include/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& setZero() { return setConstant(Scalar(0)); }$/;"	f	class:Eigen::TriangularView	access:public	signature:()
setZero	../include/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::setZero()$/;"	f	class:Eigen::internal::AmbiVector	signature:()
setZero	../include/Eigen/src/SparseCore/AmbiVector.h	/^    void setZero();$/;"	p	class:Eigen::internal::AmbiVector	access:public	signature:()
setZero	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void setZero()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
setZero	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline void setZero() { m_data.clear(); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
sgbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sgbmv)(char *, int *, int *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
sge2mm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sge2mm)(char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
sgema	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sgema)(char *, char *, int *, int *, float  *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *, float *, int *)
sgemm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sgemm)(char *, char *, int *, int *, int *, float *,$/;"	p	signature:(char *, char *, int *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
sgems	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sgems)(char *, char *, int *, int *, float  *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *, float *, int *)
sgemt	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sgemt)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *)
sgemv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sgemv)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
sger	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sger)(int *,    int *, float *,  float *, int *,$/;"	p	signature:(int *, int *, float *, float *, int *, float *, int *, float *, int *)
sgesv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sgesv)(int *, int *, float  *, int *, int *, float *, int *, int *);$/;"	p	signature:(int *, int *, float *, int *, int *, float *, int *, int *)
sgetf2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sgetf2)(int *, int *, float  *, int *, int *, int *);$/;"	p	signature:(int *, int *, float *, int *, int *, int *)
sgetrf	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sgetrf)(int *, int *, float  *, int *, int *, int *);$/;"	p	signature:(int *, int *, float *, int *, int *, int *)
sgetrs	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sgetrs)(char *, int *, int *, float  *, int *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, int *, float *, int *, int *, float *, int *, int *)
shear	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::shear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform	signature:(Scalar sx, Scalar sy)
shear	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  Transform& shear(Scalar sx, Scalar sy);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar sx, Scalar sy)
shear	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::shear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform	signature:(Scalar sx, Scalar sy)
shear	../include/Eigen/src/Geometry/Transform.h	/^  Transform& shear(Scalar sx, Scalar sy);$/;"	p	class:Eigen::Transform	access:public	signature:(Scalar sx, Scalar sy)
shift	../include/Eigen/src/Householder/HouseholderSequence.h	/^    Index shift() const { return m_shift; }    \/**< \\brief Returns the shift of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
Side	../include/Eigen/src/Core/GeneralProduct.h	/^    enum { Side = Lhs::IsVectorAtCompileTime ? OnTheLeft : OnTheRight };$/;"	e	enum:Eigen::GeneralProduct::__anon147
signedDistance	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar signedDistance(const VectorType& p) const { return p.eigen2_dot(normal()) + offset(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
signedDistance	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Scalar signedDistance(const VectorType& p) const { return normal().dot(p) + offset(); }$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p) const
significant_decimals_default_impl	../include/Eigen/src/Core/IO.h	/^struct significant_decimals_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
significant_decimals_default_impl	../include/Eigen/src/Core/IO.h	/^struct significant_decimals_default_impl$/;"	s	namespace:Eigen::internal
significant_decimals_impl	../include/Eigen/src/Core/IO.h	/^struct significant_decimals_impl$/;"	s	namespace:Eigen::internal	inherits:significant_decimals_default_impl
SimplicialCholeskyBase	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^class SimplicialCholeskyBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
SimplicialCholeskyBase	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const MatrixType& matrix)
~SimplicialCholeskyBase	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    ~SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:()
SimplicialCholeskyBase	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:()
SimplicialCholesky	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialCholesky : public SimplicialCholeskyBase<SimplicialCholesky<_MatrixType,_UpLo> >$/;"	c	namespace:Eigen	inherits:SimplicialCholeskyBase
SimplicialCholesky	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky() : Base(), m_LDLT(true) {}$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:()
SimplicialCholesky	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixType& matrix)
SimplicialCholeskyLDLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLDLT$/;"	e	enum:Eigen::SimplicialCholeskyMode
SimplicialCholeskyLLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLLT,$/;"	e	enum:Eigen::SimplicialCholeskyMode
SimplicialCholeskyMode	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^enum SimplicialCholeskyMode {$/;"	g	namespace:Eigen
SimplicialLDLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLDLT : public SimplicialCholeskyBase<SimplicialLDLT<_MatrixType,_UpLo> >$/;"	c	namespace:Eigen	inherits:SimplicialCholeskyBase
SimplicialLDLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT() : Base() {}$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:()
SimplicialLDLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:(const MatrixType& matrix)
SimplicialLLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLLT : public SimplicialCholeskyBase<SimplicialLLT<_MatrixType,_UpLo> >$/;"	c	namespace:Eigen	inherits:SimplicialCholeskyBase
SimplicialLLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT() : Base() {}$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:()
SimplicialLLT	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT	access:public	signature:(const MatrixType& matrix)
S	../include/Eigen/src/Core/SolveTriangular.h	/^    S = IsLower ? 0     : I+1$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon364
s	../include/Eigen/src/Jacobi/Jacobi.h	/^    Scalar s() const { return m_s; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
s	../include/Eigen/src/Jacobi/Jacobi.h	/^    Scalar& s() { return m_s; }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:()
SingletonVector	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    class SingletonVector$/;"	c	class:Eigen::SparseMatrix	access:protected
SingletonVector	../include/Eigen/src/SparseCore/SparseMatrix.h	/^        SingletonVector(Index i, Index v)$/;"	f	class:Eigen::SparseMatrix::SingletonVector	access:public	signature:(Index i, Index v)
singularValues	../include/Eigen/src/Eigen2Support/SVD.h	/^    const SingularValuesType& singularValues() const { return m_sigma; }$/;"	f	class:Eigen::SVD	access:public	signature:() const
singularValues	../include/Eigen/src/SVD/JacobiSVD.h	/^    const SingularValuesType& singularValues() const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:() const
SingularValuesType	../include/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MinSize, 1> SingularValuesType;$/;"	t	class:Eigen::SVD	access:private
SingularValuesType	../include/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_diag_type<MatrixType, RealScalar>::type SingularValuesType;$/;"	t	class:Eigen::JacobiSVD	access:public
sinh	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> sinh() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
sin	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixFunctionReturnValue<Derived> sin() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
sin	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_sin_op)      sin() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
sin	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::sin() const$/;"	f	class:Eigen::Cwise	signature:() const
sin	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sin() const$/;"	f	signature:() const
SizeA	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeA = ActualRows * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon107
SizeAtCompileTime	../include/Eigen/src/Core/BandMatrix.h	/^      SizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime)$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon79
SizeAtCompileTime	../include/Eigen/src/Core/DenseBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon216
SizeAtCompileTime	../include/Eigen/src/Core/MapBase.h	/^      SizeAtCompileTime = Base::SizeAtCompileTime$/;"	e	enum:Eigen::MapBase::__anon76
SizeAtCompileTime	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon28
SizeB	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeB = ActualCols * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon107
size	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
size	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon251
size	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
size	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon253
size	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon254
size	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon255
size	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
size	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon257
size	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
size	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon259
size	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon260
size	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon261
size	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
size	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
size	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon240
size	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon238
size	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon245
size	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
size	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon246
size	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon248
size	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon247
size	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon249
size	../include/Eigen/src/Core/EigenBase.h	/^  inline Index size() const { return rows() * cols(); }$/;"	f	struct:Eigen::EigenBase	access:public	signature:() const
size	../include/Eigen/src/Core/GenericPacketMath.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon230
size	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Index size() const { return indices().size(); }$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Size	../include/Eigen/src/Core/Redux.h	/^    Size = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_impl::__anon276
size	../include/Eigen/src/Core/Transpositions.h	/^    inline Index size() const { return indices().size(); }$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
size	../include/Eigen/src/Core/Transpositions.h	/^    inline int size() const { return m_transpositions.size(); }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
Size	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon45
Size	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon40
Size	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon42
size	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Index size() const { return m_size; }$/;"	f	class:Eigen::internal::AmbiVector	access:public	signature:() const
size	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline size_t size() const { return m_size; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:() const
size	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index size() const { return rows() * cols(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
SizeMinusOne	../include/Eigen/src/Core/MatrixBase.h	/^      SizeMinusOne = SizeAtCompileTime==Dynamic ? Dynamic : SizeAtCompileTime-1$/;"	e	enum:Eigen::MatrixBase::__anon150
SizeMinusOne	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : Size - 1,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon45
SizeMinusOne	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : (Size > 1 ? Size - 1 : 1),$/;"	e	enum:Eigen::Tridiagonalization::__anon42
sizes	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline const CwiseBinaryOp< internal::scalar_difference_op<Scalar>, const VectorType, const VectorType> sizes() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
size_type	../include/Eigen/src/Core/util/Memory.h	/^    typedef size_t    size_type;$/;"	t	class:Eigen::aligned_allocator	access:public
size_type	../include/Eigen/src/StlSupport/details.h	/^    typedef size_t    size_type;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
SizeW	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeW = MaxDepth * Traits::WorkSpaceFactor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon107
SkipFirst	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    enum { SkipFirst = ((Mode&Lower) && !(MatrixType::Flags&RowMajorBit))$/;"	e	enum:Eigen::SparseTriangularView::__anon29
SkipLast	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^           SkipLast = !SkipFirst,$/;"	e	enum:Eigen::SparseTriangularView::__anon29
slaswp	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(slaswp)(int *, float  *, int *, int *, int *, int *, int *);$/;"	p	signature:(int *, float *, int *, int *, int *, int *, int *)
slauu2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(slauu2)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
slauum	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(slauum)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
slerp	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar> Quaternion<Scalar>::slerp(Scalar t, const Quaternion& other) const$/;"	f	class:Eigen::Quaternion	signature:(Scalar t, const Quaternion& other) const
slerp	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Quaternion slerp(Scalar t, const Quaternion& other) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(Scalar t, const Quaternion& other) const
slerp	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D slerp(Scalar t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(Scalar t, const Rotation2D& other) const
slerp	../include/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::slerp(Scalar t, const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase	signature:(Scalar t, const QuaternionBase<OtherDerived>& other) const
slerp	../include/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> Quaternion<Scalar> slerp(Scalar t, const QuaternionBase<OtherDerived>& other) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(Scalar t, const QuaternionBase<OtherDerived>& other) const
slerp	../include/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D slerp(Scalar t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D	access:public	signature:(Scalar t, const Rotation2D& other) const
SliceVectorizedTraversal	../include/Eigen/src/Core/util/Constants.h	/^  SliceVectorizedTraversal,$/;"	e	enum:Eigen::__anon209
SluMatrix	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix	access:public	signature:(const SluMatrix& other)
SluMatrix	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix()$/;"	f	struct:Eigen::SluMatrix	access:public	signature:()
SluMatrix	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrix : SuperMatrix$/;"	s	namespace:Eigen	inherits:SuperMatrix
SluMatrixMapHelper	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<Matrix<Scalar,Rows,Cols,Options,MRows,MCols> >$/;"	s	namespace:Eigen
SluMatrixMapHelper	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<SparseMatrixBase<Derived> >$/;"	s	namespace:Eigen
Small	../include/Eigen/src/Core/GeneralProduct.h	/^  Small = 3$/;"	e	enum:Eigen::__anon120
SmallPanelWidth	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = 2 * EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon102
SmallPanelWidth	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon103
smart_copy_helper	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,false> {$/;"	s	namespace:Eigen::internal
smart_copy_helper	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,true> {$/;"	s	namespace:Eigen::internal
smart_copy	../include/Eigen/src/Core/util/Memory.h	/^template<typename T> void smart_copy(const T* start, const T* end, T* target)$/;"	f	namespace:Eigen::internal	signature:(const T* start, const T* end, T* target)
smax	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(smax)  (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
smin	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(smin)  (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
smmtm	splib_utils.cpp	/^CompRow_Mat_double smmtm (CompCol_Mat_double &A, CompCol_Mat_double &B)$/;"	f
smmtm	splib_utils.cpp	/^CompRow_Mat_double smmtm (CompRow_Mat_double &A, CompRow_Mat_double &B)$/;"	f
smv	splib_utils.cpp	/^smv ( CompRow_Mat_double &M, MV_ColMat_double &V )$/;"	f
snorm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(snorm)(char *, int *, int *, float  *, int *);$/;"	p	signature:(char *, int *, int *, float *, int *)
snrm2	../include/Eigen/src/misc/blas.h	/^float  BLASFUNC(snrm2) (int *, float  *, int *);$/;"	p	signature:(int *, float *, int *)
solveABCD	solve.cpp	/^abcd::solveABCD ( MV_ColMat_double &b )$/;"	f	class:abcd
solve	../include/Eigen/src/Cholesky/LDLT.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LDLT	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
solve	../include/Eigen/src/Cholesky/LDLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LDLT	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	../include/Eigen/src/Cholesky/LLT.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LLT	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
solve	../include/Eigen/src/Cholesky/LLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LLT	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
_solve	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
_solve	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void _solve(const SparseMatrix<RhsScalar,RhsOptions,RhsIndex> &b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::CholmodBase	access:public	signature:(const SparseMatrix<RhsScalar,RhsOptions,RhsIndex> &b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
solve	../include/Eigen/src/Core/SolveTriangular.h	/^TriangularView<Derived,Mode>::solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<Other>& other) const
solve	../include/Eigen/src/Core/TriangularMatrix.h	/^    solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<Other>& other) const
solve	../include/Eigen/src/Core/TriangularMatrix.h	/^    solve(const MatrixBase<Other>& other) const;$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<Other>& other) const
solve	../include/Eigen/src/Eigen2Support/LU.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LU	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
solve	../include/Eigen/src/Eigen2Support/QR.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::QR	access:public	signature:(const MatrixBase<OtherDerived>& b, ResultType *result) const
solve	../include/Eigen/src/Eigen2Support/SVD.h	/^    bool solve(const MatrixBase<OtherDerived> &b, ResultType* result) const;$/;"	p	class:Eigen::SVD	access:public	signature:(const MatrixBase<OtherDerived> &b, ResultType* result) const
solve	../include/Eigen/src/Eigen2Support/SVD.h	/^bool SVD<MatrixType>::solve(const MatrixBase<OtherDerived> &b, ResultType* result) const$/;"	f	class:Eigen::SVD	signature:(const MatrixBase<OtherDerived> &b, ResultType* result) const
solve	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    inline const Rhs& solve(const Rhs& b) const { return b; }$/;"	f	class:Eigen::IdentityPreconditioner	access:public	signature:(const Rhs& b) const
solve	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const MatrixBase<Rhs>& b) const
_solve	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::DiagonalPreconditioner	access:public	signature:(const Rhs& b, Dest& x) const
_solve	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const Rhs& b, Dest& x) const
_solve	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const Rhs& b, Dest& x) const
solve	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^     solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const MatrixBase<Rhs>& b) const
_solve	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::IncompleteLUT	access:public	signature:(const Rhs& b, Dest& x) const
solve	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
solve	../include/Eigen/src/LU/FullPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivLU	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	../include/Eigen/src/LU/PartialPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PartialPivLU	access:public	signature:(const MatrixBase<Rhs>& b) const
_solve	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^bool PardisoImpl<Base>::_solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const$/;"	f	class:Eigen::PardisoImpl	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const
_solve	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool _solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const;$/;"	p	class:Eigen::PardisoImpl	access:public	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const
solve	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
_solve	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^bool PastixBase<Base>::_solve (const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const$/;"	f	class:Eigen::PastixBase	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const
_solve	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    bool _solve (const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const;$/;"	p	class:Eigen::PastixBase	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const
solve	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PastixBase	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PastixBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
solve	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	../include/Eigen/src/QR/HouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::HouseholderQR	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const MatrixBase<Rhs>& b) const
solve	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const SparseMatrixBase<Rhs>& b) const
_solve	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
_solve	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
solve	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    solve(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseTriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other) const
solve	../include/Eigen/src/SparseCore/TriangularSolver.h	/^SparseTriangularView<ExpressionType,Mode>::solve(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView	signature:(const MatrixBase<OtherDerived>& other) const
solve	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const internal::solve_retval<SuperLUBase, Rhs> solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SuperLUBase	access:public	signature:(const MatrixBase<Rhs>& b) const
_solve	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const;$/;"	p	class:Eigen::SuperILU	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
_solve	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const;$/;"	p	class:Eigen::SuperLU	access:public	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
_solve	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::_solve(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperILU	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const
_solve	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::_solve(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperLU	signature:(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const
solve	../include/Eigen/src/SVD/JacobiSVD.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::JacobiSVD	access:public	signature:(const MatrixBase<Rhs>& b) const
_solve	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    bool _solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const;$/;"	p	class:Eigen::UmfPackLU	access:public	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const
_solve	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^bool UmfPackLU<MatrixType>::_solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const$/;"	f	class:Eigen::UmfPackLU	signature:(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const
solve	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const internal::solve_retval<UmfPackLU, Rhs> solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixBase<Rhs>& b) const
solveInPlace	../include/Eigen/src/Cholesky/LDLT.h	/^bool LDLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LDLT	signature:(MatrixBase<Derived> &bAndX) const
solveInPlace	../include/Eigen/src/Cholesky/LDLT.h	/^    bool solveInPlace(MatrixBase<Derived> &bAndX) const;$/;"	p	class:Eigen::LDLT	access:public	signature:(MatrixBase<Derived> &bAndX) const
solveInPlace	../include/Eigen/src/Cholesky/LLT.h	/^void LLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LLT	signature:(MatrixBase<Derived> &bAndX) const
solveInPlace	../include/Eigen/src/Cholesky/LLT.h	/^    void solveInPlace(MatrixBase<Derived> &bAndX) const;$/;"	p	class:Eigen::LLT	access:public	signature:(MatrixBase<Derived> &bAndX) const
solveInPlace	../include/Eigen/src/Core/SolveTriangular.h	/^void TriangularView<MatrixType,Mode>::solveInPlace(const MatrixBase<OtherDerived>& _other) const$/;"	f	class:Eigen::TriangularView	signature:(const MatrixBase<OtherDerived>& _other) const
solveInPlace	../include/Eigen/src/Core/TriangularMatrix.h	/^    void solveInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other) const
solveInPlace	../include/Eigen/src/Core/TriangularMatrix.h	/^    void solveInPlace(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::TriangularView	access:public	signature:(const MatrixBase<OtherDerived>& other) const
solveInPlace	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    template<typename OtherDerived> void solveInPlace(MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseTriangularView	access:public	signature:(MatrixBase<OtherDerived>& other) const
solveInPlace	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    template<typename OtherDerived> void solveInPlace(SparseMatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseTriangularView	access:public	signature:(SparseMatrixBase<OtherDerived>& other) const
solveInPlace	../include/Eigen/src/SparseCore/TriangularSolver.h	/^void SparseTriangularView<ExpressionType,Mode>::solveInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView	signature:(MatrixBase<OtherDerived>& other) const
solveInPlace	../include/Eigen/src/SparseCore/TriangularSolver.h	/^void SparseTriangularView<ExpressionType,Mode>::solveInPlace(SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView	signature:(SparseMatrixBase<OtherDerived>& other) const
solve_retval_base	../include/Eigen/src/misc/Solve.h	/^  solve_retval_base(const DecompositionType& dec, const Rhs& rhs)$/;"	f	struct:Eigen::internal::solve_retval_base	access:public	signature:(const DecompositionType& dec, const Rhs& rhs)
solve_retval_base	../include/Eigen/src/misc/Solve.h	/^template<typename _DecompositionType, typename Rhs> struct solve_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
solve_retval	../include/Eigen/src/Cholesky/LDLT.h	/^struct solve_retval<LDLT<_MatrixType,_UpLo>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/Cholesky/LLT.h	/^struct solve_retval<LLT<_MatrixType, UpLo>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^struct solve_retval<CholmodBase<_MatrixType,_UpLo,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^struct solve_retval<DiagonalPreconditioner<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^struct solve_retval<BiCGSTAB<_MatrixType, _Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^struct solve_retval<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^struct solve_retval<IncompleteLUT<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/LU/FullPivLU.h	/^struct solve_retval<FullPivLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/LU/PartialPivLU.h	/^struct solve_retval<PartialPivLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^struct solve_retval<PardisoImpl<_Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^struct solve_retval<PastixBase<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^struct solve_retval<ColPivHouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^struct solve_retval<FullPivHouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/QR/HouseholderQR.h	/^struct solve_retval<HouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^struct solve_retval<SimplicialCholeskyBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct solve_retval<SuperLUBase<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/SVD/JacobiSVD.h	/^struct solve_retval<JacobiSVD<_MatrixType, QRPreconditioner>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^struct solve_retval<UmfPackLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:solve_retval_base
solve_retval_with_guess	../include/Eigen/src/misc/SparseSolve.h	/^  solve_retval_with_guess(const DecompositionType& dec, const Rhs& rhs, const Guess& guess)$/;"	f	struct:Eigen::internal::solve_retval_with_guess	access:public	signature:(const DecompositionType& dec, const Rhs& rhs, const Guess& guess)
solve_retval_with_guess	../include/Eigen/src/misc/SparseSolve.h	/^template<typename DecompositionType, typename Rhs, typename Guess> struct solve_retval_with_guess$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
_solve_sparse	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
_solve_sparse	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::PardisoImpl	access:public	signature:(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
_solve_sparse	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::PastixBase	access:public	signature:(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
_solve_sparse	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase	access:public	signature:(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const
solveTriangular	../include/Eigen/src/Core/Flagged.h	/^    typename ExpressionType::PlainObject solveTriangular(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Flagged	access:public	signature:(const MatrixBase<OtherDerived>& other) const
solveTriangular	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^Flagged<ExpressionType,Added,Removed>::solveTriangular(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::Flagged	signature:(const MatrixBase<OtherDerived>& other) const
solveTriangular	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    solveTriangular(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(const MatrixBase<OtherDerived>& other) const
solveTriangular	../include/Eigen/src/SparseCore/TriangularSolver.h	/^SparseMatrixBase<Derived>::solveTriangular(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(const MatrixBase<OtherDerived>& other) const
solveTriangularInPlace	../include/Eigen/src/Core/Flagged.h	/^    void solveTriangularInPlace(const MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::Flagged	access:public	signature:(const MatrixBase<OtherDerived>& other) const
solveTriangularInPlace	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^void Flagged<ExpressionType,Added,Removed>::solveTriangularInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::Flagged	signature:(const MatrixBase<OtherDerived>& other) const
solveTriangularInPlace	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    void solveTriangularInPlace(MatrixBase<OtherDerived>& other) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(MatrixBase<OtherDerived>& other) const
solveTriangularInPlace	../include/Eigen/src/SparseCore/TriangularSolver.h	/^void SparseMatrixBase<Derived>::solveTriangularInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase	signature:(MatrixBase<OtherDerived>& other) const
solveWithGuess	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const MatrixBase<Rhs>& b, const Guess& x0) const
_solveWithGuess	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB	access:public	signature:(const Rhs& b, Dest& x) const
solveWithGuess	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const MatrixBase<Rhs>& b, const Guess& x0) const
_solveWithGuess	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient	access:public	signature:(const Rhs& b, Dest& x) const
sortEigenvalues	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::sortEigenvalues(bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver	signature:(bool computeEigenvectors)
sortEigenvalues	../include/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    void sortEigenvalues(bool computeEigenvectors);$/;"	p	class:Eigen::ComplexEigenSolver	access:private	signature:(bool computeEigenvectors)
sort	../include/Eigen/src/Eigen2Support/SVD.h	/^SVD<MatrixType>& SVD<MatrixType>::sort()$/;"	f	class:Eigen::SVD	signature:()
sort	../include/Eigen/src/Eigen2Support/SVD.h	/^    SVD& sort();$/;"	p	class:Eigen::SVD	access:public	signature:()
SparseBase	../include/Eigen/src/SparseCore/SparseVector.h	/^    typedef SparseMatrixBase<SparseVector> SparseBase;$/;"	t	class:Eigen::SparseVector	access:public
sparse_cwise_binary_op_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<BinaryOp, Lhs, Rhs, Derived, Sparse, Sparse>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Dense, Sparse>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Sparse, Dense>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Sparse, Sparse>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE sparse_cwise_binary_op_inner_iterator_selector(const CwiseBinaryXpr& xpr, Index outer)$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:(const CwiseBinaryXpr& xpr, Index outer)
SparseDenseOuterProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^class SparseDenseOuterProduct$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
SparseDenseOuterProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE SparseDenseOuterProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SparseDenseOuterProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE SparseDenseOuterProduct(const Rhs& rhs, const Lhs& lhs)$/;"	f	class:Eigen::SparseDenseOuterProduct	access:public	signature:(const Rhs& rhs, const Lhs& lhs)
SparseDenseProductReturnType	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs, int InnerSize> struct SparseDenseProductReturnType$/;"	s	namespace:Eigen
SparseDenseProductReturnType	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs> struct SparseDenseProductReturnType<Lhs,Rhs,1>$/;"	s	namespace:Eigen
SparseDiagonalProduct	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^class SparseDiagonalProduct$/;"	c	namespace:Eigen	inherits:SparseMatrixBase,internal::no_assignment_operator
SparseDiagonalProduct	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE SparseDiagonalProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseDiagonalProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
sparse_diagonal_product_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^class sparse_diagonal_product_inner_iterator_selector$/;"	c	namespace:Eigen::internal	inherits:CwiseBinaryOp::InnerIterator
sparse_diagonal_product_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^class sparse_diagonal_product_inner_iterator_selector$/;"	c	namespace:Eigen::internal	inherits:CwiseUnaryOp::InnerIterator
sparse_diagonal_product_inner_iterator_selector	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline sparse_diagonal_product_inner_iterator_selector($/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector	access:public	signature:( const SparseDiagonalProductType& expr, Index outer)
sparse_eval	../include/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Cols> struct sparse_eval<T,1,Cols> {$/;"	s	namespace:Eigen::internal
sparse_eval	../include/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Rows,int Cols> struct sparse_eval {$/;"	s	namespace:Eigen::internal
sparse_eval	../include/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Rows> struct sparse_eval<T,Rows,1> {$/;"	s	namespace:Eigen::internal
sparse_eval	../include/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct sparse_eval<T,1,1> {$/;"	s	namespace:Eigen::internal
SparseFlags	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    SparseFlags = is_diagonal<_Lhs>::ret ? int(_Rhs::Flags) : int(_Lhs::Flags),$/;"	e	enum:Eigen::internal::traits::__anon35
SparseInnerVectorSet	../include/Eigen/src/SparseCore/SparseBlock.h	/^class SparseInnerVectorSet : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,SparseMatrixBase
SparseInnerVectorSet	../include/Eigen/src/SparseCore/SparseBlock.h	/^class SparseInnerVectorSet<SparseMatrix<_Scalar, _Options, _Index>, Size>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
SparseInnerVectorSet	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseInnerVectorSet(const MatrixType& matrix, Index outer)$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:(const MatrixType& matrix, Index outer)
SparseInnerVectorSet	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseInnerVectorSet(const MatrixType& matrix, Index outerStart, Index outerSize)$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:(const MatrixType& matrix, Index outerStart, Index outerSize)
SparseMatrixBase	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseMatrixBase() : m_isRValue(false) { \/* TODO check flags *\/ }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
SparseMatrixBase	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^template<typename Derived> class SparseMatrixBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
SparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
SparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
SparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(const SparseMatrix& other)
~SparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline ~SparseMatrix()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
SparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix()$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
SparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index rows, Index cols)
SparseMatrixType	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef SparseMatrix<Scalar,RowMajor,Index> SparseMatrixType;$/;"	t	class:Eigen::PardisoImpl	access:public
SparseSelfAdjointTimeDenseProduct	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class SparseSelfAdjointTimeDenseProduct$/;"	c	namespace:Eigen	inherits:ProductBase
SparseSelfAdjointTimeDenseProduct	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::SparseSelfAdjointTimeDenseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SparseSelfAdjointView	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline SparseSelfAdjointView(const MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const MatrixType& matrix)
SparseSelfAdjointView	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<typename MatrixType, unsigned int UpLo> class SparseSelfAdjointView$/;"	c	namespace:Eigen	inherits:EigenBase
sparse_solve_retval_base	../include/Eigen/src/misc/SparseSolve.h	/^  sparse_solve_retval_base(const DecompositionType& dec, const Rhs& rhs)$/;"	f	struct:Eigen::internal::sparse_solve_retval_base	access:public	signature:(const DecompositionType& dec, const Rhs& rhs)
sparse_solve_retval_base	../include/Eigen/src/misc/SparseSolve.h	/^template<typename _DecompositionType, typename Rhs> struct sparse_solve_retval_base$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
sparse_solve_retval	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^struct sparse_solve_retval<CholmodBase<_MatrixType,_UpLo,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^struct sparse_solve_retval<IterativeSolverBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^struct sparse_solve_retval<PardisoImpl<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^struct sparse_solve_retval<PastixBase<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^struct sparse_solve_retval<SimplicialCholeskyBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct sparse_solve_retval<SuperLUBase<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_retval	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^struct sparse_solve_retval<UmfPackLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal	inherits:sparse_solve_retval_base
sparse_solve_triangular_selector	../include/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	../include/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	../include/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	../include/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_sparse_selector	../include/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_sparse_selector<Lhs,Rhs,Mode,UpLo,ColMajor>$/;"	s	namespace:Eigen::internal
SparseSparseProduct	../include/Eigen/src/SparseCore/SparseProduct.h	/^class SparseSparseProduct : internal::no_assignment_operator,$/;"	c	namespace:Eigen	inherits:internal::no_assignment_operator,SparseMatrixBase
SparseSparseProduct	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE SparseSparseProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SparseSparseProduct	../include/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE SparseSparseProduct(const Lhs& lhs, const Rhs& rhs, RealScalar tolerance)$/;"	f	class:Eigen::SparseSparseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs, RealScalar tolerance)
SparseSparseProductReturnType	../include/Eigen/src/SparseCore/SparseProduct.h	/^struct SparseSparseProductReturnType$/;"	s	namespace:Eigen
sparse_sparse_product_with_pruning_impl	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^static void sparse_sparse_product_with_pruning_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res, typename ResultType::RealScalar tolerance)$/;"	f	namespace:Eigen::internal	signature:(const Lhs& lhs, const Rhs& rhs, ResultType& res, typename ResultType::RealScalar tolerance)
sparse_sparse_product_with_pruning_selector	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	../include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
SparseSymmetricPermutationProduct	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class SparseSymmetricPermutationProduct$/;"	c	namespace:Eigen	inherits:EigenBase
SparseSymmetricPermutationProduct	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct(const MatrixType& mat, const Perm& perm)$/;"	f	class:Eigen::SparseSymmetricPermutationProduct	access:public	signature:(const MatrixType& mat, const Perm& perm)
sparse_time_dense_product_impl	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, ColMajor, false>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, ColMajor, true>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, RowMajor, false>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, RowMajor, true>$/;"	s	namespace:Eigen::internal
SparseTimeDenseProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^class SparseTimeDenseProduct$/;"	c	namespace:Eigen	inherits:ProductBase
sparse_time_dense_product	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^inline void sparse_time_dense_product(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)$/;"	f	namespace:Eigen::internal	signature:(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)
SparseTimeDenseProduct	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    SparseTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::SparseTimeDenseProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
SparseTriangularView	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline SparseTriangularView(const MatrixType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::SparseTriangularView	access:public	signature:(const MatrixType& matrix)
SparseTriangularView	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^template<typename MatrixType, int Mode> class SparseTriangularView$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^class SparseVector$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseMatrixBase<OtherDerived>& other)
SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseVector& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(const SparseVector& other)
~SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline ~SparseVector() {}$/;"	f	class:Eigen::SparseVector	access:public	signature:()
SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(Index rows, Index cols) : m_size(0) { resize(rows,cols); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index rows, Index cols)
SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(Index size) : m_size(0) { resize(size); }$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index size)
SparseVector	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector() : m_size(0) { resize(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
sparseView	../include/Eigen/src/Core/MatrixBase.h	/^    const SparseView<Derived> sparseView(const Scalar& m_reference = Scalar(0),$/;"	p	class:Eigen::MatrixBase	access:public	signature:(const Scalar& m_reference = Scalar(0), typename NumTraits<Scalar>::Real m_epsilon = NumTraits<Scalar>::dummy_precision()) const
SparseView	../include/Eigen/src/SparseCore/SparseView.h	/^class SparseView : public SparseMatrixBase<SparseView<MatrixType> >$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
sparseView	../include/Eigen/src/SparseCore/SparseView.h	/^const SparseView<Derived> MatrixBase<Derived>::sparseView(const Scalar& m_reference,$/;"	f	class:Eigen::MatrixBase	signature:(const Scalar& m_reference, typename NumTraits<Scalar>::Real m_epsilon) const
SparseView	../include/Eigen/src/SparseCore/SparseView.h	/^  SparseView(const MatrixType& mat, const Scalar& m_reference = Scalar(0),$/;"	f	class:Eigen::SparseView	access:public	signature:(const MatrixType& mat, const Scalar& m_reference = Scalar(0), typename NumTraits<Scalar>::Real m_epsilon = NumTraits<Scalar>::dummy_precision())
Specialized	../include/Eigen/src/Core/util/Constants.h	/^  Specialized,$/;"	e	enum:Eigen::__anon211
splitOffTwoRows	../include/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::splitOffTwoRows(Index iu, bool computeU, Scalar exshift)$/;"	f	class:Eigen::RealSchur	signature:(Index iu, bool computeU, Scalar exshift)
splitOffTwoRows	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    void splitOffTwoRows(Index iu, bool computeU, Scalar exshift);$/;"	p	class:Eigen::RealSchur	access:private	signature:(Index iu, bool computeU, Scalar exshift)
spmm	splib_utils.cpp	/^spmm ( CompRow_Mat_double &A, CompRow_Mat_double &B )$/;"	f
spotf2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(spotf2)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
spotrf	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(spotrf)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
spotri	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(spotri)(char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, int *, float *, int *, int *)
sqrt_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct sqrt_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
sqrt_default_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct sqrt_default_impl$/;"	s	namespace:Eigen::internal
sqrt_impl	../include/Eigen/src/Core/MathFunctions.h	/^struct sqrt_impl : sqrt_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal	inherits:sqrt_default_impl
sqrt	../include/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(sqrt, Scalar) sqrt(const Scalar& x)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& x)
sqrt	../include/Eigen/src/Core/MatrixBase.h	/^    const MatrixSquareRootReturnValue<Derived> sqrt() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
sqrt	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_sqrt_op)     sqrt() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
sqrt	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::sqrt() const$/;"	f	class:Eigen::Cwise	signature:() const
sqrt	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sqrt() const$/;"	f	signature:() const
sqrt_retval	../include/Eigen/src/Core/MathFunctions.h	/^struct sqrt_retval$/;"	s	namespace:Eigen::internal
squaredDistance	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
squaredDistance	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p) const
squaredExteriorDistance	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbiantDim>::squaredExteriorDistance(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox	signature:(const VectorType& p) const
squaredExteriorDistance	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline Scalar squaredExteriorDistance(const VectorType& p) const;$/;"	p	class:Eigen::AlignedBox	access:public	signature:(const VectorType& p) const
squaredExteriorDistance	../include/Eigen/src/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox	signature:(const AlignedBox& b) const
squaredExteriorDistance	../include/Eigen/src/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const MatrixBase<Derived>& a_p) const$/;"	f	class:Eigen::AlignedBox	signature:(const MatrixBase<Derived>& a_p) const
squaredExteriorDistance	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline Scalar squaredExteriorDistance(const AlignedBox& b) const;$/;"	p	class:Eigen::AlignedBox	access:public	signature:(const AlignedBox& b) const
squaredExteriorDistance	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline Scalar squaredExteriorDistance(const MatrixBase<Derived>& a_p) const;$/;"	p	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& a_p) const
squaredNorm	../include/Eigen/src/Core/Dot.h	/^EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
squaredNorm	../include/Eigen/src/Core/MatrixBase.h	/^    RealScalar squaredNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
squaredNorm	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_squaredNorm,RealScalar>::Type squaredNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
squaredNorm	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar squaredNorm() const { return m_coeffs.squaredNorm(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
squaredNorm	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar squaredNorm() const { return coeffs().squaredNorm(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
squaredNorm	../include/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
squaredNorm	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    RealScalar squaredNorm() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
squaredNorm	splib_utils.cpp	/^double squaredNorm(CompRow_Mat_double &M)$/;"	f
squaredNorm	splib_utils.cpp	/^double squaredNorm(VECTOR_double &V){$/;"	f
squaredNorm	splib_utils.cpp	/^double squaredNorm(VECTOR_double &V, VECTOR_int &I){$/;"	f
square	../include/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_UNOP_RETURN_TYPE(internal::scalar_square_op)   square() const;$/;"	p	class:Eigen::Cwise	access:public	signature:() const
square	../include/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::square() const$/;"	f	class:Eigen::Cwise	signature:() const
square	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^square() const$/;"	f	signature:() const
SquareMatrixType	../include/Eigen/src/Core/MatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::MatrixBase	access:public
SquareMatrixType	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
squeeze	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    void squeeze()$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:()
SrcHasDirectAccess	../include/Eigen/src/Core/Assign_MKL.h	/^      SrcHasDirectAccess = Src::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
SrcIsAligned	../include/Eigen/src/Core/Assign.h	/^    SrcIsAligned = OtherDerived::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon218
SrcStorageOrder	../include/Eigen/src/SparseCore/SparsePermutation.h	/^      SrcStorageOrder = MatrixTypeNestedCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::permut_sparsematrix_product_retval::__anon19
SrcStorageOrder	../include/Eigen/src/SparseCore/SparsePermutation.h	/^    SrcStorageOrder = MatrixTypeNestedCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::traits::__anon18
srotg	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(srotg) (float  *, float  *, float  *, float  *);$/;"	p	signature:(float *, float *, float *, float *)
srot	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(srot)  (int *, float  *, int *, float  *, int *, float  *, float  *);$/;"	p	signature:(int *, float *, int *, float *, int *, float *, float *)
srotmg	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(srotmg)(float  *, float  *, float  *, float  *, float  *);$/;"	p	signature:(float *, float *, float *, float *, float *)
srotm	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(srotm) (int *, float  *, int *, float  *, int *, float  *);$/;"	p	signature:(int *, float *, int *, float *, int *, float *)
ssbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ssbmv)(char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
sscal	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(sscal) (int *,  float  *, float  *, int *);$/;"	p	signature:(int *, float *, float *, int *)
SSE	../include/Eigen/src/Core/util/Constants.h	/^    SSE = 0x1,$/;"	e	enum:Eigen::Architecture::Type
sspmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sspmv) (char *, int *, float  *, float *,$/;"	p	signature:(char *, int *, float *, float *, float *, int *, float *, float *, int *)
sspr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sspr2) (char *, int *, float   *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *)
sspr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(sspr) (char *, int *, float   *, float  *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *)
sswap	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(sswap) (int *, float  *, int *, float  *, int *);$/;"	p	signature:(int *, float *, int *, float *, int *)
ssymm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ssymm)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
ssymv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ssymv) (char *, int *, float  *, float *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
ssyr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ssyr2) (char *, int *, float   *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *, float *, int *)
ssyr2k	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ssyr2k)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, int *, float *, float *, int *)
ssyr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ssyr) (char *, int *, float   *, float  *, int *,$/;"	p	signature:(char *, int *, float *, float *, int *, float *, int *)
ssyrk	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ssyrk)(char *, char *, int *, int *, float  *, float  *, int *,$/;"	p	signature:(char *, char *, int *, int *, float *, float *, int *, float *, float *, int *)
stableNorm	../include/Eigen/src/Core/MatrixBase.h	/^    RealScalar stableNorm() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
stableNorm	../include/Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::stableNorm() const$/;"	f	class:Eigen::MatrixBase	signature:() const
stableNorm	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_stableNorm,RealScalar>::Type stableNorm() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
stable_norm_kernel	../include/Eigen/src/Core/StableNorm.h	/^inline void stable_norm_kernel(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)$/;"	f	namespace:Eigen::internal	signature:(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)
startCol	../include/Eigen/src/Core/Block.h	/^    Index startCol() const $/;"	f	class:Eigen::Block	access:public	signature:() const
startFill	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void startFill(Index reserve)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index reserve)
start	../include/Eigen/src/Core/MatrixBase.h	/^    const VectorBlock<const Derived> start(Index size) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size) const
start	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Size> const VectorBlock<const Derived,Size> start() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
start	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Size> VectorBlock<Derived,Size> start();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
start	../include/Eigen/src/Core/MatrixBase.h	/^    VectorBlock<Derived> start(Index size);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size)
start	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start() const$/;"	f	class:Eigen::MatrixBase	signature:() const
start	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start()$/;"	f	class:Eigen::MatrixBase	signature:()
start	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start(Index size) const$/;"	f	class:Eigen::MatrixBase	signature:(Index size) const
start	../include/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start(Index size)$/;"	f	class:Eigen::MatrixBase	signature:(Index size)
start_index	../include/abcd.h	/^    int start_index; \/\/\/ To define wether it's Fortran-Style (1) or C-Style (0)$/;"	m	class:abcd	access:public
startRow	../include/Eigen/src/Core/Block.h	/^    Index startRow() const $/;"	f	class:Eigen::Block	access:public	signature:() const
startVec	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(Index outer)
startVec	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseVector	access:public	signature:(Index outer)
static_assertion	../include/Eigen/src/Core/util/StaticAssert.h	/^    struct static_assertion {};$/;"	s	namespace:Eigen::internal
static_assertion	../include/Eigen/src/Core/util/StaticAssert.h	/^    struct static_assertion<true>$/;"	s	namespace:Eigen::internal
stbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(stbmv) (char *, char *, char *, int *, int *, float  *, int *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, float *, int *, float *, int *)
stbsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(stbsv) (char *, char *, char *, int *, int *, float  *, int *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, float *, int *, float *, int *)
std::deque::deque_base	../include/Eigen/src/StlSupport/StdDeque.h	/^                Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > deque_base;$/;"	t	class:std::deque	access:private
std::deque	../include/Eigen/src/StlSupport/StdDeque.h	/^  class deque<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std	inherits:deque
std::deque::insert	../include/Eigen/src/StlSupport/StdDeque.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const_iterator position, const value_type& x)
std::deque::insert	../include/Eigen/src/StlSupport/StdDeque.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const_iterator position, size_type new_size, const value_type& x)
std::deque::push_back	../include/Eigen/src/StlSupport/StdDeque.h	/^  void push_back(const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const value_type& x)
std::deque::push_front	../include/Eigen/src/StlSupport/StdDeque.h	/^  void push_front(const value_type& x)$/;"	f	class:std::deque	access:private	signature:(const value_type& x)
std::deque::resize	../include/Eigen/src/StlSupport/StdDeque.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::deque	access:private	signature:(size_type new_size, const value_type& x)
std::deque::resize	../include/Eigen/src/StlSupport/StdDeque.h	/^  void resize(size_type new_size)$/;"	f	class:std::deque	access:private	signature:(size_type new_size)
std	../include/Eigen/src/Core/GlobalFunctions.h	/^namespace std$/;"	n
std	../include/Eigen/src/StlSupport/StdDeque.h	/^namespace std {$/;"	n
std	../include/Eigen/src/StlSupport/StdList.h	/^namespace std$/;"	n
std	../include/Eigen/src/StlSupport/StdVector.h	/^namespace std {$/;"	n
std::list	../include/Eigen/src/StlSupport/StdList.h	/^  class list<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std	inherits:list
std::list::insert	../include/Eigen/src/StlSupport/StdList.h	/^    iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::list	access:private	signature:(const_iterator position, const value_type& x)
std::list::insert	../include/Eigen/src/StlSupport/StdList.h	/^    void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::list	access:private	signature:(const_iterator position, size_type new_size, const value_type& x)
std::list::list_base	../include/Eigen/src/StlSupport/StdList.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > list_base;$/;"	t	class:std::list	access:private
std::list::push_back	../include/Eigen/src/StlSupport/StdList.h	/^    void push_back(const value_type& x)$/;"	f	class:std::list	access:private	signature:(const value_type& x)
std::list::resize	../include/Eigen/src/StlSupport/StdList.h	/^    void resize(size_type new_size, const value_type& x)$/;"	f	class:std::list	access:private	signature:(size_type new_size, const value_type& x)
std::list::resize	../include/Eigen/src/StlSupport/StdList.h	/^    void resize(size_type new_size)$/;"	f	class:std::list	access:private	signature:(size_type new_size)
std::pow	../include/Eigen/src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<Derived>& exponents) $/;"	f	namespace:std	signature:(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<Derived>& exponents)
std::pow	../include/Eigen/src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const typename Derived::Scalar& exponent) {$/;"	f	namespace:std	signature:(const Eigen::ArrayBase<Derived>& x, const typename Derived::Scalar& exponent)
std::vector	../include/Eigen/src/StlSupport/StdVector.h	/^  class vector<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std	inherits:vector
std::vector::insert	../include/Eigen/src/StlSupport/StdVector.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::vector	access:private	signature:(const_iterator position, const value_type& x)
std::vector::insert	../include/Eigen/src/StlSupport/StdVector.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::vector	access:private	signature:(const_iterator position, size_type new_size, const value_type& x)
std::vector::push_back	../include/Eigen/src/StlSupport/StdVector.h	/^  void push_back(const value_type& x)$/;"	f	class:std::vector	access:private	signature:(const value_type& x)
std::vector::resize	../include/Eigen/src/StlSupport/StdVector.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::vector	access:private	signature:(size_type new_size, const value_type& x)
std::vector::resize	../include/Eigen/src/StlSupport/StdVector.h	/^  void resize(size_type new_size)$/;"	f	class:std::vector	access:private	signature:(size_type new_size)
std::vector::vector_base	../include/Eigen/src/StlSupport/StdVector.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > vector_base;$/;"	t	class:std::vector	access:private
StemFunction	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::stem_function<Scalar>::type StemFunction;$/;"	t	class:Eigen::MatrixBase	access:public
stem_function	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^struct stem_function$/;"	s	namespace:Eigen::internal
StorageBaseType	../include/Eigen/src/Core/ArrayBase.h	/^    typedef ArrayBase StorageBaseType;$/;"	t	class:Eigen::ArrayBase	access:public
StorageBaseType	../include/Eigen/src/Core/MatrixBase.h	/^    typedef MatrixBase StorageBaseType;$/;"	t	class:Eigen::MatrixBase	access:public
StorageBaseType	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrixBase StorageBaseType;$/;"	t	class:Eigen::SparseMatrixBase	access:public
Storage	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef internal::CompressedStorage<Scalar,Index> Storage;$/;"	t	class:Eigen::SparseMatrix	access:public
storage	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  } storage;$/;"	m	struct:Eigen::SluMatrix	typeref:struct:Eigen::SluMatrix::__anon1	access:public
StorageKind	../include/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::ArrayBase	access:public
StorageKind	../include/Eigen/src/Core/BandMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/CwiseBinaryOp.h	/^                                           typename traits<Rhs>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseBase	access:public
StorageKind	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseCoeffsBase	access:public
StorageKind	../include/Eigen/src/Core/Diagonal.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalBase	access:public
StorageKind	../include/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalMatrix	access:public
StorageKind	../include/Eigen/src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	struct:Eigen::EigenBase	access:public
StorageKind	../include/Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MapBase	access:public
StorageKind	../include/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MatrixBase	access:public
StorageKind	../include/Eigen/src/Core/Matrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/PermutationMatrix.h	/^  typedef PermutationStorage StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::PlainObjectBase	access:public
StorageKind	../include/Eigen/src/Core/ProductBase.h	/^  typedef typename traits<NestedProduct>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/ProductBase.h	/^                                           typename traits<Rhs>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/Product.h	/^                                        typename traits<RhsCleaned>::StorageKind>::ret StorageKind;$/;"	t	struct:internal::traits	access:public
StorageKind	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^                                           typename traits<_RhsNested>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/Select.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/Transpose.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularBase	access:public
StorageKind	../include/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularView	access:public
StorageKind	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Eigen2Support/Minor.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;$/;"	t	class:Eigen::FullPivLU	access:public
StorageKind	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;$/;"	t	class:Eigen::PartialPivLU	access:public
StorageKind	../include/Eigen/src/SparseCore/SparseBlock.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::SparseMatrixBase	access:public
StorageKind	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/SparseCore/SparseVector.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
StorageKind	../include/Eigen/src/SparseCore/SparseView.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits	access:public
_StorageOrder	../include/Eigen/src/Core/DiagonalProduct.h	/^    _StorageOrder = MatrixType::Flags & RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::traits::__anon77
StorageOrdersAgree	../include/Eigen/src/Core/Assign.h	/^    StorageOrdersAgree = (int(Derived::IsRowMajor) == int(OtherDerived::IsRowMajor)),$/;"	e	enum:Eigen::internal::assign_traits::__anon220
StorageOrdersAgree	../include/Eigen/src/Core/Assign_MKL.h	/^      StorageOrdersAgree = (int(Dst::IsRowMajor) == int(Src::IsRowMajor)),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
StorageOrdersAgree	../include/Eigen/src/Core/CwiseBinaryOp.h	/^    StorageOrdersAgree = (int(Lhs::Flags)&RowMajorBit)==(int(Rhs::Flags)&RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon65
StorageOrdersMatch	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon398
StorageOrdersMatch	../include/Eigen/src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon399
stpmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(stpmv) (char *, char *, char *, int *, float  *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, float *, float *, int *)
stpsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(stpsv) (char *, char *, char *, int *, float  *, float  *, int *);$/;"	p	signature:(char *, char *, char *, int *, float *, float *, int *)
StreamPrecision	../include/Eigen/src/Core/IO.h	/^enum { StreamPrecision = -1,$/;"	e	enum:Eigen::__anon55
StrictlyLower	../include/Eigen/src/Core/util/Constants.h	/^  StrictlyLower=ZeroDiag|Lower, $/;"	e	enum:Eigen::__anon207
StrictlyUpper	../include/Eigen/src/Core/util/Constants.h	/^  StrictlyUpper=ZeroDiag|Upper,$/;"	e	enum:Eigen::__anon207
StridedAlignedMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
StridedConstAlignedMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
StridedConstMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
StridedMapType	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase	access:public
stride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index stride() const$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
stride	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void stride();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
Stride	../include/Eigen/src/Core/Stride.h	/^class Stride$/;"	c	namespace:Eigen
Stride	../include/Eigen/src/Core/Stride.h	/^    Stride(const Stride& other)$/;"	f	class:Eigen::Stride	access:public	signature:(const Stride& other)
Stride	../include/Eigen/src/Core/Stride.h	/^    Stride()$/;"	f	class:Eigen::Stride	access:public	signature:()
Stride	../include/Eigen/src/Core/Stride.h	/^    Stride(Index outerStride, Index innerStride)$/;"	f	class:Eigen::Stride	access:public	signature:(Index outerStride, Index innerStride)
strmm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(strmm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, float *, float *, int *, float *, int *)
strmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(strmv) (char *, char *, char *, int *, float  *, int *,$/;"	p	signature:(char *, char *, char *, int *, float *, int *, float *, int *)
strow	../include/abcd.h	/^    ArrayXi strow; \/\/\/ The starting row index of each partition$/;"	m	class:abcd	access:public
strsm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(strsm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, float *, float *, int *, float *, int *)
strsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(strsv) (char *, char *, char *, int *, float  *, int *,$/;"	p	signature:(char *, char *, char *, int *, float *, int *, float *, int *)
strti2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(strti2)(char *, char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, char *, int *, float *, int *, int *)
strtri	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(strtri)(char *, char *, int *, float  *, int *, int *);$/;"	p	signature:(char *, char *, int *, float *, int *, int *)
subcols	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,Dynamic> subcols(Index start, Index size) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size) const
subcols	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,Dynamic> subcols(Index start, Index size);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size)
subdiagonalEntryIsNeglegible	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool subdiagonalEntryIsNeglegible(Index i);$/;"	p	class:Eigen::ComplexSchur	access:private	signature:(Index i)
subdiagonalEntryIsNeglegible	../include/Eigen/src/Eigenvalues/ComplexSchur.h	/^inline bool ComplexSchur<MatrixType>::subdiagonalEntryIsNeglegible(Index i)$/;"	f	class:Eigen::ComplexSchur	signature:(Index i)
subDiagonal	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    SubDiagonalReturnType subDiagonal() const;$/;"	p	class:Eigen::Tridiagonalization	access:public	signature:() const
subDiagonal	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::subDiagonal() const$/;"	f	class:Eigen::Tridiagonalization	signature:() const
SubDiagonalReturnType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^            >::type SubDiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization	access:public
SubDiagonalType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<RealScalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> SubDiagonalType;$/;"	t	class:Eigen::Tridiagonalization	access:public
sub	../include/Eigen/src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<-1>::Type sub() const$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:() const
sub	../include/Eigen/src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<-1>::Type sub()$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:()
sub_matrix	splib_utils.cpp	/^sub_matrix ( CompCol_Mat_double &M, std::vector<int> &ci )$/;"	f
subrows	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const SparseInnerVectorSet<Derived,Dynamic> subrows(Index start, Index size) const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size) const
subrows	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseInnerVectorSet<Derived,Dynamic> subrows(Index start, Index size);$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:(Index start, Index size)
subs	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return derived().subs(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
subs	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
subs	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
Subs	../include/Eigen/src/Core/BandMatrix.h	/^      Subs   = internal::traits<Derived>::Subs,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Subs	../include/Eigen/src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon81
Subs	../include/Eigen/src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon82
subTo	../include/Eigen/src/Core/DiagonalMatrix.h	/^    void subTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase	access:public	signature:(MatrixBase<DenseDerived> &other) const
subTo	../include/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void subTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase	access:public	signature:(Dest& dst) const
subTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void subTo(Dest& dst) const { scaleAndAddTo(dst,Scalar(-1)); }$/;"	f	class:Eigen::ProductBase	access:public	signature:(Dest& dst) const
subTo	../include/Eigen/src/Core/ProductBase.h	/^    inline void subTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(-1)); }$/;"	f	class:Eigen::ScaledProduct	access:public	signature:(Dest& dst) const
subVector	../include/Eigen/src/Core/VectorwiseOp.h	/^    SubVector subVector(Index i)$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:(Index i)
SubVector	../include/Eigen/src/Core/VectorwiseOp.h	/^                               typename ExpressionType::RowXpr>::type SubVector;$/;"	t	class:Eigen::VectorwiseOp	access:protected
subVectors	../include/Eigen/src/Core/VectorwiseOp.h	/^    Index subVectors() const$/;"	f	class:Eigen::VectorwiseOp	access:protected	signature:() const
Success	../include/Eigen/src/Core/util/Constants.h	/^  Success = 0,        $/;"	e	enum:Eigen::ComputationInfo
sum_cols	../include/abcd.h	/^int sum_cols(int res, Eigen::SparseMatrix<double, RowMajor> M);$/;"	p	signature:(int res, Eigen::SparseMatrix<double, RowMajor> M)
sum_cols	splib_utils.cpp	/^int sum_cols(int res, CompRow_Mat_double M)$/;"	f
sum_cols	../src/utils.cpp	/^int sum_cols(int res, Eigen::SparseMatrix<double, RowMajor> M)$/;"	f	signature:(int res, Eigen::SparseMatrix<double, RowMajor> M)
sum	../include/Eigen/src/Core/DenseBase.h	/^    Scalar sum() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
sum	../include/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::sum() const$/;"	f	class:Eigen::DenseBase	signature:() const
sum	../include/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_sum>::Type sum() const$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:() const
sum	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Scalar sum() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
sum	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    Scalar sum() const;$/;"	p	class:Eigen::SparseMatrix	access:public	signature:() const
sum	../include/Eigen/src/SparseCore/SparseRedux.h	/^SparseMatrixBase<Derived>::sum() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
sum	../include/Eigen/src/SparseCore/SparseRedux.h	/^SparseMatrix<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseMatrix	signature:() const
sum	../include/Eigen/src/SparseCore/SparseRedux.h	/^SparseVector<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseVector	signature:() const
sum	../include/Eigen/src/SparseCore/SparseVector.h	/^    Scalar sum() const;$/;"	p	class:Eigen::SparseVector	access:public	signature:() const
sum_nnz	../include/abcd.h	/^int sum_nnz(int res, Eigen::SparseMatrix<double, RowMajor> M);$/;"	p	signature:(int res, Eigen::SparseMatrix<double, RowMajor> M)
sum_nnz	splib_utils.cpp	/^int sum_nnz(int res, CompRow_Mat_double M)$/;"	f
sum_nnz	../src/utils.cpp	/^int sum_nnz(int res, Eigen::SparseMatrix<double, RowMajor> M)$/;"	f	signature:(int res, Eigen::SparseMatrix<double, RowMajor> M)
sumProject	../include/abcd.h	/^    Eigen::MatrixXd sumProject(double alpha, Eigen::MatrixXd B, double beta, Eigen::MatrixXd X);$/;"	p	class:abcd	access:private	signature:(double alpha, Eigen::MatrixXd B, double beta, Eigen::MatrixXd X)
sumProject	../src/mumps.cpp	/^Eigen::MatrixXd abcd::sumProject(double alpha, Eigen::MatrixXd B, double beta, Eigen::MatrixXd X)$/;"	f	class:abcd	signature:(double alpha, Eigen::MatrixXd B, double beta, Eigen::MatrixXd X)
sum_rows	../include/abcd.h	/^int sum_rows(int res, Eigen::SparseMatrix<double, RowMajor> M);$/;"	p	signature:(int res, Eigen::SparseMatrix<double, RowMajor> M)
sum_rows	splib_utils.cpp	/^int sum_rows(int res, CompRow_Mat_double M)$/;"	f
sum_rows	../src/utils.cpp	/^int sum_rows(int res, Eigen::SparseMatrix<double, RowMajor> M)$/;"	f	signature:(int res, Eigen::SparseMatrix<double, RowMajor> M)
sumupDuplicates	../include/Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_Index>::sumupDuplicates()$/;"	f	class:Eigen::SparseMatrix	signature:()
sumupDuplicates	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    void sumupDuplicates();$/;"	p	class:Eigen::SparseMatrix	access:public	signature:()
SuperDiagVectorType	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTimeMinusOne, 1> SuperDiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization	access:public
SuperILU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperILU : public SuperLUBase<_MatrixType,SuperILU<_MatrixType> >$/;"	c	namespace:Eigen	inherits:SuperLUBase
SuperILU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU() : Base() { init(); }$/;"	f	class:Eigen::SuperILU	access:public	signature:()
SuperILU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperILU	access:public	signature:(const MatrixType& matrix)
~SuperILU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperILU()$/;"	f	class:Eigen::SuperILU	access:public	signature:()
SuperILU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(SuperILU& ) { }$/;"	f	class:Eigen::SuperILU	access:private	signature:(SuperILU& )
super	../include/Eigen/src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<1>::Type super() const$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:() const
super	../include/Eigen/src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<1>::Type super()$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:()
SuperLUBase	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperLUBase : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
~SuperLUBase	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLUBase()$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
SuperLUBase	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase() {}$/;"	f	class:Eigen::SuperLUBase	access:public	signature:()
SuperLUBase	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase(SuperLUBase& ) { }$/;"	f	class:Eigen::SuperLUBase	access:private	signature:(SuperLUBase& )
SuperLU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperLU : public SuperLUBase<_MatrixType,SuperLU<_MatrixType> >$/;"	c	namespace:Eigen	inherits:SuperLUBase
SuperLU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU() : Base() { init(); }$/;"	f	class:Eigen::SuperLU	access:public	signature:()
SuperLU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperLU	access:public	signature:(const MatrixType& matrix)
~SuperLU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLU()$/;"	f	class:Eigen::SuperLU	access:public	signature:()
SuperLU	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(SuperLU& ) { }$/;"	f	class:Eigen::SuperLU	access:private	signature:(SuperLU& )
supers	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return derived().supers(); }$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
supers	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrix	access:public	signature:() const
supers	../include/Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper	access:public	signature:() const
Supers	../include/Eigen/src/Core/BandMatrix.h	/^      Supers = internal::traits<Derived>::Supers,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon78
Supers	../include/Eigen/src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon81
Supers	../include/Eigen/src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon82
SupportedAccessPatterns	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon31
SupportedAccessPatterns	../include/Eigen/src/SparseCore/SparseVector.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon25
svd	../include/Eigen/src/Core/MatrixBase.h	/^    SVD<PlainObject> svd() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
svd	../include/Eigen/src/Eigen2Support/SVD.h	/^MatrixBase<Derived>::svd() const$/;"	f	class:Eigen::MatrixBase	signature:() const
SVD	../include/Eigen/src/Eigen2Support/SVD.h	/^    SVD() {} \/\/ a user who relied on compiler-generated default compiler reported problems with MSVC in 2.0.7$/;"	f	class:Eigen::SVD	access:public	signature:()
SVD	../include/Eigen/src/Eigen2Support/SVD.h	/^    SVD(const MatrixType& matrix)$/;"	f	class:Eigen::SVD	access:public	signature:(const MatrixType& matrix)
SVD	../include/Eigen/src/Eigen2Support/SVD.h	/^template<typename MatrixType> class SVD$/;"	c	namespace:Eigen
SVD	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<MatrixType, QRPreconditioner> SVD;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real	access:public
svd_precondition_2x2_block_to_be_real	../include/Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, false>$/;"	s	namespace:Eigen::internal
svd_precondition_2x2_block_to_be_real	../include/Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>$/;"	s	namespace:Eigen::internal
svd_precondition_2x2_block_to_be_real	../include/Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real {};$/;"	s	namespace:Eigen::internal
swap	../include/Eigen/src/Core/Array.h	/^    void swap(ArrayBase<OtherDerived> const & other)$/;"	f	class:Eigen::Array	access:public	signature:(ArrayBase<OtherDerived> const & other)
swap	../include/Eigen/src/Core/DenseBase.h	/^    void swap(const DenseBase<OtherDerived>& other,$/;"	f	class:Eigen::DenseBase	access:public	signature:(const DenseBase<OtherDerived>& other, int = OtherDerived::ThisConstantIsPrivateInPlainObjectBase)
swap	../include/Eigen/src/Core/DenseBase.h	/^    void swap(PlainObjectBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase	access:public	signature:(PlainObjectBase<OtherDerived>& other)
swap	../include/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& ) {}$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& )
swap	../include/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& other)$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
swap	../include/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
swap	../include/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
swap	../include/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }$/;"	f	class:Eigen::DenseStorage	access:public	signature:(DenseStorage& other)
swap	../include/Eigen/src/Core/Matrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::Matrix	access:public	signature:(MatrixBase<OtherDerived> const & other)
_swap	../include/Eigen/src/Core/PlainObjectBase.h	/^    void _swap(DenseBase<OtherDerived> const & other)$/;"	f	class:Eigen::PlainObjectBase	access:protected	signature:(DenseBase<OtherDerived> const & other)
swap	../include/Eigen/src/Core/TriangularMatrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(MatrixBase<OtherDerived> const & other)
swap	../include/Eigen/src/Core/TriangularMatrix.h	/^    void swap(TriangularBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularView	access:public	signature:(TriangularBase<OtherDerived> const & other)
swap	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    void swap(CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(CompressedStorage& other)
swap	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void swap(SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix	access:public	signature:(SparseMatrix& other)
swap	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline void swap(SparseVector& other)$/;"	f	class:Eigen::SparseVector	access:public	signature:(SparseVector& other)
SwapWrapper	../include/Eigen/src/Core/Swap.h	/^    inline SwapWrapper(ExpressionType& xpr) : m_expression(xpr) {}$/;"	f	class:Eigen::SwapWrapper	access:public	signature:(ExpressionType& xpr)
SwapWrapper	../include/Eigen/src/Core/Swap.h	/^template<typename ExpressionType> class SwapWrapper$/;"	c	namespace:Eigen	inherits:internal::dense_xpr_base::type
sym	../include/abcd.h	/^    bool sym; \/\/\/ Symmetry$/;"	m	class:abcd	access:public
Symmetric	../include/Eigen/src/Core/util/Constants.h	/^  Symmetric=0x20$/;"	e	enum:Eigen::__anon207
symm_pack_lhs	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_lhs$/;"	s	namespace:Eigen::internal
symm_pack_rhs	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_rhs$/;"	s	namespace:Eigen::internal
sync	../include/Eigen/src/Core/products/Parallelizer.h	/^  int volatile sync;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
tail	../include/Eigen/src/Core/DenseBase.h	/^    SegmentReturnType tail(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
tail	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> typename ConstFixedSegmentReturnType<Size>::Type tail() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
tail	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> typename FixedSegmentReturnType<Size>::Type tail();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
tail	../include/Eigen/src/Core/DenseBase.h	/^    typename DenseBase::ConstSegmentReturnType tail(Index size) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size) const
tail	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::tail() const$/;"	f	class:Eigen::DenseBase	signature:() const
tail	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::tail()$/;"	f	class:Eigen::DenseBase	signature:()
tail	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::tail(Index size) const$/;"	f	class:Eigen::DenseBase	signature:(Index size) const
tail	../include/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::tail(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
take_affine_part	../include/Eigen/src/Geometry/Transform.h	/^  typedef internal::transform_take_affine_part<Transform> take_affine_part;$/;"	t	class:Eigen::Transform	access:public
take_matrix_for_product	../include/Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product$/;"	s	namespace:Eigen::internal
take_matrix_for_product	../include/Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Mode, Options> >$/;"	s	namespace:Eigen::internal
take_matrix_for_product	../include/Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Projective, Options> >$/;"	s	namespace:Eigen::internal
tan	../include/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^tan() const$/;"	f	signature:() const
Target	../include/Eigen/src/Core/util/Constants.h	/^    Target = SSE$/;"	e	enum:Eigen::Architecture::Type
testFunctor	../include/Eigen/src/Core/util/Meta.h	/^    static has_none            testFunctor(...);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(....)
testFunctor	../include/Eigen/src/Core/util/Meta.h	/^    static has_std_result_type testFunctor(T const *, typename T::result_type const * = 0);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(T const *, typename T::result_type const * = 0)
testFunctor	../include/Eigen/src/Core/util/Meta.h	/^    static has_tr1_result      testFunctor(T const *, typename T::template result<T(ArgType0,ArgType1)>::type const * = 0);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(T const *, typename T::template result<T(ArgType0,ArgType1)>::type const * = 0)
testFunctor	../include/Eigen/src/Core/util/Meta.h	/^    static has_tr1_result      testFunctor(T const *, typename T::template result<T(ArgType)>::type const * = 0);$/;"	p	struct:Eigen::internal::result_of	access:public	signature:(T const *, typename T::template result<T(ArgType)>::type const * = 0)
THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD	../include/Eigen/src/Core/util/StaticAssert.h	/^        THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE	../include/Eigen/src/Core/util/StaticAssert.h	/^        THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE	../include/Eigen/src/Core/util/StaticAssert.h	/^        THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
thenMatrix	../include/Eigen/src/Core/Select.h	/^    const ThenMatrixType& thenMatrix() const$/;"	f	class:Eigen::Select	access:public	signature:() const
ThenMatrixNested	../include/Eigen/src/Core/Select.h	/^  typedef typename ThenMatrixType::Nested ThenMatrixNested;$/;"	t	struct:Eigen::internal::traits	access:public
THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH	../include/Eigen/src/Core/util/StaticAssert.h	/^        THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH$/;"	e	enum:Eigen::internal::static_assertion::__anon201
ThisConstantIsPrivateInPlainObjectBase	../include/Eigen/src/Core/DenseBase.h	/^    enum { ThisConstantIsPrivateInPlainObjectBase };$/;"	e	enum:Eigen::DenseBase::__anon217
ThisConstantIsPrivateInPlainObjectBase	../include/Eigen/src/Core/PlainObjectBase.h	/^    enum { ThisConstantIsPrivateInPlainObjectBase };$/;"	e	enum:Eigen::PlainObjectBase::__anon63
THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE	../include/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
threshold	../include/Eigen/src/LU/FullPivLU.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivLU	access:public	signature:() const
threshold	../include/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::ColPivHouseholderQR	access:public	signature:() const
threshold	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivHouseholderQR	access:public	signature:() const
Through	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1, const VectorType& p2)
Through	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1)
Through	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p0, const VectorType& p1)
Through	../include/Eigen/src/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1, const VectorType& p2)
Through	../include/Eigen/src/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const VectorType& p0, const VectorType& p1)
Through	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine	access:public	signature:(const VectorType& p0, const VectorType& p1)
throw_std_bad_alloc	../include/Eigen/src/Core/util/Memory.h	/^inline void throw_std_bad_alloc()$/;"	f	namespace:Eigen::internal	signature:()
TmpFlags	../include/Eigen/src/Geometry/Homogeneous.h	/^    TmpFlags = _MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon390
TmpMatrixType	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1, Options, MaxRowsAtCompileTime, 1> TmpMatrixType;$/;"	t	class:Eigen::LDLT	access:public
toDense	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^      Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> toDense() const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
toDenseMatrix	../include/Eigen/src/Core/BandMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::internal::BandMatrixBase	access:public	signature:() const
toDenseMatrix	../include/Eigen/src/Core/DiagonalMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return derived(); }$/;"	f	class:Eigen::DiagonalBase	access:public	signature:() const
toDenseMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
toDenseMatrix	../include/Eigen/src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return *this; }$/;"	f	class:Eigen::Transpose	access:public	signature:() const
toDenseMatrix	../include/Eigen/src/Core/TriangularMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::TriangularBase	access:public	signature:() const
tolerance	../include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar tolerance() const { return m_tolerance; }$/;"	f	class:Eigen::IterativeSolverBase	access:public	signature:() const
TopLeftCeil	../include/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
topLeftCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> topLeftCorner()$/;"	f	signature:()
topLeftCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> topLeftCorner(Index cRows, Index cCols)$/;"	f	signature:(Index cRows, Index cCols)
topLeftCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> topLeftCorner() const$/;"	f	signature:() const
topLeftCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> topLeftCorner(Index cRows, Index cCols) const$/;"	f	signature:(Index cRows, Index cCols) const
TopLeftFloor	../include/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopLeft	../include/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
TopLeft	../include/Eigen/src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRightCeil	../include/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
topRightCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> topRightCorner()$/;"	f	signature:()
topRightCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> topRightCorner(Index cRows, Index cCols)$/;"	f	signature:(Index cRows, Index cCols)
topRightCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> topRightCorner() const$/;"	f	signature:() const
topRightCorner	../include/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> topRightCorner(Index cRows, Index cCols) const$/;"	f	signature:(Index cRows, Index cCols) const
TopRightFloor	../include/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRight	../include/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
TopRight	../include/Eigen/src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
topRows	../include/Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr topRows(Index n) const$/;"	f	signature:(Index n) const
topRows	../include/Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr topRows(Index n)$/;"	f	signature:(Index n)
topRows	../include/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type topRows() const$/;"	f	signature:() const
topRows	../include/Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type topRows()$/;"	f	signature:()
toQMatrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline QMatrix toQMatrix(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
toQMatrix	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim>::toQMatrix(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
toQMatrix	../include/Eigen/src/Geometry/Transform.h	/^  inline QMatrix toQMatrix(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
toQMatrix	../include/Eigen/src/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim,Mode,Options>::toQMatrix(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
toQTransform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline QTransform toQTransform(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
toQTransform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim>::toQTransform(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
toQTransform	../include/Eigen/src/Geometry/Transform.h	/^  inline QTransform toQTransform(void) const;$/;"	p	class:Eigen::Transform	access:public	signature:(void) const
toQTransform	../include/Eigen/src/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim,Mode,Options>::toQTransform(void) const$/;"	f	class:Eigen::Transform	signature:(void) const
toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis	signature:(void) const
toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Matrix3 toRotationMatrix(void) const;$/;"	p	class:Eigen::AngleAxis	access:public	signature:(void) const
toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Matrix3 toRotationMatrix(void) const;$/;"	p	class:Eigen::Quaternion	access:public	signature:(void) const
toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Quaternion	signature:(void) const
toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  Matrix2 toRotationMatrix(void) const;$/;"	p	class:Eigen::Rotation2D	access:public	signature:(void) const
toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D	signature:(void) const
toRotationMatrix	../include/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
toRotationMatrix	../include/Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis	signature:(void) const
toRotationMatrix	../include/Eigen/src/Geometry/AngleAxis.h	/^  Matrix3 toRotationMatrix(void) const;$/;"	p	class:Eigen::AngleAxis	access:public	signature:(void) const
toRotationMatrix	../include/Eigen/src/Geometry/Quaternion.h	/^  Matrix3 toRotationMatrix() const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:() const
toRotationMatrix	../include/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::toRotationMatrix(void) const$/;"	f	class:Eigen::QuaternionBase	signature:(void) const
toRotationMatrix	../include/Eigen/src/Geometry/Rotation2D.h	/^  Matrix2 toRotationMatrix(void) const;$/;"	p	class:Eigen::Rotation2D	access:public	signature:(void) const
toRotationMatrix	../include/Eigen/src/Geometry/Rotation2D.h	/^Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D	signature:(void) const
toRotationMatrix	../include/Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase	access:public	signature:() const
toRotationMatrix	../include/Eigen/src/Geometry/RotationBase.h	/^static inline const MatrixBase<OtherDerived>& toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen::internal	signature:(const MatrixBase<OtherDerived>& mat)
toRotationMatrix	../include/Eigen/src/Geometry/RotationBase.h	/^static inline Matrix<Scalar,2,2> toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen::internal	signature:(const Scalar& s)
toRotationMatrix	../include/Eigen/src/Geometry/RotationBase.h	/^static inline Matrix<Scalar,Dim,Dim> toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen::internal	signature:(const RotationBase<OtherDerived,Dim>& r)
trace	../include/Eigen/src/Core/DenseBase.h	/^    Scalar trace() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
trace	../include/Eigen/src/Core/MatrixBase.h	/^    Scalar trace() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
trace	../include/Eigen/src/Core/Redux.h	/^MatrixBase<Derived>::trace() const$/;"	f	class:Eigen::MatrixBase	signature:() const
TraitsBase	../include/Eigen/src/Core/Map.h	/^  typedef traits<PlainObjectType> TraitsBase;$/;"	t	struct:Eigen::internal::traits	access:public
TraitsBase	../include/Eigen/src/Geometry/Quaternion.h	/^    typedef traits<Quaternion<_Scalar, _Options> > TraitsBase;$/;"	t	struct:Eigen::internal::traits	access:public
Traits	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef internal::LDLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LDLT	access:public
Traits	../include/Eigen/src/Cholesky/LLT.h	/^    typedef internal::LLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LLT	access:public
traits	../include/Eigen/src/Core/Array.h	/^struct traits<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > : traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/ArrayWrapper.h	/^struct traits<ArrayWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/ArrayWrapper.h	/^struct traits<MatrixWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/BandMatrix.h	/^struct traits<BandMatrix<_Scalar,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Core/BandMatrix.h	/^struct traits<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Core/Block.h	/^struct traits<Block<XprType, BlockRows, BlockCols, InnerPanel, HasDirectAccess> > : traits<XprType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/CwiseBinaryOp.h	/^struct traits<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Core/CwiseNullaryOp.h	/^struct traits<CwiseNullaryOp<NullaryOp, PlainObjectType> > : traits<PlainObjectType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/CwiseUnaryOp.h	/^struct traits<CwiseUnaryOp<UnaryOp, XprType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/CwiseUnaryView.h	/^struct traits<CwiseUnaryView<ViewOp, MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/Diagonal.h	/^struct traits<Diagonal<MatrixType,DiagIndex> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/DiagonalMatrix.h	/^struct traits<DiagonalMatrix<_Scalar,SizeAtCompileTime,MaxSizeAtCompileTime> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/DiagonalMatrix.h	/^struct traits<DiagonalWrapper<_DiagonalVectorType> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Core/DiagonalProduct.h	/^struct traits<DiagonalProduct<MatrixType, DiagonalType, ProductOrder> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/Flagged.h	/^struct traits<Flagged<ExpressionType, Added, Removed> > : traits<ExpressionType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/ForceAlignedAccess.h	/^struct traits<ForceAlignedAccess<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,GemvProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,InnerProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,OuterProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/Map.h	/^struct traits<Map<PlainObjectType, MapOptions, StrideType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/Matrix.h	/^struct traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Core/NestByValue.h	/^struct traits<NestByValue<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/PermutationMatrix.h	/^struct traits<Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/PermutationMatrix.h	/^struct traits<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/PermutationMatrix.h	/^struct traits<PermutationWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Core/PermutationMatrix.h	/^struct traits<permut_matrix_product_retval<PermutationType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Core/PermutationMatrix.h	/^struct traits<Transpose<PermutationBase<Derived> > >$/;"	s	namespace:Eigen::internal	inherits:traits
Traits	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::PermutationBase	access:private
Traits	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map	access:private
Traits	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationMatrix> Traits;$/;"	t	class:Eigen::PermutationMatrix	access:private
Traits	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationType> Traits;$/;"	t	class:Eigen::Transpose	access:public
Traits	../include/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationWrapper> Traits;$/;"	t	class:Eigen::PermutationWrapper	access:private
traits	../include/Eigen/src/Core/ProductBase.h	/^struct traits<ProductBase<Derived,_Lhs,_Rhs> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Core/ProductBase.h	/^struct traits<ScaledProduct<NestedProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/Product.h	/^struct traits<Product<Lhs, Rhs> >$/;"	s	namespace:internal
traits	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct traits<CoeffBasedProduct<LhsNested,RhsNested,NestingFlags> >$/;"	s	namespace:Eigen::internal
Traits	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> Traits;$/;"	t	struct:Eigen::internal::gebp_kernel	access:public
traits	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct traits<GeneralProduct<Lhs,Rhs,GemmProduct> >$/;"	s	namespace:Eigen::internal	inherits:traits
Traits	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef gebp_traits<LhsScalar,RhsScalar> Traits;$/;"	t	class:Eigen::internal::gemm_blocking_space	access:private
Traits	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjLhs,ConjRhs> Traits;$/;"	t	struct:Eigen::internal::tribb_kernel	access:public
traits	../include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct traits<SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
Traits	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  typedef gebp_traits<Scalar,Scalar> Traits;$/;"	t	struct:Eigen::internal::product_triangular_matrix_matrix	access:public
traits	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,true> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,true,Rhs,false> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/Replicate.h	/^struct traits<Replicate<MatrixType,RowFactor,ColFactor> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/ReturnByValue.h	/^struct traits<ReturnByValue<Derived> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/Reverse.h	/^struct traits<Reverse<MatrixType, Direction> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/Select.h	/^struct traits<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/SelfAdjointView.h	/^struct traits<SelfAdjointView<MatrixType, UpLo> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/SelfCwiseBinaryOp.h	/^struct traits<SelfCwiseBinaryOp<BinaryOp,Lhs,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/SolveTriangular.h	/^struct traits<triangular_solve_retval<Side, TriangularType, Rhs> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Core/Swap.h	/^struct traits<SwapWrapper<ExpressionType> > : traits<ExpressionType> {};$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/Transpose.h	/^struct traits<Transpose<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/Transpositions.h	/^struct traits<Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,_PacketAccess> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Core/Transpositions.h	/^struct traits<transposition_matrix_product_retval<TranspositionType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Core/Transpositions.h	/^struct traits<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Core/Transpositions.h	/^struct traits<TranspositionsWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
Traits	../include/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::TranspositionsBase	access:private
Traits	../include/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map	access:private
Traits	../include/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Transpositions> Traits;$/;"	t	class:Eigen::Transpositions	access:private
Traits	../include/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<TranspositionsWrapper> Traits;$/;"	t	class:Eigen::TranspositionsWrapper	access:private
traits	../include/Eigen/src/Core/TriangularMatrix.h	/^struct traits<TriangularView<MatrixType, _Mode> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename T> struct traits<const T> : traits<T> {};$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/VectorBlock.h	/^struct traits<VectorBlock<VectorType, Size> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Core/VectorwiseOp.h	/^struct traits<PartialReduxExpr<MatrixType, MemberOp, Direction> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Eigen2Support/Minor.h	/^struct traits<Minor<MatrixType> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^struct traits<HessenbergDecompositionMatrixHReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct traits<TridiagonalizationMatrixTReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Geometry/AngleAxis.h	/^template<typename _Scalar> struct traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Geometry/Homogeneous.h	/^struct traits<homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Geometry/Homogeneous.h	/^struct traits<Homogeneous<MatrixType,Direction> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Geometry/Homogeneous.h	/^struct traits<homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Geometry/Quaternion.h	/^  struct traits<Map<const Quaternion<_Scalar>, _Options> >:$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Geometry/Quaternion.h	/^  struct traits<Map<Quaternion<_Scalar>, _Options> >:$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/Geometry/Quaternion.h	/^struct traits<Quaternion<_Scalar,_Options> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Geometry/Rotation2D.h	/^template<typename _Scalar> struct traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/Householder/HouseholderSequence.h	/^struct traits<HouseholderSequence<VectorsType,CoeffsType,Side> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^struct traits<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^struct traits<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/LU/Inverse.h	/^struct traits<inverse_impl<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/misc/Image.h	/^struct traits<image_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/misc/Kernel.h	/^struct traits<kernel_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/misc/Solve.h	/^struct traits<solve_retval_base<DecompositionType, Rhs> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/misc/SparseSolve.h	/^struct traits<solve_retval_with_guess<DecompositionType, Rhs, Guess> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/misc/SparseSolve.h	/^struct traits<sparse_solve_retval_base<DecompositionType, Rhs> >$/;"	s	namespace:Eigen::internal
Traits	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef internal::pardiso_traits<Derived> Traits;$/;"	t	class:Eigen::PardisoImpl	access:private
traits	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^struct traits<FullPivHouseholderQRMatrixQReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo> struct traits<SimplicialCholesky<_MatrixType,_UpLo> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType,int _UpLo> struct traits<SimplicialLDLT<_MatrixType,_UpLo> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo> struct traits<SimplicialLLT<_MatrixType,_UpLo> >$/;"	s	namespace:Eigen::internal
Traits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialCholesky> Traits;$/;"	t	class:Eigen::SimplicialCholesky	access:public
Traits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT> Traits;$/;"	t	class:Eigen::SimplicialLDLT	access:public
Traits	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT> Traits;$/;"	t	class:Eigen::SimplicialLLT	access:public
traits	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^struct traits<MappedSparseMatrix<_Scalar, _Flags, _Index> > : traits<SparseMatrix<_Scalar, _Flags, _Index> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/SparseCore/SparseBlock.h	/^struct traits<SparseInnerVectorSet<MatrixType, Size> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct traits<DenseTimeSparseProduct<Lhs,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct traits<SparseDenseOuterProduct<Lhs,Rhs,Tr> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct traits<SparseTimeDenseProduct<Lhs,Rhs> >$/;"	s	namespace:Eigen::internal	inherits:traits
Traits	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef internal::traits<SparseDenseOuterProduct> Traits;$/;"	t	class:Eigen::SparseDenseOuterProduct	access:public
traits	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^struct traits<SparseDiagonalProduct<Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<Diagonal<const SparseMatrix<_Scalar, _Options, _Index>, DiagIndex> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<SparseMatrix<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/SparseCore/SparsePermutation.h	/^struct traits<permut_sparsematrix_product_retval<PermutationType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/SparseCore/SparseProduct.h	/^struct traits<SparseSparseProduct<LhsNested, RhsNested> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<DenseTimeSparseSelfAdjointProduct<Lhs,Rhs,UpLo> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointTimeDenseProduct<Lhs,Rhs,UpLo> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointView<MatrixType,UpLo> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSymmetricPermutationProduct<MatrixType,UpLo> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^struct traits<SparseTriangularView<MatrixType,Mode> >$/;"	s	namespace:Eigen::internal	inherits:traits
traits	../include/Eigen/src/SparseCore/SparseVector.h	/^struct traits<SparseVector<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
traits	../include/Eigen/src/SparseCore/SparseView.h	/^struct traits<SparseView<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal	inherits:traits
Transform2d	../include/Eigen/src/Eigen2Support/Geometry/All.h	39;"	d
Transform2d	../include/Eigen/src/Eigen2Support/Geometry/All.h	94;"	d
Transform2d	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<double,2> Transform2d;$/;"	t	namespace:Eigen
Transform2f	../include/Eigen/src/Eigen2Support/Geometry/All.h	38;"	d
Transform2f	../include/Eigen/src/Eigen2Support/Geometry/All.h	93;"	d
Transform2f	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<float,2> Transform2f;$/;"	t	namespace:Eigen
Transform3d	../include/Eigen/src/Eigen2Support/Geometry/All.h	41;"	d
Transform3d	../include/Eigen/src/Eigen2Support/Geometry/All.h	96;"	d
Transform3d	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<double,3> Transform3d;$/;"	t	namespace:Eigen
Transform3f	../include/Eigen/src/Eigen2Support/Geometry/All.h	40;"	d
Transform3f	../include/Eigen/src/Eigen2Support/Geometry/All.h	95;"	d
Transform3f	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<float,3> Transform3f;$/;"	t	namespace:Eigen
transform_construct_from_matrix	../include/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	../include/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	../include/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	../include/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
Transform	../include/Eigen/src/Eigen2Support/Geometry/All.h	37;"	d
Transform	../include/Eigen/src/Eigen2Support/Geometry/All.h	92;"	d
transform	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)
transform	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime>& t,$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Transform<Scalar,AmbientDimAtCompileTime>& t, TransformTraits traits = Affine)
Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived>& other)
Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const RotationBase<Derived, Dim>& r) { *this = r; }$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived, Dim>& r)
Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const ScalingType& s) { *this = s; }$/;"	f	class:Eigen::Transform	access:public	signature:(const ScalingType& s)
Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const Transform<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<OtherScalarType,Dim>& other)
Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const TranslationType& t) { *this = t; }$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform() { }$/;"	f	class:Eigen::Transform	access:public	signature:()
Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
Transform	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
transform	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)
transform	../include/Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t,$/;"	f	class:Eigen::Hyperplane	access:public	signature:(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t, TransformTraits traits = Affine)
Transform	../include/Eigen/src/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const EigenBase<OtherDerived>& other)
Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const RotationBase<Derived, Dim>& r)$/;"	f	class:Eigen::Transform	access:public	signature:(const RotationBase<Derived, Dim>& r)
Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const Transform<OtherScalarType,Dim,Mode,Options>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<OtherScalarType,Dim,Mode,Options>& other)
Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const TranslationType& t)$/;"	f	class:Eigen::Transform	access:public	signature:(const TranslationType& t)
Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform	access:public	signature:(const UniformScaling<Scalar>& s)
Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform(const QMatrix& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QMatrix& other)
Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform(const QTransform& other);$/;"	p	class:Eigen::Transform	access:public	signature:(const QTransform& other)
Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform& other)
Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform(const Transform<Scalar,Dim,Mode,OtherOptions>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<Scalar,Dim,Mode,OtherOptions>& other)
Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other)
Transform	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform()$/;"	f	class:Eigen::Transform	access:public	signature:()
Transform	../include/Eigen/src/Geometry/Transform.h	/^  Transform(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform	access:public	signature:(const ReturnByValue<OtherDerived>& other)
Transform	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform	signature:(const QMatrix& other)
Transform	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform	signature:(const QTransform& other)
transform_left_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_product_result	../include/Eigen/src/Geometry/Transform.h	/^struct transform_product_result$/;"	s	namespace:Eigen::internal
transform_right_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 0 >$/;"	s	namespace:Eigen::internal
transform_right_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 1 >$/;"	s	namespace:Eigen::internal
transform_right_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 2 >$/;"	s	namespace:Eigen::internal
transform_take_affine_part	../include/Eigen/src/Geometry/Transform.h	/^struct transform_take_affine_part<Transform<Scalar,Dim,AffineCompact, Options> > {$/;"	s	namespace:Eigen::internal
transform_take_affine_part	../include/Eigen/src/Geometry/Transform.h	/^template<typename TransformType> struct transform_take_affine_part {$/;"	s	namespace:Eigen::internal
TransformTimeDiagonalMode	../include/Eigen/src/Geometry/Transform.h	/^  enum { TransformTimeDiagonalMode = ((Mode==int(Isometry))?Affine:int(Mode)) };$/;"	e	enum:Eigen::Transform::__anon375
TransformTimeDiagonalReturnType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,TransformTimeDiagonalMode> TransformTimeDiagonalReturnType;$/;"	t	class:Eigen::Transform	access:public
TransformTraits	../include/Eigen/src/Core/util/Constants.h	/^enum TransformTraits {$/;"	g	namespace:Eigen
transform_traits	../include/Eigen/src/Geometry/Transform.h	/^struct transform_traits$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,AffineCompact,LhsOptions>,Transform<Scalar,Dim,Projective,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,false >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	../include/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,Projective,LhsOptions>,Transform<Scalar,Dim,AffineCompact,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
TransformType	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	class:Eigen::Scaling	access:public
TransformType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
TransformType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim> TransformType;$/;"	t	struct:Eigen::ei_transform_product_impl	access:public
TransformType	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	class:Eigen::Translation	access:public
TransformType	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Mode, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
TransformType	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Projective, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
TransformType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,AffineCompact,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
TransformType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Mode,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl	access:public
_transformVector	../include/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_STRONG_INLINE Vector3 _transformVector(Vector3 v) const;$/;"	p	class:Eigen::QuaternionBase	access:public	signature:(Vector3 v) const
_transformVector	../include/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::_transformVector(Vector3 v) const$/;"	f	class:Eigen::QuaternionBase	signature:(Vector3 v) const
_transformVector	../include/Eigen/src/Geometry/RotationBase.h	/^    inline VectorType _transformVector(const OtherVectorType& v) const$/;"	f	class:Eigen::RotationBase	access:public	signature:(const OtherVectorType& v) const
trans	../include/Eigen/src/Householder/HouseholderSequence.h	/^    bool trans() const { return m_trans; }     \/**< \\brief Returns the transpose flag. *\/$/;"	f	class:Eigen::HouseholderSequence	access:protected	signature:() const
translate	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& translate(const VectorType& t)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const VectorType& t)
translate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& translate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
translate	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
translate	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& translate(const MatrixBase<Derived>& a_t)$/;"	f	class:Eigen::AlignedBox	access:public	signature:(const MatrixBase<Derived>& a_t)
translate	../include/Eigen/src/Geometry/Transform.h	/^  inline Transform& translate(const MatrixBase<OtherDerived> &other);$/;"	p	class:Eigen::Transform	access:public	signature:(const MatrixBase<OtherDerived> &other)
translate	../include/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform	signature:(const MatrixBase<OtherDerived> &other)
Translation2d	../include/Eigen/src/Eigen2Support/Geometry/All.h	100;"	d
Translation2d	../include/Eigen/src/Eigen2Support/Geometry/All.h	45;"	d
Translation2d	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Translation2d	../include/Eigen/src/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Translation2f	../include/Eigen/src/Eigen2Support/Geometry/All.h	44;"	d
Translation2f	../include/Eigen/src/Eigen2Support/Geometry/All.h	99;"	d
Translation2f	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Translation2f	../include/Eigen/src/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Translation3d	../include/Eigen/src/Eigen2Support/Geometry/All.h	102;"	d
Translation3d	../include/Eigen/src/Eigen2Support/Geometry/All.h	47;"	d
Translation3d	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Translation3d	../include/Eigen/src/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Translation3f	../include/Eigen/src/Eigen2Support/Geometry/All.h	101;"	d
Translation3f	../include/Eigen/src/Eigen2Support/Geometry/All.h	46;"	d
Translation3f	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
Translation3f	../include/Eigen/src/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
translationExt	../include/Eigen/src/Geometry/Transform.h	/^  inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt()$/;"	f	class:Eigen::Transform	access:public	signature:()
translationExt	../include/Eigen/src/Geometry/Transform.h	/^  inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt() const$/;"	f	class:Eigen::Transform	access:public	signature:() const
Translation	../include/Eigen/src/Eigen2Support/Geometry/All.h	43;"	d
Translation	../include/Eigen/src/Eigen2Support/Geometry/All.h	98;"	d
translation	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline ConstTranslationPart translation() const { return m_matrix.template block<Dim,1>(0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
translation	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline TranslationPart translation() { return m_matrix.template block<Dim,1>(0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Translation	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Translation	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& vector)
Translation	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation<OtherScalarType,Dim>& other)
Translation	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Translation	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy)
Translation	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  Translation() {}$/;"	f	class:Eigen::Translation	access:public	signature:()
translation	../include/Eigen/src/Geometry/Transform.h	/^  inline ConstTranslationPart translation() const { return ConstTranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:() const
translation	../include/Eigen/src/Geometry/Transform.h	/^  inline TranslationPart translation() { return TranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform	access:public	signature:()
Translation	../include/Eigen/src/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
translation	../include/Eigen/src/Geometry/Translation.h	/^  const VectorType& translation() const { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:() const
Translation	../include/Eigen/src/Geometry/Translation.h	/^  explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation	access:public	signature:(const VectorType& vector)
Translation	../include/Eigen/src/Geometry/Translation.h	/^  inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation	access:public	signature:(const Translation<OtherScalarType,Dim>& other)
Translation	../include/Eigen/src/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy, const Scalar& sz)
Translation	../include/Eigen/src/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation	access:public	signature:(const Scalar& sx, const Scalar& sy)
Translation	../include/Eigen/src/Geometry/Translation.h	/^  Translation() {}$/;"	f	class:Eigen::Translation	access:public	signature:()
translation	../include/Eigen/src/Geometry/Translation.h	/^  VectorType& translation() { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:()
TranslationPart	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1> TranslationPart;$/;"	t	class:Eigen::Transform	access:public
TranslationPart	../include/Eigen/src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1,int(Mode)==(AffineCompact)> TranslationPart;$/;"	t	class:Eigen::Transform	access:public
TranslationType	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Scaling	access:public
TranslationType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform	access:public
TranslationType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform	access:public
TransposedSparseMatrix	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef SparseMatrix<Scalar,(Flags&~RowMajorBit)|(IsRowMajor?RowMajorBit:0)> TransposedSparseMatrix;$/;"	t	class:Eigen::SparseMatrix	access:protected
TransposeImpl_base	../include/Eigen/src/Core/Transpose.h	/^struct TransposeImpl_base<MatrixType, false>$/;"	s	namespace:Eigen::internal
TransposeImpl_base	../include/Eigen/src/Core/Transpose.h	/^struct TransposeImpl_base$/;"	s	namespace:Eigen::internal
TransposeImpl	../include/Eigen/src/Core/Transpose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Dense>$/;"	c	namespace:Eigen	inherits:internal::TransposeImpl_base::type
TransposeImpl	../include/Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>$/;"	c	namespace:Eigen	inherits:SparseMatrixBase
transpose	../include/Eigen/src/Core/DenseBase.h	/^    ConstTransposeReturnType transpose() const;$/;"	p	class:Eigen::DenseBase	access:public	signature:() const
transpose	../include/Eigen/src/Core/DenseBase.h	/^    Eigen::Transpose<Derived> transpose();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
Transpose	../include/Eigen/src/Core/PermutationMatrix.h	/^class Transpose<PermutationBase<Derived> >$/;"	c	namespace:Eigen	inherits:EigenBase
transpose	../include/Eigen/src/Core/PermutationMatrix.h	/^    inline Transpose<PermutationBase> transpose() const$/;"	f	class:Eigen::PermutationBase	access:public	signature:() const
Transpose	../include/Eigen/src/Core/PermutationMatrix.h	/^    Transpose(const PermutationType& p) : m_permutation(p) {}$/;"	f	class:Eigen::Transpose	access:public	signature:(const PermutationType& p)
Transpose	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon106
Transpose	../include/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon108
transpose	../include/Eigen/src/Core/Transpose.h	/^DenseBase<Derived>::transpose() const$/;"	f	class:Eigen::DenseBase	signature:() const
transpose	../include/Eigen/src/Core/Transpose.h	/^DenseBase<Derived>::transpose()$/;"	f	class:Eigen::DenseBase	signature:()
Transpose	../include/Eigen/src/Core/Transpose.h	/^    inline Transpose(MatrixType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Transpose	access:public	signature:(MatrixType& matrix)
Transpose	../include/Eigen/src/Core/Transpose.h	/^template<typename MatrixType> class Transpose$/;"	c	namespace:Eigen	inherits:TransposeImpl
Transpose	../include/Eigen/src/Core/Transpositions.h	/^class Transpose<TranspositionsBase<TranspositionsDerived> >$/;"	c	namespace:Eigen
transpose	../include/Eigen/src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> transpose() const$/;"	f	class:Eigen::TranspositionsBase	access:public	signature:() const
Transpose	../include/Eigen/src/Core/Transpositions.h	/^    Transpose(const TranspositionType& t) : m_transpositions(t) {}$/;"	f	class:Eigen::Transpose	access:public	signature:(const TranspositionType& t)
transpose	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline const TriangularView<Transpose<MatrixType>,TransposeMode> transpose() const$/;"	f	class:Eigen::TriangularView	access:public	signature:() const
transpose	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularView<Transpose<MatrixType>,TransposeMode> transpose()$/;"	f	class:Eigen::TriangularView	access:public	signature:()
transpose	../include/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence transpose() const$/;"	f	class:Eigen::HouseholderSequence	access:public	signature:() const
transpose	../include/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation transpose() const { return JacobiRotation(m_c, -internal::conj(m_s)); }$/;"	f	class:Eigen::JacobiRotation	access:public	signature:() const
transpose	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const Transpose<const Derived> transpose() const { return derived(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:() const
transpose	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Transpose<Derived> transpose() { return derived(); }$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:()
transposeInPlace	../include/Eigen/src/Core/DenseBase.h	/^    void transposeInPlace();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
transposeInPlace	../include/Eigen/src/Core/Transpose.h	/^inline void DenseBase<Derived>::transposeInPlace()$/;"	f	class:Eigen::DenseBase	signature:()
TransposeLhs	../include/Eigen/src/SparseCore/SparseProduct.h	/^    TransposeLhs = LhsRowMajor && (!RhsRowMajor)$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon16
TransposeMode	../include/Eigen/src/Core/TriangularMatrix.h	/^      TransposeMode = (Mode & Upper ? Lower : 0)$/;"	e	enum:Eigen::TriangularView::__anon235
TransposeRhs	../include/Eigen/src/SparseCore/SparseProduct.h	/^    TransposeRhs = (!LhsRowMajor) && RhsRowMajor,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon16
TransposeTypeWithSameStorageOrder	../include/Eigen/src/SVD/JacobiSVD.h	/^          TransposeTypeWithSameStorageOrder;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
transposition_matrix_product_retval	../include/Eigen/src/Core/Transpositions.h	/^struct transposition_matrix_product_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
transposition_matrix_product_retval	../include/Eigen/src/Core/Transpositions.h	/^    transposition_matrix_product_retval(const TranspositionType& tr, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval	access:public	signature:(const TranspositionType& tr, const MatrixType& matrix)
TranspositionsBase	../include/Eigen/src/Core/Transpositions.h	/^class TranspositionsBase$/;"	c	namespace:Eigen
Transpositions	../include/Eigen/src/Core/Transpositions.h	/^class Transpositions : public TranspositionsBase<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >$/;"	c	namespace:Eigen	inherits:TranspositionsBase
Transpositions	../include/Eigen/src/Core/Transpositions.h	/^    explicit inline Transpositions(const MatrixBase<Other>& indices) : m_indices(indices)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const MatrixBase<Other>& indices)
Transpositions	../include/Eigen/src/Core/Transpositions.h	/^    inline Transpositions(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions	access:public	signature:(const TranspositionsBase<OtherDerived>& other)
Transpositions	../include/Eigen/src/Core/Transpositions.h	/^    inline Transpositions(const Transpositions& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::Transpositions	access:public	signature:(const Transpositions& other)
Transpositions	../include/Eigen/src/Core/Transpositions.h	/^    inline Transpositions() {}$/;"	f	class:Eigen::Transpositions	access:public	signature:()
Transpositions	../include/Eigen/src/Core/Transpositions.h	/^    inline Transpositions(Index size) : m_indices(size)$/;"	f	class:Eigen::Transpositions	access:public	signature:(Index size)
transpositionsP	../include/Eigen/src/Cholesky/LDLT.h	/^    inline const TranspositionType& transpositionsP() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
TranspositionsWrapper	../include/Eigen/src/Core/Transpositions.h	/^class TranspositionsWrapper$/;"	c	namespace:Eigen	inherits:TranspositionsBase
TranspositionsWrapper	../include/Eigen/src/Core/Transpositions.h	/^    inline TranspositionsWrapper(IndicesType& indices)$/;"	f	class:Eigen::TranspositionsWrapper	access:public	signature:(IndicesType& indices)
TranspositionType	../include/Eigen/src/Cholesky/LDLT.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::LDLT	access:public
TranspositionType	../include/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsDerived TranspositionType;$/;"	t	class:Eigen::Transpose	access:private
TranspositionType	../include/Eigen/src/LU/PartialPivLU.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::PartialPivLU	access:public
Traversal	../include/Eigen/src/Core/Assign.h	/^    Traversal = int(MayInnerVectorize)  ? int(InnerVectorizedTraversal)$/;"	e	enum:Eigen::internal::assign_traits::__anon221
Traversal	../include/Eigen/src/Core/Assign_MKL.h	/^      Traversal = MayLinearize ? LinearVectorizedTraversal$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon284
Traversal	../include/Eigen/src/Core/Redux.h	/^    Traversal = int(MayLinearVectorize) ? int(LinearVectorizedTraversal)$/;"	e	enum:Eigen::internal::redux_traits::__anon269
TraversalSize	../include/Eigen/src/Core/VectorwiseOp.h	/^    TraversalSize = Direction==Vertical ? RowsAtCompileTime : ColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon68
triangular_assignment_selector	../include/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Lower), UnrollCount, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Upper), UnrollCount, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Lower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Mode, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, StrictlyLower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, StrictlyUpper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, UnitLower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, UnitUpper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Upper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	../include/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector$/;"	s	namespace:Eigen::internal
TriangularBase	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularBase() { eigen_assert(!((Mode&UnitDiag) && (Mode&ZeroDiag))); }$/;"	f	class:Eigen::TriangularBase	access:public	signature:()
TriangularBase	../include/Eigen/src/Core/TriangularMatrix.h	/^template<typename Derived> class TriangularBase : public EigenBase<Derived>$/;"	c	namespace:Eigen	inherits:EigenBase
triangular_matrix_vector_product	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,ColMajor,Version>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,RowMajor,Version>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product_trmv	../include/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^struct triangular_matrix_vector_product_trmv :$/;"	s	namespace:Eigen::internal	inherits:triangular_matrix_vector_product
TriangularProduct	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false>$/;"	s	namespace:Eigen	inherits:ProductBase
TriangularProduct	../include/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
TriangularProduct	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct TriangularProduct<Mode,false,Lhs,true,Rhs,false>$/;"	s	namespace:Eigen	inherits:ProductBase
TriangularProduct	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct TriangularProduct<Mode,true,Lhs,false,Rhs,true>$/;"	s	namespace:Eigen	inherits:ProductBase
TriangularProduct	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::TriangularProduct	access:public	signature:(const Lhs& lhs, const Rhs& rhs)
triangular_solve_matrix	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	../include/Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,Side,Mode,Conjugate,TriStorageOrder,RowMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_retval	../include/Eigen/src/Core/SolveTriangular.h	/^template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
triangular_solve_retval	../include/Eigen/src/Core/SolveTriangular.h	/^  triangular_solve_retval(const TriangularType& tri, const Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solve_retval	access:public	signature:(const TriangularType& tri, const Rhs& rhs)
triangular_solver_selector	../include/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheLeft,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
triangular_solver_selector	../include/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheRight,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
triangular_solver_selector	../include/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,1>$/;"	s	namespace:Eigen::internal
triangular_solver_selector	../include/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,Dynamic>$/;"	s	namespace:Eigen::internal
triangular_solver_unroller	../include/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,false> {$/;"	s	namespace:Eigen::internal
triangular_solver_unroller	../include/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,true> {$/;"	s	namespace:Eigen::internal
triangular_solve_vector	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_vector	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, RowMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_vector	../include/Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheRight, Mode, Conjugate, StorageOrder>$/;"	s	namespace:Eigen::internal
triangularView	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> typename ConstTriangularViewReturnType<Mode>::Type triangularView() const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:() const
triangularView	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> typename TriangularViewReturnType<Mode>::Type triangularView();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
TriangularView	../include/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularView(const MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::TriangularView	access:public	signature:(const MatrixType& matrix)
triangularView	../include/Eigen/src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::MatrixBase	signature:() const
triangularView	../include/Eigen/src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView()$/;"	f	class:Eigen::MatrixBase	signature:()
TriangularView	../include/Eigen/src/Core/TriangularMatrix.h	/^template<typename _MatrixType, unsigned int _Mode> class TriangularView$/;"	c	namespace:Eigen	inherits:TriangularBase
triangularView	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const SparseTriangularView<Derived, Mode> triangularView() const;$/;"	p	class:Eigen::SparseMatrixBase	access:public	signature:() const
triangularView	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^SparseMatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::SparseMatrixBase	signature:() const
TriangularViewReturnType	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase	access:public
tribb_kernel	../include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct tribb_kernel$/;"	s	namespace:Eigen::internal
Tridiagonalization	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^template<typename _MatrixType> class Tridiagonalization$/;"	c	namespace:Eigen
Tridiagonalization	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:(const MatrixType& matrix)
Tridiagonalization	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::Tridiagonalization	access:public	signature:(Index size = Size==Dynamic ? 2 : Size)
tridiagonalization_inplace	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& matA, CoeffVectorType& hCoeffs)
tridiagonalization_inplace	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs);$/;"	p	namespace:Eigen::internal	signature:(MatrixType& matA, CoeffVectorType& hCoeffs)
tridiagonalization_inplace	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	namespace:Eigen::internal	signature:(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
tridiagonalization_inplace_selector	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,1,IsComplex>$/;"	s	namespace:Eigen::internal
tridiagonalization_inplace_selector	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,3,false>$/;"	s	namespace:Eigen::internal
tridiagonalization_inplace_selector	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector$/;"	s	namespace:Eigen::internal
TridiagonalizationMatrixTReturnType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^template<typename MatrixType> struct TridiagonalizationMatrixTReturnType$/;"	s	namespace:Eigen::internal	inherits:ReturnByValue
TridiagonalizationMatrixTReturnType	../include/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    TridiagonalizationMatrixTReturnType(const MatrixType& mat) : m_matrix(mat) { }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType	access:public	signature:(const MatrixType& mat)
TridiagonalizationType	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Tridiagonalization<MatrixType> TridiagonalizationType;$/;"	t	class:Eigen::SelfAdjointEigenSolver	access:public
TridiagonalMatrix	../include/Eigen/src/Core/BandMatrix.h	/^class TridiagonalMatrix : public BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor>$/;"	c	namespace:Eigen::internal	inherits:BandMatrix
TridiagonalMatrix	../include/Eigen/src/Core/BandMatrix.h	/^    TridiagonalMatrix(Index size = Size) : Base(size,size,Options&SelfAdjoint?0:1,1) {}$/;"	f	class:Eigen::internal::TridiagonalMatrix	access:public	signature:(Index size = Size)
tridiagonal_qr_step	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)$/;"	f	namespace:Eigen::internal	signature:(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)
tridiagonal_qr_step	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n);$/;"	p	namespace:Eigen::internal	signature:(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)
Triplet	../include/Eigen/src/SparseCore/SparseUtil.h	/^class Triplet$/;"	c	namespace:Eigen
Triplet	../include/Eigen/src/SparseCore/SparseUtil.h	/^  Triplet(const Index& i, const Index& j, const Scalar& v = Scalar(0))$/;"	f	class:Eigen::Triplet	access:public	signature:(const Index& i, const Index& j, const Scalar& v = Scalar(0))
Triplet	../include/Eigen/src/SparseCore/SparseUtil.h	/^  Triplet() : m_row(0), m_col(0), m_value(0) {}$/;"	f	class:Eigen::Triplet	access:public	signature:()
trmv_selector	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^template<> struct trmv_selector<ColMajor>$/;"	s	namespace:Eigen::internal
trmv_selector	../include/Eigen/src/Core/products/TriangularMatrixVector.h	/^template<> struct trmv_selector<RowMajor>$/;"	s	namespace:Eigen::internal
trsolve_traits	../include/Eigen/src/Core/SolveTriangular.h	/^class trsolve_traits$/;"	c	namespace:Eigen::internal
true_type	../include/Eigen/src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
twistedBy	../include/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseSymmetricPermutationProduct<Derived,Upper|Lower> twistedBy(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const$/;"	f	class:Eigen::SparseMatrixBase	access:public	signature:(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const
twistedBy	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct<_MatrixTypeNested,UpLo> twistedBy(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const$/;"	f	class:Eigen::SparseSelfAdjointView	access:public	signature:(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const
type	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits	access:public
type	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
Type	../include/Eigen/src/Core/BandMatrix.h	/^                 BuildType>::type Type;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType	access:public
Type	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	t	struct:Eigen::DenseBase::ConstFixedSegmentReturnType	access:public
Type	../include/Eigen/src/Core/DenseBase.h	/^    template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	t	struct:Eigen::DenseBase::FixedSegmentReturnType	access:public
type	../include/Eigen/src/Core/DenseCoeffsBase.h	/^  typedef typename conditional<is_arithmetic<T>::value, T, typename add_const_on_value_type<T>::type>::type type;$/;"	t	struct:Eigen::internal::add_const_on_value_type_if_arithmetic	access:public
Type	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef CoeffBasedProduct<LhsNested, RhsNested, EvalBeforeAssigningBit | EvalBeforeNestingBit> Type;$/;"	t	struct:Eigen::ProductReturnType	access:public
Type	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef CoeffBasedProduct<LhsNested, RhsNested, NestByRefBit> Type;$/;"	t	struct:Eigen::ProductReturnType	access:public
Type	../include/Eigen/src/Core/GeneralProduct.h	/^  typedef GeneralProduct<Lhs\/*Nested*\/, Rhs\/*Nested*\/, ProductType> Type;$/;"	t	struct:Eigen::ProductReturnType	access:public
type	../include/Eigen/src/Core/GenericPacketMath.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::packet_traits	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	t	struct:Eigen::internal::always_void	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::atan2_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::conj_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::pow_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::random_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::sqrt_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::abs2_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::abs_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::hypot_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::imag_ref_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::imag_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::norm1_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::real_ref_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::real_retval	access:public
type	../include/Eigen/src/Core/MathFunctions.h	/^  typedef typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base	access:public
Type	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstDiagonalIndexReturnType	access:public
Type	../include/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::DiagonalIndexReturnType	access:public
Type	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstTriangularViewReturnType	access:public
Type	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::TriangularViewReturnType	access:public
Type	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstSelfAdjointViewReturnType	access:public
Type	../include/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::SelfAdjointViewReturnType	access:public
type	../include/Eigen/src/Core/MatrixBase.h	/^      typedef Matrix<Scalar,MatrixBase::RowsAtCompileTime,MatrixBase::ColsAtCompileTime> type;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type	access:public
type	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedAlignedMapType	access:public
type	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstAlignedMapType	access:public
type	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstMapType	access:public
type	../include/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedMapType	access:public
type	../include/Eigen/src/Core/ProductBase.h	/^  typedef PlainObject const& type;$/;"	t	struct:Eigen::internal::nested	access:public
type	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef PlainObject const& type;$/;"	t	struct:Eigen::internal::nested	access:public
type	../include/Eigen/src/Core/ReturnByValue.h	/^  typedef typename traits<Derived>::ReturnType type;$/;"	t	struct:Eigen::internal::nested	access:public
type	../include/Eigen/src/Core/Transpose.h	/^  typedef typename dense_xpr_base<Transpose<MatrixType> >::type type;$/;"	t	struct:Eigen::internal::TransposeImpl_base	access:public
type	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef SelfAdjointView<MatrixType, Upper> type;$/;"	t	struct:Eigen::internal::eigen2_part_return_type	access:public
type	../include/Eigen/src/Core/TriangularMatrix.h	/^  typedef TriangularView<MatrixType, Mode> type;$/;"	t	struct:Eigen::internal::eigen2_part_return_type	access:public
type	../include/Eigen/src/Core/TriangularMatrix.h	/^      typedef typename ProdRetType::PlainObject type;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type	access:public
Type	../include/Eigen/src/Core/util/Constants.h	/^  enum Type {$/;"	g	namespace:Eigen::Architecture
type	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^  typedef ComplexScalar type(ComplexScalar, int);$/;"	t	struct:Eigen::internal::stem_function	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select {typedef ArgType0 type;};$/;"	t	struct:Eigen::internal::binary_result_of_select	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	t	struct:Eigen::internal::conditional	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	t	struct:Eigen::internal::conditional	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select {typedef ArgType type;};$/;"	t	struct:Eigen::internal::unary_result_of_select	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	t	struct:Eigen::internal::remove_const	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	t	struct:Eigen::internal::remove_const	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	t	struct:Eigen::internal::add_const_on_value_type	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	t	struct:Eigen::internal::add_const	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	t	struct:Eigen::internal::add_const	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	t	struct:Eigen::internal::remove_all	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^{ typedef T type; };$/;"	t	struct:Eigen::internal::enable_if	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^    typedef typename binary_result_of_select<Func, ArgType0, ArgType1, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^{typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^{typedef typename Func::template result<Func(ArgType0,ArgType1)>::type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select	access:public
type	../include/Eigen/src/Core/util/Meta.h	/^    typedef typename unary_result_of_select<Func, ArgType, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of	access:public
Type	../include/Eigen/src/Core/VectorwiseOp.h	/^                        Direction==Horizontal ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::ExtendedType	access:public
Type	../include/Eigen/src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReduxReturnType	access:public
Type	../include/Eigen/src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReturnType	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T>   { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T*>  { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T&>  { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T*>        { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T&>        { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype { typedef T type; };$/;"	t	struct:Eigen::ei_cleantype	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<const T> { typedef T type; };$/;"	t	struct:Eigen::ei_unconst	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const *> { typedef T * type; };$/;"	t	struct:Eigen::ei_unconst	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const &> { typedef T & type; };$/;"	t	struct:Eigen::ei_unconst	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst { typedef T type; };$/;"	t	struct:Eigen::ei_unconst	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*> { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref<T&> { typedef T type; };$/;"	t	struct:Eigen::ei_unref	access:public
type	../include/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref { typedef T type; };$/;"	t	struct:Eigen::ei_unref	access:public
type	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef MatrixOrTransformType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
type	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename internal::add_const<typename TransformType::ConstAffinePart>::type type;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
type	../include/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename TransformType::MatrixType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product	access:public
type	../include/Eigen/src/Geometry/Umeyama.h	/^  > type;$/;"	t	struct:Eigen::internal::umeyama_transform_matrix_type	access:public
Type	../include/Eigen/src/Householder/HouseholderSequence.h	/^                 0, MatrixType::MaxRowsAtCompileTime, MatrixType::MaxColsAtCompileTime> Type;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type	access:public
Type	../include/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:ConstNColsBlockXpr	access:public
Type	../include/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:ConstNRowsBlockXpr	access:public
Type	../include/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:NColsBlockXpr	access:public
Type	../include/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:NRowsBlockXpr	access:public
Type	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef DenseTimeSparseProduct<Lhs,Rhs> Type;$/;"	t	struct:Eigen::DenseSparseProductReturnType	access:public
Type	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef SparseDenseOuterProduct<Lhs,Rhs,false> Type;$/;"	t	struct:Eigen::SparseDenseProductReturnType	access:public
Type	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef SparseDenseOuterProduct<Rhs,Lhs,true> Type;$/;"	t	struct:Eigen::DenseSparseProductReturnType	access:public
Type	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef SparseTimeDenseProduct<Lhs,Rhs> Type;$/;"	t	struct:Eigen::SparseDenseProductReturnType	access:public
Type	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef SparseSparseProduct<LhsNested, RhsNested> Type;$/;"	t	struct:Eigen::SparseSparseProductReturnType	access:public
type	../include/Eigen/src/SparseCore/SparseUtil.h	/^    typedef Matrix<_Scalar, 1, 1> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
type	../include/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Flags> type;$/;"	t	struct:Eigen::internal::plain_matrix_type	access:public
type	../include/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Flags> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
type	../include/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, _Flags> type;$/;"	t	struct:Eigen::internal::sparse_eval	access:public
UMatrixType	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType,  Upper>           UMatrixType;$/;"	t	class:Eigen::SuperLU	access:public
umeyama	../include/Eigen/src/Geometry/Umeyama.h	/^umeyama(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)$/;"	f	namespace:Eigen	signature:(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)
umeyama_transform_matrix_type	../include/Eigen/src/Geometry/Umeyama.h	/^struct umeyama_transform_matrix_type$/;"	s	namespace:Eigen::internal
umfpack_free_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, double)$/;"	f	namespace:Eigen	signature:(void **Numeric, double)
umfpack_free_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, std::complex<double>)$/;"	f	namespace:Eigen	signature:(void **Numeric, std::complex<double>)
umfpack_free_symbolic	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, double)$/;"	f	namespace:Eigen	signature:(void **Symbolic, double)
umfpack_free_symbolic	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, std::complex<double>)$/;"	f	namespace:Eigen	signature:(void **Symbolic, std::complex<double>)
umfpack_get_determinant	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen	signature:(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])
umfpack_get_determinant	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen	signature:(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])
umfpack_get_lunz	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)$/;"	f	namespace:Eigen	signature:(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)
umfpack_get_lunz	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)$/;"	f	namespace:Eigen	signature:(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)
umfpack_get_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[],$/;"	f	namespace:Eigen	signature:(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[], int P[], int Q[], double Dx[], int *do_recip, double Rs[], void *Numeric)
umfpack_get_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[],$/;"	f	namespace:Eigen	signature:(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[], int P[], int Q[], std::complex<double> Dx[], int *do_recip, double Rs[], void *Numeric)
UmfPackLU	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^class UmfPackLU : internal::noncopyable$/;"	c	namespace:Eigen	inherits:internal::noncopyable
UmfPackLU	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU	access:public	signature:(const MatrixType& matrix)
~UmfPackLU	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    ~UmfPackLU()$/;"	f	class:Eigen::UmfPackLU	access:public	signature:()
UmfPackLU	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU() { init(); }$/;"	f	class:Eigen::UmfPackLU	access:public	signature:()
UmfPackLU	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(UmfPackLU& ) { }$/;"	f	class:Eigen::UmfPackLU	access:private	signature:(UmfPackLU& )
UmfpackMatrixType	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar,ColMajor,int> UmfpackMatrixType;$/;"	t	class:Eigen::UmfPackLU	access:public
umfpack_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen	signature:( const int Ap[], const int Ai[], const double Ax[], void *Symbolic, void **Numeric, const double Control[UMFPACK_CONTROL],double Info [UMFPACK_INFO])
umfpack_numeric	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen	signature:( const int Ap[], const int Ai[], const std::complex<double> Ax[], void *Symbolic, void **Numeric, const double Control[UMFPACK_CONTROL],double Info [UMFPACK_INFO])
umfpack_solve	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen	signature:( int sys, const int Ap[], const int Ai[], const double Ax[], double X[], const double B[], void *Numeric, const double Control[UMFPACK_CONTROL], double Info[UMFPACK_INFO])
umfpack_solve	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen	signature:( int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[], std::complex<double> X[], const std::complex<double> B[], void *Numeric, const double Control[UMFPACK_CONTROL], double Info[UMFPACK_INFO])
umfpack_symbolic	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_symbolic(int n_row,int n_col,$/;"	f	namespace:Eigen	signature:(int n_row,int n_col, const int Ap[], const int Ai[], const double Ax[], void **Symbolic, const double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])
umfpack_symbolic	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_symbolic(int n_row,int n_col,$/;"	f	namespace:Eigen	signature:(int n_row,int n_col, const int Ap[], const int Ai[], const std::complex<double> Ax[], void **Symbolic, const double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])
unaligned_assign_impl	../include/Eigen/src/Core/Assign.h	/^struct unaligned_assign_impl<false>$/;"	s	namespace:Eigen::internal
unaligned_assign_impl	../include/Eigen/src/Core/Assign.h	/^struct unaligned_assign_impl$/;"	s	namespace:Eigen::internal
Unaligned	../include/Eigen/src/Core/util/Constants.h	/^  Unaligned=0, $/;"	e	enum:Eigen::__anon208
UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC	../include/Eigen/src/Core/util/StaticAssert.h	/^        UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
unaryExpr	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^unaryExpr(const CustomUnaryOp& func = CustomUnaryOp()) const$/;"	f	signature:(const CustomUnaryOp& func = CustomUnaryOp()) const
unary_result_of_select	../include/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	s	namespace:Eigen::internal
unary_result_of_select	../include/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	s	namespace:Eigen::internal
unary_result_of_select	../include/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select {typedef ArgType type;};$/;"	s	namespace:Eigen::internal
unaryViewExpr	../include/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^unaryViewExpr(const CustomViewOp& func = CustomViewOp()) const$/;"	f	signature:(const CustomViewOp& func = CustomViewOp()) const
unblocked	../include/Eigen/src/Cholesky/LDLT.h	/^  static bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, int* sign=0)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, int* sign=0)
unblocked	../include/Eigen/src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, int* sign=0)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, int* sign=0)
unblocked	../include/Eigen/src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE typename MatrixType::Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat)
unblocked	../include/Eigen/src/Cholesky/LLT.h	/^  static typename MatrixType::Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace	access:public	signature:(MatrixType& mat)
unblocked_lu	../include/Eigen/src/LU/PartialPivLU.h	/^  static Index unblocked_lu(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)$/;"	f	struct:Eigen::internal::partial_lu_impl	access:public	signature:(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)
UniformScaling	../include/Eigen/src/Geometry/Scaling.h	/^class UniformScaling$/;"	c	namespace:Eigen
UniformScaling	../include/Eigen/src/Geometry/Scaling.h	/^  explicit inline UniformScaling(const Scalar& s) : m_factor(s) {}$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const Scalar& s)
UniformScaling	../include/Eigen/src/Geometry/Scaling.h	/^  inline explicit UniformScaling(const UniformScaling<OtherScalarType>& other)$/;"	f	class:Eigen::UniformScaling	access:public	signature:(const UniformScaling<OtherScalarType>& other)
UniformScaling	../include/Eigen/src/Geometry/Scaling.h	/^  UniformScaling() {}$/;"	f	class:Eigen::UniformScaling	access:public	signature:()
UnitDiagBit	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitDiagBit = UnitDiag;$/;"	m	namespace:Eigen
UnitDiag	../include/Eigen/src/Core/util/Constants.h	/^  UnitDiag=0x4, $/;"	e	enum:Eigen::__anon207
Unit	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index i)$/;"	f	class:Eigen::MatrixBase	signature:(Index i)
Unit	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index size, Index i)$/;"	f	class:Eigen::MatrixBase	signature:(Index size, Index i)
Unit	../include/Eigen/src/Core/MatrixBase.h	/^    static const BasisReturnType Unit(Index i);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index i)
Unit	../include/Eigen/src/Core/MatrixBase.h	/^    static const BasisReturnType Unit(Index size, Index i);$/;"	p	class:Eigen::MatrixBase	access:public	signature:(Index size, Index i)
UnitLower	../include/Eigen/src/Core/util/Constants.h	/^  UnitLower=UnitDiag|Lower, $/;"	e	enum:Eigen::__anon207
UnitLowerTriangular	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitLowerTriangular = UnitLower;$/;"	m	namespace:Eigen
unitOrthogonal	../include/Eigen/src/Core/MatrixBase.h	/^    PlainObject unitOrthogonal(void) const;$/;"	p	class:Eigen::MatrixBase	access:public	signature:(void) const
unitOrthogonal	../include/Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::unitOrthogonal() const$/;"	f	class:Eigen::MatrixBase	signature:() const
unitOrthogonal_selector	../include/Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,2>$/;"	s	namespace:Eigen::internal
unitOrthogonal_selector	../include/Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,3>$/;"	s	namespace:Eigen::internal
unitOrthogonal_selector	../include/Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector$/;"	s	namespace:Eigen::internal
UnitUpper	../include/Eigen/src/Core/util/Constants.h	/^  UnitUpper=UnitDiag|Upper,$/;"	e	enum:Eigen::__anon207
UnitUpperTriangular	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitUpperTriangular = UnitUpper;$/;"	m	namespace:Eigen
UnitW	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitW()$/;"	f	class:Eigen::MatrixBase	signature:()
UnitW	../include/Eigen/src/Core/MatrixBase.h	/^    static const BasisReturnType UnitW();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
UnitX	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitX()$/;"	f	class:Eigen::MatrixBase	signature:()
UnitX	../include/Eigen/src/Core/MatrixBase.h	/^    static const BasisReturnType UnitX();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
UnitY	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitY()$/;"	f	class:Eigen::MatrixBase	signature:()
UnitY	../include/Eigen/src/Core/MatrixBase.h	/^    static const BasisReturnType UnitY();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
UnitZ	../include/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitZ()$/;"	f	class:Eigen::MatrixBase	signature:()
UnitZ	../include/Eigen/src/Core/MatrixBase.h	/^    static const BasisReturnType UnitZ();$/;"	p	class:Eigen::MatrixBase	access:public	signature:()
unpacket_traits	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	../include/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	../include/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpackRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void unpackRhs(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)
unpackRhs	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void unpackRhs(DenseIndex n, const Scalar* rhs, Scalar* b)$/;"	f	class:Eigen::internal::gebp_traits	access:public	signature:(DenseIndex n, const Scalar* rhs, Scalar* b)
Unroll	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^      Unroll = CoeffReadCost != Dynamic && CoeffReadCost <= EIGEN_UNROLLING_LIMIT,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon88
Unrolling	../include/Eigen/src/Core/Assign.h	/^    Unrolling = (int(Traversal) == int(InnerVectorizedTraversal) || int(Traversal) == int(DefaultTraversal))$/;"	e	enum:Eigen::internal::assign_traits::__anon223
Unrolling	../include/Eigen/src/Core/Redux.h	/^    Unrolling = Cost != Dynamic && Cost <= UnrollingLimit$/;"	e	enum:Eigen::internal::redux_traits::__anon271
Unrolling	../include/Eigen/src/Core/SolveTriangular.h	/^      Unrolling   = (RhsIsVectorAtCompileTime && Rhs::SizeAtCompileTime != Dynamic && Rhs::SizeAtCompileTime <= 8)$/;"	e	enum:Eigen::internal::trsolve_traits::__anon363
UnrollingLimit	../include/Eigen/src/Core/Assign.h	/^    UnrollingLimit      = EIGEN_UNROLLING_LIMIT * (Vectorized ? int(PacketSize) : 1),$/;"	e	enum:Eigen::internal::assign_traits::__anon222
UnrollingLimit	../include/Eigen/src/Core/Redux.h	/^    UnrollingLimit = EIGEN_UNROLLING_LIMIT * (int(Traversal) == int(DefaultTraversal) ? 1 : int(PacketSize))$/;"	e	enum:Eigen::internal::redux_traits::__anon270
Unusable	../include/Eigen/src/Core/ReturnByValue.h	81;"	d
Unusable	../include/Eigen/src/Core/ReturnByValue.h	/^    class Unusable{$/;"	c	class:Eigen::ReturnByValue	access:public
Unusable	../include/Eigen/src/Core/ReturnByValue.h	/^      Unusable(const Unusable&) {}$/;"	f	class:Eigen::ReturnByValue::Unusable	access:private	signature:(const Unusable&)
update	../include/Eigen/src/Cholesky/LDLT.h	/^  static bool update(MatrixType& mat, const TranspositionType& transpositions, Workspace& tmp, const WType& w, typename MatrixType::RealScalar sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, const TranspositionType& transpositions, Workspace& tmp, const WType& w, typename MatrixType::RealScalar sigma=1)
update	../include/Eigen/src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool update(MatrixType& mat, TranspositionType& transpositions, Workspace& tmp, WType& w, typename MatrixType::RealScalar sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, TranspositionType& transpositions, Workspace& tmp, WType& w, typename MatrixType::RealScalar sigma=1)
updateInPlace	../include/Eigen/src/Cholesky/LDLT.h	/^  static bool updateInPlace(MatrixType& mat, MatrixBase<WDerived>& w, typename MatrixType::RealScalar sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace	access:public	signature:(MatrixType& mat, MatrixBase<WDerived>& w, typename MatrixType::RealScalar sigma=1)
UpLo	../include/Eigen/src/Cholesky/LDLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LDLT::__anon405
UpLo	../include/Eigen/src/Cholesky/LLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LLT::__anon404
UpLo	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::CholmodBase::__anon3
UpLo	../include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^    UpLo = _UpLo$/;"	e	enum:Eigen::ConjugateGradient::__anon10
UpLo	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = Options&(Upper|Lower) };$/;"	e	enum:Eigen::PardisoLDLT::__anon402
UpLo	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PardisoLLT::__anon401
UpLo	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLDLT::__anon47
UpLo	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLLT::__anon46
UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = internal::traits<Derived>::UpLo };$/;"	e	enum:Eigen::SimplicialCholeskyBase::__anon406
UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon407
UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon408
UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon409
UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialCholesky::__anon412
UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLDLT::__anon411
UpLo	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLLT::__anon410
UpperBidiagonalization	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^template<typename _MatrixType> class UpperBidiagonalization$/;"	c	namespace:Eigen::internal
UpperBidiagonalization	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:(const MatrixType& matrix)
UpperBidiagonalization	../include/Eigen/src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization() : m_householder(), m_bidiagonal(), m_isInitialized(false) {}$/;"	f	class:Eigen::internal::UpperBidiagonalization	access:public	signature:()
Upper	../include/Eigen/src/Core/util/Constants.h	/^  Upper=0x2,                      $/;"	e	enum:Eigen::__anon207
upperMat	splib_utils.cpp	/^MV_ColMat_double upperMat(MV_ColMat_double &M){$/;"	f
UpperTriangularBit	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UpperTriangularBit = Upper;$/;"	m	namespace:Eigen
UpperTriangular	../include/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UpperTriangular = Upper;$/;"	m	namespace:Eigen
users	../include/Eigen/src/Core/products/Parallelizer.h	/^  int volatile users;$/;"	m	struct:Eigen::internal::GemmParallelInfo	access:public
use_xk	../include/abcd.h	/^    bool use_xk;$/;"	m	class:abcd	access:private
val	../include/abcd.h	/^    double *val;$/;"	m	class:abcd	access:public
value	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon243
value	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon241
value	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon242
value	../include/Eigen/src/Core/DenseBase.h	/^    CoeffReturnType value() const$/;"	f	class:Eigen::DenseBase	access:public	signature:() const
value	../include/Eigen/src/Core/GeneralProduct.h	/^         value = is_large  ? Large$/;"	e	enum:Eigen::internal::product_size_category::__anon121
value	../include/Eigen/src/Core/GeneralProduct.h	/^    value = selector::ret$/;"	e	enum:Eigen::internal::product_type::__anon124
value	../include/Eigen/src/Core/MathFunctions.h	/^  enum { value = floor_log2<n, floor_log2_selector<n, lower, upper>::middle, upper>::value };$/;"	e	enum:Eigen::internal::floor_log2::__anon265
value	../include/Eigen/src/Core/MathFunctions.h	/^  enum { value = floor_log2<n, lower, floor_log2_selector<n, lower, upper>::middle>::value };$/;"	e	enum:Eigen::internal::floor_log2::__anon264
value	../include/Eigen/src/Core/MathFunctions.h	/^  enum { value = (n >= ((unsigned int)(1) << (lower+1))) ? lower+1 : lower };$/;"	e	enum:Eigen::internal::floor_log2::__anon266
value	../include/Eigen/src/Core/MathFunctions.h	/^         value = (upper <= lower + 1) ? int(floor_log2_terminate)$/;"	e	enum:Eigen::internal::floor_log2_selector::__anon263
value	../include/Eigen/src/Core/util/ForwardDeclarations.h	/^         value = has_direct_access ? (has_write_access ? DirectWriteAccessors : DirectAccessors)$/;"	e	enum:Eigen::internal::accessors_level::__anon206
value	../include/Eigen/src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::false_type::__anon174
value	../include/Eigen/src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	e	enum:Eigen::internal::true_type::__anon173
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon181
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon182
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon179
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon178
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon180
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon183
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon187
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon189
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon185
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon184
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon188
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon190
value	../include/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon186
value	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon177
value	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_const::__anon191
value	../include/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_const::__anon192
value	../include/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_same::__anon176
value	../include/Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_same::__anon175
value	../include/Eigen/src/Core/VectorwiseOp.h	/^  { enum { value = (Size-1) * functor_traits<BinaryOp>::Cost }; };$/;"	e	enum:Eigen::internal::member_redux::Cost::__anon70
value	../include/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar value() const { return m_cachedValue; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/AmbiVector.h	/^      Scalar value;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl	access:public
value	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline const Scalar& value(size_t i) const { return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i) const
value	../include/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar& value(size_t i) { return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage	access:public	signature:(size_t i)
value	../include/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::DenseBase::InnerIterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_id-1]; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_id]; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_functor(m_lhsIter.value(), m_rhsIter.value()); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_value; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryOpImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryOpImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Scalar value() const { return Base::value() * m_factor; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar& value() const { return m_values[m_id-1]; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar& value() const { return m_values[m_id]; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Scalar value() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseUtil.h	/^  const Scalar& value() const { return m_value; }$/;"	f	class:Eigen::Triplet	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar value() const { return m_data.value(m_id-1); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:() const
value	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar value() const { return m_data.value(m_id); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:() const
valuePtr	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline const Scalar* valuePtr() const { return m_values; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:() const
valuePtr	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar* valuePtr() { return m_values; }$/;"	f	class:Eigen::MappedSparseMatrix	access:public	signature:()
valuePtr	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar* valuePtr() const$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:() const
valuePtr	../include/Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar* valuePtr()$/;"	f	class:Eigen::SparseInnerVectorSet	access:public	signature:()
valuePtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar* valuePtr() const { return &m_data.value(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:() const
valuePtr	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar* valuePtr() { return &m_data.value(0); }$/;"	f	class:Eigen::SparseMatrix	access:public	signature:()
valuePtr	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Scalar* valuePtr() const { return &m_data.value(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:() const
valuePtr	../include/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Scalar* valuePtr() { return &m_data.value(0); }$/;"	f	class:Eigen::SparseVector	access:public	signature:()
valueRef	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_id-1]); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator	access:public	signature:()
valueRef	../include/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_id]); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator	access:public	signature:()
valueRef	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator	access:public	signature:()
valueRef	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator	access:public	signature:()
valueRef	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typename CwiseUnaryOpImpl::Scalar& valueRef();$/;"	p	class:Eigen::CwiseUnaryOpImpl::InnerIterator	access:private	signature:()
valueRef	../include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typename CwiseUnaryOpImpl::Scalar& valueRef();$/;"	p	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator	access:private	signature:()
valueRef	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id-1]); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator	access:public	signature:()
valueRef	../include/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id]); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator	access:public	signature:()
valueRef	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_data.value(m_id-1)); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator	access:public	signature:()
valueRef	../include/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_data.value(m_id)); }$/;"	f	class:Eigen::SparseVector::InnerIterator	access:public	signature:()
values	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void *values;$/;"	m	struct:Eigen::SluMatrix::__anon1	access:public
value_type	../include/Eigen/src/Core/util/Memory.h	/^    typedef T         value_type;$/;"	t	class:Eigen::aligned_allocator	access:public
value_type	../include/Eigen/src/SparseCore/SparseMatrix.h	/^        typedef Index value_type;$/;"	t	class:Eigen::SparseMatrix::SingletonVector	access:public
value_type	../include/Eigen/src/StlSupport/details.h	/^    typedef T         value_type;$/;"	t	class:Eigen::aligned_allocator_indirection	access:public
vec2d_swizzle1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	54;"	d
vec4f_swizzle1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	48;"	d
vec4f_swizzle2	../include/Eigen/src/Core/arch/SSE/PacketMath.h	57;"	d
vec4i_swizzle1	../include/Eigen/src/Core/arch/SSE/PacketMath.h	51;"	d
vec4i_swizzle2	../include/Eigen/src/Core/arch/SSE/PacketMath.h	60;"	d
vec	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Block<Coefficients,3,1> vec() { return m_coeffs.template start<3>(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
vec	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline const Block<const Coefficients,3,1> vec() const { return m_coeffs.template start<3>(); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
vec	../include/Eigen/src/Geometry/Quaternion.h	/^  inline const VectorBlock<const Coefficients,3> vec() const { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
vec	../include/Eigen/src/Geometry/Quaternion.h	/^  inline VectorBlock<Coefficients,3> vec() { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
Vector2	../include/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D	access:public
Vector2	../include/Eigen/src/Geometry/OrthoMethods.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
Vector2	../include/Eigen/src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D	access:public
Vector3	../include/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis	access:public
Vector3	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::Quaternion	access:public
Vector3	../include/Eigen/src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis	access:public
Vector3	../include/Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::QuaternionBase	access:public
Vector3s	../include/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealSchur	access:private
vector_base	../include/Eigen/src/StlSupport/StdVector.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > vector_base;$/;"	t	class:std::vector	access:private
VectorBlock	../include/Eigen/src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start)$/;"	f	class:Eigen::VectorBlock	access:public	signature:(VectorType& vector, Index start)
VectorBlock	../include/Eigen/src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start, Index size)$/;"	f	class:Eigen::VectorBlock	access:public	signature:(VectorType& vector, Index start, Index size)
VectorBlock	../include/Eigen/src/Core/VectorBlock.h	/^template<typename VectorType, int Size> class VectorBlock$/;"	c	namespace:Eigen	inherits:Block
vectorD	../include/Eigen/src/Cholesky/LDLT.h	/^    inline Diagonal<const MatrixType> vectorD() const$/;"	f	class:Eigen::LDLT	access:public	signature:() const
vectorD	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialCholesky	access:public	signature:() const
vectorD	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialLDLT	access:public	signature:() const
VectorI	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<Index,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSelfAdjointView	access:public
VectorI	../include/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<Index,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct	access:public
vector	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:() const
vector	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:()
vector	../include/Eigen/src/Geometry/Translation.h	/^  const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:() const
vector	../include/Eigen/src/Geometry/Translation.h	/^  VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation	access:public	signature:()
Vector	../include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::DiagonalPreconditioner	access:private
Vector	../include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::IncompleteLUT	access:private
Vector	../include/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::PastixBase	access:public
vector	../include/Eigen/src/StlSupport/StdVector.h	/^  class vector<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std	inherits:vector
Vector	../include/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::SuperLUBase	access:public
Vector	../include/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::UmfPackLU	access:public
Vectorizable	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon250
Vectorizable	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon252
Vectorizable	../include/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
Vectorizable	../include/Eigen/src/Core/arch/NEON/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon256
Vectorizable	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
Vectorizable	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
Vectorizable	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon237
Vectorizable	../include/Eigen/src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon239
Vectorizable	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon244
Vectorizable	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon245
Vectorizable	../include/Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon246
_Vectorizable	../include/Eigen/src/Core/DiagonalProduct.h	/^    _Vectorizable = bool(int(MatrixType::Flags)&PacketAccessBit) && _SameTypes && ((!_PacketOnDiag) || (bool(int(DiagonalType::Flags)&PacketAccessBit))),$/;"	e	enum:Eigen::internal::traits::__anon77
Vectorizable	../include/Eigen/src/Core/Functors.h	/^    Vectorizable = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasMul && packet_traits<RhsScalar>::HasMul$/;"	e	enum:Eigen::internal::scalar_product_op::__anon292
Vectorizable	../include/Eigen/src/Core/GenericPacketMath.h	/^    Vectorizable = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon230
Vectorizable	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
Vectorizable	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
Vectorizable	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
Vectorizable	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
Vectorizable	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable  = Traits::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon99
Vectorizable	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon91
Vectorizable	../include/Eigen/src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon92
Vectorized	../include/Eigen/src/Core/Assign.h	/^    Vectorized = int(Traversal) == InnerVectorizedTraversal$/;"	e	enum:Eigen::internal::assign_traits::__anon221
VectorizedSize	../include/Eigen/src/Core/Redux.h	/^    VectorizedSize = (Size \/ PacketSize) * PacketSize$/;"	e	enum:Eigen::internal::redux_impl::__anon276
VectorType	../include/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::AlignedBox	access:public
VectorType	../include/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane	access:public
VectorType	../include/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::ParametrizedLine	access:public
VectorType	../include/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Scaling	access:public
VectorType	../include/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform	access:public
VectorType	../include/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation	access:public
VectorType	../include/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, 1, Size, Options | RowMajor, 1, MaxSize> VectorType;$/;"	t	class:Eigen::HessenbergDecomposition	access:private
VectorType	../include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::RealVectorType VectorType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues	access:public
VectorType	../include/Eigen/src/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1>  VectorType;$/;"	t	class:Eigen::AlignedBox	access:public
VectorType	../include/Eigen/src/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane	access:public
VectorType	../include/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename plain_matrix_type<Derived>::type VectorType;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector	access:public
VectorType	../include/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1,Options> VectorType;$/;"	t	class:Eigen::ParametrizedLine	access:public
VectorType	../include/Eigen/src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::RotationBase	access:public
VectorType	../include/Eigen/src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform	access:public
VectorType	../include/Eigen/src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation	access:public
VectorType	../include/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::PardisoImpl	access:public
VectorType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholesky	access:public
VectorType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholeskyBase	access:public
VectorType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLDLT	access:public
VectorType	../include/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLLT	access:public
VectorwiseOp	../include/Eigen/src/Core/VectorwiseOp.h	/^    inline VectorwiseOp(ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::VectorwiseOp	access:public	signature:(ExpressionType& matrix)
VectorwiseOp	../include/Eigen/src/Core/VectorwiseOp.h	/^template<typename ExpressionType, int Direction> class VectorwiseOp$/;"	c	namespace:Eigen
Vertical	../include/Eigen/src/Core/util/Constants.h	/^  Vertical, $/;"	e	enum:Eigen::DirectionType
viewAsCholmod	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_dense viewAsCholmod(MatrixBase<Derived>& mat)$/;"	f	namespace:Eigen	signature:(MatrixBase<Derived>& mat)
viewAsCholmod	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(const SparseSelfAdjointView<SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)$/;"	f	namespace:Eigen	signature:(const SparseSelfAdjointView<SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)
viewAsCholmod	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen	signature:(SparseMatrix<_Scalar,_Options,_Index>& mat)
viewAsCholmod	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^const cholmod_sparse viewAsCholmod(const SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen	signature:(const SparseMatrix<_Scalar,_Options,_Index>& mat)
viewAsEigen	../include/Eigen/src/CholmodSupport/CholmodSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> viewAsEigen(cholmod_sparse& cm)$/;"	f	namespace:Eigen	signature:(cholmod_sparse& cm)
v	../include/Eigen/src/Core/arch/AltiVec/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf	access:public
v	../include/Eigen/src/Core/arch/NEON/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf	access:public
v	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  __m128d  v;$/;"	m	struct:Eigen::internal::Packet1cd	access:public
v	../include/Eigen/src/Core/arch/SSE/Complex.h	/^  __m128  v;$/;"	m	struct:Eigen::internal::Packet2cf	access:public
visit	../include/Eigen/src/Core/DenseBase.h	/^    void visit(Visitor& func) const;$/;"	p	class:Eigen::DenseBase	access:public	signature:(Visitor& func) const
visit	../include/Eigen/src/Core/Visitor.h	/^void DenseBase<Derived>::visit(Visitor& visitor) const$/;"	f	class:Eigen::DenseBase	signature:(Visitor& visitor) const
visitor_impl	../include/Eigen/src/Core/Visitor.h	/^struct visitor_impl$/;"	s	namespace:Eigen::internal
visitor_impl	../include/Eigen/src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, 1>$/;"	s	namespace:Eigen::internal
visitor_impl	../include/Eigen/src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, Dynamic>$/;"	s	namespace:Eigen::internal
vld1_f32	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x2_t vld1_f32 (const float* x) { return ::vld1_f32 ((const float32_t*)x); }$/;"	f	namespace:Eigen::internal	signature:(const float* x)
vld1q_f32	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x4_t vld1q_f32(const float* x) { return ::vld1q_f32((const float32_t*)x); }$/;"	f	namespace:Eigen::internal	signature:(const float* x)
vml_assign_impl	../include/Eigen/src/Core/Assign_MKL.h	/^struct vml_assign_impl<Derived1, Derived2, UnaryOp, Traversal, Unrolling, InnerVectorizedTraversal>$/;"	s	namespace:Eigen::internal
vml_assign_impl	../include/Eigen/src/Core/Assign_MKL.h	/^struct vml_assign_impl<Derived1, Derived2, UnaryOp, Traversal, Unrolling, LinearVectorizedTraversal>$/;"	s	namespace:Eigen::internal
vml_assign_impl	../include/Eigen/src/Core/Assign_MKL.h	/^struct vml_assign_impl$/;"	s	namespace:Eigen::internal	inherits:assign_impl
vml_assign_traits	../include/Eigen/src/Core/Assign_MKL.h	/^class vml_assign_traits$/;"	c	namespace:Eigen::internal
vml_call	../include/Eigen/src/Core/Assign_MKL.h	/^template<typename Op> struct vml_call$/;"	s	namespace:Eigen::internal
VmlSize	../include/Eigen/src/Core/Assign_MKL.h	/^      VmlSize = MightLinearize ? MaxSizeAtCompileTime : InnerMaxSize,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon283
volume	../include/Eigen/src/Geometry/AlignedBox.h	/^  inline Scalar volume() const$/;"	f	class:Eigen::AlignedBox	access:public	signature:() const
vst1_f32	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1_f32 (float* to, float32x2_t from) { ::vst1_f32 ((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, float32x2_t from)
vst1q_f32	../include/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1q_f32(float* to, float32x4_t from) { ::vst1q_f32((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal	signature:(float* to, float32x4_t from)
w	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    w() const { return (*this)[3]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
w	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    w() { return (*this)[3]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
w	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar w() const { return m_coeffs.coeff(3); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
w	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& w() { return m_coeffs.coeffRef(3); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
w	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar w() const { return this->derived().coeffs().coeff(3); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
w	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& w() { return this->derived().coeffs().coeffRef(3); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
WithFormat	../include/Eigen/src/Core/IO.h	/^class WithFormat$/;"	c	namespace:Eigen
WithFormat	../include/Eigen/src/Core/IO.h	/^    WithFormat(const ExpressionType& matrix, const IOFormat& format)$/;"	f	class:Eigen::WithFormat	access:public	signature:(const ExpressionType& matrix, const IOFormat& format)
workaround_msvc_stl_support	../include/Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support(const T& other) : T(other) {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:(const T& other)
workaround_msvc_stl_support	../include/Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support() : T() {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support	access:public	signature:()
workaround_msvc_stl_support	../include/Eigen/src/StlSupport/details.h	/^  template<typename T> struct workaround_msvc_stl_support : public T$/;"	s	namespace:Eigen::internal	inherits:T
WorkMatrixType	../include/Eigen/src/SVD/JacobiSVD.h	/^            WorkMatrixType;$/;"	t	class:Eigen::JacobiSVD	access:public
WorkSpaceFactor	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr * RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon95
WorkSpaceFactor	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr*RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon96
WorkSpaceFactor	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr*RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon98
WorkSpaceFactor	../include/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = Vectorizable ? 2*nr*RealPacketSize : nr,$/;"	e	enum:Eigen::internal::gebp_traits::__anon97
WorkspaceType	../include/Eigen/src/SVD/JacobiSVD.h	/^  typedef Matrix<Scalar, 1, RowsAtCompileTime, RowMajor, 1, MaxRowsAtCompileTime> WorkspaceType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl	access:public
WorkVectorType	../include/Eigen/src/QR/FullPivHouseholderQR.h	/^                 MatrixType::MaxRowsAtCompileTime> WorkVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType	access:public
WriteAccessors	../include/Eigen/src/Core/util/Constants.h	/^  WriteAccessors, $/;"	e	enum:Eigen::AccessorLevels
writePacketByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacketByOuterInner$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index outer, Index inner, const typename internal::packet_traits<Scalar>::type& x)
writePacketByOuterInner	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void writePacketByOuterInner();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
writePacket	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index index, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index index, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::ArrayWrapper	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::MatrixWrapper	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/Block.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Block	access:public	signature:(Index index, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/Block.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Block	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacket$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index index, const typename internal::packet_traits<Scalar>::type& x)
writePacket	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacket$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:(Index row, Index col, const typename internal::packet_traits<Scalar>::type& x)
writePacket	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    void writePacket();$/;"	p	class:Eigen::DenseCoeffsBase	access:protected	signature:()
writePacket	../include/Eigen/src/Core/Flagged.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index index, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/Flagged.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Flagged	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index index, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/MapBase.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index index, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/MapBase.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::MapBase	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/NestByValue.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index index, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/NestByValue.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index index, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::PlainObjectBase	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/Reverse.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index index, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/Reverse.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Reverse	access:public	signature:(Index row, Index col, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/Transpose.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index index, const PacketScalar& x)
writePacket	../include/Eigen/src/Core/Transpose.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::TransposeImpl	access:public	signature:(Index row, Index col, const PacketScalar& x)
WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED	../include/Eigen/src/Core/util/StaticAssert.h	/^        WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
xaxpyc	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(xaxpyc)(int *, double *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *, double *, int *)
xaxpy	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(xaxpy) (int *, double *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *, double *, int *)
xcopy	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(xcopy) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
xerbla	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(xerbla)(const char *, int *info, int);$/;"	p	signature:(const char *, int *info, int)
xgbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xgbmv)(char *, int *, int *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xgemm3m	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xgemm3m)(char *, char *, int *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xgemm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xgemm)(char *, char *, int *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xgemv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xgemv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xgerc	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xgerc)(int *,    int *, double *, double *, int *,$/;"	p	signature:(int *, int *, double *, double *, int *, double *, int *, double *, int *)
xgeru	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xgeru)(int *,    int *, double *, double *, int *,$/;"	p	signature:(int *, int *, double *, double *, int *, double *, int *, double *, int *)
xgesv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xgesv)(int *, int *, double *, int *, int *, double*, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, double*, int *, int *)
xgetf2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xgetf2)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
xgetrf	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xgetrf)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
xgetrs	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xgetrs)(char *, int *, int *, double *, int *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, int *, double *, int *, int *, double *, int *, int *)
xhbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xhbmv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xhemm3m	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xhemm3m)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xhemm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xhemm)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xhemv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xhemv) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xher2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xher2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, int *)
xher2k	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xher2k)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
xher2m	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xher2m)(char *, char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
xher	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xher) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *)
xherk	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xherk)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, double *, int *)
xhpmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xhpmv) (char *, int *, double  *, double *,$/;"	p	signature:(char *, int *, double *, double *, double *, int *, double *, double *, int *)
xhpr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xhpr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *)
xhpr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xhpr) (char *, int *, double  *, double *, int *, double *);$/;"	p	signature:(char *, int *, double *, double *, int *, double *)
x	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    x() const { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
x	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    x() { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
x	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar x() const { return m_coeffs.coeff(0); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
x	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& x() { return m_coeffs.coeffRef(0); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
x	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar x() const { return this->derived().coeffs().coeff(0); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
x	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& x() { return this->derived().coeffs().coeffRef(0); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
x	../include/Eigen/src/Geometry/Translation.h	/^  inline Scalar x() const { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
x	../include/Eigen/src/Geometry/Translation.h	/^  inline Scalar& x() { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation	access:public	signature:()
xk	../include/abcd.h	/^    Eigen::Matrix<double,Dynamic, Dynamic, ColMajor> xk;$/;"	m	class:abcd	access:private
xlaswp	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xlaswp)(int *, double *, int *, int *, int *, int *, int *);$/;"	p	signature:(int *, double *, int *, int *, int *, int *, int *)
xlauu2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xlauu2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
xlauum	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xlauum)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
xpotf2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xpotf2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
xpotrf	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xpotrf)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
xpotri	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xpotri)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
XprBase	../include/Eigen/src/Core/Array.h	/^  typedef ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > XprBase;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/Array.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/ArrayWrapper.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/ArrayWrapper.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename traits<Ancestor>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/Matrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/ProductBase.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/Product.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:internal::traits	access:public
XprKind	../include/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/Transpose.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/SparseCore/SparseBlock.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/SparseCore/SparseProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprKind	../include/Eigen/src/SparseCore/SparseVector.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits	access:public
XprType	../include/Eigen/src/Core/Transpose.h	/^  typedef SelfCwiseBinaryOp<BinOp,NestedXpr,Rhs> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
XprType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
XprType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_multiple_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
XprType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
XprType	../include/Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits	access:public
XprTypeIsRowMajor	../include/Eigen/src/Core/Block.h	/^    XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0,$/;"	e	enum:Eigen::internal::traits::__anon228
XprTypeNested	../include/Eigen/src/Core/Block.h	/^  typedef typename nested<XprType>::type XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_XprTypeNested	../include/Eigen/src/Core/Block.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
_XprTypeNested	../include/Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
XprTypeNested	../include/Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename XprType::Nested XprTypeNested;$/;"	t	struct:Eigen::internal::traits	access:public
xqrot	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(xqrot) (int *, double *, int *, double *, int *, double *, double *);$/;"	p	signature:(int *, double *, int *, double *, int *, double *, double *)
xqscal	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(xqscal)(int *,  double *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *)
xrotg	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(xrotg) (double *, double *, double *, double *);$/;"	p	signature:(double *, double *, double *, double *)
xsbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xsbmv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xscal	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(xscal) (int *,  double *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *)
xspmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xspmv) (char *, int *, double  *, double *,$/;"	p	signature:(char *, int *, double *, double *, double *, int *, double *, double *, int *)
xspr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xspr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *)
xspr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xspr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *)
xswap	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(xswap) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
xsymm3m	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xsymm3m)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xsymm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xsymm)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xsymv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xsymv) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
xsyr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xsyr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, int *)
xsyr2k	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xsyr2k)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
xsyr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xsyr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *)
xsyrk	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xsyrk)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, double *, int *)
xtbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xtbmv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
xtbsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xtbsv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
xtpmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xtpmv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
xtpsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xtpsv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
xtrmm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xtrmm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
xtrmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xtrmv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
xtrsm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xtrsm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
xtrsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xtrsv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
xtrti2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xtrti2)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
xtrtri	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(xtrtri)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
y	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    y() const { return (*this)[1]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
y	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    y() { return (*this)[1]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
y	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar y() const { return m_coeffs.coeff(1); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
y	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& y() { return m_coeffs.coeffRef(1); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
y	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar y() const { return this->derived().coeffs().coeff(1); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
y	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& y() { return this->derived().coeffs().coeffRef(1); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
y	../include/Eigen/src/Geometry/Translation.h	/^  inline Scalar y() const { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
y	../include/Eigen/src/Geometry/Translation.h	/^  inline Scalar& y() { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation	access:public	signature:()
YOU_ALREADY_SPECIFIED_THIS_STRIDE	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_ALREADY_SPECIFIED_THIS_STRIDE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
YOU_CANNOT_MIX_ARRAYS_AND_MATRICES	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_CANNOT_MIX_ARRAYS_AND_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
YOU_MADE_A_PROGRAMMING_MISTAKE	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX	../include/Eigen/src/Core/util/StaticAssert.h	/^        YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon201
zaxpyc	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(zaxpyc)(int *, double *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *, double *, int *)
zaxpy	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(zaxpy) (int *, double *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *, double *, int *)
zcopy	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(zcopy) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
zdotcw	../include/Eigen/src/misc/blas.h	/^int  BLASFUNC(zdotcw)  (int *, double  *, int *, double  *, int *, double*);$/;"	p	signature:(int *, double *, int *, double *, int *, double*)
zdotuw	../include/Eigen/src/misc/blas.h	/^int  BLASFUNC(zdotuw)  (int *, double  *, int *, double  *, int *, double*);$/;"	p	signature:(int *, double *, int *, double *, int *, double*)
zdrot	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(zdrot) (int *, double *, int *, double *, int *, double *, double *);$/;"	p	signature:(int *, double *, int *, double *, int *, double *, double *)
zdscal	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(zdscal)(int *,  double *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *)
ZeroDiag	../include/Eigen/src/Core/util/Constants.h	/^  ZeroDiag=0x8,$/;"	e	enum:Eigen::__anon207
Zero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero()$/;"	f	class:Eigen::DenseBase	signature:()
Zero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase	signature:(Index rows, Index cols)
Zero	../include/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index size)$/;"	f	class:Eigen::DenseBase	signature:(Index size)
Zero	../include/Eigen/src/Core/DenseBase.h	/^    static const ConstantReturnType Zero(Index rows, Index cols);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index rows, Index cols)
Zero	../include/Eigen/src/Core/DenseBase.h	/^    static const ConstantReturnType Zero(Index size);$/;"	p	class:Eigen::DenseBase	access:public	signature:(Index size)
Zero	../include/Eigen/src/Core/DenseBase.h	/^    static const ConstantReturnType Zero();$/;"	p	class:Eigen::DenseBase	access:public	signature:()
zgbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgbmv)(char *, int *, int *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zge2mm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zge2mm)(char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zgema	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgema)(char *, char *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, double *, int *, double*, int *)
zgemm3m	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgemm3m)(char *, char *, int *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zgemm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgemm)(char *, char *, int *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zgems	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgems)(char *, char *, int *, int *, double *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, double *, int *, double*, int *)
zgemt	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgemt)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *)
zgemv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgemv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zgerc	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgerc)(int *,    int *, double *, double *, int *,$/;"	p	signature:(int *, int *, double *, double *, int *, double *, int *, double *, int *)
zgeru	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgeru)(int *,    int *, double *, double *, int *,$/;"	p	signature:(int *, int *, double *, double *, int *, double *, int *, double *, int *)
zgesv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgesv)(int *, int *, double *, int *, int *, double*, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, double*, int *, int *)
zgetf2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgetf2)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
zgetrf	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgetrf)(int *, int *, double *, int *, int *, int *);$/;"	p	signature:(int *, int *, double *, int *, int *, int *)
zgetrs	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zgetrs)(char *, int *, int *, double *, int *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, int *, double *, int *, int *, double *, int *, int *)
zhbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zhbmv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zhemm3m	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zhemm3m)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zhemm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zhemm)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zhemv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zhemv) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zher2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zher2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, int *)
zher2k	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zher2k)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
zher2m	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zher2m)(char *, char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
zher	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zher) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *)
zherk	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zherk)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, double *, int *)
zhpmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zhpmv) (char *, int *, double  *, double *,$/;"	p	signature:(char *, int *, double *, double *, double *, int *, double *, double *, int *)
zhpr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zhpr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *)
zhpr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zhpr) (char *, int *, double  *, double *, int *, double *);$/;"	p	signature:(char *, int *, double *, double *, int *, double *)
z	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    z() const { return (*this)[2]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:() const
z	../include/Eigen/src/Core/DenseCoeffsBase.h	/^    z() { return (*this)[2]; }$/;"	f	class:Eigen::DenseCoeffsBase	access:public	signature:()
z	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar z() const { return m_coeffs.coeff(2); }$/;"	f	class:Eigen::Quaternion	access:public	signature:() const
z	../include/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& z() { return m_coeffs.coeffRef(2); }$/;"	f	class:Eigen::Quaternion	access:public	signature:()
z	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar z() const { return this->derived().coeffs().coeff(2); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:() const
z	../include/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& z() { return this->derived().coeffs().coeffRef(2); }$/;"	f	class:Eigen::QuaternionBase	access:public	signature:()
z	../include/Eigen/src/Geometry/Translation.h	/^  inline Scalar z() const { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation	access:public	signature:() const
z	../include/Eigen/src/Geometry/Translation.h	/^  inline Scalar& z() { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation	access:public	signature:()
zlaswp	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zlaswp)(int *, double *, int *, int *, int *, int *, int *);$/;"	p	signature:(int *, double *, int *, int *, int *, int *, int *)
zlauu2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zlauu2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
zlauum	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zlauum)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
znorm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(znorm)(char *, int *, int *, double *, int *);$/;"	p	signature:(char *, int *, int *, double *, int *)
zpotf2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zpotf2)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
zpotrf	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zpotrf)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
zpotri	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zpotri)(char *, int *, double *, int *, int *);$/;"	p	signature:(char *, int *, double *, int *, int *)
zrotg	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(zrotg) (double *, double *, double *, double *);$/;"	p	signature:(double *, double *, double *, double *)
zsbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zsbmv)(char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zscal	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(zscal) (int *,  double *, double *, int *);$/;"	p	signature:(int *, double *, double *, int *)
zspmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zspmv) (char *, int *, double  *, double *,$/;"	p	signature:(char *, int *, double *, double *, double *, int *, double *, double *, int *)
zspr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zspr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *)
zspr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zspr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *)
zswap	../include/Eigen/src/misc/blas.h	/^int    BLASFUNC(zswap) (int *, double *, int *, double *, int *);$/;"	p	signature:(int *, double *, int *, double *, int *)
zsymm3m	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zsymm3m)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zsymm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zsymm)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zsymv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zsymv) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, double *, int *)
zsyr2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zsyr2) (char *, int *, double  *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *, double *, int *)
zsyr2k	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zsyr2k)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double*, int *, double *, double *, int *)
zsyr	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zsyr) (char *, int *, double  *, double *, int *,$/;"	p	signature:(char *, int *, double *, double *, int *, double *, int *)
zsyrk	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(zsyrk)(char *, char *, int *, int *, double *, double *, int *,$/;"	p	signature:(char *, char *, int *, int *, double *, double *, int *, double *, double *, int *)
ztbmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ztbmv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
ztbsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ztbsv) (char *, char *, char *, int *, int *, double *, int *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, int *, double *, int *, double *, int *)
ztpmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ztpmv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
ztpsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ztpsv) (char *, char *, char *, int *, double *, double *, int *);$/;"	p	signature:(char *, char *, char *, int *, double *, double *, int *)
ztrmm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ztrmm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
ztrmv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ztrmv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
ztrsm	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ztrsm)(char *, char *, char *, char *, int *, int *,$/;"	p	signature:(char *, char *, char *, char *, int *, int *, double *, double *, int *, double *, int *)
ztrsv	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ztrsv) (char *, char *, char *, int *, double *, int *,$/;"	p	signature:(char *, char *, char *, int *, double *, int *, double *, int *)
ztrti2	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ztrti2)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
ztrtri	../include/Eigen/src/misc/blas.h	/^int BLASFUNC(ztrtri)(char *, char *, int *, double *, int *, int *);$/;"	p	signature:(char *, char *, int *, double *, int *, int *)
