<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; }
code > span.dt { color: #204a87; }
code > span.dv { color: #0000cf; }
code > span.bn { color: #0000cf; }
code > span.fl { color: #0000cf; }
code > span.ch { color: #4e9a06; }
code > span.st { color: #4e9a06; }
code > span.co { color: #8f5902; font-style: italic; }
code > span.ot { color: #8f5902; }
code > span.al { color: #ef2929; }
code > span.fu { color: #000000; }
code > span.er { font-weight: bold; }
  </style>
  <link rel="stylesheet" href="linear/docco.css" type="text/css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#the-abcd-solver">The ABCD Solver</a><ul>
<li><a href="#an-introductory-example">An introductory example</a></li>
<li><a href="#the-linear-system">The linear system</a></li>
<li><a href="#the-controls">The Controls</a><ul>
<li><a href="#the-integer-control-array">The integer control array</a></li>
<li><a href="#the-double-precision-control-array">The double precision control array</a></li>
</ul></li>
<li><a href="#installation">Installation</a></li>
</ul></li>
</ul>
</div>
<h1 id="the-abcd-solver">The ABCD Solver</h1>
<p>The package <code>ABCD Solver</code> is a distributed hybrid (iterative/direct) solver for sparse linear systems <span class="math">\(Ax = b\)</span> where <span class="math">\(A\)</span> is a double precision <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> square <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> matrix with any structure. <code>ABCD Solver</code> uses two methods to solve the linear system:</p>
<ul>
<li><em>Regular Block Cimmino</em>: A block-projection technique that iterates to solve the linear system. During the iterations it solves a set of small problems (augmented systems built using the partitions of the original system).</li>
<li><em>Augmented Block Cimmino</em>: A pseudo-direct technique that augments the original system and through a succession of direct solves finds the solution.</li>
</ul>
<p>The solver is in the form of a class called <code>abcd</code> and an instance of it represents an instance of the solver with its own linear system. In the following we will use the <code>Boost::MPI</code> syntax for <code>MPI</code> specefic commands. Moreover, in the following description we refer to the members of the class by <code>obj.member</code> where <code>obj</code> is an instance of the solver and <code>member</code> is the corresponding member, similarly, we refer to the public methods by <code>obj.method()</code>. Finally, arrays will have <code>[]</code> appended to them, if we specify a size then the array is pre-initialized at construction, otherwise it is either allocated by the user (such as the linear system entries) or by the solver (such as the solution).</p>
<h2 id="an-introductory-example">An introductory example</h2>
<p>To see how the solver can be used, we expose a basic example that uses the regular block Cimmino scheme. We comment the interesting parts, and explain how they fit together, the details regarding the members of the <code>abcd</code> class are explained in <a href="#the-linear-system">The linear system</a> and the controls are detailed in <a href="#the-controls">The Controls</a>.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="ot">#include &quot;abcd.h&quot;</span>
    <span class="co">// use boost::mpi for simplicity, the user can use which ever he wants</span>
    <span class="ot">#include &quot;mpi.h&quot;</span>
    <span class="ot">#include &lt;boost/mpi.hpp&gt;</span>

    <span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[]) 
    {
        mpi::environment env(argc, argv);
        <span class="co">// obtain the WORLD communicator, by default the solver uses it</span>
        mpi::communicator world;

        <span class="co">// create one instance of the abcd solver per mpi-process</span>
        abcd obj;

        <span class="kw">if</span>(world.rank() == <span class="dv">0</span>) { <span class="co">// the master</span>
            <span class="co">// we create a 5x5 matrix for a 1D mesh + three-point stencil </span>
            obj.sym = <span class="kw">true</span>; <span class="co">// the matrix is symmetric</span>
            obj.m = <span class="dv">10</span>; <span class="co">// number of rows</span>
            obj.n = obj.m; <span class="co">// number of columns</span>
            obj.nz = <span class="dv">2</span>*obj.m - <span class="dv">1</span>; <span class="co">// number of nnz in the lower-triangular part</span>

            <span class="co">// allocate the arrays</span>
            obj.irn = <span class="kw">new</span> <span class="dt">int</span>[obj.nz];
            obj.jcn = <span class="kw">new</span> <span class="dt">int</span>[obj.nz];
            obj.val = <span class="kw">new</span> <span class="dt">double</span>[obj.nz];

            <span class="co">// initialize the matrix</span>
            <span class="co">// Notice that the matrix is stored in 1-based format</span>
            size_t pos = <span class="dv">0</span>;
            <span class="kw">for</span> (size_t i = <span class="dv">1</span>; i &lt; obj.m; i++) {
                <span class="co">// the diagonal</span>
                obj.irn[pos] = i;
                obj.jcn[pos] = i;
                obj.val[pos] = <span class="fl">2.0</span>;
                pos++;

                <span class="co">// the lower-triangular part</span>
                obj.irn[pos] = i + <span class="dv">1</span>;
                obj.jcn[pos] = i;
                obj.val[pos] = -<span class="fl">1.0</span>;
                pos++;
            }

            <span class="co">// the last diagonal element</span>
            obj.irn[pos] = obj.m;
            obj.jcn[pos] = obj.m;
            obj.val[pos] = <span class="fl">2.0</span>;

            pos++;

            <span class="co">// set the rhs</span>
            obj.rhs = <span class="kw">new</span> <span class="dt">double</span>[obj.m];
            <span class="kw">for</span> (size_t i = <span class="dv">0</span>; i &lt; obj.m; i++) {
                obj.rhs[i] = ((<span class="dt">double</span>) i + <span class="dv">1</span>)/obj.m;
            }

            <span class="co">// ask the solver to guess the number of partitions</span>
            obj.icntl[Controls::part_guess] = <span class="dv">1</span>;
        }

        <span class="kw">try</span> {
            <span class="co">// We call the solver directly using the object itself</span>
            <span class="co">// (the abcd class is a functor)</span>
            obj(-<span class="dv">1</span>); <span class="co">// initialize the object with defaults</span>
            obj(<span class="dv">5</span>); <span class="co">// equivalent to running 1, 2 and 3 successively</span>
            <span class="co">// the solution is stored in obj.sol</span>
        } <span class="kw">catch</span> (runtime_error err) {
            <span class="co">// In case there is a critical error, we throw a runtime_error exception</span>
            cout &lt;&lt; <span class="st">&quot;An error occured: &quot;</span> &lt;&lt; err.what() &lt;&lt; endl;
        }
        
        <span class="kw">delete</span>[] obj.irn;
        <span class="kw">delete</span>[] obj.jcn;
        <span class="kw">delete</span>[] obj.val;

      <span class="kw">return</span> <span class="dv">0</span>;
    }</code></pre>
<h2 id="the-linear-system">The linear system</h2>
<p>The definition of the linear system uses 7 members:</p>
<ul>
<li><code>obj.m</code> (type: <code>int</code>), the number of rows.</li>
<li><code>obj.n</code> (type: <code>int</code>), the number of columns.</li>
<li><code>obj.nz</code> (type: <code>int</code>), the number of entries.</li>
<li><code>obj.sym</code> (type: <code>bool</code>), the symmetry of the matrix. If the matrix is symmetric, the matrix must be given in a lower-triangular form.</li>
<li><code>obj.irn</code> (type: <code>int *</code>), the row indices.</li>
<li><code>obj.jcn</code> (type: <code>int *</code>), the column indices.</li>
<li><code>obj.val</code> (type: <code>double *</code>), the matrix entries.</li>
<li><code>obj.rhs</code> (type: <code>double *</code>), the right-hand side.</li>
</ul>
<p>If either of the row and column indices start with <code>0</code> the arrays are supposed to be zero based (<code>C</code> arrays indexation), otherwise, if they start with <code>1</code> the arrays are supposed to be one based (<code>Fortran</code> arrays indexation). If however, none starts with <code>0</code> or <code>1</code> then there is either an empty row or an empty column and the solver stops.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="co">// Create an object for each mpi-process</span>
    abcd obj;
    obj.n = <span class="dv">7</span>;
    obj.m = <span class="dv">7</span>;
    obj.nz = <span class="dv">15</span>;
    obj.sym = <span class="kw">false</span>;
    <span class="co">// put the data in the arrays</span>
    obj.irn[<span class="dv">0</span>] = <span class="dv">1</span>;
    <span class="co">//..</span></code></pre>
<h2 id="the-controls">The Controls</h2>
<p>Define the general behavior of the solver. They are split into two arrays, <code>icntl</code> and <code>dcntl</code>. <code>icntl</code> is an <em>integer</em> array and defines the options that control the specific parts of the solver, such as the scaling, the type of algorithm to run and so on. <code>dcntl</code> is a <em>double precision</em> array and defines some of the options required by the algorithms we use such as the imbalance between the partition sizes and the stopping criteria of the solver.</p>
<p>To access each of the control options we can either use the indices <code>0, 1, ..</code> or, preferably, use the <em>enums</em> defined in the header <code>defaults.h</code>. To access them, the user can use the namespace <code>Controls</code>, eg. <code>Controls::scaling</code> has a value of <code>5</code> and is used with <code>icntl</code> to handle the scaling of the linear system.</p>
<h3 id="the-integer-control-array">The integer control array</h3>
<ul>
<li><p><code>obj.icntl[Controls::nbparts]</code> or <code>obj.icntl[1]</code> defines the number of partitions in our linear system, can be from <code>1</code> to <code>m</code> (the number of rows in the matrix)</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// we have 8 partitions</span>
obj.icntl[Controls::nbparts] = <span class="dv">8</span>;</code></pre></li>
<li><p><code>obj.icntl[Controls::part_type]</code> or <code>obj.icntl[2]</code> defines the partitioning type. It can have the values:</p>
<p>~ <code>1</code>, manual partitioning, the <em>nbparts</em> partitions can be provided into the STL vector <code>obj.nbrows[]</code>. Example:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// use manual partitioning</span>
obj.icntl[Controls::part_type] = <span class="dv">1</span>;
<span class="co">// say that we want 20 rows per partition</span>
obj.nrows.assign(obj.icntl[Controls::nbparts], <span class="dv">20</span>);

<span class="co">// or </span>
obj.nrows.resize(obj.icntl[Controls::nbparts]);
obj.nrows[<span class="dv">0</span>] = <span class="dv">20</span>;
obj.nrows[<span class="dv">1</span>] = <span class="dv">20</span>;
<span class="co">//...</span></code></pre>
<p>~ <code>2</code> <em>(default)</em>, automatic uniform partitioning, creates <em>nbparts</em> partitions of similar size.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// use patoh partitioning</span>
obj.icntl[Controls::part_type] = <span class="dv">2</span>;</code></pre>
<p>~ <code>3</code>, automatic hypergraph partitioning, creates <em>nbparts</em> partitions using the hypergraph partitioner <code>PaToH</code>. The imbalance between the partitions is handled using <code>obj.dcntl[Controls::part_imbalance]</code>. Example:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// use patoh partitioning</span>
obj.icntl[Controls::part_type] = <span class="dv">3</span>;
<span class="co">// say that we want an imbalance of 0.3 between the partitions</span>
obj.dcntl[Controls::part_imbalance] = <span class="fl">0.3</span>;</code></pre></li>
<li><code>obj.icntl[3]</code> reserved for a future use.</li>
<li><p><code>obj.icntl[Controls::part_guess]</code> or <code>obj.icntl[4]</code> asks the solver to guess the appropriate number of partitions and overrides the defined <em>nbparts</em>.</p>
<p>~ <code>0</code> <em>(default)</em>, no guess</p>
~ <code>1</code>, guess</li>
<li><p><code>obj.icntl[Controls::scaling]</code> or <code>obj.icntl[5]</code> defines the type of scaling to be used.</p>
<p>~ <code>0</code>, no scaling</p>
<p>~ <code>1</code>, infinity norm <code>MC77</code> based scaling</p>
~ <code>2</code> <em>(default)</em>, combination of one norm and two norm <code>MC77</code> based scaling</li>
<li><code>obj.icntl[Controls::itmax]</code> or <code>obj.icntl[6]</code> defines the maximum number of iterations in block-CG acceleration, default is <code>1000</code></li>
<li><code>obj.icntl[Controls::block_size]</code> or <code>obj.icntl[7]</code> defines the block-size to be used by the block-CG acceleration, default is <code>1</code> for classical CG acceleration</li>
<li><code>obj.icntl[Controls::verbose_level]</code> or <code>obj.icntl[8]</code> <strong>Not Yet Implemented</strong>, defines how verbose the solver has to be.</li>
<li><code>obj.icntl[9]</code> reserved for a future use.</li>
<li><p><code>obj.icntl[Controls::aug_type]</code> or <code>obj.icntl[10]</code> defines the augmentation type.</p>
<p>~ <code>0</code> <em>(default)</em>, no augmentation. This makes the solver run in <strong>regular block Cimmino</strong> mode.</p>
<p>~ <code>1</code>, makes the solver run in <strong>Augmented Block Cimmino</strong> mode with an augmentation of the matrix using the <span class="math">\(C_{ij}/-I\)</span> technique. For numerical stability, this augmentation technique has to be used with a scaling.</p>
<p>~ <code>2</code>, makes the solver run in <strong>Augmented Block Cimmino</strong> mode with an augmentation of the matrix using the <span class="math">\(A_{ij}/-A_{ji}\)</span> technique. This is the prefered augmentation technique.</p></li>
<li><code>obj.icntl[Controls::aug_blocking]</code> or <code>obj.icntl[11]</code> defines the blocking factor when building the auxiliary matrix <span class="math">\(S\)</span>, default is <code>128</code>.</li>
<li><code>obj.icntl[Controls::aug_analysis]</code> or <code>obj.icntl[12]</code>, when set to a value different than <code>0</code>, analyses the number of columns in the augmentation.</li>
<li><code>obj.icntl[13]</code> to <code>obj.icntl[16]</code> are for development and testing purposes only.</li>
<li><p><code>obj.icntl[17]</code> to <code>obj.icntl[19]</code> are reserved for a future use.</p></li>
</ul>
<h3 id="the-double-precision-control-array">The double precision control array</h3>
<ul>
<li><code>obj.dcntl[Controls::part_imbalance]</code> or <code>obj.dcntl[1]</code> defines the imbalance between the partitions when using <code>PaToH</code> (<code>obj.icntl[Controls::part_imbalance] = 3</code>).</li>
<li><code>obj.dcntl[Controls::threshold]</code> or <code>obj.dcntl[2]</code> defines the stopping threshold for the block-CG acceleration, default is <code>1e-12</code>.</li>
<li><code>obj.dcnlt[3]</code> to <code>obj.dcntl[20]</code> are reserved for future use.</li>
</ul>
<h2 id="installation">Installation</h2>
<p>The ABCD Solver depends on a few libraries: <code>MUMPS 5.0 (custom)</code>, <code>Sparselib++ (custom)</code>, <code>PaToH</code>, <code>lapack</code> and <code>Boost::MPI</code>.</p>
<p>First, clone the latest version of the <code>ABCD Solver</code>:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">    <span class="co"># download the latest stable version</span>
    <span class="kw">git</span> clone https://gitlab.enseeiht.fr/mohamed.zenadi/abcd.git
    <span class="co"># get the dev version</span>
    <span class="kw">git</span> checkout dev</code></pre>
<ul>
<li><code>MUMPS 5.0 (custom)</code>: a modified version of <code>MUMPS</code> to suits our needs, it is distributed with our solver in the <code>lib/mumps/</code> directory. The distributed version is compiled in <code>x86_64</code> compilers, a <code>i686</code> version can be distributed on request. Moreover,</li>
<li><p><code>Sparselib++ (custom)</code>: a modified version of <code>SparseLib++</code> to suits our needs, to download it run the following commands from the root of your</p>
<pre class="sourceCode bash"><code class="sourceCode bash">    <span class="kw">cd</span> abcd
    <span class="kw">git</span> submodule init
    <span class="co"># clone the sparselib repository into lib/sparselib</span>
    <span class="kw">git</span> submodule update</code></pre></li>
<li><p><code>PaToH</code>: Can be downloaded from <a href="http://bmi.osu.edu/~umit/software.html">Ümit V. Çatalyürek</a> webpage. The file <code>libpatoh.a</code> has to be copied into the <code>lib/</code> directory and the header <code>patho.h</code> has to be copied into the <code>include</code> directory.</p></li>
</ul>
<p>To summarize, here is a simple script that will do everything:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">    <span class="co"># download the latest stable version</span>
    <span class="kw">git</span> clone https://gitlab.enseeiht.fr/mohamed.zenadi/abcd.git
    <span class="co"># get the dev version</span>
    <span class="kw">git</span> checkout dev

    <span class="kw">cd</span> abcd
    <span class="kw">git</span> submodule init
    <span class="kw">git</span> submodule update
    
    <span class="kw">cd</span> lib
    <span class="co"># download the appropriate version of patoh</span>
    <span class="kw">wget</span> http://bmi.osu.edu/~umit/PaToH/...tar.gz
    <span class="co"># extract </span>
    <span class="kw">tar</span> xvzf patoh-....tar.gz
    <span class="kw">cp</span> build/*/libpatoh.a .
    <span class="kw">cp</span> build/*/patoh.h ../include/
    <span class="kw">rm</span> -rf build patoh-....tar.gz
    <span class="kw">cd</span> ..</code></pre>
<p>Now that everything is ready, we can compile the solver. To do so, we need a configuration file from the <code>cmake.in</code> directory, suppose we are going to use the <code>ACML</code> library (provides <code>blas</code> and <code>lapack</code>).</p>
<pre class="sourceCode bash"><code class="sourceCode bash">    <span class="co"># get the appropriate configuration file</span>
    <span class="kw">cp</span> cmake.in/abcdCmake.in.ACML ./abcdCmake.in</code></pre>
<p>Edit that file to suite your configuration</p>
<pre class="sourceCode cmake"><code class="sourceCode cmake">    <span class="co"># where to find Boost?</span>
    <span class="kw">set</span>(BOOST_ROOT /path/to/boost/headers)
    <span class="kw">set</span>(BOOST_LIBRARYDIR /path/to/boost/libraries)

    <span class="co"># the compilers </span>
    <span class="kw">set</span>(<span class="dv">CMAKE_CXX_COMPILER</span> mpic++)
    <span class="kw">set</span>(<span class="dv">CMAKE_C_COMPILER</span> mpicc)
    <span class="kw">set</span>(<span class="dv">CMAKE_FC_COMPILER</span> mpif90)

    <span class="co"># where to find ACML, scalapack and blacs?</span>
    <span class="kw">set</span>(BLAS_LAPACK_SCALAPACK_DIRS /path/to/acml/gfortran64/lib
                                   /path/to/scalapack-acml
                                   /path/to/blacs
        )
    <span class="co"># the different libraries</span>
    <span class="kw">set</span>(BLAS_LAPACK_SCALAPACK_LIBS acml
        blacsF77init blacsCinit blacs blacsF77init blacsCinit
        scalapack
        )

    <span class="co"># where to find Openmpi (or any mpi distributuion)</span>
    <span class="kw">set</span>(MPI_LIB_DIR /opt/openmpi-1.6.3-gnu/lib/)
    <span class="kw">set</span>(MPI_INC_DIR /opt/openmpi-1.6.3-gnu/include/)
    <span class="co"># the corresponding libraries</span>
    <span class="kw">set</span>(MPI_LIBRARIES 
        mpi
        mpi_f90
        mpi_f77
        mpi_cxx
        dl
    )</code></pre>
<p>Notice that we link against <code>scalapack</code> and <code>blacs</code>, these are required libraries by <code>MUMPS</code>. If we want to use <code>MKL</code>, just change this part:</p>
<pre class="sourceCode cmake"><code class="sourceCode cmake">    <span class="kw">set</span>(BLAS_LAPACK_SCALAPACK_DIRS /path/to/mkl)
    <span class="kw">set</span>(BLAS_LAPACK_SCALAPACK_LIBS mkl_lapack95_lp64 mkl_blas95_lp64
        mkl_scalapack_lp64 mkl_cdft_core mkl_gf_lp64 mkl_sequential mkl_core
        mkl_blacs_openmpi_lp64 mkl_lapack95_lp64 mkl_blas95_lp64
        )</code></pre>
<p>In this example we used the non-threaded version of these libraries, for the <code>ACML</code> library use the <code>_mp</code> suffix, for <code>MKL</code> use the <a href="https://software.intel.com/en-us/articles/intel-mkl-link-line-advisor">Intel® Math Kernel Library Link Line Advisor</a> to obtain the correct set of libraries.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The current implementation is double precision only.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>In reality the system can rectangular, but this case is not fully tested yet.<a href="#fnref2">↩</a></p></li>
</ol>
</div>
</body>
</html>
