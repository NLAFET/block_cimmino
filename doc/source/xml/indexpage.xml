<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>The Augmented Block Cimmino Distributed Solver</title>
    <detaileddescription>
<para>The package <computeroutput>ABCD Solver</computeroutput> is a distributed hybrid (iterative/direct) solver for sparse linear systems <formula id="3">$Ax = b$</formula> where <formula id="4">$A$</formula> is a double precision matrix with. <computeroutput>ABCD Solver</computeroutput> uses two methods to solve the linear system:</para><para><itemizedlist>
<listitem><para><emphasis>Regular Block Cimmino</emphasis>: A block-projection technique that iterates to solve the linear system. During the iterations it solves a set of small problems (augmented systems built using the partitions of the original system).</para></listitem><listitem><para><emphasis>Augmented Block Cimmino</emphasis>: A pseudo-direct technique that augments the original system and through a succession of direct solves finds the solution.</para></listitem></itemizedlist>
</para><sect1 id="index_1section_cimmino">
<title>The regular block Cimmino</title>
<para>The block Cimmino method is an iterative method that uses block-row projections. To solve the <formula id="3">$Ax = b$</formula>, where <formula id="4">$A$</formula> is an <formula id="5">$m\times n$</formula> sparse matrix, <formula id="6">$x$</formula> is an <formula id="7">$n$</formula>-vector and <formula id="8">$b$</formula> is an <formula id="9">$m$</formula>-vector, we subdivide the system into strips of rows as follows:</para><para><formula id="10">\begin{eqnarray*} \left( \begin{array}{c} A_1 \\ A_2 \\ \vdots \\ A_p \end{array} \right) x &amp;=&amp; \left( \begin{array}{c} b_1 \\ b_2 \\ \vdots \\ b_p \end{array} \right). \end{eqnarray*}</formula></para><para>Let <formula id="11">$P_{\mathcal{R}(A_i^T)}$</formula> be the projector onto the range of <formula id="12">$A_i^T$</formula> and <formula id="13">${A_i}^+$</formula> be the Moore-Penrose pseudo-inverse of the partition <formula id="14">$A_i$</formula>. The block Cimmino algorithm then computes a solution iteratively from an initial estimate <formula id="15">$x^{(0)}$</formula> according to: <formula id="16">\begin{eqnarray*} \begin{array}{ccl} u_{i} &amp; = &amp; A_i^+ \left ( {b_i - A_i x^{(k)}} \right ) ~~~ i = 1, .... p \\ x^{(k+1)} &amp; = &amp; x^{(k)} + \omega \sum_{i=1}^p{u_i} \end{array} \end{eqnarray*}</formula> where we see the independence of the set of <formula id="17">$p$</formula> equations, which is why the method is so attractive in a parallel environment.</para><para>With the above notations, the iteration equations are thus: <formula id="18">\[ \begin{array}{ccl} x^{(k+1)} &amp; = &amp; x^{(k)} + \omega \sum_{i=1}^p{A_i^+ \left ( {b_i - A_i x^{(k)}} \right )} \\ &amp; = &amp; \left( {I - \omega \sum_{i=1}^p{A_i^+ A_i}} \right) x^{(k)} + \omega \sum_{i=1}^p{A_i^+ b_i} \\ &amp; = &amp; Q x^{(k)} + \omega \sum_{i=1}^p{A_i^+ b_i}. \label{something} \end{array} \]</formula></para><para>The iteration matrix for block Cimmino, <formula id="19">$H = I - Q$</formula>, is then a sum of projectors <formula id="20">$H = \omega \sum_{i=1}^p{\mathcal{P}_{\mathcal{R}(A_i^T)}}$</formula>. It is thus symmetric and positive definite and so we can solve <formula id="21">\[ H x ~=~ \xi, \]</formula> where <formula id="22">$\xi = \omega \sum_{i=1}^p{A_i^+ b_i}$</formula> using conjugate gradient or block conjugate gradient methods. As <formula id="23">$\omega$</formula> appears on both sides of the equation, we can set it to one.</para><para>At each step of the conjugate gradient algorithm we must solve for the <formula id="17">$p$</formula> projections viz. <formula id="24">\begin{equation} A_i u_i ~=~ r_i, ~~~~ (r_i = {b_i - A_i x^{(k)}}),~~~ i = 1, .... p. \end{equation}</formula></para><para>In our approach we choose to solve these equations using the augmented system <formula id="25">\begin{eqnarray*} \left ( \begin{array}{cc} I &amp; A_i^T \\ A_i &amp; 0 \end{array} \right ) \left ( \begin{array}{l} u_i \\ v_i \end{array} \right ) &amp;=&amp; \left ( \begin{array}{l} 0 \\ r_i \end{array} \right ) \end{eqnarray*}</formula> that we will solve, at each iteration, using a direct method and gives <formula id="26">$u_i = A_i^+ r_i$</formula> the projection we need for the partition <formula id="14">$A_i$</formula>. We use the multifrontal parallel solver <computeroutput><ref refid="struct_m_u_m_p_s" kindref="compound">MUMPS</ref></computeroutput> to do this.</para><para>Running our solver in the regular mode will go through the following steps:</para><para><itemizedlist>
<listitem><para>Partition the system into strips of rows ( <formula id="14">$A_i$</formula> and <formula id="27">$b_i$</formula> for <formula id="28">$i = 1, \dots p$</formula>)</para></listitem><listitem><para>Create the augmented systems</para></listitem><listitem><para>Analyze and factorize the augmented systems using the direct solver <computeroutput><ref refid="struct_m_u_m_p_s" kindref="compound">MUMPS</ref></computeroutput></para></listitem><listitem><para>Run a block conjugate gradient with an implicit matrix <formula id="29">$H$</formula>, and at each iteration compute the matrix-vector product as a sum of projections. These projects being a set of solves using the direct solver.</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="index_1section_abcd">
<title>The augmented block Cimmino</title>
<para>To understand the algorith, suppose that we have a matrix <formula id="4">$A$</formula> with three partitions, described as follow:</para><para><formula id="30">\begin{equation} A = \left[ \begin{array}{cccccc} A_{1,1} &amp; A_{1,2} &amp;&amp;&amp;&amp; A_{1,3}\\ &amp; A_{2,1} &amp; A_{2,2} &amp; A_{2,3} &amp; \\ &amp;&amp;&amp; A_{3,2} &amp; A_{3,3} &amp; A_{3,1} \end{array} \right]. \end{equation}</formula></para><para>Where <formula id="31">$A_{i,j}$</formula> is the sub-part of <formula id="14">$A_i$</formula>, the <formula id="32">$i$</formula>-th partition, that is interconnected algebraically to the partition <formula id="33">$A_j$</formula>, and vice versa.</para><para>The goal of the augmented block Cimmino algorithm is to make these three partitions mutually orthogonal to each other, meaning that the product of each couple of partitions is zero. We consider two different ways to augment the matrix to obtain these zero matrix products.</para><para><itemizedlist>
<listitem><para>The first way to augment the matrix to make all the partitions mutually orthogonal to each other is by putting the product <formula id="34">$C_{ij} = A_{ij}A_{ji}^T$</formula> on the right of the partition <formula id="14">$A_i$</formula> and put <formula id="35">$-I$</formula> on the right of <formula id="33">$A_j$</formula> viz. <formula id="36">\begin{equation} \bar{A} = \left[ \begin{array}{cccccc|ccc} A_{1,1} &amp; A_{1,2} &amp; &amp; &amp; A_{1,3} &amp; &amp; C_{1,2} &amp; C_{1,3} &amp; \\ &amp; A_{2,1} &amp; A_{2,2} &amp; A_{2,3} &amp; &amp; &amp; -I &amp; &amp; C_{2,3}\\ &amp; &amp; &amp; A_{3,2} &amp; A_{3,3} &amp; A_{3,1} &amp; &amp; -I &amp; -I \end{array}\right]. \end{equation}</formula> This way <formula id="37">$\bar{A}_i\bar{A}_j^T$</formula> is zero for any pair <formula id="38">$i/j$</formula>, hence the new matrix has mutually orthogonal partitions.</para></listitem><listitem><para>We can repeat the submatrices <formula id="39">$A_{ij}$</formula> and <formula id="40">$A_{ji}$</formula>, reversing the signs of one of them to obtain the augmented matrix <formula id="41">$\bar{A}$</formula> as in the following <formula id="42">\[ \bar{A} = \left[ \begin{array}{cccccc|ccc} A_{1,1} &amp; A_{1,2} &amp; &amp; &amp; A_{1,3} &amp; &amp; A_{1,2} &amp; A_{1,3} &amp; \\ &amp; A_{2,1} &amp; A_{2,2} &amp; A_{2,3} &amp; &amp; &amp; -A_{2,1} &amp; &amp; A_{2,3}\\ &amp; &amp; &amp; A_{3,2} &amp; A_{3,3} &amp; A_{3,1} &amp; &amp; -A_{3,1}&amp; -A_{3,2} \end{array}\right]. \]</formula> Notice that we augment the matrix upper-down and shift the augmentation at each step. This way, we do not create any new interconnections between the new partitions. A simple check shows that <formula id="43">$\bar{A}_i \bar{A}_j^T$</formula> is zero for any pair <formula id="38">$i/j$</formula>.</para></listitem></itemizedlist>
</para><para>We shall call the first augmentation model the <formula id="44">$C_{ij}/-I$</formula> process, the second way as <formula id="45">$A_{ij}/-A_{ji}$</formula>, and the augmentation part as <formula id="46">$C$</formula>. Implementation wise, they are enabled by setting <computeroutput><ref refid="classabcd_1a4e25bee21981dc6f6541126221d6c197" kindref="member">abcd::icntl</ref>[<ref refid="namespace_controls_1a41634ad81c9287acd66e5a0ebb45dd6ea306cb5cda1f0c844d33652130450fe4d" kindref="member">Controls::aug_type</ref>]</computeroutput> to 1 for the former and 2 for the latter. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
