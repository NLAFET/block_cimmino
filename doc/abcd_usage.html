<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; }
code > span.dt { color: #204a87; }
code > span.dv { color: #0000cf; }
code > span.bn { color: #0000cf; }
code > span.fl { color: #0000cf; }
code > span.ch { color: #4e9a06; }
code > span.st { color: #4e9a06; }
code > span.co { color: #8f5902; font-style: italic; }
code > span.ot { color: #8f5902; }
code > span.al { color: #ef2929; }
code > span.fu { color: #000000; }
code > span.er { font-weight: bold; }
  </style>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h1 id="the-abcd-solver">The ABCD Solver</h1>
<p>The package <code>ABCD Solver</code> is a distributed hybrid (iterative/direct) solver for sparse linear systems <span class="math">\(Ax = b\)</span> where <span class="math">\(A\)</span> is a double precision <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> square <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> matrix with any structure. <code>ABCD Solver</code> uses two methods to solve the linear system:</p>
<ul>
<li><em>Regular Block Cimmino</em>: A block-projection technique that iterates to solve the linear system. During the iterations it solves a set of small problems (augmented systems built using the partitions of the original system).</li>
<li><em>Augmented Block Cimmino</em>: A pseudo-direct technique that augments the original system and through a succession of direct solves finds the solution.</li>
</ul>
<p>The solver is in the form of a class called <code>abcd</code> and an instance of it represents an instance of the solver with its own linear system. In the following we will use the <code>Boost::MPI</code> syntax for <code>MPI</code> specefic commands. Moreover, in the following description we refer to the members of the class by <code>obj.member</code> where <code>obj</code> is an instance of the solver and <code>member</code> is the corresponding member, similarly, we refer to the public methods by <code>obj.method()</code>. Finally, arrays will have <code>[]</code> appended to them, if we specify a size then the array is pre-initialized at construction, otherwise it is either allocated by the user (such as the linear system entries) or by the solver (such as the solution).</p>
<h2 id="the-linear-system">The linear system</h2>
<p>The definition of the linear system uses 7 members:</p>
<ul>
<li><code>obj.m</code> (type: <code>int</code>), the number of rows.</li>
<li><code>obj.n</code> (type: <code>int</code>), the number of columns.</li>
<li><code>obj.nz</code> (type: <code>int</code>), the number of entries.</li>
<li><code>obj.sym</code> (type: <code>bool</code>), the symmetry of the matrix. If the matrix is symmetric, the matrix must be given in a lower-triangular form.</li>
<li><code>obj.irn</code> (type: <code>int *</code>), the row indices.</li>
<li><code>obj.jcn</code> (type: <code>int *</code>), the column indices.</li>
<li><code>obj.val</code> (type: <code>double *</code>), the matrix entries.</li>
<li><code>obj.rhs</code> (type: <code>double *</code>), the right-hand side.</li>
</ul>
<p>If either of the row and column indices start with <code>0</code> the arrays are supposed to be zero based (<code>C</code> arrays indexation), otherwise, if they start with <code>1</code> the arrays are supposed to be one based (<code>Fortran</code> arrays indexation). If however, none starts with <code>0</code> or <code>1</code> then there is either an empty row or an empty column and the solver stops.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="co">// Create an object for each mpi-process</span>
    abcd obj;
    obj.n = <span class="dv">7</span>;
    obj.m = <span class="dv">7</span>;
    obj.nz = <span class="dv">15</span>;
    obj.sym = <span class="kw">false</span>;
    <span class="co">// put the data in the arrays</span>
    obj.irn[<span class="dv">0</span>] = <span class="dv">1</span>;
    <span class="co">//..</span></code></pre>
<h2 id="the-controls">The Controls</h2>
<p>Define the general behavior of the solver. They are split into two arrays, <code>icntl</code> and <code>dcntl</code>. <code>icntl</code> is an <em>integer</em> array and defines the options that control the specific parts of the solver, such as the scaling, the type of algorithm to run and so on. <code>dcntl</code> is a <em>double precision</em> array and defines some of the options required by the algorithms we use such as the imbalance between the partition sizes and the stopping criteria of the solver.</p>
<p>To access each of the control options we can either use the indices <code>0, 1, ..</code> or, preferably, use the <em>enums</em> defined in the header <code>defaults.h</code>. To access them, the user can use the namespace <code>Controls</code>, eg. <code>Controls::scaling</code> has a value of <code>5</code> and is used with <code>icntl</code> to handle the scaling of the linear system.</p>
<h3 id="the-integer-control-array-obj.icntl20">The integer control array <code>obj.icntl[20]</code></h3>
<ul>
<li><p><code>obj.icntl[Controls::nbparts]</code> or <code>obj.icntl[1]</code> defines the number of partitions in our linear system, can be from <code>1</code> to <code>m</code> (the number of rows in the matrix)</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// we have 8 partitions</span>
obj.icntl[Controls::nbparts] = <span class="dv">8</span>;</code></pre></li>
<li><code>obj.icntl[Controls::part_type]</code> or <code>obj.icntl[2]</code> defines the partitioning type. It can have the values:
<ul>
<li><code>1</code>, manual partitioning, the <em>nbparts</em> partitions can be provided into the STL vector <code>obj.nbrows[]</code>. Example:</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// use manual partitioning</span>
obj.icntl[Controls::part_type] = <span class="dv">1</span>;
<span class="co">// say that we want 20 rows per partition</span>
obj.nrows.assign(obj.icntl[Controls::nbparts], <span class="dv">20</span>);

<span class="co">// or </span>
obj.nrows.resize(obj.icntl[Controls::nbparts]);
obj.nrows[<span class="dv">0</span>] = <span class="dv">20</span>;
obj.nrows[<span class="dv">1</span>] = <span class="dv">20</span>;
<span class="co">//...</span></code></pre>
<ul>
<li><code>2</code> <em>(default)</em>, automatic uniform partitioning, creates <em>nbparts</em> partitions of similar size.</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// use patoh partitioning</span>
obj.icntl[Controls::part_type] = <span class="dv">2</span>;</code></pre>
<ul>
<li><code>3</code>, automatic hypergraph partitioning, creates <em>nbparts</em> partitions using the hypergraph partitioner <code>PaToH</code>. The imbalance between the partitions is handled using <code>obj.dcntl[Controls::part_imbalance]</code>. Example:</li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// use patoh partitioning</span>
obj.icntl[Controls::part_type] = <span class="dv">3</span>;
<span class="co">// say that we want an imbalance of 0.3 between the partitions</span>
obj.dcntl[Controls::part_imbalance] = <span class="fl">0.3</span>;</code></pre></li>
<li><code>obj.icntl[3]</code> reserved for a future use.</li>
<li><code>obj.icntl[Controls::part_guess]</code> or <code>obj.icntl[4]</code> asks the solver to guess the appropriate number of partitions and overrides the defined <em>nbparts</em>.
<ul>
<li><code>0</code> <em>(default)</em>, no guess</li>
<li><code>1</code>, guess</li>
</ul></li>
<li><code>obj.icntl[Controls::scaling]</code> or <code>obj.icntl[5]</code> defines the type of scaling to be used.
<ul>
<li><code>0</code>, no scaling</li>
<li><code>1</code>, infinity norm <code>MC77</code> based scaling</li>
<li><code>2</code> <em>(default)</em>, combination of one norm and two norm <code>MC77</code> based scaling</li>
</ul></li>
<li><code>obj.icntl[Controls::itmax]</code> or <code>obj.icntl[6]</code> defines the maximum number of iterations in block-CG acceleration, default is <code>1000</code></li>
<li><code>obj.icntl[Controls::block_size]</code> or <code>obj.icntl[7]</code> defines the block-size to be used by the block-CG acceleration, default is <code>1</code> for classical CG acceleration</li>
<li><code>obj.icntl[Controls::verbose_level]</code> or <code>obj.icntl[8]</code> <strong>Not Yet Implemented</strong>, defines how verbose the solver has to be.</li>
<li><code>obj.icntl[9]</code> reserved for a future use.</li>
<li><code>obj.icntl[Controls::aug_type]</code> or <code>obj.icntl[10]</code> defines the augmentation type.</li>
<li><code>0</code> <em>(default)</em>, no augmentation. This makes the solver run in <strong>regular block Cimmino</strong> mode.</li>
<li><code>1</code>, makes the solver run in <strong>Augmented Block Cimmino</strong> mode with an augmentation of the matrix using the <span class="math">\(C_{ij}/-I\)</span> technique. For numerical stability, this augmentation technique has to be used with a scaling.</li>
<li><code>2</code>, makes the solver run in <strong>Augmented Block Cimmino</strong> mode with an augmentation of the matrix using the <span class="math">\(A_{ij}/-A_{ji}\)</span> technique. This is the prefered augmentation technique.</li>
<li><code>obj.icntl[Controls::aug_blocking]</code> or <code>obj.icntl[11]</code> defines the blocking factor when building the auxiliary matrix <span class="math">\(S\)</span>, default is <code>128</code>.</li>
<li><code>obj.icntl[Controls::aug_analysis]</code> or <code>obj.icntl[12]</code>, when set to a value different than <code>0</code>, analyses the number of columns in the augmentation.</li>
<li><code>obj.icntl[13]</code> to <code>obj.icntl[16]</code> are for development and testing purposes only.</li>
<li><p><code>obj.icntl[17]</code> to <code>obj.icntl[19]</code> are reserved for a future use.</p></li>
</ul>
<h3 id="the-real-control-array-obj.dcntl20">The real control array <code>obj.dcntl[20]</code></h3>
<ul>
<li><code>obj.dcntl[Controls::part_imbalance]</code> or <code>obj.dcntl[1]</code> defines the imbalance between the partitions when using <code>PaToH</code> (<code>obj.icntl[Controls::part_imbalance] = 3</code>).</li>
<li><code>obj.dcntl[Controls::threshold]</code> or <code>obj.dcntl[2]</code> defines the stopping threshold for the block-CG acceleration, default is <code>1e-12</code>.</li>
<li><code>obj.dcnlt[3]</code> to <code>obj.dcntl[20]</code> are reserved for future use.</li>
</ul>
<h2 id="methods">Methods</h2>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The current implementation is double precision only.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>In reality the system can rectangular, but this case is not fully tested yet.<a href="#fnref2">↩</a></p></li>
</ol>
</div>
</body>
</html>
